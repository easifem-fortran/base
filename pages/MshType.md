---
title: Mesh file type in easifem
author: Vikas Sharma
language: fortran
---

# Mesh file in `EASIFEM`

## Status

- [ ] Incomplete task
  - [ ] Add methods to extract nptrs from `msh4_`
  - [ ] Add more methods for post-processing

---

## Structure

`EASIFEM` uses `msh` mesh file format which is generated by `Gmsh` pre/post processing opensource software. All methods are included in a single module called `mshType.f90` which is located in the directory called `Classes/MSH/`. Following user defined objects are declared in this module.

- `mshFormat_`
- `mshPhysicalNames_`
- `mshEntity_`
- `mshNodes_`
- `mshElements_`
- `msh4_`

`msh4_` is the main class; it contains other msh related object as its fields.

```fortran
TYPE :: msh4_
  INTEGER( I4B ) :: nsd = 0
  TYPE( File_ ) :: mshFile
  TYPE( mshFormat_ ) :: Format
  TYPE( mshPhysicalNames_ ) :: PhysicalNames
  TYPE( mshEntity_ ), ALLOCATABLE :: PointEntities( : )
  TYPE( mshEntity_ ), ALLOCATABLE :: CurveEntities( : )
  TYPE( mshEntity_ ), ALLOCATABLE :: SurfaceEntities( : )
  TYPE( mshEntity_ ), ALLOCATABLE :: VolumeEntities( : )
  TYPE( mshNodes_ ) :: Nodes
  TYPE( mshElements_ ) :: Elements
```

- `nsd` spatial dimension of mesh
- `mshFile` name of the mshFile from where mesh details are read
- `Format` mesh format
- `PhysicalNames` information about the physical names
- `PointEntities` information about the point entities
- `CurveEntities` information about the curve entities
- `SurfaceEntities` information about the surface entities
- `VolumeEntities` information about the volume entities
- `Nodes` information about the nodes
- `Elements` information about the elements

```fortran
TYPE :: mshFormat_
  REAL( DFP ) :: Version = 0.0_DFP
  INTEGER( I4B ) :: FileType = 0, DataSize = 0
  LOGICAL( LGT ) :: isASCII = .FALSE.
  CHARACTER( LEN = 100 ) :: MeshFormat = ""
```

```fortran
TYPE :: mshPhysicalNames_
  INTEGER( I4B ), ALLOCATABLE :: NSD( : )
  INTEGER( I4B ), ALLOCATABLE :: Tag( : )
  INTEGER( I4B ), ALLOCATABLE :: numElements( : )
  INTEGER( I4B ), ALLOCATABLE :: numNodes( : )
  TYPE( IntVector_ ), ALLOCATABLE :: Entities( : )
  TYPE( String ), ALLOCATABLE :: PhysicalName( : )
```

- `NSD` contains spatial dimension of each physical entity
- `Tag` contains the physical id of a physical entity
- `numElements` contains the total number of elements in a physical entity
- `numNodes` contains the total nodes in a physical entity
- `entities` contains the ids of geometrical entities associated with a physical entity

```fortran
TYPE :: mshEntity_
  INTEGER( I4B ) :: uid = 0
  INTEGER( I4B ) :: XiDim = 0
  INTEGER( I4B ) :: ElemType = 0
  INTEGER( I4B ), ALLOCATABLE :: PhysicalTag( : )
  INTEGER( I4B ), ALLOCATABLE :: NodeNumber( : )
  INTEGER( I4B ), ALLOCATABLE :: ElemNumber( : )
  INTEGER( I4B ), ALLOCATABLE :: Nptrs( :, : )
  INTEGER( I4B ), ALLOCATABLE :: BoundingEntity( : )

  REAL( DFP ) :: minX = 0.0_DFP, minY = 0.0_DFP, minZ = 0.0_DFP
  REAL( DFP ) :: maxX = 0.0_DFP, maxY = 0.0_DFP, maxZ = 0.0_DFP
  REAL( DFP ) :: X = 0.0_DFP, Y = 0.0_DFP, Z = 0.0_DFP
  REAL( DFP ), ALLOCATABLE :: NodeCoord( :, : )
```

- `uid` unique id of an entity
- `Xidim` dimension of an entity {0,1,2,3} for {point, curve, surface, volume}
- `ElemType` element type used for meshing the entity
- `PhysicalTag` ids of physical entities associated with an entity
- `NodeNumber` ids of node in the meshing of an entity
- `ElemNumber` ids of element in the meshing of an entity
- `Nptrs` connectivity matrix
- `BoundingEntity` id of bounding entity of an entity
- `minX, minY, minZ` related to bounding box
- `maxX, maxY, maxZ` related to bounding box
- `X,Y,Z` coordinates of center
- `NodeCoord` coordinates of the mesh

```fortran
TYPE :: mshNodes_
  INTEGER( I4B ) :: numNodes = 0
  INTEGER( I4B ) :: numEntityBlocks = 0
  INTEGER( I4B ) :: minNodeTag = 0
  INTEGER( I4B ) :: maxNodeTag = 0
  LOGICAL( LGT ) :: isSparse = .FALSE.
```

- `numNodes` contains the total number of nodes
- `numEntityBlocks` total number of entities where nodes are defined
- `minNodeTag` minimum value of node number
- `maxNodeTag` maximum value of node number

```fortran
TYPE :: mshElements_
  INTEGER( I4B ) :: numElements = 0
  INTEGER( I4B ) :: numEntityBlocks = 0
  INTEGER( I4B ) :: minElementTag = 0
  INTEGER( I4B ) :: maxElementTag = 0
  LOGICAL( LGT ) :: isSparse = .FALSE.
```

- `numElements` contains the total number of Elements
- `numEntityBlocks` total number of entities where Elements are defined
- `minElementTag` minimum value of Element number
- `maxElementTag` maximum value of node number

---

## Getting Started

---

## Description Of Methods

Module `mshType.f90` contains the interface of all methods relted to `msh` file type. There are several submodules which provide implementation of these interfaces:

- `mshType@mshFormat.f90`
- `mshType@mshPhysicalNames.f90`
- `mshType@mshEntity.f90`
- `mshType@mshNodes.f90`
- `mshType@mshElements.f90`
- `mshType@msh4.f90`

| PURE | Routine | Sumodule | Name | Link |
|:---  | :---:   | :---:    | :---:|     ---:|
|      | SUB     | `@MSH4` | `*Initiate()` | [LINK](#msh4-initiate) |
|      | SUB     | `@MSH4` | `DeallocateData()` | [LINK](#msh4-deallocatedata) |
|      | SUB     | `@MSH4` | `Display()` | [LINK](#msh4-display) |
| PURE | FUN     | `@MSH4` | `*TotalNodes()` | [LINK](#msh4-totalnodes) |
| PURE | SUB     | `@MSH4` | `*getNodes()` | [LINK](#msh4-getnodes) |
| PURE | FUN     | `@MSH4` | `*TotalElements()` | [LINK](#msh4-totalelements) |
|      | SUB     | `@MSH4` | `*getElements()` | [LINK](#msh4-getelements) |
|      | SUB     | `@MSH4` | `*WriteNodeData()` | [LINK](#msh4-getnodedata) |
|      | SUB     | `@mshFormat` | `*ReadFromFile()` | [LINK](#msh4-readfromfile) |
|      | SUB     | `@mshFormat` | `*WriteToFile()` | [LINK](#msh4-writetofile) |
|      | SUB     | `@mshFormat` | `*GotoTag()` | [LINK](#msh4-gototag) |
|      | SUB     | `@mshFormat` | `Display()` | [LINK](#msh4-display) |
|      | SUB     | `@mshFormat` | `DeallocateData()` | |
|      | SUB     | `@mshPhysicalNames` | `*GotoTag()` | [LINK](#mshphysicalnames-gototag) |
|      | SUB     | `@mshPhysicalNames` | `*ReadFromFile()` | [LINK](#mshphysicalnames-readfromfile) |
|      | SUB     | `@mshPhysicalNames` | `*WriteToFile()` | [LINK](#mshphysicalnames-writetofile) |
|      | SUB     | `@mshPhysicalNames` | `Display()` | [LINK](#mshphysicalnames-display) |
| PURE | FUN     | `@mshPhysicalNames` | `*SIZE()` | [LINK](#mshphysicalnames-size) |
| PURE | FUN     | `@mshPhysicalNames` | `*TotalPhysicalPoints()` | [LINK](#mshphysicalnames-totalphysicalpoints) |
| PURE | FUN     | `@mshPhysicalNames` | `*TotalPhysicalcurves()` | [LINK](#mshphysicalnames-totalphysicalcurves) |
| PURE | FUN     | `@mshPhysicalNames` | `*TotalPhysicalsurfaces()` | [LINK](#mshphysicalnames-totalphysicalsurfaces) |
| PURE | FUN     | `@mshPhysicalNames` | `*TotalPhysicalvolumes()` | [LINK](#mshphysicalnames-totalphysicalvolumes) |
| PURE | FUN     | `@mshPhysicalNames` | `*Index()` | [LINK](#mshphysicalnames-index) |
| PURE | FUN     | `@mshPhysicalNames` | `*PhysicalPointNames()` | [LINK](#mshphysicalnames-physicalpointnames) |
| PURE | FUN     | `@mshPhysicalNames` | `*PhysicalcurveNames()` | [LINK](#mshphysicalnames-physicalcurvenames) |
| PURE | FUN     | `@mshPhysicalNames` | `*PhysicalsurfaceNames()` | [LINK](#mshphysicalnames-physicalsurfacenames) |
| PURE | FUN     | `@mshPhysicalNames` | `*PhysicalvolumeNames()` | [LINK](#mshphysicalnames-physicalvolumenames) |
| PURE | FUN     | `@mshPhysicalNames` | `*PhysicalpointTags()` | [LINK](#mshphysicalnames-physicalpointtags) |
| PURE | FUN     | `@mshPhysicalNames` | `*PhysicalcurveTags()` | [LINK](#mshphysicalnames-physicalcurvetags) |
| PURE | FUN     | `@mshPhysicalNames` | `*PhysicalsurfaceTags()` | [LINK](#mshphysicalnames-physicalsurfacetags) |
| PURE | FUN     | `@mshPhysicalNames` | `*PhysicalvolumeTags()` | [LINK](#mshphysicalnames-physicalvolumetags) |
| PURE | FUN     | `@mshPhysicalNames` | `*WhoAmI()` | [LINK](#mshphysicalnames-whoami) |
| PURE | FUN     | `@mshPhysicalNames` | `*IndexOfPhysicalPoint()` | [LINK](#mshphysicalnames-indexofphysicalpoint) |
| PURE | FUN     | `@mshPhysicalNames` | `*IndexOfPhysicalcurve()` | [LINK](#mshphysicalnames-indexofphysicalcurve) |
| PURE | FUN     | `@mshPhysicalNames` | `*IndexOfPhysicalsurface()` | [LINK](#mshphysicalnames-indexofphysicalsurface) |
| PURE | FUN     | `@mshPhysicalNames` | `*IndexOfPhysicalvolume()` | [LINK](#mshphysicalnames-indexofphysicalvolume) |
|      | SUB     | `@mshPhysicalNames` | `*DeallocateData()` |  |
|      | SUB     | `@mshEntity` | `*GotoTag()` | [LINK](#mshentity-gototag) |
|      | SUB     | `@mshEntity` | `*ReadPointEntity()` | [LINK](#mshentity-readpointentity) |
|      | SUB     | `@mshEntity` | `*ReadCurveEntity()` | [LINK](#mshentity-readcurveentity) |
|      | SUB     | `@mshEntity` | `*ReadSurfaceEntity()` | [LINK](#mshentity-readsurfaceentity) |
|      | SUB     | `@mshEntity` | `*ReadVolumeEntity()` | [LINK](#mshentity-readvolumeentity) |
| PURE | FUN     | `@mshEntity` | `*TotalPhysicalTags()` | [LINK](#mshentity-totalphysicaltags) |
| PURE | FUN     | `@mshEntity` | `*TotalPhysicalTags()` | [LINK](#mshentity-totalphysicaltags) |
| PURE | FUN     | `@mshEntity` | `*TotalBoundingTags()` | [LINK](#mshentity-totalboundingtags) |
| PURE | FUN     | `@mshEntity` | `*TotalElements()` | [LINK](#mshentity-totalelements) |
|      | SUB     | `@mshEntity` | `*WriteToFile()` | [LINK](#mshentity-writetofile) |
|      | SUB     | `@mshEntity` | `DeallocateData()` | |
|      | SUB     | `@mshEntity` | `Display()` | [LINK](#mshentity-display) |
| PURE | FUN     | `@mshEntity` | `Index()` | [LINK](#mshentity-index) |
|      | SUB     | `@mshNodes` | `*GotoTag()` | [LINK](#mshnodes-gototag) |
|      | SUB     | `@mshNodes` | `*ReadFromFile()` | [LINK](#mshnodes-readfromfile) |
|      | SUB     | `@mshNodes` | `*WriteToFile()` | [LINK](#mshnodes-writetofile) |
|      | SUB     | `@mshNodes` | `Display()` | [LINK](#mshnodes-display) |
|      | SUB     | `@mshNodes` | `DeallocateData()` |  |
|      | SUB     | `@mshElements` | `*GotoTag()` | [LINK](#mshelements-gototag) |
|      | SUB     | `@mshElements` | `*ReadFromFile()` | [LINK](#mshelements-readfromfile) |
|      | SUB     | `@mshElements` | `*WriteToFile()` | [LINK](#mshelements-writetofile) |
|      | SUB     | `@mshElements` | `Display()` | [LINK](#mshelements-display) |
|      | SUB     | `@mshElements` | `DeallocateData()` |  |


We will first discuss the methods/routines defined for `MSH4` object.

### MSH4-Initiate

```fortran
!<--- Read the mesh file
MODULE SUBROUTINE initiate( Obj, Path, FileName, Extension, NSD )
  CLASS( msh4_ ), INTENT( INOUT ) :: Obj
    CHARACTER( LEN = * ), INTENT( IN ) :: FileName, Extension, Path
    INTEGER( I4B ), INTENT( IN ) :: NSD
END SUBROUTINE initiate
```

### MSH4-DeallocateData

```fortran
!<--- deallocate data occupied by the msh4 object
MODULE SUBROUTINE deallocatedata( Obj )
  CLASS( msh4_ ), INTENT( INOUT) :: Obj
END SUBROUTINE deallocatedata
```

### MSH4-Display

```fortran
!<--- Display the content
MODULE SUBROUTINE Display( Obj, Msg, UnitNo )
  CLASS( msh4_ ), INTENT( IN ) :: Obj
  CHARACTER( LEN = * ), INTENT( IN ) :: msg
  INTEGER( I4B ), OPTIONAL, INTENT( IN ) :: UnitNo
END SUBROUTINE Display
```

### MSH4-TotalNodes

```fortran
!<--- return the total nodes present in the msh file
MODULE PURE FUNCTION totalnodes( Obj ) RESULT( Ans )
  CLASS( msh4_ ), INTENT( IN ) :: Obj
  INTEGER( I4B ) :: Ans
END FUNCTION totalnodes
```

### MSH4-getnodes

```fortran
!<--- get node in the Nodes array
!<--- Nodes( 1 : nsd, 1 : tnodes )
MODULE PURE SUBROUTINE getNodes( Obj, Nodes )
  CLASS( msh4_ ), INTENT( IN ) :: Obj
  REAL( DFP ), ALLOCATABLE, INTENT( INOUT ) :: Nodes( :, : )
END SUBROUTINE getNodes
```

```fortran
!<--- Return nodes in a file
MODULE SUBROUTINE getNodes( Obj, UnitNo, Str, EndStr )
  CLASS( msh4_ ), INTENT( IN ) :: Obj
  INTEGER( I4B ), INTENT( IN ), OPTIONAL :: UnitNo
  CHARACTER( LEN = * ), OPTIONAL, INTENT( IN ) :: Str, EndStr
END SUBROUTINE getNodes
```

### MSH4-TotalElements

There are three interfaces to this generic function.

```fortran
!<--- Return the total elements present in the mesh file
MODULE PURE FUNCTION TotalElements( Obj ) RESULT( Ans )
  CLASS( msh4_ ), INTENT( IN ) :: Obj
  INTEGER( I4B ) :: Ans
END FUNCTION TotalElements
```

```fortran
!<--- Return the total number of elements with a given Xidim
!<--- XiDim = 0, 1, 2, 3 implies points, curve, surface, volume, respectively
MODULE PURE FUNCTION TotalElements( Obj, XiDim ) RESULT( Ans )
  CLASS( msh4_ ), INTENT( IN ) :: Obj
  INTEGER( I4B ), INTENT( IN ) :: XiDim
  INTEGER( I4B ) :: Ans
END FUNCTION TotalElements
!<--- How to Use
!<--- To get total number of surface element
!<--- telem = Obj % TotalElements( XiDim = 2 )
```

```fortran
!<--- Total number of elements with filter xiDim and their Physical IDs
MODULE PURE FUNCTION TotalElements( Obj, XiDim, Tag ) RESULT( Ans )
  CLASS( msh4_ ), INTENT( IN ) :: Obj
  INTEGER( I4B ), INTENT( IN ) :: XiDim
  INTEGER( I4B ), INTENT( IN ) :: Tag( : )
  INTEGER( I4B ) :: Ans
END FUNCTION TotalElements
```

### MSH4-GetElements

There are four interfaces for this generic subroutine.

```fortran
!<--- Get all elements without any filter
MODULE SUBROUTINE getElements( Obj, MeshObj, FEObj )
  CLASS( msh4_ ), INTENT( IN ) :: Obj
  CLASS( Mesh_ ), INTENT( INOUT), TARGET :: MeshObj
  CLASS( Element_ ), INTENT( IN ) :: FEObj
END SUBROUTINE getElements
```

```fortran
!<--- get elements by using xidimension filter
!<--- FEObj specifies the type of finite element
!<--- IF offset is present the user should allocate meshobj because
!<--- this routine will not allocate it
MODULE SUBROUTINE getElements( Obj, MeshObj, XiDim, FEObj, Offset )
  CLASS( msh4_ ), INTENT( IN ) :: Obj
  CLASS( Mesh_ ), INTENT( INOUT), TARGET :: MeshObj
  INTEGER( I4B ), INTENT( IN ) :: XiDim
  CLASS( Element_ ), INTENT( IN ) :: FEObj
  INTEGER( I4B ), OPTIONAL, INTENT( IN ) :: Offset
END SUBROUTINE getElements
```

```fortran
!<--- get elements by using xidimension, and physical id, filter
!<--- FEObj specifies the type of finite element
!<--- IF offset is present the user should allocate meshobj because
!<--- this routine will not allocate it
MODULE SUBROUTINE getElements( Obj, MeshObj, XiDim, Tag, FEObj,&
  & Offset )
  CLASS( msh4_ ), INTENT( IN ) :: Obj
  CLASS( Mesh_ ), INTENT( INOUT), TARGET :: MeshObj
  INTEGER( I4B ), INTENT( IN ) :: XiDim, Tag( : )
  CLASS( Element_ ), INTENT( IN ) :: FEObj
  INTEGER( I4B ), OPTIONAL, INTENT( IN ) :: Offset
END SUBROUTINE getElements
```

```fortran
!<--- get elements by using xidimension, and physical name, filter
!<--- FEObj specifies the type of finite element
!<--- IF offset is present the user should allocate meshobj because
!<--- this routine will not allocate it
MODULE SUBROUTINE getelements( Obj, MeshObj, XiDim, TagNames, FEObj, &
  & Offset )
  CLASS( msh4_ ), INTENT( IN ) :: Obj
  CLASS( Mesh_ ), INTENT( INOUT), TARGET :: MeshObj
  INTEGER( I4B ), INTENT( IN ) :: XiDim
  CLASS( Element_ ), INTENT( IN ) :: FEObj
  TYPE( String ), INTENT( IN ) :: TagNames( : )
  INTEGER( I4B ), OPTIONAL, INTENT( IN ) :: Offset
END SUBROUTINE getelements
```

### MSH-WriteNodeData

This is a post-processing routine which writes the nodal data into

```fortran
MODULE SUBROUTINE WriteNodeData( Obj, x, Indx, dofObj, Name )
  CLASS( msh4_ ), INTENT( IN ) :: Obj
  REAL( DFP ), INTENT( IN ) :: x( : )
  INTEGER( I4B ), INTENT( IN ) :: Indx( : )
  TYPE( DOF_ ), INTENT( IN ) :: dofObj
  CHARACTER( LEN = 1 ), INTENT( IN ) :: Name
END SUBROUTINE WriteNodeData
```


### mshFormat-ReadFromFile

```fortran
!<--- open the file and read the mesh format
MODULE SUBROUTINE ReadFromFile( Obj, mshFile, ierr )
  CLASS( mshFormat_ ), INTENT( INOUT) :: Obj
  TYPE( File_ ), INTENT( INOUT) :: mshFile
  LOGICAL( LGT ), INTENT( INOUT ) :: ierr
END SUBROUTINE ReadFromFile
```

### mshFormat-WriteToFile

```fortran
!<--- Open the file and write to it
MODULE SUBROUTINE writeToFile( Obj, mshFile, Str, EndStr )
  CLASS( mshFormat_ ), INTENT( INOUT ) :: Obj
  TYPE( File_ ), INTENT( INOUT ) :: mshFile
  CHARACTER( LEN = * ), INTENT( IN ), OPTIONAL :: Str, EndStr
END SUBROUTINE writeToFile
```

### mshFormat-gotoTag

```fortran
MODULE SUBROUTINE GotoTag( Obj, mshFile, ierr )
  CLASS( mshFormat_ ), INTENT( IN ) :: Obj
  TYPE( File_ ), INTENT( INOUT ) :: mshFile
  LOGICAL( LGT ), INTENT( INOUT ) :: ierr
END SUBROUTINE GotoTag
```

### mshFormat-Display

```fortran
!<--- display the content of mshformat
MODULE SUBROUTINE display( Obj, Msg, UnitNo )
  CLASS( mshFormat_ ), INTENT( IN ) :: Obj
  CHARACTER( LEN = * ), INTENT( IN ) :: Msg
  INTEGER( I4B ), OPTIONAL, INTENT( IN ) :: UnitNo
END SUBROUTINE display
```

### mshPhysicalNames-gotoTag

```fortran
MODULE SUBROUTINE gotoTag( Obj, mshFile, ierr )
  CLASS( mshPhysicalNames_ ), INTENT( IN ) :: Obj
  TYPE( File_ ), INTENT( INOUT ) :: mshFile
  LOGICAL( LGT ), INTENT( INOUT ) :: ierr
END SUBROUTINE gotoTag
```

### mshPhysicalNames-ReadFromFile

```fortran
MODULE SUBROUTINE ReadFromFile( Obj, mshFile, ierr )
  CLASS( mshPhysicalNames_ ), INTENT( INOUT ) :: Obj
  TYPE( File_ ), INTENT( INOUT ) :: mshFile
  LOGICAL( LGT ), INTENT( INOUT ) :: ierr
END SUBROUTINE ReadFromFile
```

### mshPhysicalNames-WriteToFile

```fortran
MODULE SUBROUTINE WriteToFile( Obj, mshFile, Str, EndStr )
  CLASS( mshPhysicalNames_ ), INTENT( INOUT ) :: Obj
  TYPE( File_ ), INTENT( INOUT ) :: mshFile
  CHARACTER( LEN = * ), OPTIONAL, INTENT( IN ) :: Str, EndStr
END SUBROUTINE WriteToFile
```

### mshPhysicalNames-Display

```fortran
MODULE SUBROUTINE Display( Obj, Msg, UnitNo )
  CLASS( mshPhysicalNames_ ), INTENT( IN ) :: Obj
  CHARACTER( LEN = * ), INTENT( IN ) :: Msg
  INTEGER( I4B ), OPTIONAL, INTENT( IN ) :: UnitNo
END SUBROUTINE Display
```

### mshPhysicalNames-SIZE

```fortran
MODULE PURE FUNCTION SIZE( Obj ) RESULT( Ans )
  CLASS( mshPhysicalNames_ ), INTENT( IN ):: Obj
  INTEGER( I4B ) :: Ans
END FUNCTION SIZE
```

### mshPhysicalNames-TotalPhysicalPoints

```fortran
MODULE PURE FUNCTION TotalPhysicalPoints( Obj ) RESULT( Ans )
  CLASS( mshPhysicalNames_ ), INTENT( IN ):: Obj
  INTEGER( I4B ) :: Ans
END FUNCTION TotalPhysicalPoints
```

### mshPhysicalNames-TotalPhysicalCurves

```fortran
MODULE PURE FUNCTION TotalPhysicalCurves( Obj ) RESULT( Ans )
  CLASS( mshPhysicalNames_ ), INTENT( IN ):: Obj
  INTEGER( I4B ) :: Ans
END FUNCTION TotalPhysicalCurves
```

### mshPhysicalNames-TotalPhysicalSurfaces

```fortran
MODULE PURE FUNCTION TotalPhysicalSurfaces( Obj ) RESULT( Ans )
  CLASS( mshPhysicalNames_ ), INTENT( IN ):: Obj
  INTEGER( I4B ) :: Ans
END FUNCTION TotalPhysicalSurfaces
```

### mshPhysicalNames-TotalPhysicalVolumes

```fortran
MODULE PURE FUNCTION TotalPhysicalVolumes( Obj ) RESULT( Ans )
  CLASS( mshPhysicalNames_ ), INTENT( IN ):: Obj
  INTEGER( I4B ) :: Ans
END FUNCTION TotalPhysicalVolumes
```

### mshPhysicalNames-Index

There are four interfaces for this generic function.

```fortran
!<--- return the index of a given physical name
MODULE PURE FUNCTION Index( Obj, Name ) RESULT( Ans )
  CLASS( mshPhysicalNames_ ), INTENT( IN ) :: Obj
  CHARACTER( LEN = * ), INTENT( IN ) :: Name
  INTEGER( I4B ) :: Ans
END FUNCTION Index
```

```fortran
!<--- return the indices of given physical names
MODULE PURE FUNCTION Index( Obj, Name ) RESULT( Ans )
  CLASS( mshPhysicalNames_ ), INTENT( IN ) :: Obj
  TYPE( String ), INTENT( IN ) :: Name( : )
  INTEGER( I4B ) :: Ans( SIZE( Name ) )
END FUNCTION Index
```

```fortran
!<--- Return the index
!<--- XiDimTag( 1 ) denotes the XiDImension of physical entity
!<---               0 => point
!<---               1 => line
!<---               2 => surface
!<---               3 => volume
!<--- XiDimTag( 2 ) denotes the id of Physical entity whose index we want

MODULE PURE FUNCTION Index( Obj, XiDimTag ) RESULT( Ans )
  CLASS( mshPhysicalNames_ ), INTENT( IN ) :: Obj
  INTEGER( I4B ), INTENT( IN ) :: XiDimTag( 2 )
  INTEGER( I4B ) :: Ans
END FUNCTION Index
```

```fortran
!<--- Return the index
!<--- XiDim denotes the XiDImension of physical entity
!<--- XiDim = 0 => Points and we get indices of points
!<--- XiDim = 1 => Lines and we get indices of lines
!<--- XiDim = 2 => Surfaces and we get indices of surfaces
!<--- XiDim = 3 => Volumes and we get indices of volumes

MODULE PURE FUNCTION Index( Obj, XiDimTag ) RESULT( Ans )
  CLASS( mshPhysicalNames_ ), INTENT( IN ) :: Obj
  INTEGER( I4B ), INTENT( IN ) :: XiDimTag
  INTEGER( I4B ), ALLOCATABLE  :: Ans( : )
END FUNCTION Index
```

### mshPhysicalNames-PhysicalPointNames

```fortran
MODULE PURE FUNCTION PhysicalPointNames( Obj ) RESULT( Ans )
  CLASS( mshPhysicalNames_ ), INTENT( IN ) :: Obj
  TYPE( String ), ALLOCATABLE :: Ans( : )
END FUNCTION PhysicalPointNames
```

### mshPhysicalNames-PhysicalCurveNames

```fortran
MODULE PURE FUNCTION PhysicalCurveNames( Obj ) RESULT( Ans )
  CLASS( mshPhysicalNames_ ), INTENT( IN ) :: Obj
  TYPE( String ), ALLOCATABLE :: Ans( : )
END FUNCTION PhysicalCurveNames
```

### mshPhysicalNames-PhysicalSurfaceNames

```fortran
MODULE PURE FUNCTION PhysicalSurfaceNames( Obj ) RESULT( Ans )
  CLASS( mshPhysicalNames_ ), INTENT( IN ) :: Obj
  TYPE( String ), ALLOCATABLE :: Ans( : )
END FUNCTION PhysicalSurfaceNames
```

### mshPhysicalNames-PhysicalVolumeNames

```fortran
MODULE PURE FUNCTION PhysicalVolumeNames( Obj ) RESULT( Ans )
  CLASS( mshPhysicalNames_ ), INTENT( IN ) :: Obj
  TYPE( String ), ALLOCATABLE :: Ans( : )
END FUNCTION PhysicalVolumeNames
```

### mshPhysicalNames-PhysicalPointTags

```fortran
MODULE PURE FUNCTION PhysicalPointTags( Obj ) RESULT( Ans )
  CLASS( mshPhysicalNames_ ), INTENT( IN ) :: Obj
  INTEGER( I4B ), ALLOCATABLE :: Ans( : )
END FUNCTION PhysicalPointTags
```

### mshPhysicalNames-PhysicalCurveTags

```fortran
MODULE PURE FUNCTION PhysicalCurveTags( Obj ) RESULT( Ans )
  CLASS( mshPhysicalNames_ ), INTENT( IN ) :: Obj
  INTEGER( I4B ), ALLOCATABLE :: Ans( : )
END FUNCTION PhysicalCurveTags
```

### mshPhysicalNames-PhysicalSurfaceTags

```fortran
MODULE PURE FUNCTION PhysicalSurfaceTags( Obj ) RESULT( Ans )
  CLASS( mshPhysicalNames_ ), INTENT( IN ) :: Obj
  INTEGER( I4B ), ALLOCATABLE :: Ans( : )
END FUNCTION PhysicalSurfaceTags
```

### mshPhysicalNames-PhysicalVolumeTags

```fortran
MODULE PURE FUNCTION PhysicalVolumeTags( Obj ) RESULT( Ans )
  CLASS( mshPhysicalNames_ ), INTENT( IN ) :: Obj
  INTEGER( I4B ), ALLOCATABLE :: Ans( : )
END FUNCTION PhysicalVolumeTags
```

### mshPhysicalNames-WhoAmI

```fortran
MODULE PURE FUNCTION WhoAmI( Obj, I ) RESULT( Ans )
  CLASS( mshPhysicalNames_ ), INTENT( IN ) :: Obj
  INTEGER( I4B ), INTENT( IN ) :: I
  TYPE( String ) :: Ans
END FUNCTION WhoAmI
```

### mshPhysicalNames-IndexOfPhysicalPoint

```fortran
!<--- return the index of a physical point
MODULE PURE FUNCTION IndexOfPhysicalPoint( Obj, Tag ) RESULT( Ans )
  CLASS( mshPhysicalNames_ ), INTENT( IN ) :: Obj
  INTEGER( I4B ), INTENT( IN ) :: Tag
  INTEGER( I4B ) :: Ans
END FUNCTION IndexOfPhysicalPoint
```

```fortran
!<--- return the indices of physical points
MODULE PURE FUNCTION IndexOfPhysicalPoint( Obj, Tag ) RESULT( Ans )
  CLASS( mshPhysicalNames_ ), INTENT( IN ) :: Obj
  INTEGER( I4B ), INTENT( IN ) :: Tag( : )
  INTEGER( I4B ) :: Ans( SIZE( Tag ) )
END FUNCTION IndexOfPhysicalPoint
```

### mshPhysicalNames-IndexOfPhysicalCurve

```fortran
!<--- return the index of a physical Curve
MODULE PURE FUNCTION IndexOfPhysicalCurve( Obj, Tag ) RESULT( Ans )
  CLASS( mshPhysicalNames_ ), INTENT( IN ) :: Obj
  INTEGER( I4B ), INTENT( IN ) :: Tag
  INTEGER( I4B ) :: Ans
END FUNCTION IndexOfPhysicalCurve
```

```fortran
!<--- return the indices of physical Curves
MODULE PURE FUNCTION IndexOfPhysicalCurve( Obj, Tag ) RESULT( Ans )
  CLASS( mshPhysicalNames_ ), INTENT( IN ) :: Obj
  INTEGER( I4B ), INTENT( IN ) :: Tag( : )
  INTEGER( I4B ) :: Ans( SIZE( Tag ) )
END FUNCTION IndexOfPhysicalCurve
```

### mshPhysicalNames-IndexOfPhysicalSurface

```fortran
!<--- return the index of a physical Surface
MODULE PURE FUNCTION IndexOfPhysicalSurface( Obj, Tag ) RESULT( Ans )
  CLASS( mshPhysicalNames_ ), INTENT( IN ) :: Obj
  INTEGER( I4B ), INTENT( IN ) :: Tag
  INTEGER( I4B ) :: Ans
END FUNCTION IndexOfPhysicalSurface
```

```fortran
!<--- return the indices of physical Surfaces
MODULE PURE FUNCTION IndexOfPhysicalSurface( Obj, Tag ) RESULT( Ans )
  CLASS( mshPhysicalNames_ ), INTENT( IN ) :: Obj
  INTEGER( I4B ), INTENT( IN ) :: Tag( : )
  INTEGER( I4B ) :: Ans( SIZE( Tag ) )
END FUNCTION IndexOfPhysicalSurface
```

### mshPhysicalNames-IndexOfPhysicalVolume

```fortran
!<--- return the index of a physical Volume
MODULE PURE FUNCTION IndexOfPhysicalVolume( Obj, Tag ) RESULT( Ans )
  CLASS( mshPhysicalNames_ ), INTENT( IN ) :: Obj
  INTEGER( I4B ), INTENT( IN ) :: Tag
  INTEGER( I4B ) :: Ans
END FUNCTION IndexOfPhysicalVolume
```

```fortran
!<--- return the indices of physical Volumes
MODULE PURE FUNCTION IndexOfPhysicalVolume( Obj, Tag ) RESULT( Ans )
  CLASS( mshPhysicalNames_ ), INTENT( IN ) :: Obj
  INTEGER( I4B ), INTENT( IN ) :: Tag( : )
  INTEGER( I4B ) :: Ans( SIZE( Tag ) )
END FUNCTION IndexOfPhysicalVolume
```

### mshEntity-gotoTag

```fortran
MODULE SUBROUTINE gotoTag( Obj, mshFile, ierr )
  CLASS( mshEntity_ ), INTENT( IN ) :: Obj
  TYPE( File_ ), INTENT( INOUT ) :: mshFile
  LOGICAL( LGT ), INTENT( INOUT ) :: ierr
END SUBROUTINE gotoTag
```

### mshEntity-ReadPointEntity

```fortran
MODULE SUBROUTINE ReadPointEntity( Obj, mshFile, readTag, ierr )
  CLASS( mshEntity_ ), INTENT( INOUT) :: Obj
  TYPE( File_ ), INTENT( INOUT) :: mshFile
  LOGICAL( LGT ), INTENT( INOUT) :: ierr
  LOGICAL( LGT ), INTENT( IN ) :: readTag
END SUBROUTINE ReadPointEntity
```

### mshEntity-ReadCurveEntity

```fortran
MODULE SUBROUTINE ReadCurveEntity( Obj, mshFile, readTag, ierr )
  CLASS( mshEntity_ ), INTENT( INOUT) :: Obj
  TYPE( File_ ), INTENT( INOUT) :: mshFile
  LOGICAL( LGT ), INTENT( INOUT) :: ierr
  LOGICAL( LGT ), INTENT( IN ) :: readTag
END SUBROUTINE ReadCurveEntity
```

### mshEntity-ReadSurfaceEntity

```fortran
MODULE SUBROUTINE ReadSurfaceEntity( Obj, mshFile, readTag, ierr )
  CLASS( mshEntity_ ), INTENT( INOUT) :: Obj
  TYPE( File_ ), INTENT( INOUT) :: mshFile
  LOGICAL( LGT ), INTENT( INOUT) :: ierr
  LOGICAL( LGT ), INTENT( IN ) :: readTag
END SUBROUTINE ReadSurfaceEntity
```

### mshEntity-ReadVolumeEntity

```fortran
MODULE SUBROUTINE ReadVolumeEntity( Obj, mshFile, readTag, ierr )
  CLASS( mshEntity_ ), INTENT( INOUT) :: Obj
  TYPE( File_ ), INTENT( INOUT) :: mshFile
  LOGICAL( LGT ), INTENT( INOUT) :: ierr
  LOGICAL( LGT ), INTENT( IN ) :: readTag
END SUBROUTINE ReadVolumeEntity
```

### mshEntity-WriteToFile

```fortran
MODULE SUBROUTINE WriteToFile( Obj, mshFile, Str, EndStr )
  CLASS( mshEntity_ ), INTENT( INOUT ) :: Obj
  TYPE( File_ ), INTENT( INOUT) :: mshFile
  CHARACTER( LEN = * ), INTENT( IN ), OPTIONAL :: Str, EndStr
END SUBROUTINE WriteToFile
```

### mshEntity-Display

```fortran
MODULE SUBROUTINE Display( Obj, Msg, UnitNo )
  CLASS( mshEntity_ ), INTENT( IN ) :: Obj
  CHARACTER( LEN = * ), INTENT( IN ) :: Msg
  INTEGER( I4B ), OPTIONAL, INTENT( IN ) :: UnitNo
END SUBROUTINE Display
```

### mshEntity-Index

```fortran
MODULE PURE FUNCTION Index( mshEntities, Uid ) RESULT( Ans )
  TYPE( mshEntity_ ), INTENT( IN ) :: mshEntities( : )
  INTEGER( I4B ), INTENT( IN ) :: Uid
  INTEGER( I4B ) :: Ans
END FUNCTION Index
```

### mshEntity-TotalPhysicalTags

```fortran
MODULE PURE FUNCTION TotalPhysicalTags( Obj ) RESULT( Ans )
  CLASS( mshEntity_ ), INTENT( IN ) :: Obj
  INTEGER( I4B ) :: Ans
END FUNCTION TotalPhysicalTags
```

### mshEntity-TotalBoundingTags

```fortran
MODULE PURE FUNCTION TotalBoundingTags( Obj ) RESULT( Ans )
  CLASS( mshEntity_ ), INTENT( IN ) :: Obj
  INTEGER( I4B ) :: Ans
END FUNCTION TotalBoundingTags
```

### mshEntity-TotalElements

```fortran
MODULE PURE FUNCTION TotalElements( Obj ) RESULT( Ans )
  CLASS( mshEntity_ ), INTENT( IN ) :: Obj
  INTEGER( I4B ) :: Ans
END FUNCTION TotalElements
```

### mshNodes-GotoTag

```fortran
MODULE SUBROUTINE GotoTag( Obj, mshFile, ierr )
  CLASS( mshNodes_ ), INTENT( IN ) :: Obj
  TYPE( File_ ), INTENT( INOUT ) :: mshFile
  LOGICAL( LGT ), INTENT( INOUT ) :: ierr
END SUBROUTINE GotoTag
```

### mshNodes-ReadFromFile

```fortran
MODULE SUBROUTINE ReadFromFile( Obj, mshFile, mshFormat, ierr )
  CLASS( mshNodes_ ), INTENT( INOUT ) :: Obj
  TYPE( File_ ), INTENT( INOUT ) :: mshFile
  TYPE( mshFormat_ ), INTENT( INOUT ) :: mshFormat
  LOGICAL( LGT ), INTENT( INOUT ) :: ierr
END SUBROUTINE ReadFromFile
```

### mshNodes-WriteToFile

```fortran
MODULE SUBROUTINE WriteToFile( Obj, mshFile, mshFormat, Str, EndStr )
  CLASS( mshNodes_ ), INTENT( INOUT ) :: Obj
  TYPE( File_ ), INTENT( INOUT ) :: mshFile
  CHARACTER( LEN = * ), INTENT( IN ), OPTIONAL :: Str, EndStr
  TYPE( mshFormat_ ), INTENT( INOUT ) :: mshFormat
END SUBROUTINE WriteToFile
```

### mshNodes-Display

```fortran
MODULE SUBROUTINE Display( Obj, Msg, UnitNo )
  CLASS( mshNodes_ ), INTENT( IN ) :: Obj
  CHARACTER( LEN = * ), INTENT( IN ) :: Msg
  INTEGER( I4B ), OPTIONAL, INTENT( IN ) :: UnitNo
END SUBROUTINE Display
```

### mshElements-GotoTag

```fortran
MODULE SUBROUTINE GotoTag( Obj, mshFile, ierr )
  CLASS( mshElements_ ), INTENT( IN ) :: Obj
  TYPE( File_ ), INTENT( INOUT ) :: mshFile
  LOGICAL( LGT ), INTENT( INOUT ) :: ierr
END SUBROUTINE GotoTag
```

### mshElements-ReadFromFile

```fortran
MODULE SUBROUTINE ReadFromFile( Obj, mshFile, mshFormat, ierr )
  CLASS( mshElements_ ), INTENT( INOUT ) :: Obj
  TYPE( File_ ), INTENT( INOUT ) :: mshFile
  TYPE( mshFormat_ ), INTENT( INOUT ) :: mshFormat
  LOGICAL( LGT ), INTENT( INOUT ) :: ierr
END SUBROUTINE ReadFromFile
```

### mshElements-WriteToFile

```fortran
MODULE SUBROUTINE WriteToFile( Obj, mshFile, mshFormat, Str, EndStr )
  CLASS( mshElements_ ), INTENT( INOUT ) :: Obj
  TYPE( File_ ), INTENT( INOUT ) :: mshFile
  CHARACTER( LEN = * ), INTENT( IN ), OPTIONAL :: Str, EndStr
  TYPE( mshFormat_ ), INTENT( INOUT ) :: mshFormat
END SUBROUTINE WriteToFile
```

### mshElements-Display

```fortran
MODULE SUBROUTINE Display( Obj, Msg, UnitNo )
  CLASS( mshElements_ ), INTENT( IN ) :: Obj
  CHARACTER( LEN = * ), INTENT( IN ) :: Msg
  INTEGER( I4B ), OPTIONAL, INTENT( IN ) :: UnitNo
END SUBROUTINE Display
```