var tipuesearch = {"pages":[{"title":" Fortran Program ","text":"Fortran Program EASIFEM Introduction About EASIFEM stands for Expandable And Scalable infrastructure for Finite Element Method. It is a framework for developing code for finite element method by using modern fortran. The framework has been developed in Modern-Fortran programming language. The library is still in the development stage. EASIFEM is written both in OOP and Multiple dispatch approach. Capabilities The goal of EASIFEM is to ease the coding of FEM by using fortran language. The library is developed for developing code for complex problems related to multiphysics and multiphase problems. EASIFEM will facilitate an environment where new FEM can be implemented easily while decreasing the time required for writing the code. Dr Vikas Sharma, the creator EASIFEM conducts his research in the area of computational geomechanics. Therefore, so far, easifem has been used to develop applications related to dam-reservoir-soil interactions, seismic cracking of dams, nonlinear seismic behavior of earthdams, high-order accurate solvers for transient problems, space-time finite element methods for moving boundary problems, simulation of freezing and thawing in frozen soils, among others. EASIFEM describes all types of datatype required for coding FEM, such as string, file, vector, array, degrees of freedom, indices, mesh, nodes, finite elements, domain, shape functions, quadrature rules, linear solver, sparse and dense matrix, iterative and non iterative solvers, among others. EASIFEM also have a strong interface with the GMSH for pre- and post- processing. In addition, it provides great interface with PARAVIEW for visualization of results. In future, EASIFEM, will also act as a platform to use exisiting finite element libraries in effortless manner. The vision of EASIFEM will always be  to keep  FEM programming easy and ellegant. Bug Reporting ChangeLog License ToDo Installation Installing Usage Structure Base BoundingBox Buffer DOF ElemShapeData FEMatrix FEVariable File IndexValue IterationData KeyValue QuadraturePoint Random Tensor ReferenceElement RealMatrix SparseMatrix IntVector RealVector AbstractArray AbstractMatrix AbstractVector BaseMethod BaseType BlasInterface ErrorHandling GlobalData IO Utility Dependencies String Contributing Credits Developer Info Dr Vikas Sharma Ph. D.\nKyoto University,\nKyoto, Japan","tags":"home","loc":"index.html"},{"title":"EASIFEM.f90 – Fortran Program","text":"Contents Modules EASIFEM Source Code EASIFEM.f90 Source Code MODULE EASIFEM USE BaseType USE BaseMethod USE easifemClasses USE mod_functional USE ogpf ! USE UserDefinedClasses ! USE GlobalData ! USE IO ! USE Utility ! USE BLASInterface ! USE LinearAlgebra ! USE Voigt ! USE Geometry_Module ! USE ElementGeometry_Module ! USE QuadraturePoints_Module ! USE ShapeFunction_Module ! !------------------------------------------------------------------- ! USE IndexVector_Class ! USE Set_Class ! USE String_Class ! USE KeyValue_Class ! USE MaterialParameter_Class ! USE IterationData_Class ! USE File_Class ! !------------------------------------------------------------------- ! USE Tensor ! !------------------------------------------------------------------- ! !USE Materials ! !------------------------------------------------------------------- ! USE BoundingBox_Class ! USE NodeCoord_Class ! USE Node_Class ! USE STSlab_Class ! !------------------------------------------------------------------- ! USE QuadPoints_Class ! USE ShapeData_Class ! USE STShapeData_Class ! !------------------------------------------------------------------- ! USE NodalDOF_Class ! USE DOFMetaData_Class ! USE GroupDOF_Class ! USE HomoGroupDOF_Class ! !------------------------------------------------------------------- ! USE ElemShapeData_Class ! USE SpaceMatrix_Class ! USE MassMatrix_Class ! USE ConvectiveMatrix_Class ! USE DiffusionMatrix_Class ! USE StiffnessMatrix_Class ! USE FextVector_Class ! USE FintVector_Class ! !------------------------------------------------------------------- ! USE STElemShapeData_Class ! USE SpaceTimeMatrix_Class ! USE STMassMatrix_Class ! USE STConvectiveMatrix_Class ! USE STDiffusionMatrix_Class ! USE STStiffnessMatrix_Class ! USE STFextVector_Class ! USE STFintVector_Class ! USE ST_Tau_SUPG_RGN_Class ! !------------------------------------------------------------------- ! !USE ConstitutiveModel_Class ! !------------------------------------------------------------------- ! USE ElementData_Class ! USE GenericElement_Class ! USE Element_Class ! USE FacetElement_Class ! USE STElement_Class ! USE ElementFactory ! !------------------------------------------------------------------- ! USE Mesh_Class ! USE MeshData_Class ! USE MeshConnectivity_Class ! !------------------------------------------------------------------- ! USE TanMat_Class ! USE SparseDoublet_Class ! USE SparseVector_Class ! USE fSparse_Class ! USE BlockLayout_Class ! USE SparseTanMat_Class ! USE BlockMat_Class ! USE GroupElementDOF_Class ! USE BlockElemTanMat_Class ! USE BlockTanMat_Class ! !------------------------------------------------------------------- ! USE LIS_Module ! ! USE ElemTanMat_Class ! ! USE IterativeLinearSolver_Class ! ! USE GpBiCG_Class ! ! USE GpBiCG_AR_Class ! ! USE GpBiCG_AR2_Class ! ! USE BiCGSAFE1_Class ! ! USE BiCGSAFE2_Class ! ! USE BiCGSAFE3_Class ! !------------------------------------------------------------------- ! USE MSH2_MODULE ! USE GmshPostProcessing_Module ! !------------------------------------------------------------------- ! USE GroundMotion_Class END MODULE EASIFEM","tags":"","loc":"sourcefile/easifem.f90.html"},{"title":"easifemClasses.f90 – Fortran Program","text":"Contents Modules easifemClasses Source Code easifemClasses.f90 Source Code MODULE easifemClasses USE FE USE Mesh_Class USE MeshData_Class USE MeshConnectivity_Class USE Domain_Class USE QuadratureVariables_Class USE gmsh_class USE gmshMesh_Class USE vtkType USE LinSolver_Class USE Material_Class USE stdMaterials USE ThermCondModel_Class USE VolHeatCapModel_Class USE SFCCModel_Class END MODULE easifemClasses","tags":"","loc":"sourcefile/easifemclasses.f90.html"},{"title":"MeshData_Class.f90 – Fortran Program","text":"Contents Modules MeshData_Class Source Code MeshData_Class.f90 Source Code MODULE MeshData_Class !! This module defines Mesh data class USE BaseType USE GlobalData USE Mesh_Class USE FE IMPLICIT NONE PRIVATE !---------------------------------------------------------------------------- !                                                                 MeshData_ !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! [[MeshData_]] contains data related to a mesh ! ! @note ! In **EASIFEM** mesh-data is separated from the `Mesh_` mainly because ! very often we only require connectivity information which is already ! stored inside the `Mesh_`. ! @endnote TYPE :: MeshData_ !! [[MeshData_]] is contains mesh realated data INTEGER ( I4B ) :: MaxNptrs !! Largest node number present inside mesh INTEGER ( I4B ) :: MinNptrs !! Smallest node number present inside mesh INTEGER ( I4B ) :: tNodes !! Total number of nodes in mesh LOGICAL ( LGT ) :: isInitiated !! `.True.` if `MeshObj_` is initiated INTEGER ( I4B ), ALLOCATABLE :: LBndyIndex ( : ) !! For a given element if `LBndyIndex(iel) .eq. 0` then `iel` is not a !! a boundary element else it a boundary element which represents the !! index of `iel` in `BoundaryData()`. INTEGER ( I4B ), ALLOCATABLE :: Nptrs ( : ) !! Node number of mesh `Nptrs( minNptrs : maxNptrs )` INTEGER ( I4B ), ALLOCATABLE :: BoundaryNptrs ( : ) !! Node number of boundary of mesh INTEGER ( I4B ), ALLOCATABLE :: InternalNptrs ( : ) !! Node number of internal nodes INTEGER ( I4B ), ALLOCATABLE :: Local_Nptrs ( : ) !! This converts a given global node into local-node which can be !! used for accessing data inside `NodeToElem, NodeToNode` TYPE ( ReferenceElement_ ), POINTER :: refelem => NULL () !! Reference element TYPE ( IntVector_ ), ALLOCATABLE :: NodeToElem ( : ) !! `NodeToElem( iLocalNode )` denotes indx of elems in mesh which are !! directly connected to node `GlobalNptrs( iLocalNode )` TYPE ( IntVector_ ), ALLOCATABLE :: ElemToElem ( : ) !! `ElemToElem( iel )` denotes data of elements !! connected to the element`iel` TYPE ( IntVector_ ), ALLOCATABLE :: NTN ( : ) !! `NTN( iLocalNode )` denotes node-ids that are connected to a node !! `GlobalNode( iLocalNode )` TYPE ( IntVector_ ), ALLOCATABLE :: ElemToNode ( : ) !! ElemToNode( iel ) denotes the node numbers in element `iel` TYPE ( IntVector_ ), ALLOCATABLE :: BoundaryData ( : ) !! If `iel` is boundary element; !! then `Vec=BoundaryData( LBndyIndex(iel) ) ` !! contains boundary data, where `vec(1)` is equal to `iel`, and !! `vec(2:)` are ids of local facets which are boundaries of mesh TYPE ( IntVector_ ), ALLOCATABLE :: InternalBndyElemNum ( : ) !! To do TYPE ( IntVector_ ), ALLOCATABLE :: InternalBoundaryData ( : ) !! To do CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: Finalize => Deallocate_meshdata !! Deallocate mesh data PROCEDURE , PUBLIC , PASS ( Obj ) :: Initiate => init_meshdata_1 !! Initiate mesh data PROCEDURE , PUBLIC , PASS ( Obj ) :: TotalNodes => get_total_nodes !! Returns total number of nodes in mesh PROCEDURE , PUBLIC , PASS ( Obj ) :: TotalBoundaryNodes => get_tbndy_nodes !! Returns total number of boundary nodes in mesh PROCEDURE , PUBLIC , PASS ( Obj ) :: TotalInternalNodes => get_tint_nodes !! Return total number of internal nodes in mesh PROCEDURE , PUBLIC , PASS ( Obj ) :: TotalBoundaryElements => get_tbndy_elems !! Rertuns total boundary elements in mesh PROCEDURE , PUBLIC , PASS ( Obj ) :: BoundingBox => get_bBox !! return boundingbox of mesh PROCEDURE , PUBLIC , PASS ( Obj ) :: local_from_global !! return local node number of a given global node number PROCEDURE , PUBLIC , PASS ( Obj ) :: local_from_global_scalar !! return local node number of a given global node number GENERIC , PUBLIC :: LocalNptrs => local_from_global , & & local_from_global_scalar !! return local node number of a given global node number PROCEDURE , PUBLIC , PASS ( Obj ) :: global_from_local !! return global node nuber of a given local node number PROCEDURE , PUBLIC , PASS ( Obj ) :: global_from_local_scalar !! return global node nuber of a given local node number GENERIC , PUBLIC :: GlobalNptrs => global_from_local , & & global_from_local_scalar !! return global node nuber of a given local node number PROCEDURE , PUBLIC , PASS ( Obj ) :: isNodePresent => is_node_present !! returns `.true.` if a given node is present in the mesh PROCEDURE , PUBLIC , PASS ( Obj ) :: isNodeToNodesInitiated => & & is_node_nodes_initiated !! returns `.true.` if `NToN` array is allocated PROCEDURE , PUBLIC , PASS ( Obj ) :: isNodeToElementsInitiated => & & is_node_elements_initiated !! returns `.true.` if `NodeToElem` array is allocated PROCEDURE , PUBLIC , PASS ( Obj ) :: isElementToElementsInitiated => & & is_element_elements_initiated !! returns `.true.` if `ElemToElem` array is allocated PROCEDURE , PUBLIC , PASS ( Obj ) :: isElementToNodesInitiated => & & is_element_nodes_initiated !! returns `.true.` if `ElemToNode` array is allocated PROCEDURE , PUBLIC , PASS ( Obj ) :: isBoundaryDataInitiated => & & is_boundarydata !! returns `.true.` if `BoundaryData` array is allocated PROCEDURE , PUBLIC , PASS ( Obj ) :: isInternalNptrsInitiated => & & is_internalnptrs !! returns `.true.` if `InternalNptrs` array is allocated PROCEDURE , PUBLIC , PASS ( Obj ) :: isBoundaryNptrsInitiated => & & is_bndy_nptrs PROCEDURE , PUBLIC , PASS ( Obj ) :: isLocalNptrsInitiated => & & is_local_nptrs !! returns `.true.` if `Local_Nptrs` array is allocated PROCEDURE , PUBLIC , PASS ( Obj ) :: isInternalBoundaryDataInitiated => & & is_int_bndy_data !! returns `.true.` if `InternalBoundaryData` array is allocated PROCEDURE , PUBLIC , PASS ( Obj ) :: InitiateNodeToElements => & & init_node_elements !! construct node to element connectivity data PROCEDURE , PUBLIC , PASS ( Obj ) :: InitiateNodeToNodes => & & init_node_nodes !! construct node to node connectivity data PROCEDURE , PUBLIC , PASS ( Obj ) :: InitiateElementToElements => & & init_element_elements !! construct element to element connectivity data PROCEDURE , PUBLIC , PASS ( Obj ) :: InitiateElementToNodes => & & init_elem_nodes !! construct element to node connectivity data PROCEDURE , PUBLIC , PASS ( Obj ) :: InitiateBoundaryData => init_bndy_data !! construct boundary data information PROCEDURE , PUBLIC , PASS ( Obj ) :: InitiateInternalNptrs => init_int_nptrs !! construct details about the internal boundary PROCEDURE , PUBLIC , PASS ( Obj ) :: InitiateInternalBoundaryData => & & init_int_bndydata !! construct details about the internal boundary PROCEDURE , PUBLIC , PASS ( Obj ) :: NodeToElements => node_elements !! return node to element connectivity data for `GlobalIndx` PROCEDURE , PUBLIC , PASS ( Obj ) :: NodeToNodes => get_node_nodes !! return node to node connectivity data for `GlobalIndx` PROCEDURE , PUBLIC , PASS ( Obj ) :: get_elem_elems_1 !! return element to element connectivity data for `iel` element PROCEDURE , PUBLIC , PASS ( Obj ) :: get_elem_elems_2 !! return element to element connectivity data for `iel` element GENERIC , PUBLIC :: ElementToElements => get_elem_elems_1 , get_elem_elems_2 !! return element to element connectivity data for `iel` element PROCEDURE , PUBLIC , PASS ( Obj ) :: ElementToNodes => get_elem_nodes !! return element to node connectivity data for `iel` element PROCEDURE , PUBLIC , PASS ( Obj ) :: isBoundaryElement => is_bndy_elem !! return `.true.` if element `iel` is a boundary element PROCEDURE , PUBLIC , PASS ( Obj ) :: BoundaryElementData => get_bndy_elem !! return boundary element data of a boundary element `iel` if it is !! boundary element PROCEDURE , PUBLIC , PASS ( Obj ) :: setSparsity => setSparsity_1 !! set sparsity in sparseMatrix_ PROCEDURE , PUBLIC , PASS ( mdObj ) :: getFacetElements => get_facet_elements !! return the boundary elements PROCEDURE , PUBLIC , PASS ( CellMeshData ) :: connectFacetToCell => & & mc_connect_facet_cell !! connect facet to cell PROCEDURE , PUBLIC , PASS ( Obj ) :: MeshQuality => md_quality !! return mesh quality PROCEDURE , PUBLIC , PASS ( Obj ) :: FindElement => md_findElement END TYPE MeshData_ !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- PUBLIC :: MeshData_ TYPE ( MeshData_ ), PUBLIC , PARAMETER :: TypeMeshData = & & MeshData_ ( & & MaxNptrs = 0 , MinNptrs = 0 , tNodes = 0 , & & isInitiated = . FALSE ., & & LBndyIndex = NULL ( ), Nptrs = NULL ( ), & & BoundaryNptrs = NULL ( ), & & InternalNptrs = NULL ( ), Local_Nptrs = NULL ( ), & & NodeToElem = NULL ( ), & & ElemToElem = NULL ( ), & & NTN = NULL ( ), & & ElemToNode = NULL ( ), & & BoundaryData = NULL ( ), & & InternalBndyElemNum = NULL ( ), & & InternalBoundaryData = NULL ( ) ) !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- !> ! Contains [[MeshData_]] pointer as its field TYPE :: MeshDataPointer_ CLASS ( MeshData_ ), POINTER :: Ptr => NULL ( ) END TYPE MeshDataPointer_ PUBLIC :: MeshDataPointer_ !---------------------------------------------------------------------------- !                                                    Initiate@MeshDataMethods !---------------------------------------------------------------------------- INTERFACE !! Initiate [[meshdata_]] object !> authors: Dr. Vikas Sharma ! ! Initiate [[meshdata_]] object ! !### Usage ! ! ```fortran !\tcall obj % initiate( meshobj ) ! ``` MODULE PURE SUBROUTINE init_meshdata_1 ( Obj , MeshObj ) CLASS ( MeshData_ ), INTENT ( INOUT ) :: Obj !! mesh data container CLASS ( Mesh_ ), INTENT ( INOUT ) :: MeshObj !! mesh object END SUBROUTINE init_meshdata_1 END INTERFACE !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- INTERFACE Initiate MODULE PROCEDURE init_meshdata_1 END INTERFACE Initiate PUBLIC :: Initiate !---------------------------------------------------------------------------- !                                                   MeshData@MeshDataMethods !---------------------------------------------------------------------------- INTERFACE !! `MeshData()` function to construct mesh data !> authors: Dr. Vikas Sharma ! ! `MeshData()` function to construct mesh data ! !### Usage ! ! ```fortran !\tobj = meshData( MeshObj ) ! ``` MODULE FUNCTION meshdata_1 ( MeshObj ) RESULT ( Ans ) TYPE ( MeshData_ ) :: Ans !! Meshdata object CLASS ( Mesh_ ), INTENT ( INOUT ) :: MeshObj !! Mesh object END FUNCTION meshdata_1 END INTERFACE !> ! Generic function to construct [[meshdata_]] INTERFACE MeshData MODULE PROCEDURE meshdata_1 END INTERFACE MeshData PUBLIC :: MeshData !---------------------------------------------------------------------------- !                                           MeshData_Pointer@MeshDataMethods !---------------------------------------------------------------------------- !> ! Generic function that Returns pointer to [[meshdata_]] object INTERFACE MeshData_Pointer MODULE PROCEDURE meshdata_ptr_1 END INTERFACE MeshData_Pointer PUBLIC :: MeshData_Pointer !---------------------------------------------------------------------------- !                                             DeallocateData@MeshDataMethods !---------------------------------------------------------------------------- INTERFACE !! Deallocate data stored inside [[meshdata_]] !> authors: Dr. Vikas Sharma ! ! Deallocate data stored inside [[meshdata_]] ! !### Usage ! ! ```fortran !\tcall deallocateData( Obj ) ! ``` MODULE SUBROUTINE Deallocate_meshdata ( Obj ) CLASS ( MeshData_ ), INTENT ( INOUT ) :: Obj !! mesh data object END SUBROUTINE Deallocate_meshdata END INTERFACE !> ! Generic subroutine to deallocate data stored inside [[MeshData_]] INTERFACE DeallocateData MODULE PROCEDURE Deallocate_meshdata END INTERFACE DeallocateData PUBLIC :: DeallocateData !---------------------------------------------------------------------------- !                                                 TotalNodes@MeshDataMethods !---------------------------------------------------------------------------- INTERFACE !! Return total number of nodes !> authors: Dr. Vikas Sharma ! ! This function will Return the total number of nodes present in meshdata ! !### Usage ! ! ```fortran !\ttnodes = Obj % TotalNodes( ) ! ``` MODULE PURE FUNCTION get_total_nodes ( Obj ) RESULT ( Ans ) CLASS ( MeshData_ ), INTENT ( IN ) :: Obj !! Mesh data object INTEGER ( I4B ) :: Ans !! Total number of nodes END FUNCTION get_total_nodes END INTERFACE !---------------------------------------------------------------------------- !                                      TotalBoundaryNodes@MeshDataMethods !---------------------------------------------------------------------------- INTERFACE !! Return total number of boundary nodes !> authors: Dr. Vikas Sharma ! ! Return total number of boundary nodes ! !### Usage ! ! ```fortran !\ttnodes = Obj % totalBoundaryNodes( ) ! ``` MODULE PURE FUNCTION get_tbndy_nodes ( Obj ) RESULT ( Ans ) CLASS ( MeshData_ ), INTENT ( IN ) :: Obj !! mesh data INTEGER ( I4B ) :: Ans !! total boundary nodes END FUNCTION get_tbndy_nodes END INTERFACE !---------------------------------------------------------------------------- !                                      TotalInternalNodes@MeshDataMethods !---------------------------------------------------------------------------- INTERFACE !! Returns total number of internal bounary nodes !> authors: Dr. Vikas Sharma ! ! Returns total number of internal bounary nodes ! !### Usage ! ! ```fortran !\ttnodes = obj % totalInternalNodes( ) ! ``` MODULE PURE FUNCTION get_tint_nodes ( Obj ) RESULT ( Ans ) CLASS ( MeshData_ ), INTENT ( IN ) :: Obj !! mesh data INTEGER ( I4B ) :: Ans !! total number of internal boundary nodes END FUNCTION get_tint_nodes END INTERFACE !---------------------------------------------------------------------------- !                                     TotalBoundaryElements@MeshDataMethods !---------------------------------------------------------------------------- INTERFACE !! This function returns the total boundary elements in mesh !> authors: Dr. Vikas Sharma ! ! This function returns the total bounadry elements in mesh MODULE PURE FUNCTION get_tbndy_elems ( Obj ) RESULT ( Ans ) CLASS ( MeshData_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ) :: Ans END FUNCTION get_tbndy_elems END INTERFACE !---------------------------------------------------------------------------- !                                           getBoundaringBox@MeshDataMethods !---------------------------------------------------------------------------- INTERFACE !! Return the boundinb box of mesh !> authors: Dr. Vikas Sharma ! ! Return the bounding box of mesh ! !### Usage ! ! ```fortran !\tbbox = BoundingBox( Obj, nodes ) ! ``` MODULE PURE FUNCTION get_Bbox ( Obj , nodes ) RESULT ( Ans ) CLASS ( MeshData_ ), INTENT ( IN ) :: Obj !! mesh data object REAL ( DFP ), INTENT ( IN ) :: nodes ( :, : ) !! nodal coordinates in xiJ format TYPE ( BoundingBox_ ) :: Ans !! bounding box for mesh END FUNCTION get_Bbox END INTERFACE !> Generic method for obtaining bounding box for a mesh INTERFACE BoundingBox MODULE PROCEDURE get_bBox END INTERFACE BoundingBox PUBLIC :: BoundingBox !---------------------------------------------------------------------------- !                                              getLocalNptrs@MeshDataMethods !---------------------------------------------------------------------------- INTERFACE !! Convert global node number to local node  number !> authors: Dr. Vikas Sharma ! ! Convert global node number to local node  number ! !### Usage ! ! ```fortran !\tindx = obj % localNptrs( globalIndx ) ! ``` MODULE PURE FUNCTION local_from_global ( Obj , GlobalIndx ) & & RESULT ( Ans ) CLASS ( MeshData_ ), INTENT ( IN ) :: Obj !! mesh data INTEGER ( I4B ), INTENT ( IN ) :: GlobalIndx ( : ) !! vec of global node numbers INTEGER ( I4B ), ALLOCATABLE :: Ans ( : ) !! vec of local node number END FUNCTION local_from_global END INTERFACE !---------------------------------------------------------------------------- !                                               getLocalNptrs@MeshDataMethods !---------------------------------------------------------------------------- INTERFACE !! Convert global node numbr to local node number !> authors: Dr. Vikas Sharma ! ! Convert global node numbr to local node number ! !### Usage ! ! ```fortran !\tindx = Obj % localNptrs( GlobalIndx ) ! ``` MODULE PURE FUNCTION local_from_global_scalar ( Obj , GlobalIndx ) & & RESULT ( Ans ) CLASS ( MeshData_ ), INTENT ( IN ) :: Obj !! mesh data INTEGER ( I4B ), INTENT ( IN ) :: GlobalIndx !! global node number INTEGER ( I4B ) :: Ans !! local node number END FUNCTION local_from_global_scalar END INTERFACE !---------------------------------------------------------------------------- !                                               GlobalNptrs@MeshDataMethods !---------------------------------------------------------------------------- INTERFACE !! Convert local node number to global node number !> authors: Dr. Vikas Sharma ! ! Convert local node number to global node number ! !### Usage ! ! ```fortran !\tindx = obj % globalNptrs( localIndx ) ! ``` MODULE PURE FUNCTION global_from_local ( Obj , LocalIndx ) & & RESULT ( Ans ) CLASS ( MeshData_ ), INTENT ( IN ) :: Obj !! mesh data INTEGER ( I4B ), INTENT ( IN ) :: LocalIndx ( : ) !! vec of local node number INTEGER ( I4B ), ALLOCATABLE :: Ans ( : ) !! vec of global node number END FUNCTION global_from_local END INTERFACE !---------------------------------------------------------------------------- !                                                GlobalNptrs@MeshDataMethods !---------------------------------------------------------------------------- INTERFACE !! Convert local node number to global node number !> authors: Dr. Vikas Sharma ! ! Convert local node number to global node number ! !### Usage ! ! ```fortran !\tindx = obj % globalNptrs( localIndx ) ! ``` MODULE PURE FUNCTION global_from_local_scalar ( Obj , LocalIndx ) RESULT ( Ans ) CLASS ( MeshData_ ), INTENT ( IN ) :: Obj !! mesh data INTEGER ( I4B ), INTENT ( IN ) :: LocalIndx !! local node number INTEGER ( I4B ) :: Ans !! global node number END FUNCTION global_from_local_scalar END INTERFACE !---------------------------------------------------------------------------- !                                             isNodePresent@MeshDataMethods !---------------------------------------------------------------------------- INTERFACE !! Returns `.true.` if the a global node is present inside the mesh-data !> authors: Dr. Vikas Sharma ! ! Returns `.true.` if the a global node is present inside the mesh-data ! !### Usage ! ! ```fortran !\tis = Obj % isNodePresent( Nptrs ) ! ``` MODULE PURE FUNCTION is_node_present ( Obj , Nptrs ) RESULT ( Ans ) CLASS ( MeshData_ ), INTENT ( IN ) :: Obj !! mesh data INTEGER ( I4B ), INTENT ( IN ) :: Nptrs !! global node number LOGICAL ( LGT ) :: Ans !! Returns true if present END FUNCTION is_node_present END INTERFACE !---------------------------------------------------------------------------- !                                     isNodeToNodesInitiated@MeshDataMethods !---------------------------------------------------------------------------- INTERFACE !! Returns `.true.` if node to node connectivity data is initiated. ! Returns `.true.` if node to node connectivity data is initiated. MODULE PURE FUNCTION is_node_nodes_initiated ( Obj ) RESULT ( Ans ) CLASS ( MeshData_ ), INTENT ( IN ) :: Obj LOGICAL ( LGT ) :: Ans END FUNCTION is_node_nodes_initiated END INTERFACE !---------------------------------------------------------------------------- !                                  isNodeToElementsInitiated@MeshDataMethods !---------------------------------------------------------------------------- INTERFACE !! Returns `.true.` if node to elem connectivity data is initiated. !> authors: Dr. Vikas Sharma ! ! Returns `.true.` if node to elem connectivity data is initiated. MODULE PURE FUNCTION is_node_elements_initiated ( Obj ) RESULT ( Ans ) CLASS ( MeshData_ ), INTENT ( IN ) :: Obj LOGICAL ( LGT ) :: Ans END FUNCTION is_node_elements_initiated END INTERFACE !---------------------------------------------------------------------------- !                               isElementToElementsInitiated@MeshDataMethods !---------------------------------------------------------------------------- INTERFACE !! Returns `.true.` if elem to elem connectivity data is initiated. !> authors: Dr. Vikas Sharma ! ! Returns `.true.` if elem to elem connectivity data is initiated. MODULE PURE FUNCTION is_element_elements_initiated ( Obj ) RESULT ( Ans ) CLASS ( MeshData_ ), INTENT ( IN ) :: Obj LOGICAL ( LGT ) :: Ans END FUNCTION is_element_elements_initiated END INTERFACE !---------------------------------------------------------------------------- !                                 isElementToNodesInitiated@MeshDataMethods !---------------------------------------------------------------------------- INTERFACE !! Returns `.true.` if elem to node connectivity data is initiated. !> authors: Dr. Vikas Sharma ! ! Returns `.true.` if elem to node connectivity data is initiated. MODULE PURE FUNCTION is_element_nodes_initiated ( Obj ) RESULT ( Ans ) CLASS ( MeshData_ ), INTENT ( IN ) :: Obj LOGICAL ( LGT ) :: Ans END FUNCTION is_element_nodes_initiated END INTERFACE !---------------------------------------------------------------------------- !                                   isBoundaryDataInitiated@MeshDataMethods !---------------------------------------------------------------------------- INTERFACE !! Returns `.true.` if boundary data is initiated. !> authors: Dr. Vikas Sharma ! ! Returns `.true.` if boundary data is initiated. MODULE PURE FUNCTION is_boundarydata ( Obj ) RESULT ( Ans ) CLASS ( MeshData_ ), INTENT ( IN ) :: Obj LOGICAL ( LGT ) :: Ans END FUNCTION is_boundarydata END INTERFACE !---------------------------------------------------------------------------- !                                   isInternalNptrsInitiated@MeshDataMethods !---------------------------------------------------------------------------- INTERFACE !! Returns `.true.` if data related to internal nptrs is initiated. !> authors: Dr. Vikas Sharma ! ! Returns `.true.` if data related to internal nptrs is initiated. MODULE PURE FUNCTION is_internalnptrs ( Obj ) RESULT ( Ans ) CLASS ( MeshData_ ), INTENT ( IN ) :: Obj LOGICAL ( LGT ) :: Ans END FUNCTION is_internalnptrs END INTERFACE !---------------------------------------------------------------------------- !                                   isBoundaryNptrsInitiated@MeshDataMethods !---------------------------------------------------------------------------- INTERFACE !! Returns `.true.` if data related to boundary nptrs is initiated. !> authors: Dr. Vikas Sharma ! ! Returns `.true.` if data related to boundary nptrs is initiated. MODULE PURE FUNCTION is_bndy_nptrs ( Obj ) RESULT ( Ans ) CLASS ( MeshData_ ), INTENT ( IN ) :: Obj LOGICAL ( LGT ) :: Ans END FUNCTION is_bndy_nptrs END INTERFACE !---------------------------------------------------------------------------- !                                      isLocalNptrsInitiated@MeshDataMethods !---------------------------------------------------------------------------- INTERFACE !! Returns `.true.` if data  `local_nptrs` array is initiated. !> authors: Dr. Vikas Sharma ! ! Returns `.true.` if data  `local_nptrs` array is initiated. MODULE PURE FUNCTION is_local_nptrs ( Obj ) RESULT ( Ans ) CLASS ( MeshData_ ), INTENT ( IN ) :: Obj LOGICAL ( LGT ) :: Ans END FUNCTION is_local_nptrs END INTERFACE !---------------------------------------------------------------------------- !                            isInternalBoundaryDataInitiated@MeshDataMethods !---------------------------------------------------------------------------- INTERFACE !! Returns `.true.` if internal bounary data is initiated !> authors: Dr. Vikas Sharma ! ! Returns `.true.` if internal bounary data is initiated MODULE PURE FUNCTION is_int_bndy_data ( Obj ) RESULT ( Ans ) CLASS ( MeshData_ ), INTENT ( IN ) :: Obj LOGICAL ( LGT ) :: Ans END FUNCTION is_int_bndy_data END INTERFACE !---------------------------------------------------------------------------- !                                      initiateNodeToElements@MeshDataMethods !---------------------------------------------------------------------------- INTERFACE !! generate Elements surrounding a node mapping !> authors: Dr. Vikas Sharma ! ! This subroutine generate Elements surrounding a node mapping ! - The mapping is stored in the array called `NodeToElem` ! - The size of `NodeToElem` array is same as `Obj % Nptrs` ! - Always use method called `NodeToElements()` to access this information ! ! @warning ! Always use the mapping between global node number and local node number to ! avoid segmentation fault ! @endwarning ! !### Usage ! ! ```fortran !\tcall Obj % initiateNodeToElements( MeshObj ) ! ``` MODULE PURE SUBROUTINE init_node_elements ( Obj , MeshObj ) CLASS ( MeshData_ ), INTENT ( INOUT ) :: Obj !! mesh data CLASS ( Mesh_ ), INTENT ( INOUT ) :: MeshObj !! mesh object END SUBROUTINE init_node_elements END INTERFACE !---------------------------------------------------------------------------- !                                             NodeToElements@MeshDataMethods !---------------------------------------------------------------------------- INTERFACE !! Returns the element numbers which are connected to the a global node !> authors: Dr. Vikas Sharma ! ! Returns the element numbers which are connected to the a global node ! !### Usage ! ! ```fortran ! val = Obj % NodeToElements( GlobalPt ) ! ``` MODULE PURE FUNCTION node_elements ( Obj , GlobalPt ) RESULT ( Ans ) CLASS ( MeshData_ ), INTENT ( IN ) :: Obj !! mesh data INTEGER ( I4B ), INTENT ( IN ) :: GlobalPt !! global node number INTEGER ( I4B ), ALLOCATABLE :: Ans ( : ) !! vec of element number END FUNCTION node_elements END INTERFACE !---------------------------------------------------------------------------- !                                        InitiateNodeToNode@MeshDataMethods !---------------------------------------------------------------------------- INTERFACE !! Initiate node to node connectivity data !> authors: Dr. Vikas Sharma ! ! Initiate node to node connectivity data ! !### Usage ! ! ```fortran !\tcall obj % initiateNodeToNode( meshobj ) ! ``` MODULE PURE SUBROUTINE init_node_nodes ( Obj , MeshObj ) CLASS ( MeshData_ ), INTENT ( INOUT ) :: Obj !! mesh data CLASS ( Mesh_ ), INTENT ( INOUT ) :: MeshObj !! mesh object END SUBROUTINE init_node_nodes END INTERFACE !---------------------------------------------------------------------------- !                                                NodeToNodes@MeshDataMethods !---------------------------------------------------------------------------- INTERFACE !! Return a list of nodes surrounding a given global node number !> authors: Dr. Vikas Sharma ! ! - Return a list of nodes surrounding a given global node number ! - `IndcludeSelf` is a logical parameter; if it is true self number is !     is also returned, otherwise only surrounding node number is returned MODULE PURE FUNCTION get_node_nodes ( Obj , GlobalNode , IncludeSelf )& & RESULT ( Ans ) CLASS ( MeshData_ ), INTENT ( IN ) :: Obj !! mesh data INTEGER ( I4B ), INTENT ( IN ) :: GlobalNode !! global node number LOGICAL ( LGT ), INTENT ( IN ) :: IncludeSelf !! logical variable INTEGER ( I4B ), ALLOCATABLE :: Ans ( : ) !! vec of node number surrounding `GlobalNode` END FUNCTION get_node_nodes END INTERFACE !---------------------------------------------------------------------------- !                                       init_element_elements@MeshDataMethods !---------------------------------------------------------------------------- INTERFACE !! Initiate element to element connectivity data !> authors: Dr. Vikas Sharma ! ! Initiate element to element connectivity data ! !### Usage ! ! ```fortran !\tcall obj % initiateElementToElement( MeshObj ) ! ``` MODULE PURE SUBROUTINE init_element_elements ( Obj , MeshObj ) CLASS ( MeshData_ ), INTENT ( INOUT ) :: Obj !! mesh data CLASS ( Mesh_ ), INTENT ( INOUT ) :: MeshObj !! mesh object END SUBROUTINE init_element_elements END INTERFACE !---------------------------------------------------------------------------- !                                         ElementToElements@MeshDataMethods !---------------------------------------------------------------------------- INTERFACE !! Return element to element connectivity information !> authors: Dr. Vikas Sharma ! ! Return element to element connectivity information for a given element ! number `iel` ! - This routine return **full information** about elements surrounding ! element `iel` ! - Rows of `Ans` denote the element to which `iel` is connected to ! - Column-1 of `Ans` denotes element number ! - Column-2 denotes the local face number of element `iel`, and ! - Column-3 denotes the local face number of element whose element number is ! given in the column-1 ! !### Usage ! ! ```fortran !\tval = Obj % ElementToElements( iel ) ! ``` MODULE PURE FUNCTION get_elem_elems_1 ( Obj , iel ) RESULT ( Ans ) CLASS ( MeshData_ ), INTENT ( IN ) :: Obj !! mesh data INTEGER ( I4B ), INTENT ( IN ) :: iel !! element number INTEGER ( I4B ), ALLOCATABLE :: Ans ( :, : ) !! list of elements surrounding elements END FUNCTION get_elem_elems_1 END INTERFACE !---------------------------------------------------------------------------- !                                         ElementToElements@MeshDataMethods !---------------------------------------------------------------------------- INTERFACE !! Return element to element connectivity information !> authors: Dr. Vikas Sharma ! ! Return element to element connectivity information for a given element ! number `iel` ! - `iel( 2 )` denotes the extra options !     0 ---> only Return the element numbers !     1 ---> Return the full information ! - This routine return **full information** when `iel(2)=1` ! about elements surrounding element `iel` ! - Rows of `Ans` denote the element to which `iel` is connected to ! - Column-1 of `Ans` denotes element number ! - Column-2 denotes the local face number of element `iel`, and ! - Column-3 denotes the local face number of element whose element number is ! given in the column-1 ! !### Usage ! ! ```fortran !\tval = Obj % ElementToElements( iel ) ! ``` MODULE PURE FUNCTION get_elem_elems_2 ( Obj , iel ) RESULT ( Ans ) CLASS ( MeshData_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: iel ( 2 ) INTEGER ( I4B ), ALLOCATABLE :: Ans ( :, : ) END FUNCTION get_elem_elems_2 END INTERFACE !---------------------------------------------------------------------------- !                                     InitiateElementToNodes@MeshDataMethods !---------------------------------------------------------------------------- INTERFACE !! Initiate element to node data !> authors: Dr. Vikas Sharma ! ! Initiate element to node data ! !### Usage ! ! ```fortran !\tcall obj % elementToNodes( Meshobj ) ! ``` MODULE PURE SUBROUTINE init_elem_nodes ( Obj , MeshObj ) CLASS ( MeshData_ ), INTENT ( INOUT ) :: Obj !! mesh data CLASS ( Mesh_ ), INTENT ( INOUT ) :: MeshObj !! mesh object END SUBROUTINE init_elem_nodes END INTERFACE !---------------------------------------------------------------------------- !                                             ElementToNodes@MeshDataMethods !---------------------------------------------------------------------------- INTERFACE !! Return element to nodes data !> authors: Dr. Vikas Sharma ! ! Return element to nodes data ! !### Usage ! ! ```fortran !\tval = Obj % elementToNodes( iel ) ! ``` MODULE PURE FUNCTION get_elem_nodes ( Obj , iel ) RESULT ( Ans ) CLASS ( MeshData_ ), INTENT ( IN ) :: Obj !! mesh data INTEGER ( I4B ), INTENT ( IN ) :: iel !! element number INTEGER ( I4B ), ALLOCATABLE :: Ans ( : ) !! list of elements surrounding the nodes END FUNCTION get_elem_nodes END INTERFACE !---------------------------------------------------------------------------- !                                                       InitiateBoundaryData !---------------------------------------------------------------------------- INTERFACE !! Initiate boundary data of mesh !> authors: Dr. Vikas Sharma ! ! Initiate boundary data of mesh ! !### Usage ! ! ```fortran !\tcall obj % initiateBoundaryData( MeshObj ) ! ``` MODULE PURE SUBROUTINE init_bndy_data ( Obj , MeshObj ) CLASS ( MeshData_ ), INTENT ( INOUT ) :: Obj !! mesh data CLASS ( Mesh_ ), INTENT ( INOUT ) :: MeshObj !! mesh object END SUBROUTINE init_bndy_data END INTERFACE !---------------------------------------------------------------------------- !                                                         isBoundaryElement !---------------------------------------------------------------------------- INTERFACE !! Returns `.true.` if a given element number `iel` is boundary element !> authors: Dr. Vikas Sharma ! ! Returns `.true.` if a given element number `iel` is boundary element ! !### Usage ! ! ```fortran !\tis = Obj % isBoundaryElement( iel ) ! ``` MODULE PURE FUNCTION is_bndy_elem ( Obj , iel ) RESULT ( Ans ) CLASS ( MeshData_ ), INTENT ( IN ) :: Obj !! mesh data INTEGER ( I4B ), INTENT ( IN ) :: iel !! element number LOGICAL ( LGT ) :: Ans !! `.true.` if `iel` is a boundary element END FUNCTION is_bndy_elem END INTERFACE !---------------------------------------------------------------------------- !                                                        BoundaryElementData !---------------------------------------------------------------------------- INTERFACE !! Returns boundary element data !> authors: Dr. Vikas Sharma ! ! If element is a boundary element then it Returns a integer vector ! containing the id of local facets which is boundary of mesh ! otherwise it will return `[0]` ! !### Usage ! ! ```fortran !\tval = Obj % boundaryElementData(iel) ! ``` MODULE PURE FUNCTION get_bndy_elem ( Obj , iel ) RESULT ( Ans ) CLASS ( MeshData_ ), INTENT ( IN ) :: Obj !! mesh data INTEGER ( I4B ), INTENT ( IN ) :: iel !! element number INTEGER ( I4B ), ALLOCATABLE :: Ans ( : ) !! boundary data END FUNCTION get_bndy_elem END INTERFACE !---------------------------------------------------------------------------- !                                                      InitiateInternalNptrs !---------------------------------------------------------------------------- INTERFACE !! Initiate internal node numbers !> authors: Dr. Vikas Sharma ! ! Initiate internal node numbers ! !### Usage ! ! ```fortran !\tcall obj % initiateInternalNptrs( MeshObj ) ! ``` MODULE PURE SUBROUTINE init_int_nptrs ( Obj , MeshObj ) CLASS ( MeshData_ ), INTENT ( INOUT ) :: Obj !! mesh data CLASS ( Mesh_ ), INTENT ( INOUT ) :: MeshObj !! mesh object END SUBROUTINE init_int_nptrs END INTERFACE !---------------------------------------------------------------------------- !                                               InitiateInternalBoundaryData !---------------------------------------------------------------------------- INTERFACE !! Initiate internal boundary data MODULE PURE SUBROUTINE init_int_bndydata ( Obj , MeshObj ) CLASS ( MeshData_ ), INTENT ( INOUT ) :: Obj CLASS ( Mesh_ ), INTENT ( INOUT ) :: MeshObj END SUBROUTINE init_int_bndydata END INTERFACE !---------------------------------------------------------------------------- !                                                setSparsity@MeshDataMethods !---------------------------------------------------------------------------- INTERFACE !! This routine set the sparsity pattern in `SparseMatrix_` object !> authors: Dr. Vikas Sharma ! ! This routine set the sparsity pattern in `SparseMatrix_` object ! !### Usage ! ! ```fortran !\tcall setSparsity( Obj, MeshObj, Mat ) ! ``` MODULE PURE SUBROUTINE setSparsity_1 ( Obj , MeshObj , Mat , map ) CLASS ( MeshData_ ), INTENT ( INOUT ) :: Obj !! mesh data TYPE ( Mesh_ ), INTENT ( INOUT ) :: MeshObj !! mesh object TYPE ( SparseMatrix_ ), INTENT ( INOUT ) :: Mat !! sparsematrix object INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: map ( : ) !! Global to local node number map END SUBROUTINE setSparsity_1 END INTERFACE !> ! generic interfac for setting sparsity pattern in [[SparseMatrix_]]. INTERFACE setSparsity MODULE PROCEDURE setSparsity_1 END INTERFACE setSparsity PUBLIC :: setSparsity !---------------------------------------------------------------------------- !                                                           getFacetElements !---------------------------------------------------------------------------- INTERFACE !! This subroutine returns the mesh of facet/boundary elements of mesh obj !> authors: Dr. Vikas Sharma ! ! This subroutine returns the mesh of boundary/facet elements of parent mesh ! `Obj` MODULE SUBROUTINE get_facet_elements ( mdObj , Obj , facetmesh , feObj ) CLASS ( MeshData_ ), INTENT ( INOUT ) :: mdObj !! Mesh data of parent mesh CLASS ( Mesh_ ), INTENT ( INOUT ) :: Obj !! Parent mesh CLASS ( Mesh_ ), INTENT ( INOUT ) :: facetmesh !! facet mesh to be constructed CLASS ( Element_ ), INTENT ( IN ) :: feObj !! Finite element END SUBROUTINE get_facet_elements END INTERFACE !---------------------------------------------------------------------------- !                                             ConnectFacetToCell@MeshMethods !---------------------------------------------------------------------------- INTERFACE !! Connect facet to cell elements !> authors: Dr. Vikas Sharma ! ! This subroutine connects the mesh of facet elements to the mesh of ! cell elements. ! !### Usage ! ! ```fortran !\tcall ConnectFacetToCell( CellMesh, FacetMesh, CellMeshData ) ! ``` MODULE PURE SUBROUTINE mc_connect_facet_cell ( CellMeshData , CellMesh , FacetMesh ) CLASS ( MeshData_ ), INTENT ( INOUT ) :: CellMeshData !! Mesh data of cell mesh CLASS ( Mesh_ ), INTENT ( INOUT ), TARGET :: CellMesh !! Mesh of  cell elements CLASS ( Mesh_ ), INTENT ( INOUT ), TARGET :: FacetMesh !! Mesh of facet elements END SUBROUTINE mc_connect_facet_cell END INTERFACE !---------------------------------------------------------------------------- !                                                     getMeshQuality@Methods !---------------------------------------------------------------------------- INTERFACE MODULE FUNCTION md_quality ( Obj , MeshObj , Nodes , Measure ) RESULT ( Ans ) CLASS ( MeshData_ ), INTENT ( INOUT ) :: Obj CLASS ( Mesh_ ), TARGET , INTENT ( INOUT ) :: Meshobj REAL ( DFP ) , INTENT ( IN ) :: Nodes (:,:) INTEGER ( I4B ), INTENT ( IN ) :: Measure REAL ( DFP ), ALLOCATABLE :: Ans (:) END FUNCTION md_quality END INTERFACE !---------------------------------------------------------------------------- !                                                                 FindElement !---------------------------------------------------------------------------- INTERFACE MODULE FUNCTION md_findelement ( Obj , MeshObj , coord , nodes ) & & RESULT ( Ans ) CLASS ( MeshData_ ), INTENT ( IN ) :: Obj CLASS ( Mesh_ ), INTENT ( IN ) :: MeshObj REAL ( DFP ), INTENT ( IN ) :: coord (:,:) REAL ( DFP ), INTENT ( IN ) :: nodes (:,:) REAL ( DFP ) :: Ans ( SIZE ( coord , 2 ) ) END FUNCTION md_findelement END INTERFACE !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- CONTAINS !---------------------------------------------------------------------------- !                                                             meshdata_ptr_2 !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! Function that returns pointer to the [[MeshData_]] object ! !### Usage ! ! ```fortran !\tclass( meshdata_ ), pointer :: obj ! obj => MeshData_Pointer( MeshObj ) ! ``` FUNCTION meshdata_ptr_1 ( MeshObj ) RESULT ( Ans ) CLASS ( MeshData_ ), POINTER :: Ans !! MeshData_ object CLASS ( Mesh_ ), INTENT ( INOUT ) :: MeshObj !! Mesh_ Object ALLOCATE ( MeshData_ :: Ans ) CALL Ans % Initiate ( MeshObj ) END FUNCTION meshdata_ptr_1 END MODULE MeshData_Class","tags":"","loc":"sourcefile/meshdata_class.f90.html"},{"title":"Mesh_Class.f90 – Fortran Program","text":"Contents Modules Mesh_Class Source Code Mesh_Class.f90 Source Code !> ! `Mesh_Class` module contains three data user defined data types related to !  finite element meshes: [[Mesh_]], [[MeshData_]], and [[MeshConnectivity_]]. MODULE Mesh_Class !! This module contains `Mesh_` `MeshData_` and `MeshConnectivity_` USE BaseType USE GlobalData USE FE IMPLICIT NONE PRIVATE REAL ( DFP ), PARAMETER :: default_factor = 1.5_DFP !---------------------------------------------------------------------------- !                                                                      Mesh_ !---------------------------------------------------------------------------- !> author: Dr Vikas Sharma ! ! In **EASIFEM** `Mesh_` datatype is simply a collection of finite elements. ! To avoid working with linked list I have encapsulated a vector of ! `ElementPointer_`. This way, adding or removing of an element ! to existing mesh becomes simple. ! ! @warning !   Dont use `Obj % SetTotalElements()` method in external programs ! @endwarning TYPE :: Mesh_ TYPE ( ElementPointer_ ), ALLOCATABLE :: Elem ( : ) !! Collection of finite elements INTEGER ( I4B ) :: NSD !! spatial dimension INTEGER ( I4B ) :: tElements !! total elements in mesh INTEGER ( I4B ) :: maxElements !! maximum size of the wrapper CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: Finalize => Deallocate_Data !! Deallocate data PROCEDURE , PUBLIC , PASS ( Obj ) :: Initiate => allocateMeshSize !! Allocate size of a mesh PROCEDURE , PUBLIC , PASS ( Obj ) :: SetTotalElements => set_total_elements !! Alias of SetSize PROCEDURE , PUBLIC , PASS ( Obj ) :: Append => add_element !! Append an element to a mesh PROCEDURE , PUBLIC , PASS ( Obj ) :: SetSize => set_total_elements !! Set total elements in a mesh PROCEDURE , PUBLIC , PASS ( Obj ) :: SetElement => Set_element !! Set an element to a mesh PROCEDURE , PUBLIC , PASS ( Obj ) :: ElementPointer => getElement_Pointer !! Get Pointer to an element in mesh PROCEDURE , PUBLIC , PASS ( Obj ) :: RemoveElement => remove_element !! Remove an element from a mesh PROCEDURE , PUBLIC , PASS ( Obj ) :: SIZE => total_elements !! Returns the total elements in a mesh PROCEDURE , PUBLIC , PASS ( Obj ) :: TotalElements => total_elements !! Alias of SIZE PROCEDURE , PUBLIC , PASS ( Obj ) :: getNptrs => get_nptrs !! Get node numbers in a mesh PROCEDURE , PUBLIC , PASS ( Obj ) :: setMaterialType => setMaterialType_1 !! Set material type of a mesh END TYPE Mesh_ !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- PUBLIC :: Mesh_ TYPE ( Mesh_ ), PARAMETER , PUBLIC :: TypeMesh = Mesh_ ( & & Elem = NULL ( ), & & NSD = 0 , tElements = 0 , & & maxElements = 0 ) !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- !> ! `MeshPointer_` is a userdefine datatype which contains the pointer to ! a mesh TYPE :: MeshPointer_ TYPE ( Mesh_ ), POINTER :: Ptr => NULL ( ) END TYPE MeshPointer_ PUBLIC :: MeshPointer_ !---------------------------------------------------------------------------- !                                                       Initiate@MeshMethods !---------------------------------------------------------------------------- INTERFACE !!  Allocate the size of the mesh !> authos: Dr Vikas Sharma ! !  Allocate the size of the mesh. Generic name ---> Initiate() ! !### Usage ! ! ```fortran !call obj % initiate( NSD = 2, tELements = 10 ) ! ```end fortran MODULE PURE SUBROUTINE allocateMeshSize ( Obj , NSD , tElements , factor ) !! allocate the size of the mesh CLASS ( Mesh_ ), INTENT ( INOUT ) :: Obj !! mesh object INTEGER ( I4B ), INTENT ( IN ) :: tElements !! total number of elements in mesh INTEGER ( I4B ), INTENT ( IN ) :: NSD !! spatial dimension REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: factor !! maxLength = factor * telements END SUBROUTINE allocateMeshSize END INTERFACE !> ! Generic routine for constructing [[Mesh_]] INTERFACE Initiate MODULE PROCEDURE allocateMeshSize END INTERFACE Initiate PUBLIC :: Initiate !---------------------------------------------------------------------------- !                                                           Mesh@MeshMethods !---------------------------------------------------------------------------- INTERFACE !!  Function for constructing [[Mesh_]] !> authos: Dr Vikas Sharma ! !  Function for constructing [[Mesh_]] ! !### Usage ! ! ```fortran !obj = Mesh( NSD = 2, tELements = 10 ) ! ```end fortran MODULE PURE FUNCTION Constructor1 ( NSD , tElements , factor ) RESULT ( Ans ) TYPE ( Mesh_ ) :: Ans !! Mesh object INTEGER ( I4B ), INTENT ( IN ) :: tElements !! totat number of elements in mesh INTEGER ( I4B ), INTENT ( IN ) :: NSD !! spatial dimension REAL ( DFP ), INTENT ( IN ), OPTIONAL :: factor END FUNCTION Constructor1 END INTERFACE !> ! Generic function for constructing [[mesh_]] INTERFACE Mesh MODULE PROCEDURE Constructor1 END INTERFACE Mesh PUBLIC :: Mesh !---------------------------------------------------------------------------- !                                                   Mesh_Pointer@MeshMethods !---------------------------------------------------------------------------- !> ! Generic function for constructing pointer to [[mesh_]] INTERFACE Mesh_Pointer MODULE PROCEDURE Constructor_1 END INTERFACE Mesh_Pointer PUBLIC :: Mesh_Pointer !---------------------------------------------------------------------------- !                                                 DeallocateData@MeshMethods !---------------------------------------------------------------------------- INTERFACE !!  Deallocate data stored in [[mesh_]] !> authos: Dr Vikas Sharma ! !  Deallocate data stored in [[mesh_]] ! !### Usage ! ! ```fortran !call deallocateData( Obj = Obj ) ! ```end fortran MODULE SUBROUTINE Deallocate_Data ( Obj ) CLASS ( Mesh_ ), INTENT ( INOUT ) :: Obj !! mesh object END SUBROUTINE Deallocate_Data END INTERFACE !> ! Generic subroutine for deallcating data stored in [[mesh_]] INTERFACE DeallocateData MODULE PROCEDURE Deallocate_Data END INTERFACE DeallocateData PUBLIC :: DeallocateData !---------------------------------------------------------------------------- !                                                         SetSize@MeshMethods !---------------------------------------------------------------------------- INTERFACE !! Set total elements in mesh object !> authos: Dr Vikas Sharma ! !  Set total elements in mesh object ! ! @note ! this routine runs through the element array and counts element pointers ! that are associated, and return the total number of associated elements. ! Therefore, it should be called only after appending/removing an element ! from the mesh. ! @endnote ! !### Usage ! ```fortran !call obj % SetSize( ) ! ```end fortran MODULE PURE SUBROUTINE set_total_elements ( Obj ) CLASS ( Mesh_ ), INTENT ( INOUT ) :: Obj !! mesh object END SUBROUTINE set_total_elements END INTERFACE !---------------------------------------------------------------------------- !                                                 AppendElement@MeshMethods !---------------------------------------------------------------------------- INTERFACE !! Add an element to mesh !> authos: Dr Vikas Sharma ! !  Append an element, increate total elements in mesh by one ! !### Usage ! ```fortran ! call obj % append( Elem ) ! ``` MODULE SUBROUTINE add_element ( Obj , Elem ) CLASS ( Mesh_ ), INTENT ( INOUT ) :: Obj !! mesh obj CLASS ( Element_ ), TARGET , INTENT ( INOUT ) :: Elem !! finite element to be added END SUBROUTINE add_element END INTERFACE !---------------------------------------------------------------------------- !                                                     SetElement@MeshMethods !---------------------------------------------------------------------------- INTERFACE !! Set an element to a mesh !> authos: Dr Vikas Sharma ! ! Seting element; total number of elements remain same ! Size of mesh should be sufficient while using this. ! !### Usage ! ```fortran ! call obj % setElement( Elem ) ! ``` MODULE PURE SUBROUTINE Set_element ( Obj , Elem , iel ) CLASS ( Mesh_ ), INTENT ( INOUT ) :: Obj !! Mesh object CLASS ( Element_ ), TARGET , INTENT ( INOUT ) :: Elem !! Finite element to be put in mesh INTEGER ( I4B ), INTENT ( IN ) :: iel !! element number END SUBROUTINE Set_element END INTERFACE !---------------------------------------------------------------------------- !                                                  ElementPointer@MeshMethods !---------------------------------------------------------------------------- INTERFACE !! Return the pointer to an element `Obj % Elem(iel)` !> authos: Dr Vikas Sharma ! ! Return the pointer to an element `Obj % Elem(iel)` ! ! @warning ! make sure `iel ` should be less that `Obj%telements` ! @endwarning ! !### Usage ! ```fortran ! class( element_ ), pointer :: elem ! elem => obj % ElementPointer( iel ) ! ``` MODULE FUNCTION getElement_Pointer ( Obj , iel ) RESULT ( Ans ) CLASS ( Mesh_ ), INTENT ( IN ) :: Obj !! mesh object INTEGER ( I4B ), INTENT ( IN ) :: iel !! element number CLASS ( Element_ ), POINTER :: Ans !! pointer to finite element END FUNCTION getElement_Pointer END INTERFACE !---------------------------------------------------------------------------- !                                                  RemoveElement@MeshMethods !---------------------------------------------------------------------------- INTERFACE !! Remove an element from the mesh !> authors: Dr. Vikas Sharma ! ! Remove an element from the mesh ! ! - extraOption = 1 then `Obj % elem( iel )` will be nullified and deallocated ! - extraOption = 2 then `Obj % elem( iel )` will be nullified and elements in ! mesh will be rearranged ! - extraoption = 3 then `Obj % elem( iel )` will be nullified and deallocated !  and elements in the mesh will be rearranged ! !### Usage ! ! ```fortran ! call obj % removeElement( iel = iel, extraoption = 2 ) ! ``` MODULE SUBROUTINE remove_element ( Obj , iel , extraoption ) CLASS ( Mesh_ ), INTENT ( INOUT ) :: Obj !! mesh object INTEGER ( I4B ), INTENT ( IN ) :: iel !! element number INTEGER ( I4B ), INTENT ( IN ) :: extraoption END SUBROUTINE remove_element END INTERFACE !---------------------------------------------------------------------------- !                                              getTotalElements@MeshMethods !---------------------------------------------------------------------------- INTERFACE !! Returns total elements in the mesh !> authors: Dr. Vikas Sharma ! ! Returns total elements in the mesh ! !### Usage ! ! ```fortran !\ttelem = Obj % SIZE( Obj ) ! ``` MODULE PURE FUNCTION total_elements ( Obj ) RESULT ( Ans ) CLASS ( Mesh_ ), INTENT ( IN ) :: Obj !! mesh object INTEGER ( I4B ) :: Ans END FUNCTION total_elements END INTERFACE !---------------------------------------------------------------------------- !                                                        Display@MeshMethods !---------------------------------------------------------------------------- INTERFACE !! display content of [[mesh_]] !> authors: Dr. Vikas Sharma ! !  Display content of [[mesh_]] ! !### Usage ! ! ```fortran !\tcall display( obj, 'mesh', stdout ) ! ``` MODULE SUBROUTINE display_mesh ( Obj , Msg , UnitNo ) CLASS ( Mesh_ ), INTENT ( INOUT ) :: Obj !! mesh object CHARACTER ( LEN = * ), INTENT ( IN ) :: Msg !! message on screen INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: UnitNo !! unit number of ouput file END SUBROUTINE display_mesh END INTERFACE !> ! generic routine to display content of mesh INTERFACE Display MODULE PROCEDURE display_mesh END INTERFACE Display PUBLIC :: Display !---------------------------------------------------------------------------- !                                                        getNptrs@MeshMethods !---------------------------------------------------------------------------- INTERFACE !! Returns the node numbers in mesh !> authors: Dr. Vikas Sharma ! ! Returns the node numbers in mesh ! !### Usage ! ! ```fortran !\tcall obj % getNptrs( Nptrs ) ! ``` MODULE PURE SUBROUTINE get_nptrs ( Obj , Nptrs ) CLASS ( Mesh_ ), INTENT ( INOUT ) :: Obj !! mesh object INTEGER ( I4B ), ALLOCATABLE , INTENT ( INOUT ) :: Nptrs ( : ) !! node numbers END SUBROUTINE get_nptrs END INTERFACE !---------------------------------------------------------------------------- !                                                           getNptrs@Methods !---------------------------------------------------------------------------- INTERFACE !! Returns a vec of node numbers present in a collection of [[MeshPointer_]] !> authors: Dr. Vikas Sharma ! ! Returns the vec of node numbers present in a collection of [[MeshPointer_]] ! !### Usage ! ! ```fortran !\tcall getNptrs( Obj, Nptrs ) ! ``` MODULE PURE SUBROUTINE mesh_pointer_get_nptrs ( Obj , Nptrs ) TYPE ( MeshPointer_ ), INTENT ( INOUT ) :: Obj ( : ) !! Collection of pointer to [[Mesh_]] INTEGER ( I4B ), ALLOCATABLE , INTENT ( INOUT ) :: Nptrs ( : ) !! Node present in the collection of mesh END SUBROUTINE mesh_pointer_get_nptrs END INTERFACE !> authors: Dr. Vikas Sharma ! ! Generic subroutine to get `Nptrs` in [[MeshPointer_]] INTERFACE getNptrs MODULE PROCEDURE mesh_pointer_get_nptrs END INTERFACE getNptrs PUBLIC :: getNptrs !---------------------------------------------------------------------------- !                                                setMaterialType@MeshMethods !---------------------------------------------------------------------------- INTERFACE !! Set material propertie !> authors: Dr. Vikas Sharma ! ! set material properties of element in the mesh. Currently, this routine ! add same material property to all elements ! ! @todo ! - add material properties by providing MatType as a vector of material type ! @endtodo ! !### Usage ! ! ```fortran !\tcall Obj % setMaterialType( MatType = 1 ) ! ``` MODULE PURE SUBROUTINE setMaterialType_1 ( Obj , MatType ) CLASS ( Mesh_ ), INTENT ( INOUT ) :: Obj !! INTEGER ( I4B ), INTENT ( IN ) :: MatType END SUBROUTINE setMaterialType_1 END INTERFACE !---------------------------------------------------------------------------- !                                                                 Contains !---------------------------------------------------------------------------- CONTAINS !> authos: Dr Vikas Sharma ! !  Function for constructing pointer to [[Mesh_]] ! !### Usage ! ! ```fortran ! class( mesh_ ), pointer :: obj ! obj => mesh_pointer( NSD = 2, tELements = 10 ) ! ```end fortran FUNCTION Constructor_1 ( NSD , tElements , factor ) RESULT ( Ans ) CLASS ( Mesh_ ), POINTER :: Ans INTEGER ( I4B ), INTENT ( IN ) :: tElements , NSD REAL ( DFP ), INTENT ( IN ), OPTIONAL :: factor ALLOCATE ( Ans ) IF ( PRESENT ( factor ) ) THEN CALL Ans % Initiate ( NSD = NSD , tElements = tElements , factor = factor ) ELSE CALL Ans % Initiate ( NSD = NSD , tElements = tElements ) END IF END FUNCTION Constructor_1 END MODULE Mesh_Class","tags":"","loc":"sourcefile/mesh_class.f90.html"},{"title":"MeshConnectivity_Class.f90 – Fortran Program","text":"Contents Modules MeshConnectivity_Class Source Code MeshConnectivity_Class.f90 Source Code MODULE MeshConnectivity_Class !! This module defines a class for handling mesh connectivity USE BaseType USE GlobalData USE FE USE Mesh_Class USE MeshData_Class IMPLICIT NONE PRIVATE !---------------------------------------------------------------------------- !                                                          MeshConnectivity_ !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! [[MeshConnectivity_]] contains data connectivity data between two meshobject TYPE :: MeshConnectivity_ INTEGER ( I4B ), ALLOCATABLE :: CellFacet ( :, : ) !! Cell to facet connectivity data INTEGER ( I4B ), ALLOCATABLE :: CellCell ( :, : ) !! Cell to cell connectivity data INTEGER ( I4B ), ALLOCATABLE :: NodeToNodes ( :, : ) !! Node to nodes connectivity data CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: Finalize => mc_deallocate_data !! Deallocate data stored in the object PROCEDURE , PUBLIC , PASS ( Obj ) :: InitiateFacetToCellData => & & mc_init_cell_facet !! Initiate facet to cell connectivity data PROCEDURE , PUBLIC , PASS ( Obj ) :: mc_cell_of_facet !! Return the cell number of a given facet PROCEDURE , PUBLIC , PASS ( Obj ) :: mc_cells_of_facets !! Return the cell numbers of given facet elements GENERIC , PUBLIC :: CellNumber => mc_cell_of_facet , & & mc_cells_of_facets !! Return the cell numbers of given facet elements PROCEDURE , PUBLIC , PASS ( Obj ) :: mc_facet_local_id_1 !! Return the facet local id in cell element PROCEDURE , PUBLIC , PASS ( Obj ) :: mc_facet_local_id_2 !! Return the facet local id in cell element GENERIC , PUBLIC :: FacetLocalID => mc_facet_local_id_1 , & & mc_facet_local_id_2 !! Return the facet local id in cell element PROCEDURE , PUBLIC , PASS ( Obj ) :: InitiateNodeToNodeData => & & mc_init_node_node !! Initiate the node to node connectivity between two meshes END TYPE !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- PUBLIC :: MeshConnectivity_ TYPE ( MeshConnectivity_ ), PARAMETER , PUBLIC :: & & TypeMeshConnectivity = MeshConnectivity_ ( & & CellFacet = NULL ( ), & & CellCell = NULL ( ), & & NodeToNodes = NULL ( ) ) !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- !> ! This data type contains the pointer of [[MeshConnectivity_]] TYPE :: MeshConnectivityPointer_ CLASS ( MeshConnectivity_ ), POINTER :: Ptr => NULL ( ) END TYPE MeshConnectivityPointer_ PUBLIC :: MeshConnectivityPointer_ !---------------------------------------------------------------------------- !                                                             DeallocateData !---------------------------------------------------------------------------- INTERFACE !! This subroutine deallocate the data stored in [[MeshConnectivity_]] !> authors: Dr. Vikas Sharma ! ! This subroutine deallocate the data stored in [[MeshConnectivity_]] ! !### Usage ! ! ```fortran !\tcall DeallocateData( Obj ) ! ``` MODULE PURE SUBROUTINE mc_deallocate_data ( Obj ) CLASS ( MeshConnectivity_ ), INTENT ( INOUT ) :: Obj !! Mesh connectivity object END SUBROUTINE mc_deallocate_data END INTERFACE !> ! Generic subroutine to deallocate data stored inside [[MeshConnectivity_]] INTERFACE DeallocateData MODULE PROCEDURE mc_deallocate_data END INTERFACE DeallocateData !---------------------------------------------------------------------------- !                                                    InitiateFacetToCellData !---------------------------------------------------------------------------- INTERFACE !! Generate the connectivity matrix between cell and facet mesh. !> authors: Dr. Vikas Sharma ! ! This subroutine generate the connectivity matrix called Obj % CellFacet ! between cell and facet mesh. ! !  - The output result will be an integer array with 2 rows !  - First row contains the element number of `CellMesh` !  - Second row contains the local facet number of cell element which !  connects to the facet mesh element. !  - Each column of `Obj % CellFacet` corresponds to an Element of !  `FacetMesh`; total number of columns are same as total number of elem !  in the `FacetMesh` !  - if an element of `FacetMesh` is orphan then its corresponding entry !  is set to zero in `Obj % CellFacet` matrix ! !### Usage ! ! ```fortran !\tcall Obj % initiateFacetToCellData( Obj, CellMesh, FacetMesh, CellMeshData) ! ``` MODULE PURE SUBROUTINE mc_init_cell_facet ( Obj , CellMesh , FacetMesh , & & CellMeshData ) CLASS ( MeshConnectivity_ ), INTENT ( INOUT ) :: Obj !! Mesh connectivity data CLASS ( Mesh_ ), INTENT ( INOUT ) :: CellMesh !! Mesh of cell elements CLASS ( Mesh_ ), INTENT ( INOUT ) :: FacetMesh !! Mesh of facet mesh CLASS ( MeshData_ ), INTENT ( INOUT ) :: CellMeshData !! Mesh data for `CellMesh` END SUBROUTINE mc_init_cell_facet END INTERFACE !---------------------------------------------------------------------------- !                                                                 CellNumber !---------------------------------------------------------------------------- INTERFACE !! Returns cell number of given facet number !> authors: Dr. Vikas Sharma ! ! - Returns cell number of given facet number ! - if cell number is zero it means facet element is an orphan ! !### Usage ! ! ```fortran !\tid = obj % CellNumber( facetNum ) ! ``` MODULE PURE FUNCTION mc_cell_of_facet ( Obj , FacetNum ) RESULT ( Ans ) CLASS ( MeshConnectivity_ ), INTENT ( IN ) :: Obj !! Mesh connectivity data INTEGER ( I4B ), INTENT ( IN ) :: FacetNum !! Facet element number INTEGER ( I4B ) :: Ans !! Cell number END FUNCTION mc_cell_of_facet END INTERFACE INTERFACE !! Returns cell number of given facet number !> authors: Dr. Vikas Sharma ! ! - Returns cell number of given facet number ! - if cell number is zero it means facet element is an orphan ! !### Usage ! ! ```fortran !\tid = obj % CellNumber( facetNum ) ! ``` MODULE PURE FUNCTION mc_cells_of_facets ( Obj , FacetNum ) RESULT ( Ans ) CLASS ( MeshConnectivity_ ), INTENT ( IN ) :: Obj !! Mesh connectivity data INTEGER ( I4B ), INTENT ( IN ) :: FacetNum ( : ) !! List of facet element numbers INTEGER ( I4B ) :: Ans ( SIZE ( FacetNum ) ) !! List of cell element numbers END FUNCTION mc_cells_of_facets END INTERFACE !---------------------------------------------------------------------------- !                                                               FacetLocalID !---------------------------------------------------------------------------- INTERFACE !! Returns the local facet id of cell element !> authors: Dr. Vikas Sharma ! ! Returns the local facet id of cell element which is in contact with ! facet element ! !### Usage ! ! ```fortran !\tid = Obj % FacetLocalID( FacetNum ) ! ``` MODULE PURE FUNCTION mc_facet_local_id_1 ( Obj , FacetNum ) RESULT ( Ans ) CLASS ( MeshConnectivity_ ), INTENT ( IN ) :: Obj !! Mesh connectivity object INTEGER ( I4B ), INTENT ( IN ) :: FacetNum !! Facet element number INTEGER ( I4B ) :: Ans !! Local facet ID END FUNCTION mc_facet_local_id_1 END INTERFACE INTERFACE !! Returns the local facet id of cell element !> authors: Dr. Vikas Sharma ! ! Returns the local facet id of cell element which is in contact with ! facet element ! !### Usage ! ! ```fortran !\tid = Obj % FacetLocalID( FacetNum ) ! ``` MODULE PURE FUNCTION mc_facet_local_id_2 ( Obj , FacetNum ) RESULT ( Ans ) CLASS ( MeshConnectivity_ ), INTENT ( IN ) :: Obj !! Mesh connectivity data INTEGER ( I4B ), INTENT ( IN ) :: FacetNum ( : ) !! List of facet element numbers INTEGER ( I4B ) :: Ans ( SIZE ( FacetNum ) ) !! List of local facet IDs END FUNCTION mc_facet_local_id_2 END INTERFACE !---------------------------------------------------------------------------- !                                                          setNodeToNodeData !---------------------------------------------------------------------------- INTERFACE !! Generate the connectivity matrix between two meshes !> authors: Dr. Vikas Sharma ! !\t This subroutine generate the connectivity matrix between two meshes !  The output result will be an integer array with 2 columns !       - first column: contains the node number of Mesh1 !       - second column: contains the node number of Mesh2 which is !       - directly connected to the node 1 MODULE PURE SUBROUTINE mc_init_node_node ( Obj , Mesh1 , Mesh2 , & & Node1 , Node2 , MeshData1 , MeshData2 ) CLASS ( MeshConnectivity_ ), INTENT ( INOUT ) :: Obj !! mesh connectivity object CLASS ( Mesh_ ), INTENT ( IN ) :: Mesh1 !! Mesh object CLASS ( Mesh_ ), INTENT ( IN ) :: Mesh2 !! Mesh object REAL ( DFP ), INTENT ( IN ) :: Node1 ( :, : ) !! Nodal coordinates in `Mesh1` REAL ( DFP ), INTENT ( IN ) :: Node2 ( :, : ) !! Nodal coordinate in `Mesh2` CLASS ( MeshData_ ), INTENT ( INOUT ) :: MeshData1 !! Mesh data for mesh 1 CLASS ( MeshData_ ), INTENT ( INOUT ) :: MeshData2 !! Mesh data for mesh 2 END SUBROUTINE mc_init_node_node END INTERFACE !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- END MODULE MeshConnectivity_Class","tags":"","loc":"sourcefile/meshconnectivity_class.f90.html"},{"title":"Domain_Class.f90 – Fortran Program","text":"Contents Modules Domain_Class Source Code Domain_Class.f90 Source Code !> authors: Dr. Vikas Sharma ! ! `Domain_Class` module contains the collection of meshes which represent specific ! parts of domain ! MODULE Domain_Class !! This module defines `Domain_` class USE BaseType USE GlobalData USE Mesh_Class USE MeshData_Class USE MeshConnectivity_Class USE FE IMPLICIT NONE PRIVATE !---------------------------------------------------------------------------- !                                                                    Domain !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! `Domain_` contains the collection of meshes which represent specific ! parts of domain TYPE :: Domain_ TYPE ( MeshPointer_ ), ALLOCATABLE :: Omega ( : ) !! Mesh of cell elements TYPE ( MeshPointer_ ), ALLOCATABLE :: Boundary ( : ) !! Mesh of boundary elements TYPE ( MeshPointer_ ), ALLOCATABLE :: Edge ( : ) !! Mesh of lines TYPE ( MeshDataPointer_ ), ALLOCATABLE :: mdOmega ( : ) !! Mesh data for `Omega(:)` TYPE ( MeshDataPointer_ ), ALLOCATABLE :: mdBoundary ( : ) !! Mesh data for `Boundary(:)` TYPE ( MeshDataPointer_ ), ALLOCATABLE :: mdEdge ( : ) !! Mesh data for `Boundary(:)` REAL ( DFP ), POINTER :: Nodes ( :, : ) => NULL ( ) REAL ( DFP ), ALLOCATABLE :: NodalVelocity ( :, : ) REAL ( DFP ), ALLOCATABLE :: NodalAcceleration ( :, : ) LOGICAL ( LGT ) :: allocateNodes = . FALSE . !! This indicates whether nodes are allocated inside the domain or outside TYPE ( String ), ALLOCATABLE :: omega_name ( : ) !! Physical names of omega TYPE ( String ), ALLOCATABLE :: boundary_name ( : ) !! physical names of boundary TYPE ( String ), ALLOCATABLE :: edge_name ( : ) !! physical names of edge CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: Initiate => Initiate_obj !! Constructor for domain PROCEDURE , PUBLIC , PASS ( Obj ) :: Finalize => deallocate_obj !! Deallocate data store inside the domain PROCEDURE , PUBLIC , PASS ( Dom ) :: ConnectFacetToCell => & & mc_connect_facet_cell END TYPE Domain_ !---------------------------------------------------------------------------- !                                                                    Domain_ !---------------------------------------------------------------------------- PUBLIC :: Domain_ TYPE ( Domain_ ), PARAMETER , PUBLIC :: & & TypeDomain = Domain_ ( & & Omega = NULL ( ), & & Boundary = NULL ( ), & & Edge = NULL ( ), & & mdOmega = NULL ( ), & & mdBoundary = NULL ( ), & & mdEdge = NULL ( ), & & omega_name = NULL ( ), & & boundary_name = NULL ( ), & & edge_name = NULL ( ), & & NodalVelocity = NULL ( ), & & NodalAcceleration = NULL ( ) ) !---------------------------------------------------------------------------- !                                                             DomainPointer_ !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! It contains pointer to [[Domain_]] object TYPE :: DomainPointer_ CLASS ( Domain_ ), POINTER :: Ptr => NULL ( ) END TYPE DomainPointer_ PUBLIC :: DomainPointer_ !---------------------------------------------------------------------------- !                                                           Initiate@Methods !---------------------------------------------------------------------------- INTERFACE !! Initiate [[Domain_]] object !> authors: Dr. Vikas Sharma ! ! This routine allocate the memory for [[Domain_]] obj. ! - allocate size of `Obj % Omega( 1:tOmega )` ! - allocate `Obj % Boundary( 1:tBoundary )`, ! - allocate `Obj % mdOmega( 1:tOmega )` ! - allocate `Obj % mdBoundary( 1:tBoundary )` ! !### Usage ! ! ```fortran !\tcall Obj % initiate( tOmega, tBoundary ) ! ``` MODULE PURE SUBROUTINE Initiate_obj ( Obj , tOmega , tBoundary , tEdge ) CLASS ( Domain_ ), INTENT ( INOUT ) :: Obj !! Domain INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: tOmega !! total number of $\\Omega$ domains INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: tBoundary !! total number of $\\Gamma$ domains INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: tEdge !! total number of line domains END SUBROUTINE Initiate_obj END INTERFACE !> ! Generic routine for initiating [[Domain_]] object INTERFACE Initiate MODULE PROCEDURE Initiate_obj END INTERFACE Initiate PUBLIC :: Initiate !---------------------------------------------------------------------------- !                                                  DeallocateData@Constructor !---------------------------------------------------------------------------- INTERFACE !! Deallocate data in [[Domain_]] object !> authors: Dr. Vikas Sharma ! ! Deallocate data stored in [[Domain_]] object ! MODULE PURE SUBROUTINE deallocate_obj ( Obj ) CLASS ( Domain_ ), INTENT ( INOUT ) :: Obj !! Domain object END SUBROUTINE deallocate_obj END INTERFACE !> ! generic interface to deallocate data in [[Domain_]] INTERFACE DeallocateData MODULE PROCEDURE deallocate_obj END INTERFACE DeallocateData PUBLIC :: DeallocateData !---------------------------------------------------------------------------- !                                                 ConnectFacetToCell@Methods !---------------------------------------------------------------------------- INTERFACE !! Connect [[mesh_]] of [[facetelement_]] to [[mesh_]] of cell [[element_]] !> authors: Dr. Vikas Sharma ! ! This subroutine connects the mesh of facet elements to the mesh of ! cell elements ! ! User does not require to access the mesh. One can simply provide the ! index of cell mesh (i.e., dom % omega( cellIndx ) ) and index of facet mesh ! (i.e., dom % boundary( faceIndx )). This subroutine runs several ! tests and reports error if there is any. ! ! @note ! This subroutine is a wrapper around [[mesh_:connectFacetToCell]] ! !### Usage ! ! ```fortran !\tcall ConnectFacetToCell( Dom, OmegaIndx, BoundaryIndx ) ! ``` MODULE SUBROUTINE mc_connect_facet_cell ( Dom , OmegaIndx , BoundaryIndx ) CLASS ( Domain_ ), INTENT ( INOUT ), TARGET :: Dom INTEGER ( I4B ), INTENT ( IN ) :: OmegaIndx INTEGER ( I4B ), INTENT ( IN ) :: BoundaryIndx END SUBROUTINE mc_connect_facet_cell END INTERFACE !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- END MODULE Domain_Class","tags":"","loc":"sourcefile/domain_class.f90.html"},{"title":"FE.f90 – Fortran Program","text":"Contents Modules FE Source Code FE.f90 Source Code MODULE FE USE Element_Class USE FacetElement_Class PUBLIC CONTAINS !---------------------------------------------------------------------------- !                                                              getFEPointer !---------------------------------------------------------------------------- FUNCTION getFEPointer ( Obj , Nptrs , Mat_Type , RefElem ) RESULT ( Ans ) USE BaseType USE GlobalData ! Define internal variable CLASS ( Element_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Nptrs ( : ), Mat_Type CLASS ( ReferenceElement_ ), TARGET , INTENT ( INOUT ) :: RefElem CLASS ( Element_ ), POINTER :: Ans ! SELECT TYPE ( Obj ) TYPE IS ( Element_ ) Ans => Element_Pointer ( Nptrs , Mat_Type , RefElem ) TYPE IS ( FacetElement_ ) Ans => FacetElement_Pointer ( Nptrs , Mat_Type , RefElem ) END SELECT ! END FUNCTION getFEPointer END MODULE FE","tags":"","loc":"sourcefile/fe.f90.html"},{"title":"Element_Class.f90 – Fortran Program","text":"Contents Modules Element_Class Source Code Element_Class.f90 Source Code MODULE Element_Class USE GlobalData USE BaseType IMPLICIT NONE PRIVATE !---------------------------------------------------------------------------- !                                                                  Element_ !---------------------------------------------------------------------------- PUBLIC :: Element_ TYPE :: Element_ INTEGER ( I4B ), ALLOCATABLE :: Nptrs ( : ) INTEGER ( I4B ) :: MAT_Type CLASS ( ReferenceElement_ ), POINTER :: RefElem => NULL ( ) CONTAINS ! Constructor PROCEDURE , PUBLIC , PASS ( Obj ) :: m_Initiate_obj , m_initiate_from_obj GENERIC , PUBLIC :: Initiate => m_Initiate_obj , m_initiate_from_obj PROCEDURE , PUBLIC , PASS ( Obj ) :: Display => m_display_Obj PROCEDURE , PUBLIC , PASS ( Obj ) :: isBoundaryElement => m_isBoundaryElement PROCEDURE , PUBLIC , PASS ( Obj ) :: getNptrs => m_getNptrs PROCEDURE , PUBLIC , PASS ( Obj ) :: setNptrs => m_setNptrs GENERIC , PUBLIC :: OPERATOR ( . Nptrs . ) => getNptrs PROCEDURE , PUBLIC , PASS ( Obj ) :: setMaterialType => setMaterialType_1 ! ShapeData PROCEDURE , PUBLIC , PASS ( Obj ) :: get_elemsd_H1_Lagrange GENERIC , PUBLIC :: getElemShapeData => get_elemsd_H1_Lagrange ! Virtual PROCEDURE , PUBLIC , PASS ( Obj ) :: CellNptrs => getCellNptrs PROCEDURE , PUBLIC , PASS ( Obj ) :: PointerToCell => getPointerToCell PROCEDURE , PUBLIC , PASS ( Obj ) :: CellPointer => getPointerToCell PROCEDURE , PUBLIC , PASS ( Obj ) :: FacetLocalID => getFacetLocalID PROCEDURE , PUBLIC , PASS ( Obj ) :: FacetLocalNptrs => getFacetLocalNptrs PROCEDURE , PUBLIC , PASS ( Obj ) :: setPointerToCell PROCEDURE , PUBLIC , PASS ( Obj ) :: FreePointerToCell PROCEDURE , PUBLIC , PASS ( Obj ) :: setFacetLocalID END TYPE Element_ !---------------------------------------------------------------------------- !                                                              TypeElement !---------------------------------------------------------------------------- TYPE ( Element_ ), PARAMETER , PUBLIC :: & & TypeElement = Element_ ( Nptrs = NULL ( ), Mat_Type = 0_I4B , & & RefElem = NULL ( ) ) !---------------------------------------------------------------------------- !                                                           ElementPointer_ !---------------------------------------------------------------------------- TYPE :: ElementPointer_ CLASS ( Element_ ), POINTER :: Ptr => NULL ( ) END TYPE ElementPointer_ PUBLIC :: ElementPointer_ !---------------------------------------------------------------------------- !                                                      Initiate@Constructor !---------------------------------------------------------------------------- INTERFACE ! This is a method with name initiate MODULE PURE SUBROUTINE m_Initiate_obj ( Obj , Nptrs , Mat_Type , RefElem ) CLASS ( Element_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Nptrs ( : ), Mat_Type CLASS ( ReferenceElement_ ), TARGET , INTENT ( INOUT ) :: RefElem END SUBROUTINE m_Initiate_obj MODULE PURE SUBROUTINE m_initiate_from_obj ( Obj , AnotherObj ) CLASS ( Element_ ), INTENT ( INOUT ) :: Obj CLASS ( Element_ ), TARGET , INTENT ( INOUT ) :: AnotherObj END SUBROUTINE m_initiate_from_obj END INTERFACE !---------------------------------------------------------------------------- !                                                       Initiate@Constructor !---------------------------------------------------------------------------- INTERFACE ! This is a subroutine MODULE PURE SUBROUTINE s_Initiate_obj ( Obj , Nptrs , Mat_Type , RefElem ) CLASS ( Element_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Nptrs ( : ), Mat_Type CLASS ( ReferenceElement_ ), TARGET , INTENT ( INOUT ) :: RefElem END SUBROUTINE s_Initiate_obj END INTERFACE INTERFACE Initiate MODULE PROCEDURE s_initiate_obj END INTERFACE Initiate PUBLIC :: Initiate !---------------------------------------------------------------------------- !                                                       Element@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE FUNCTION Constructor1 ( Nptrs , Mat_Type , RefElem ) RESULT ( Obj ) TYPE ( Element_ ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Nptrs ( : ), Mat_Type CLASS ( ReferenceElement_ ), TARGET , INTENT ( INOUT ) :: RefElem END FUNCTION Constructor1 MODULE FUNCTION Constructor2 ( ) RESULT ( Obj ) TYPE ( Element_ ) :: Obj END FUNCTION Constructor2 MODULE FUNCTION Constructor3 ( AnotherObj ) RESULT ( Obj ) TYPE ( Element_ ) :: Obj CLASS ( Element_ ), TARGET , INTENT ( INOUT ) :: AnotherObj END FUNCTION Constructor3 END INTERFACE INTERFACE Element MODULE PROCEDURE Constructor1 , Constructor2 , Constructor3 END INTERFACE Element PUBLIC :: Element !---------------------------------------------------------------------------- !                                               Element_Pointer@Constructor !---------------------------------------------------------------------------- INTERFACE Element_Pointer MODULE PROCEDURE Constructor_1 , Constructor_2 , Constructor_3 END INTERFACE Element_Pointer PUBLIC :: Element_Pointer !---------------------------------------------------------------------------- !                                                 setMaterialType@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE setMaterialType_1 ( Obj , MatType ) CLASS ( Element_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: MatType END SUBROUTINE setMaterialType_1 END INTERFACE !---------------------------------------------------------------------------- !                                                        Display@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE m_display_Obj ( Obj , msg , UnitNo , FullDisp ) CLASS ( Element_ ), INTENT ( IN ) :: Obj CHARACTER ( LEN = * ), INTENT ( IN ) :: Msg INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: UnitNo LOGICAL ( LGT ), OPTIONAL , INTENT ( IN ) :: FullDisp END SUBROUTINE m_display_Obj END INTERFACE !---------------------------------------------------------------------------- !                                                        Display@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE s_display_Obj ( Obj , msg , UnitNo , FullDisp ) TYPE ( Element_ ), INTENT ( IN ) :: Obj CHARACTER ( LEN = * ), INTENT ( IN ) :: Msg INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: UnitNo LOGICAL ( LGT ), OPTIONAL , INTENT ( IN ) :: FullDisp END SUBROUTINE s_display_Obj END INTERFACE INTERFACE Display MODULE PROCEDURE s_display_Obj END INTERFACE Display PUBLIC :: Display !---------------------------------------------------------------------------- !                                                DeallocateData@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE Deallocate_Data ( Obj ) TYPE ( Element_ ), INTENT ( INOUT ) :: Obj END SUBROUTINE Deallocate_Data END INTERFACE INTERFACE DeallocateData MODULE PROCEDURE Deallocate_Data END INTERFACE DeallocateData PUBLIC :: DeallocateData !---------------------------------------------------------------------------- !                                              isBoundaryElement@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION m_isBoundaryElement ( Obj , NSD ) RESULT ( Ans ) CLASS ( Element_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: NSD LOGICAL ( LGT ) :: Ans END FUNCTION m_isBoundaryElement END INTERFACE !---------------------------------------------------------------------------- !                                                        getNptrs@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION m_getNptrs ( Obj ) RESULT ( Nptrs ) CLASS ( Element_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), ALLOCATABLE :: Nptrs ( : ) END FUNCTION m_getNptrs END INTERFACE !---------------------------------------------------------------------------- !                                                      setNptrs@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE m_setNptrs ( Obj , Nptrs ) CLASS ( Element_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Nptrs ( : ) END SUBROUTINE m_setNptrs END INTERFACE !---------------------------------------------------------------------------- !                                                 getElemShapeData@ShapeData !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE get_elemsd_H1_Lagrange ( Obj , ElemSD , Quad , xiJ , & & ContinuityType , InterpolType ) CLASS ( Element_ ), INTENT ( INOUT ) :: Obj CLASS ( ElemShapeData_ ), INTENT ( INOUT ) :: ElemSD TYPE ( QuadraturePoint_ ), INTENT ( IN ) :: Quad REAL ( DFP ), INTENT ( IN ) :: xIJ ( :, : ) TYPE ( H1_ ), INTENT ( IN ) :: ContinuityType TYPE ( LagrangeInterpolation_ ), INTENT ( IN ) :: InterpolType END SUBROUTINE get_elemsd_H1_Lagrange END INTERFACE !------------------------------------------------------------------------------ !                                                        getCellNptrs@Virtual !------------------------------------------------------------------------------ ! Get Obj % Cell % Nptrs INTERFACE MODULE PURE FUNCTION getCellNptrs ( Obj ) RESULT ( Ans ) CLASS ( Element_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), ALLOCATABLE :: Ans ( : ) END FUNCTION getCellNptrs END INTERFACE !---------------------------------------------------------------------------- !                                                   SetPointerToCell@Virtual !---------------------------------------------------------------------------- ! Set Obj % Cell INTERFACE MODULE PURE SUBROUTINE SetPointerToCell ( Obj , CellObj ) CLASS ( Element_ ), INTENT ( INOUT ) :: Obj CLASS ( Element_ ), INTENT ( INOUT ), TARGET :: CellObj END SUBROUTINE SetPointerToCell END INTERFACE !---------------------------------------------------------------------------- !                                                   getPointerToCell@Virtual !---------------------------------------------------------------------------- !Get Obj % Cell INTERFACE MODULE FUNCTION getPointerToCell ( Obj ) RESULT ( CellObj ) CLASS ( Element_ ), INTENT ( IN ), TARGET :: Obj CLASS ( Element_ ), POINTER :: CellObj END FUNCTION getPointerToCell END INTERFACE !------------------------------------------------------------------------------ !                                                    FreePointerToCell@Virtual !------------------------------------------------------------------------------ INTERFACE MODULE PURE SUBROUTINE FreePointerToCell ( Obj ) CLASS ( Element_ ), INTENT ( INOUT ) :: Obj END SUBROUTINE FreePointerToCell END INTERFACE !------------------------------------------------------------------------------ !                                                      getFacetLocalID@Virtual !------------------------------------------------------------------------------ INTERFACE MODULE PURE FUNCTION getFacetLocalID ( Obj ) RESULT ( Ans ) CLASS ( Element_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ) :: Ans END FUNCTION getFacetLocalID END INTERFACE !------------------------------------------------------------------------------ !                                                      setFacetLocalID@Virtual !------------------------------------------------------------------------------ INTERFACE MODULE PURE SUBROUTINE setFacetLocalID ( Obj , Id ) CLASS ( Element_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Id END SUBROUTINE setFacetLocalID END INTERFACE !------------------------------------------------------------------------------ !                                                   getFacetLocalNptrs@Virtual !------------------------------------------------------------------------------ INTERFACE MODULE PURE FUNCTION getFacetLocalNptrs ( Obj ) RESULT ( Nptrs ) CLASS ( Element_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), ALLOCATABLE :: Nptrs ( : ) END FUNCTION getFacetLocalNptrs END INTERFACE !------------------------------------------------------------------------------ !                                                                     Contains !------------------------------------------------------------------------------ CONTAINS !------------------------------------------------------------------------------ !                                                              Element_Pointer !------------------------------------------------------------------------------ FUNCTION Constructor_1 ( Nptrs , Mat_Type , RefElem ) RESULT ( Obj ) CLASS ( Element_ ), POINTER :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Nptrs ( : ), Mat_Type CLASS ( ReferenceElement_ ), TARGET , INTENT ( INOUT ) :: RefElem ALLOCATE ( Obj ) CALL Obj % Initiate ( Nptrs = Nptrs , Mat_Type = Mat_Type , RefElem = RefElem ) END FUNCTION Constructor_1 !------------------------------------------------------------------------------ !                                                              Element_Pointer !------------------------------------------------------------------------------ FUNCTION Constructor_2 ( ) RESULT ( Obj ) CLASS ( Element_ ), POINTER :: Obj ALLOCATE ( Obj ) Obj % Mat_Type = - 1 Obj % Nptrs = [ - 1 ] Obj % RefElem => NULL ( ) END FUNCTION Constructor_2 !------------------------------------------------------------------------------ !                                                             Element_Pointer !------------------------------------------------------------------------------ FUNCTION Constructor_3 ( AnotherObj ) RESULT ( Obj ) CLASS ( Element_ ), POINTER :: Obj CLASS ( Element_ ), TARGET , INTENT ( INOUT ) :: AnotherObj ALLOCATE ( Obj ) CALL Obj % Initiate ( AnotherObj ) END FUNCTION Constructor_3 END MODULE Element_Class","tags":"","loc":"sourcefile/element_class.f90.html"},{"title":"FacetElement_Class.f90 – Fortran Program","text":"Contents Modules FacetElement_Class Source Code FacetElement_Class.f90 Source Code MODULE FacetElement_Class USE GlobalData USE BaseType USE Element_Class PRIVATE !---------------------------------------------------------------------------- !                                                              FacetElement_ !---------------------------------------------------------------------------- TYPE , EXTENDS ( Element_ ) :: FacetElement_ INTEGER ( I4B ) :: LocalID CLASS ( Element_ ), POINTER :: Cell => NULL ( ) CLASS ( Element_ ), POINTER :: OuterCell => NULL ( ) CONTAINS ! Constructor PROCEDURE , PUBLIC , PASS ( Obj ) :: CellNptrs => getCellNptrs PROCEDURE , PUBLIC , PASS ( Obj ) :: PointerToCell => getPointerToCell PROCEDURE , PUBLIC , PASS ( Obj ) :: FacetLocalID => getFacetLocalID PROCEDURE , PUBLIC , PASS ( Obj ) :: FacetLocalNptrs => getFacetLocalNptrs PROCEDURE , PUBLIC , PASS ( Obj ) :: setPointerToCell PROCEDURE , PUBLIC , PASS ( Obj ) :: FreePointerToCell PROCEDURE , PUBLIC , PASS ( Obj ) :: setFacetLocalID PROCEDURE , PUBLIC , PASS ( Obj ) :: Display => m_display_Obj ! ! getElemShapeData.part PROCEDURE , PUBLIC , PASS ( Obj ) :: get_elemsd_H1_Lagrange ! PROCEDURE, PUBLIC, PASS( Obj ) :: getElemShapeData_From_XiJ2 END TYPE FacetElement_ PUBLIC :: FacetElement_ !---------------------------------------------------------------------------- !                                                            TypeFacetElement !---------------------------------------------------------------------------- TYPE ( FacetElement_ ), PARAMETER , PUBLIC :: & & TypeFacetElement = FacetElement_ ( Mat_Type = 0_I4B , & & RefElem = NULL (), LocalID = 0_I4B ) !---------------------------------------------------------------------------- !                                                        FacetElementPointer_ !---------------------------------------------------------------------------- TYPE :: FacetElementPointer_ CLASS ( FacetElementPointer_ ), POINTER :: Ptr => NULL ( ) END TYPE FacetElementPointer_ PUBLIC :: FacetElementPointer_ !---------------------------------------------------------------------------- !                                                   FacetElement@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE FUNCTION Constructor1 ( Nptrs , Mat_Type , RefElem ) RESULT ( Obj ) TYPE ( FacetElement_ ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Nptrs ( : ), Mat_Type CLASS ( ReferenceElement_ ), TARGET , INTENT ( INOUT ) :: RefElem END FUNCTION Constructor1 MODULE FUNCTION Constructor2 ( ) RESULT ( Obj ) TYPE ( FacetElement_ ) :: Obj END FUNCTION Constructor2 MODULE FUNCTION Constructor3 ( AnotherObj ) RESULT ( Obj ) TYPE ( FacetElement_ ) :: Obj CLASS ( Element_ ), TARGET , INTENT ( INOUT ) :: AnotherObj END FUNCTION Constructor3 END INTERFACE INTERFACE FacetElement MODULE PROCEDURE Constructor1 , Constructor2 , Constructor3 END INTERFACE PUBLIC :: FacetElement !------------------------------------------------------------------------------ !                                                                 FacetElement !------------------------------------------------------------------------------ INTERFACE FacetElement_Pointer MODULE PROCEDURE Constructor_1 , Constructor_2 , Constructor_3 END INTERFACE PUBLIC :: FacetElement_Pointer !---------------------------------------------------------------------------- !                                                        Display@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE m_display_Obj ( Obj , msg , UnitNo , FullDisp ) CLASS ( FacetElement_ ), INTENT ( IN ) :: Obj CHARACTER ( LEN = * ), INTENT ( IN ) :: Msg INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: UnitNo LOGICAL ( LGT ), OPTIONAL , INTENT ( IN ) :: FullDisp END SUBROUTINE m_display_Obj END INTERFACE !---------------------------------------------------------------------------- !                                                        Display@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE s_display_Obj ( Obj , msg , UnitNo , FullDisp ) TYPE ( FacetElement_ ), INTENT ( IN ) :: Obj CHARACTER ( LEN = * ), INTENT ( IN ) :: Msg INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: UnitNo LOGICAL ( LGT ), OPTIONAL , INTENT ( IN ) :: FullDisp END SUBROUTINE s_display_Obj END INTERFACE INTERFACE Display MODULE PROCEDURE s_display_Obj END INTERFACE Display PUBLIC :: Display !---------------------------------------------------------------------------- !                                                DeallocateData@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE Deallocate_Data ( Obj ) TYPE ( FacetElement_ ), INTENT ( INOUT ) :: Obj END SUBROUTINE Deallocate_Data END INTERFACE INTERFACE DeallocateData MODULE PROCEDURE Deallocate_Data END INTERFACE DeallocateData PUBLIC :: DeallocateData !------------------------------------------------------------------------------ !                                                    getCellNptrs@Constructor !------------------------------------------------------------------------------ ! Get Obj % Cell % Nptrs INTERFACE MODULE PURE FUNCTION getCellNptrs ( Obj ) RESULT ( Ans ) CLASS ( FacetElement_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), ALLOCATABLE :: Ans ( : ) END FUNCTION getCellNptrs END INTERFACE !---------------------------------------------------------------------------- !                                               SetPointerToCell@Constructor !---------------------------------------------------------------------------- ! Set Obj % Cell INTERFACE MODULE PURE SUBROUTINE SetPointerToCell ( Obj , CellObj ) CLASS ( FacetElement_ ), INTENT ( INOUT ) :: Obj CLASS ( Element_ ), INTENT ( INOUT ), TARGET :: CellObj END SUBROUTINE SetPointerToCell END INTERFACE !---------------------------------------------------------------------------- !                                               getPointerToCell@Constructor !---------------------------------------------------------------------------- !Get Obj % Cell INTERFACE MODULE FUNCTION getPointerToCell ( Obj ) RESULT ( CellObj ) CLASS ( FacetElement_ ), INTENT ( IN ), TARGET :: Obj CLASS ( Element_ ), POINTER :: CellObj END FUNCTION getPointerToCell END INTERFACE !------------------------------------------------------------------------------ !                                                FreePointerToCell@Constructor !------------------------------------------------------------------------------ INTERFACE MODULE PURE SUBROUTINE FreePointerToCell ( Obj ) CLASS ( FacetElement_ ), INTENT ( INOUT ) :: Obj END SUBROUTINE FreePointerToCell END INTERFACE !------------------------------------------------------------------------------ !                                                  getFacetLocalID@Constructor !------------------------------------------------------------------------------ INTERFACE MODULE PURE FUNCTION getFacetLocalID ( Obj ) RESULT ( Ans ) CLASS ( FacetElement_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ) :: Ans END FUNCTION getFacetLocalID END INTERFACE !------------------------------------------------------------------------------ !                                                  setFacetLocalID@Constructor !------------------------------------------------------------------------------ INTERFACE MODULE PURE SUBROUTINE setFacetLocalID ( Obj , Id ) CLASS ( FacetElement_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Id END SUBROUTINE setFacetLocalID END INTERFACE !------------------------------------------------------------------------------ !                                              getFacetLocalNptrs@Constructor !------------------------------------------------------------------------------ INTERFACE MODULE PURE FUNCTION getFacetLocalNptrs ( Obj ) RESULT ( Nptrs ) CLASS ( FacetElement_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), ALLOCATABLE :: Nptrs ( : ) END FUNCTION getFacetLocalNptrs END INTERFACE !---------------------------------------------------------------------------- !                                                 getElemShapeData@ShapeData !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE get_elemsd_H1_Lagrange ( Obj , ElemSD , Quad , xiJ , & & ContinuityType , InterpolType ) CLASS ( FacetElement_ ), INTENT ( INOUT ) :: Obj CLASS ( ElemShapeData_ ), INTENT ( INOUT ) :: ElemSD TYPE ( QuadraturePoint_ ), INTENT ( IN ) :: Quad REAL ( DFP ), INTENT ( IN ) :: xIJ ( :, : ) TYPE ( H1_ ), INTENT ( IN ) :: ContinuityType TYPE ( LagrangeInterpolation_ ), INTENT ( IN ) :: InterpolType END SUBROUTINE get_elemsd_H1_Lagrange END INTERFACE !------------------------------------------------------------------------------ !                                                         Contains@Constructor !------------------------------------------------------------------------------ CONTAINS !------------------------------------------------------------------------------ !                                                              Element_Pointer !------------------------------------------------------------------------------ FUNCTION Constructor_1 ( Nptrs , Mat_Type , RefElem ) RESULT ( Obj ) CLASS ( FacetElement_ ), POINTER :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Nptrs ( : ), Mat_Type CLASS ( ReferenceElement_ ), TARGET , INTENT ( INOUT ) :: RefElem ALLOCATE ( Obj ) CALL Obj % Initiate ( Nptrs = Nptrs , Mat_Type = Mat_Type , RefElem = RefElem ) END FUNCTION Constructor_1 !------------------------------------------------------------------------------ !                                                              Element_Pointer !------------------------------------------------------------------------------ FUNCTION Constructor_2 ( ) RESULT ( Obj ) CLASS ( FacetElement_ ), POINTER :: Obj ALLOCATE ( Obj ) Obj % Mat_Type = - 1 Obj % Nptrs = [ - 1 ] Obj % RefElem => NULL ( ) END FUNCTION Constructor_2 !------------------------------------------------------------------------------ !                                                             Element_Pointer !------------------------------------------------------------------------------ FUNCTION Constructor_3 ( AnotherObj ) RESULT ( Obj ) CLASS ( FacetElement_ ), POINTER :: Obj CLASS ( FacetElement_ ), TARGET , INTENT ( INOUT ) :: AnotherObj ALLOCATE ( Obj ) CALL Obj % Initiate ( AnotherObj ) END FUNCTION Constructor_3 END MODULE FacetElement_Class","tags":"","loc":"sourcefile/facetelement_class.f90.html"},{"title":"vtkType.f90 – Fortran Program","text":"Contents Modules vtkType Source Code vtkType.f90 Source Code MODULE vtkType !! This module contains methods to write mesh data in vtk file format !> authors: Dr. Vikas Sharma ! ! It is a wrapper around Vtk-fortran library of ! [https://github.com/szaghi/VTKFortran](Szaghi) ! USE GlobalData USE BaseType USE vtk_fortran USE Mesh_Class USE MeshData_Class IMPLICIT NONE PRIVATE !---------------------------------------------------------------------------- !                                                                       vtk_ !---------------------------------------------------------------------------- TYPE :: vtk_ TYPE ( vtk_file ) :: afile TYPE ( String ) :: path TYPE ( String ) :: filename TYPE ( String ) :: extension CHARACTER ( LEN = 10 ) :: fmt = \"ascii\" CHARACTER ( LEN = 10 ) :: meshTopology = \"UnstructuredGrid\" INTEGER ( I4B ) :: nx1 = 0 , nx2 = 0 , ny1 = 0 , ny2 = 0 , nz1 = 0 , nz2 = 0 LOGICAL ( LGT ) :: inPiece = . FALSE . CONTAINS PROCEDURE , PUBLIC , PASS ( obj ) :: Initiate => vtk_init PROCEDURE , PUBLIC , PASS ( obj ) :: Finalize => vtk_final PROCEDURE , PUBLIC , PASS ( obj ) :: openPiece => vtk_start_write_geo PROCEDURE , PUBLIC , PASS ( obj ) :: closePiece => vtk_stop_write_geo GENERIC , PUBLIC :: WriteGeometry => vtk_write_mesh_data_1 ,& & vtk_write_mesh_data_2 , vtk_write_mesh_data_3 PROCEDURE , PUBLIC , PASS ( obj ) :: vtk_write_mesh_data_1 PROCEDURE , PUBLIC , PASS ( obj ) :: vtk_write_mesh_data_2 PROCEDURE , PUBLIC , PASS ( obj ) :: vtk_write_mesh_data_3 PROCEDURE , PUBLIC , PASS ( Obj ) :: openNodeData & & => vtk_start_write_node_data PROCEDURE , PUBLIC , PASS ( Obj ) :: closeNodeData & & => vtk_stop_write_node_data GENERIC , PUBLIC :: WriteNodeData => & & vtk_write_node_data_1 , & & vtk_write_node_data_2 PROCEDURE , PUBLIC , PASS ( obj ) :: vtk_write_node_data_1 PROCEDURE , PUBLIC , PASS ( obj ) :: vtk_write_node_data_2 PROCEDURE , PUBLIC , PASS ( Obj ) :: openElementData & & => vtk_start_write_elem_data PROCEDURE , PUBLIC , PASS ( Obj ) :: closeElementData & & => vtk_stop_write_elem_data GENERIC , PUBLIC :: WriteQuadratureData => & & vtk_write_cell_data_1 , & & vtk_write_cell_data_2 PROCEDURE , PUBLIC , PASS ( Obj ) :: vtk_write_cell_data_1 , & & vtk_write_cell_data_2 END TYPE vtk_ PUBLIC :: vtk_ TYPE ( vtk_ ), PUBLIC , PARAMETER :: TypeVTK = vtk_ ( ) !---------------------------------------------------------------------------- !                                                                vtkPointer_ !---------------------------------------------------------------------------- TYPE :: vtkPointer_ CLASS ( vtk_ ), POINTER :: Ptr => NULL ( ) END TYPE vtkPointer_ PUBLIC :: vtkPointer_ !---------------------------------------------------------------------------- !                                                                   Initiate !---------------------------------------------------------------------------- INTERFACE !! This subroutine initiate the vtk object !> authors: Dr. Vikas Sharma ! ! This subroutine initate the vtk file object ! MODULE SUBROUTINE vtk_init ( obj , path , filename , extension , fmt , & & meshTopology , indx , nx1 , nx2 , ny1 , ny2 , nz1 , nz2 ) CLASS ( vtk_ ), INTENT ( INOUT ) :: obj !! [[vtk_]] filename object CHARACTER ( LEN = * ), INTENT ( IN ) :: path !! path of the filename to be created CHARACTER ( LEN = * ), INTENT ( IN ) :: filename !! name of the file to be created CHARACTER ( LEN = * ), INTENT ( IN ) :: extension !! extension of the file `.vtu` CHARACTER ( LEN = * ), INTENT ( IN ) :: fmt !! storage format `ascii, binary_append, binary` CHARACTER ( LEN = * ), INTENT ( IN ) :: meshTopology !! mesh topology `UnstructuredGrid` INTEGER ( I4B ), INTENT ( IN ) :: indx ( : ) !! `its(1)` = time-step !! `its(2)` = iteration number, if present INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: nx1 , nx2 !! for structured grid only INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: ny1 , ny2 !! for structured grid only INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: nz1 , nz2 !! for structured grid only END SUBROUTINE vtk_init END INTERFACE !---------------------------------------------------------------------------- !                                                                   Finalize !---------------------------------------------------------------------------- INTERFACE !! This subroutine closes the opened vtk file !> authors: Dr. Vikas Sharma ! ! This subroutine close the open vtk file MODULE SUBROUTINE vtk_final ( obj ) CLASS ( vtk_ ), INTENT ( INOUT ) :: obj END SUBROUTINE vtk_final END INTERFACE INTERFACE DeallocateData MODULE PROCEDURE vtk_final END INTERFACE DeallocateData PUBLIC :: DeallocateData !---------------------------------------------------------------------------- !                                                                    Display !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE vtk_display ( obj , msg , unitno ) CLASS ( vtk_ ), INTENT ( IN ) :: obj CHARACTER ( LEN = * ), INTENT ( IN ) :: msg INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: unitno END SUBROUTINE vtk_display END INTERFACE INTERFACE Display MODULE PROCEDURE vtk_display END INTERFACE Display PUBLIC :: Display !---------------------------------------------------------------------------- !                                                                 openPiece !---------------------------------------------------------------------------- INTERFACE !! Should be called before [[vtk_:writegeomery]] call !> authors: Dr. Vikas Sharma ! ! This subroutine should be called before start writing the geometry ! in the `<piece>` tag ! ! - This subroutine indicates that we are going to write the mesh information MODULE SUBROUTINE vtk_start_write_geo ( Obj ) CLASS ( vtk_ ), INTENT ( INOUT ) :: obj END SUBROUTINE vtk_start_write_geo END INTERFACE !---------------------------------------------------------------------------- !                                                                 closePiece !---------------------------------------------------------------------------- INTERFACE !! Should be called before [[vtk_:writegeomery]] call !> authors: Dr. Vikas Sharma ! ! This subroutine should be called after we are done writing the mesh ! information, point data and cell data. ! ! This subroutine will write `</piece>` tag ! MODULE SUBROUTINE vtk_stop_write_geo ( Obj ) CLASS ( vtk_ ), INTENT ( INOUT ) :: obj END SUBROUTINE vtk_stop_write_geo END INTERFACE !---------------------------------------------------------------------------- !                                                              WriteGeometry !---------------------------------------------------------------------------- INTERFACE !! This subroutine writes the mesh data information in the !> authors: Dr. Vikas Sharma ! ! This subroutine writes the information of the mesh in vtkfile ! In this interface use must provide the [[meshdata_]] object. ! ! - In the vtk file local node numbers are written ! - Only those points (coords) are written which are included in meshobj ! - Note that `nodes` can represent a super set of nodes; nodes present in ! mesh are subset of `nodes` MODULE SUBROUTINE vtk_write_mesh_data_1 ( obj , meshobj , mdObj , nodes ) CLASS ( vtk_ ), INTENT ( INOUT ) :: obj !! [[vtk_]] file CLASS ( Mesh_ ), INTENT ( INOUT ), TARGET :: meshobj !! [[mesh_]] instance CLASS ( MeshData_ ), INTENT ( INOUT ) :: mdobj !! [[meshData_]] instance REAL ( DFP ), INTENT ( IN ) :: nodes ( :, : ) !! Nodal coordinates in xij format END SUBROUTINE vtk_write_mesh_data_1 END INTERFACE !---------------------------------------------------------------------------- !                                                             WriteGeometry !---------------------------------------------------------------------------- INTERFACE !! This subroutine writes the mesh data information in the !> authors: Dr. Vikas Sharma ! ! This subroutine writes the information of the mesh in vtkfile ! This subroutine should be used carefully ! We advise you to avoide using this subroutine as much as possible MODULE SUBROUTINE vtk_write_mesh_data_2 ( obj , meshobj , nodes ) CLASS ( vtk_ ), INTENT ( INOUT ) :: obj !! [[vtk_]] file CLASS ( Mesh_ ), INTENT ( INOUT ), TARGET :: meshobj !! [[mesh_]] instance REAL ( DFP ), INTENT ( IN ) :: nodes ( :, : ) !! Nodal coordinates in xij format END SUBROUTINE vtk_write_mesh_data_2 END INTERFACE !---------------------------------------------------------------------------- !                                                              WriteGeometry !---------------------------------------------------------------------------- INTERFACE !! This subroutine writes the mesh data information in the !> authors: Dr. Vikas Sharma ! ! This subroutine writes the information of the mesh in vtkfile ! In this interface use must provide the [[meshdata_]] object. ! ! - In the vtk file local node numbers are written ! - Only those points (coords) are written which are included in meshobj ! - Note that `nodes` can represent a super set of nodes; nodes present in ! mesh are subset of `nodes` MODULE SUBROUTINE vtk_write_mesh_data_3 ( obj , meshobj , nodes , tag , & & local2global , map , lb , ub ) CLASS ( vtk_ ), INTENT ( INOUT ) :: obj !! [[vtk_]] file CLASS ( MeshPointer_ ), INTENT ( INOUT ), TARGET :: meshobj (:) !! [[mesh_]] instance REAL ( DFP ), INTENT ( IN ) :: nodes ( :, : ) !! Nodal coordinates in xij format INTEGER ( I4B ), INTENT ( IN ) :: lb , ub INTEGER ( I4B ), INTENT ( IN ) :: local2global (:), map ( lb : ub ) INTEGER ( I4B ), INTENT ( IN ) :: tag (:) END SUBROUTINE vtk_write_mesh_data_3 END INTERFACE !---------------------------------------------------------------------------- !                                                               openNodeData !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE vtk_start_write_node_data ( obj ) CLASS ( vtk_ ), INTENT ( INOUT ) :: obj END SUBROUTINE vtk_start_write_node_data END INTERFACE !---------------------------------------------------------------------------- !                                                              closeNodeData !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE vtk_stop_write_node_data ( obj ) CLASS ( vtk_ ), INTENT ( INOUT ) :: obj END SUBROUTINE vtk_stop_write_node_data END INTERFACE !---------------------------------------------------------------------------- !                                                              WriteNodeData !---------------------------------------------------------------------------- INTERFACE !! This subroutine writes the node data information in a vtk file format !> authors: Dr. Vikas Sharma ! ! This subroutine writes the nodal values of a variable `x` into vtk file ! ! - `name` is the name of physical variable whose dof will be printed ! - The subroutine will decided the nature of physical variable and ! and write in vtk file accordingly ! - The subroutine search for this name in [[dof_]] and if this name is ! is not present the subroutine writes nothing MODULE SUBROUTINE vtk_write_node_data_1 ( obj , x , dofobj , name , prefix ) CLASS ( vtk_ ), INTENT ( INOUT ) :: obj REAL ( DFP ), INTENT ( IN ) :: x ( : ) TYPE ( DOF_ ), INTENT ( IN ) :: dofobj CHARACTER ( LEN = 1 ), INTENT ( IN ) :: name CHARACTER ( LEN = * ), INTENT ( IN ) :: prefix !! It is the name of a DOF present inside dofobj; we will find this name !! and write data corresponding to that physical name END SUBROUTINE vtk_write_node_data_1 END INTERFACE !---------------------------------------------------------------------------- !                                                              WriteNodeData !---------------------------------------------------------------------------- INTERFACE !! This subroutine writes the node data information in a vtk file format !> authors: Dr. Vikas Sharma ! ! This subroutine writes the nodal values of a variable `x` into vtk file ! ! - It will write all the physical variables in vtk file ! - It calls [[vtk_write_node_data_1]] subroutine internally MODULE SUBROUTINE vtk_write_node_data_2 ( obj , x , dofobj , prefix ) CLASS ( vtk_ ), INTENT ( INOUT ) :: obj REAL ( DFP ), INTENT ( IN ) :: x ( : ) TYPE ( DOF_ ), INTENT ( IN ) :: dofobj CHARACTER ( LEN = * ), OPTIONAL , INTENT ( IN ) :: prefix END SUBROUTINE vtk_write_node_data_2 END INTERFACE !---------------------------------------------------------------------------- !                                                      startWriteElementData !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE vtk_start_write_elem_data ( obj ) CLASS ( vtk_ ), INTENT ( INOUT ) :: obj END SUBROUTINE vtk_start_write_elem_data END INTERFACE !---------------------------------------------------------------------------- !                                                       stopWriteElementData !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE vtk_stop_write_elem_data ( obj ) CLASS ( vtk_ ), INTENT ( INOUT ) :: obj END SUBROUTINE vtk_stop_write_elem_data END INTERFACE !---------------------------------------------------------------------------- !                                                              WriteElemData !---------------------------------------------------------------------------- INTERFACE !! This subroutine writes the cell data information in a vtk file format !> authors: Dr. Vikas Sharma ! ! This subroutine writes the cell data (single scalars) into a vtk file MODULE SUBROUTINE vtk_write_cell_data_1 ( obj , val , name ) CLASS ( vtk_ ), INTENT ( INOUT ) :: obj REAL ( DFP ), INTENT ( IN ) :: val (:) !! size(val) should be equal to totol number of cell CHARACTER ( LEN =* ), INTENT ( IN ) :: name END SUBROUTINE vtk_write_cell_data_1 END INTERFACE !---------------------------------------------------------------------------- !                                                              WriteElemData !---------------------------------------------------------------------------- INTERFACE !! This subroutine writes the cell data information in a vtk file format !> authors: Dr. Vikas Sharma ! ! This subroutine writes the cell data (single vector) into a vtk file MODULE SUBROUTINE vtk_write_cell_data_2 ( obj , val , name ) CLASS ( vtk_ ), INTENT ( INOUT ) :: obj REAL ( DFP ), INTENT ( IN ) :: val (:, :) !! size(val,2) should be equal to totol number of cell !! size(val,1) number of components CHARACTER ( LEN =* ), INTENT ( IN ) :: name END SUBROUTINE vtk_write_cell_data_2 END INTERFACE !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- END MODULE vtkType","tags":"","loc":"sourcefile/vtktype.f90.html"},{"title":"QuadratureVariables_Class.f90 – Fortran Program","text":"Contents Modules QuadratureVariables_Class Source Code QuadratureVariables_Class.f90 Source Code MODULE QuadratureVariables_Class !! This module defines a class `MatProps_` which contians variables !! and parameters defined inside a finite element !! (i.e., at quadrature points) USE BaseType USE GlobalData USE Mesh_Class IMPLICIT NONE PRIVATE !---------------------------------------------------------------------------- !                                                       QuadratureVariables_ !---------------------------------------------------------------------------- !> !> authors: Dr. Vikas Sharma ! ! [[QuadratureVariables_]] class contains the variables and parameters defined ! in a collection of finite elements at quadrature points. ! - If all variables inside an element do not change then ! one can initiate the object with the ColID = 'M' which then indicates ! that material-parameters are stored ! - If one or all variables in elements chages then one must ! initiate the obhect with the ColID = 'E' which then indicates that ! element variables are stored ! !### Usage ! ! ```fortran !\ttype( QuadratureVariables_ ) :: obj ! ! !initiate obj----------- !                        | ! call obj % initiate( tprop = 3, tpoint = 1, telem=100, names=names ) ! call obj %  setValue( ipoint, elemnum, Val, is, ie ) ! Val = obj % Value( ColIndx = 1 ) ! call deallocateData( Obj ) ! ``` ! ! @note ! When `colID = M` then `tPoint` argument in initiate call will be ignored ! @endnote ! TYPE :: QuadratureVariables_ INTEGER ( I4B ) :: tprop = 0 !! Total number of properties defined at a quadrature points INTEGER ( I4B ) :: tpoint = 0 !! Total number of quadrature points inside an element TYPE ( String ), ALLOCATABLE :: Names ( : ) !! Names of variables stored; its length should be equal to !! tprops REAL ( DFP ), ALLOCATABLE :: Val ( :, :, : ) !! This array contains the varialbe/parameter information !! `Val( :, i )` denotes material properties or element variables CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: Initiate => elem_var_initiate !! Subroutine that Initiates the object PROCEDURE , PUBLIC , PASS ( Obj ) :: Finalize => elem_var_deallocate_data !! deallocate data PROCEDURE , PUBLIC , PASS ( Obj ) :: setValue => elem_var_set_value !! Subroutine that Sets values/change values PROCEDURE , PUBLIC , PASS ( Obj ) :: AddContribution => elem_var_add_val !! Subroutine that Adds contribution to the existing values PROCEDURE , PUBLIC , PASS ( Obj ) :: ArrayValues => elem_var_get_value !! Subroutine that gets element variables END TYPE QuadratureVariables_ PUBLIC :: QuadratureVariables_ !> Parameter instance of type [[QuadratureVariables_]] TYPE ( QuadratureVariables_ ), PARAMETER , PUBLIC :: TypeQuadratureVariables = & & QuadratureVariables_ ( Val = NULL (), Names = NULL () ) !---------------------------------------------------------------------------- !                                                           Initiate@Methods !---------------------------------------------------------------------------- INTERFACE !! Subroutine that initiate [[quadraturevariables_]] object !> authors: Dr. Vikas Sharma ! ! This subroutine initiates `QuadratureVariables_` object ! - If `colID=M` then object stores material properties ! - In above case `tpoint` is not considered and set to 1 internally ! - If names are present then `size( names ) == tprop` ! - If `names` are not present then variables will be named as `V1, V2,...` MODULE PURE SUBROUTINE elem_var_initiate ( Obj , tprop , tpoint , telem , names ) CLASS ( QuadratureVariables_ ), INTENT ( INOUT ) :: Obj !! Instance INTEGER ( I4B ), INTENT ( IN ) :: tprop !! Total number of properties INTEGER ( I4B ), INTENT ( IN ) :: tpoint !! Total number of quadrature points INTEGER ( I4B ), INTENT ( IN ) :: telem !! Total number of columns TYPE ( String ), OPTIONAL , INTENT ( IN ) :: names ( : ) !! Names of variables END SUBROUTINE elem_var_initiate END INTERFACE !> Generic method to initiate [[quadraturevariables_]] INTERFACE Initiate MODULE PROCEDURE elem_var_initiate END INTERFACE Initiate PUBLIC :: Initiate !---------------------------------------------------------------------------- !                                                           setValue@Methods !---------------------------------------------------------------------------- INTERFACE !! Subroutine that sets values in [[quadraturevariables_]] object !> authors: Dr. Vikas Sharma ! ! This subroutine set values of `Obj % Val( :, ipoint, icol )` ! - `Obj % Val( i_s:i_e, ipoint, icol) = Val( : )` MODULE PURE SUBROUTINE elem_var_set_value ( Obj , ipoint , elemnum , Val , is , ie ) CLASS ( QuadratureVariables_ ), INTENT ( INOUT ) :: Obj !! Instance of [[quadraturevariables_]] INTEGER ( I4B ), INTENT ( IN ) :: ipoint !! Quadrature point number INTEGER ( I4B ), INTENT ( IN ) :: elemnum !! element number REAL ( DFP ), INTENT ( IN ) :: Val ( : ) !! Values INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: is !! `is` starting index INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: ie !! `ie` ending index END SUBROUTINE elem_var_set_value END INTERFACE !---------------------------------------------------------------------------- !                                                     addContribution@Methods !---------------------------------------------------------------------------- INTERFACE !! Subroutine that adds values in [[quadraturevariables_]] object !> authors: Dr. Vikas Sharma ! ! This subroutine adds values of `Obj % Val( :, ipoint, icol )` MODULE PURE SUBROUTINE elem_var_add_val ( Obj , ipoint , elemnum , Scale , Val , & & is , ie ) CLASS ( QuadratureVariables_ ), INTENT ( INOUT ) :: Obj !! Instance of [[quadraturevariables_]] INTEGER ( I4B ), INTENT ( IN ) :: elemnum !! It represents id of element or material depending on storage type INTEGER ( I4B ), INTENT ( IN ) :: ipoint !! Quadrature point number REAL ( DFP ), INTENT ( IN ) :: Val ( : ) !! Values REAL ( DFP ), INTENT ( IN ) :: Scale !! Scaling used for Values INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: is !! `is` starting index INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: ie !! `ie` ending index END SUBROUTINE elem_var_add_val END INTERFACE !---------------------------------------------------------------------------- !                                                              Value@Methods !---------------------------------------------------------------------------- INTERFACE !! Return values stored inside [[quadraturevariables_]] !> authors: Dr. Vikas Sharma ! ! This subroutine returns `Obj % Val(:,:,elemnum) ` MODULE PURE FUNCTION elem_var_get_value ( Obj , elemnum ) RESULT ( Ans ) CLASS ( QuadratureVariables_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: elemnum !! Element number or material number REAL ( DFP ), ALLOCATABLE :: Ans ( :, : ) END FUNCTION elem_var_get_value END INTERFACE !---------------------------------------------------------------------------- !                                                             Display@Methods !---------------------------------------------------------------------------- INTERFACE !! Display the content of [[quadraturevariables_]] MODULE SUBROUTINE elem_var_disp ( Obj , msg , unitno ) CLASS ( QuadratureVariables_ ), INTENT ( IN ) :: Obj CHARACTER ( LEN = * ), INTENT ( IN ) :: msg INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: unitno END SUBROUTINE elem_var_disp END INTERFACE !> Generic interaface to display content of [[quadraturevariables_]] INTERFACE Display MODULE PROCEDURE elem_var_disp END INTERFACE Display PUBLIC :: Display !---------------------------------------------------------------------------- !                                                     DeallocateData@Method !---------------------------------------------------------------------------- INTERFACE !! Deallocat data stored inside [[quadraturevariables_]] object MODULE PURE SUBROUTINE elem_var_deallocate_data ( Obj ) CLASS ( QuadratureVariables_ ), INTENT ( INOUT ) :: Obj END SUBROUTINE elem_var_deallocate_data END INTERFACE !> genenric interface for deallocating data in [[quadraturevariables_]] INTERFACE DeallocateData MODULE PROCEDURE elem_var_deallocate_data END INTERFACE DeallocateData PUBLIC :: DeallocateData !---------------------------------------------------------------------------- !                                                QuadratureVariablesPointer_ !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! [[QuadratureVariablesPointer_]] contains a pointer to ! [[QuadratureVariables_]] TYPE :: QuadratureVariablesPointer_ CLASS ( QuadratureVariables_ ), POINTER :: Ptr => NULL ( ) END TYPE QuadratureVariablesPointer_ PUBLIC :: QuadratureVariablesPointer_ END MODULE QuadratureVariables_Class","tags":"","loc":"sourcefile/quadraturevariables_class.f90.html"},{"title":"gmsh_Class.f90 – Fortran Program","text":"Contents Modules gmsh_Class Source Code gmsh_Class.f90 Source Code MODULE gmsh_Class !! Gmsh Class USE BaseType USE BaseMethod USE gmshModel_Class IMPLICIT NONE PRIVATE !---------------------------------------------------------------------------- !                                                                      gmsh_ !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This a data type for prepossing and post-processing in Gmsh ! ! !### Usage ! ! ```fortran !\ttype( gmsh_ ) :: gmsh ! ierr = gmsh % initialize ! ierr = gmsh % open( filename ) ! ierr = gmsh % merge( filename ) ! ierr = gmsh % write( filename ) ! ierr = gmsh % clear( filename ) ! ierr = gmsh % finalize ! ``` TYPE :: gmsh_ TYPE ( gmshModel_ ), POINTER :: model => NULL ( ) INTEGER ( I4B ) :: nsd = 0 CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: initialize => gmsh_init !! Initialize the gmsh engine PROCEDURE , PUBLIC , PASS ( Obj ) :: initiate => gmsh_init !! Initialize the gmsh engine PROCEDURE , PUBLIC , PASS ( Obj ) :: finalize => gmsh_final !! Closes the gmsh engine PROCEDURE , PUBLIC , PASS ( Obj ) :: open => gmsh_open !! open file to load PROCEDURE , PUBLIC , PASS ( Obj ) :: merge => gmsh_merge PROCEDURE , PUBLIC , PASS ( Obj ) :: write => gmsh_write !! Write content in a file PROCEDURE , PUBLIC , PASS ( Obj ) :: clear => gmsh_clear !! Clear the content PROCEDURE , PUBLIC , PASS ( Obj ) :: remesh => gmsh_from_gmsh !! generate new gmsh file END TYPE gmsh_ !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- PUBLIC :: gmsh_ TYPE ( gmsh_ ), PUBLIC , PARAMETER :: TypeGmsh = gmsh_ ( ) !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- INTERFACE !! This function generate a gmsh model from the mesh data stored inside !> authors: Dr. Vikas Sharma ! ! This function generates a gmsh model by reading mesh data stored inside ! `gmsh_` object. MODULE FUNCTION gmsh_from_gmsh ( Obj , gmsh , Nodes ) RESULT ( Ans ) CLASS ( gmsh_ ), TARGET , INTENT ( INOUT ) :: Obj !! Old gmsh CLASS ( gmsh_ ), TARGET , INTENT ( INOUT ) :: gmsh !! new gmsh REAL ( DFP ), INTENT ( IN ) :: Nodes ( :, : ) !! nodes INTEGER ( I4B ) :: Ans END FUNCTION gmsh_from_gmsh END INTERFACE !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- CONTAINS !---------------------------------------------------------------------------- !                                                                   Initiate !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This function will start the gmsh engine ! It allocates obj % model ! !### Usage ! ! ```fortran !\tierr = obj % initialize( NSD ) ! ``` FUNCTION gmsh_init ( Obj , NSD ) RESULT ( Ans ) CLASS ( gmsh_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: NSD INTEGER ( I4B ) :: Ans CALL Display ( \"gmsh:: Initiating gmsh\" ) IF ( ASSOCIATED ( Obj % model ) ) DEALLOCATE ( Obj % model ) ALLOCATE ( obj % model ) ans = 0 Obj % NSD = NSD END FUNCTION gmsh_init !---------------------------------------------------------------------------- !                                                                 Finalize !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This function will stop the gmsh engine ! !### Usage ! ! ```fortran !\tierr = obj % finalize() ! ``` FUNCTION gmsh_final ( Obj ) RESULT ( Ans ) CLASS ( gmsh_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ) :: Ans CALL Display ( \"gmsh:: Deallocating gmsh%modelc\" ) IF ( ASSOCIATED ( obj % model ) ) DEALLOCATE ( obj % model ) obj % model => null () Ans = 0 Obj % NSD = 0 END FUNCTION gmsh_final !---------------------------------------------------------------------------- !                                                                      open !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This function will open a file and read its content ! Based upon the extension of the file it can take different actions ! If file represents a model file then a new model will be created FUNCTION gmsh_open ( Obj , P , F , E ) RESULT ( Ans ) CLASS ( gmsh_ ), INTENT ( INOUT ) :: Obj CHARACTER ( LEN = * ), INTENT ( IN ) :: P !! Path of file CHARACTER ( LEN = * ), INTENT ( IN ) :: F !! File name CHARACTER ( LEN = * ), INTENT ( IN ) :: E !! Extension INTEGER ( I4B ) :: Ans ! main program Ans = 0 IF ( trim ( E ) . EQ . \".msh\" ) THEN ! we need to create a model in this case IF ( . NOT . ASSOCIATED ( Obj % model ) ) THEN CALL Display ( \"gmsh::  allocating obj % model\" ) ALLOCATE ( Obj % model ) END IF IF ( . NOT . ASSOCIATED ( Obj % model % mesh ) ) THEN CALL Display ( \"gmsh:: allocating obj % model % mesh\" ) ALLOCATE ( Obj % model % mesh ) ELSE CALL Display ( \"WARNING:: gmsh_Class@Methods.f90\" ) CALL Display ( \"        gmsh_open()\" ) CALL Display ( \"        gmh%model%mesh is associated\" ) CALL Display ( \"           calling deallocateData()\" ) CALL Display ( \"           buffer is untouched()\" ) CALL Obj % model % mesh % Finalize ( ) END IF CALL Display ( \"gmsh:: making obj % model % mesh object\" ) CALL Obj % model % mesh % initiate ( P , F , E , Obj % NSD ) ELSE IF ( trim ( E ) . EQ . \".geo\" ) THEN CALL Display ( \"ERROR:: gmsh_Class@Methods.f90\" ) CALL Display ( \"        gmsh_open()\" ) CALL Display ( \"        Currently .geo file cannot be loaded\" ) STOP END IF END FUNCTION gmsh_open !---------------------------------------------------------------------------- !                                                                    merge !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This function will open a file and read its content ! Based upon the extension of the file it can take different actions ! IF the file represents a model file then it will merge the content to the ! current model FUNCTION gmsh_merge ( Obj , P , F , E ) RESULT ( Ans ) CLASS ( gmsh_ ), INTENT ( INOUT ) :: Obj CHARACTER ( LEN = * ), INTENT ( IN ) :: P !! Path of file CHARACTER ( LEN = * ), INTENT ( IN ) :: F !! File name CHARACTER ( LEN = * ), INTENT ( IN ) :: E !! Extension INTEGER ( I4B ) :: Ans ! main program CALL EqualLine ( ) CALL Display ( \"ERROR:: gmsh_Class@Methods.f90\" ) CALL Display ( \"        gmsh_merge()\" ) CALL Display ( \"        Currently not supported\" ) CALL EqualLine ( ) END FUNCTION gmsh_merge !---------------------------------------------------------------------------- !                                                                     write !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This function will write the data in a file depending upon the extension ! of the file FUNCTION gmsh_write ( Obj , P , F , E ) RESULT ( Ans ) CLASS ( gmsh_ ), INTENT ( INOUT ) :: Obj CHARACTER ( LEN = * ), INTENT ( IN ) :: P !! Path of file CHARACTER ( LEN = * ), INTENT ( IN ) :: F !! File name CHARACTER ( LEN = * ), INTENT ( IN ) :: E !! Extension INTEGER ( I4B ) :: Ans ! Internal variables TYPE ( File_ ) :: aFile IF ( . NOT . ASSOCIATED ( Obj % model ) ) THEN CALL Display ( \"ERROR:: gmsh_Class@Methods.f90\" ) CALL Display ( \"        gmsh_write()\" ) CALL Display ( \"        obj % model is not allocated/added\" ) STOP END IF IF ( trim ( E ) . EQ . \".msh\" ) THEN CALL Display ( \"gmsh:: opening a file to write .geo file\" ) CALL OpenFileToWrite ( aFile , P , F , \".geo\" ) CALL Display ( \"gmsh:: calling gmsh%model%write()\" ) Ans = obj % model % write ( aFile % UnitNo ) WRITE ( aFile % UnitNo , \"(A)\" ) 'Save \"' // trim ( P ) // trim ( F ) & & // trim ( E ) // '\" ;' WRITE ( aFile % UnitNo , \"(A)\" ) \"Exit; \" CALL CloseFile ( aFile ) CALL ExecuteCommand ( 'gmsh \"' // trim ( P ) // trim ( F ) // \".geo\" // '\"' , & & \"gmsh_Class.f90>>gmsh_write()\" ) ELSE IF ( trim ( E ) . EQ . \".geo\" ) THEN CALL Display ( \"gmsh:: opening a file to write .geo file\" ) CALL OpenFileToWrite ( aFile , P , F , E ) CALL Display ( \"gmsh:: calling gmsh%model%write()\" ) Ans = obj % model % write ( aFile % UnitNo ) CALL CloseFile ( aFile ) ELSE CALL Display ( \"ERROR:: gmsh_Class@Methods.f90\" ) CALL Display ( \"        gmsh_write()\" ) CALL Display ( \"        Unknown file extension\" ) STOP END IF END FUNCTION gmsh_write !---------------------------------------------------------------------------- !                                                                    clear !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This function will clear all model and option and create an blank model FUNCTION gmsh_clear ( Obj ) RESULT ( Ans ) CLASS ( gmsh_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ) :: Ans CALL EqualLine ( ) CALL Display ( \"     gmsh_Class@Methods.f90\" ) CALL Display ( \"        gmsh_clear()\" ) CALL Display ( \"        cleanup done\" ) CALL EqualLine ( ) IF ( ASSOCIATED ( Obj % model ) ) DEALLOCATE ( Obj % model ) Obj % model => NULL ( ) END FUNCTION gmsh_clear !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- END MODULE gmsh_Class","tags":"","loc":"sourcefile/gmsh_class.f90.html"},{"title":"gmshMesh_Class.f90 – Fortran Program","text":"Contents Modules gmshMesh_Class Source Code gmshMesh_Class.f90 Source Code MODULE gmshMesh_Class USE BaseType USE GlobalData USE mshFormat_Class USE mshPhysicalNames_Class USE mshEntity_Class USE mshNodes_Class USE mshElements_Class USE Mesh_Class USE FE USE Domain_Class IMPLICIT NONE PRIVATE !---------------------------------------------------------------------------- !                                                                 gmshMesh_ !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This class handles the mesh generation by gmsh ! This class can generate the mesh and reads the mesh file TYPE :: gmshMesh_ TYPE ( Buffer_ ), POINTER :: buffer => NULL ( ) !! buffer to recoord coommands INTEGER ( I4B ) :: nsd = 0 !! Spatial dimension TYPE ( File_ ) :: mshFile !! mesh file TYPE ( mshFormat_ ) :: Format !! mesh format TYPE ( mshPhysicalNames_ ) :: PhysicalNames !! mesh physical groups TYPE ( mshEntity_ ), ALLOCATABLE :: PointEntities ( : ) !! point entities TYPE ( mshEntity_ ), ALLOCATABLE :: CurveEntities ( : ) !! curve entities TYPE ( mshEntity_ ), ALLOCATABLE :: SurfaceEntities ( : ) !! surface entities TYPE ( mshEntity_ ), ALLOCATABLE :: VolumeEntities ( : ) !! volume entities TYPE ( mshNodes_ ) :: Nodes !! nodes TYPE ( mshElements_ ) :: Elements !! elements CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: generate => mesh_generate PROCEDURE , PUBLIC , PASS ( Obj ) :: write => mesh_write PROCEDURE , PUBLIC , PASS ( Obj ) :: Finalize => gmsh_mesh_deallocateData !! deallocate the data PROCEDURE , PUBLIC , PASS ( Obj ) :: Initiate => gmsh_mesh_initiate !! initiate the object PROCEDURE , PUBLIC , PASS ( Obj ) :: TotalNodes => gmsh_mesh_totalnodes !! returns total nodes in mesh GENERIC , PUBLIC :: getNodes => gmsh_mesh_getnodes_array , & & gmsh_mesh_getnodes_file PROCEDURE , PRIVATE , PASS ( Obj ) :: gmsh_mesh_getnodes_array !! returns nodes in an array PROCEDURE , PRIVATE , PASS ( Obj ) :: gmsh_mesh_getnodes_file !! writes notes to a file GENERIC , PUBLIC :: TotalElements => gmsh_mesh_telements_1 , & & gmsh_mesh_telements_2 , & & gmsh_mesh_telements_3 PROCEDURE , PRIVATE , PASS ( Obj ) :: gmsh_mesh_telements_1 !! returns total elements in mesh PROCEDURE , PRIVATE , PASS ( Obj ) :: gmsh_mesh_telements_2 !! returns total elements in mesh PROCEDURE , PRIVATE , PASS ( Obj ) :: gmsh_mesh_telements_3 !! returns total elements in mesh GENERIC , PUBLIC :: getElements => & & gmsh_mesh_getelements_1 , & & gmsh_mesh_getelements_2 , & & gmsh_mesh_getelements_2c , & & gmsh_mesh_getelements_3 , & & gmsh_mesh_getelements_3c , & & gmsh_mesh_getelements_4 , & & gmsh_mesh_getelements_4c , & & dom_init_from_gmshMesh PROCEDURE , PUBLIC , PASS ( Obj ) :: gmsh_mesh_getelements_1 !! return finite element mesh PROCEDURE , PUBLIC , PASS ( Obj ) :: gmsh_mesh_getelements_2 PROCEDURE , PUBLIC , PASS ( Obj ) :: gmsh_mesh_getelements_2c PROCEDURE , PUBLIC , PASS ( Obj ) :: gmsh_mesh_getelements_3 PROCEDURE , PUBLIC , PASS ( Obj ) :: gmsh_mesh_getelements_3c PROCEDURE , PUBLIC , PASS ( Obj ) :: gmsh_mesh_getelements_4 PROCEDURE , PUBLIC , PASS ( Obj ) :: gmsh_mesh_getelements_4c PROCEDURE , PUBLIC , PASS ( mshobj ) :: dom_init_from_gmshMesh PROCEDURE , PUBLIC , PASS ( Obj ) :: WriteMesh => gmsh_mesh_write_mesh GENERIC , PUBLIC :: WriteNodeData => & & gmsh_mesh_write_nodedata_1 , & & gmsh_mesh_write_nodedata_2 PROCEDURE , PUBLIC , PASS ( Obj ) :: gmsh_mesh_write_nodedata_1 PROCEDURE , PUBLIC , PASS ( Obj ) :: gmsh_mesh_write_nodedata_2 END TYPE gmshMesh_ !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- PUBLIC :: gmshMesh_ TYPE ( gmshMesh_ ), PUBLIC , PARAMETER :: TypegmshMesh = gmshMesh_ ( & & mshFile = TypeFile , Format = TypemshFormat , & & PhysicalNames = TypeMSHPhysicalNames , & & PointEntities = NULL ( ), CurveEntities = NULL ( ), & & SurfaceEntities = NULL ( ), VolumeEntities = NULL ( ), & & Nodes = TypeMshNodes , Elements = TypemshElements ) !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- TYPE :: gmshMeshPointer_ CLASS ( gmshMesh_ ), POINTER :: Ptr => NULL () END TYPE gmshMeshPointer_ PUBLIC :: gmshMeshPointer_ !---------------------------------------------------------------------------- !                                                     Generate@BufferMethods !---------------------------------------------------------------------------- INTERFACE !! This will add mesh generation command to .geo file !> authors: Dr. Vikas Sharma ! ! This will add mesh generation command to .geo file MODULE FUNCTION mesh_generate ( Obj , dim ) RESULT ( Ans ) CLASS ( gmshMesh_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: dim INTEGER ( I4B ) :: Ans END FUNCTION mesh_generate END INTERFACE !---------------------------------------------------------------------------- !                                                        Write@BufferMethods !---------------------------------------------------------------------------- INTERFACE !! This function will dump the buffer content in to a file !> authors: Dr. Vikas Sharma ! ! This function will dump the buffer content in to a file MODULE FUNCTION mesh_write ( Obj , UnitNo ) RESULT ( Ans ) CLASS ( gmshMesh_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: UnitNo INTEGER ( I4B ) :: Ans END FUNCTION mesh_write END INTERFACE !---------------------------------------------------------------------------- !                                               Initiate@ConstructorMethods !---------------------------------------------------------------------------- INTERFACE !! This subroutine generates the gmshMesh_ object !> authors: Dr. Vikas Sharma ! ! This subroutine reads the .msh file and creates the object MODULE SUBROUTINE gmsh_mesh_initiate ( obj , Path , FileName , Extension , NSD ) CLASS ( gmshMesh_ ), INTENT ( INOUT ) :: obj CHARACTER ( LEN = * ), INTENT ( IN ) :: FileName , Extension , Path INTEGER ( I4B ), INTENT ( IN ) :: NSD END SUBROUTINE gmsh_mesh_initiate END INTERFACE INTERFACE Initiate MODULE PROCEDURE gmsh_mesh_initiate END INTERFACE Initiate PUBLIC :: Initiate !---------------------------------------------------------------------------- !                                          DeallocateData@ConstructorMethods !---------------------------------------------------------------------------- INTERFACE !! This will deallocate data !> authors: Dr. Vikas Sharma ! ! This subroutine deallocate data MODULE SUBROUTINE gmsh_mesh_deallocatedata ( obj ) CLASS ( gmshMesh_ ), INTENT ( INOUT ) :: obj END SUBROUTINE gmsh_mesh_deallocatedata END INTERFACE INTERFACE DeallocateData MODULE PROCEDURE gmsh_mesh_deallocatedata END INTERFACE DeallocateData PUBLIC :: DeallocateData !---------------------------------------------------------------------------- !                                               gmshMesh@ConstructorMethods !---------------------------------------------------------------------------- INTERFACE !! This function will create the [[gmshMesh_]] object !> authors: Dr. Vikas Sharma ! ! This function will create the [[gmshMesh_]] object MODULE FUNCTION gmsh_mesh_constuctor1 ( Path , FileName , Extension , NSD ) RESULT ( Ans ) TYPE ( gmshMesh_ ) :: Ans CHARACTER ( LEN = * ), INTENT ( IN ) :: FileName , Extension , Path INTEGER ( I4B ), INTENT ( IN ) :: NSD END FUNCTION gmsh_mesh_constuctor1 END INTERFACE INTERFACE gmshMesh MODULE PROCEDURE gmsh_mesh_constuctor1 END INTERFACE gmshMesh PUBLIC :: gmshMesh !---------------------------------------------------------------------------- !                                                 Display@ConstructorMethods !---------------------------------------------------------------------------- INTERFACE !! This subroutine display the content of gmshmesh object !> authors: Dr. Vikas Sharma ! ! This subroutine display the content of obj MODULE SUBROUTINE gmsh_mesh_display ( obj , Msg , UnitNo ) CLASS ( gmshMesh_ ), INTENT ( IN ) :: obj CHARACTER ( LEN = * ), INTENT ( IN ) :: msg INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: UnitNo END SUBROUTINE gmsh_mesh_display END INTERFACE INTERFACE Display MODULE PROCEDURE gmsh_mesh_display END INTERFACE Display PUBLIC :: Display !---------------------------------------------------------------------------- !                                                   TotalNodes@NodesMethods !---------------------------------------------------------------------------- INTERFACE !! This function will return the total number of nodes in mesh !> authors: Dr. Vikas Sharma ! ! This function will return the total number of nodes in mesh MODULE PURE FUNCTION gmsh_mesh_totalnodes ( obj ) RESULT ( Ans ) CLASS ( gmshMesh_ ), INTENT ( IN ) :: obj INTEGER ( I4B ) :: Ans END FUNCTION gmsh_mesh_totalnodes END INTERFACE !---------------------------------------------------------------------------- !                                                      getNodes@NodesMethods !---------------------------------------------------------------------------- INTERFACE !! This subroutine retunr the nodal coordinates !> authors: Dr. Vikas Sharma ! !  This subroutine returns the nodal coordinates MODULE PURE SUBROUTINE gmsh_mesh_getnodes_array ( obj , Nodes ) CLASS ( gmshMesh_ ), INTENT ( IN ) :: obj REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: Nodes ( :, : ) END SUBROUTINE gmsh_mesh_getnodes_array END INTERFACE !---------------------------------------------------------------------------- !                                                      getNodes@NodesMethods !---------------------------------------------------------------------------- INTERFACE !! This subroutine retunr the nodal coordinates !> authors: Dr. Vikas Sharma ! !  This subroutine returns the nodal coordinates MODULE SUBROUTINE gmsh_mesh_getnodes_file ( obj , UnitNo , Str , EndStr ) CLASS ( gmshMesh_ ), INTENT ( IN ) :: obj INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: UnitNo CHARACTER ( LEN = * ), OPTIONAL , INTENT ( IN ) :: Str , EndStr END SUBROUTINE gmsh_mesh_getnodes_file END INTERFACE !---------------------------------------------------------------------------- !                                              TotalElements@ElementsMethods !---------------------------------------------------------------------------- INTERFACE !! This function returns the total element in the mesh !> authors: Dr. Vikas Sharma ! ! This function returns the total element in the mesh MODULE PURE FUNCTION gmsh_mesh_telements_1 ( obj ) RESULT ( Ans ) CLASS ( gmshMesh_ ), INTENT ( IN ) :: obj INTEGER ( I4B ) :: Ans END FUNCTION gmsh_mesh_telements_1 END INTERFACE !---------------------------------------------------------------------------- !                                                TotalElements@ElementMethods !---------------------------------------------------------------------------- INTERFACE !! This function returns the total element in the mesh !> authors: Dr. Vikas Sharma ! ! This function returns the total element in the mesh ! Xidim is a codimension based filter ! Xidim=0 => Point ! Xidim=1 => Curve ! Xidim=2 => Surface ! Xidim=3 => Volume MODULE PURE FUNCTION gmsh_mesh_telements_2 ( obj , XiDim ) RESULT ( Ans ) CLASS ( gmshMesh_ ), INTENT ( IN ) :: obj INTEGER ( I4B ), INTENT ( IN ) :: XiDim INTEGER ( I4B ) :: Ans END FUNCTION gmsh_mesh_telements_2 END INTERFACE !---------------------------------------------------------------------------- !                                                TotalElements@ElementMethods !---------------------------------------------------------------------------- INTERFACE !! This function returns the total element in the mesh !> authors: Dr. Vikas Sharma ! ! This function returns the total element in the mesh ! We can filter elements based on `Xidim` and `tag` MODULE PURE FUNCTION gmsh_mesh_telements_3 ( obj , XiDim , Tag ) RESULT ( Ans ) CLASS ( gmshMesh_ ), INTENT ( IN ) :: obj INTEGER ( I4B ), INTENT ( IN ) :: XiDim INTEGER ( I4B ), INTENT ( IN ) :: Tag ( : ) INTEGER ( I4B ) :: Ans END FUNCTION gmsh_mesh_telements_3 END INTERFACE !---------------------------------------------------------------------------- !                                                getElements@ElementsMethods !---------------------------------------------------------------------------- INTERFACE !! This subroutine returns a mesh of elements; !> authors: Dr. Vikas Sharma ! ! This subroutine returns a single [[mesh_]] object containing all elements MODULE SUBROUTINE gmsh_mesh_getelements_1 ( obj , MeshObj , FEObj ) CLASS ( gmshMesh_ ), INTENT ( IN ) :: obj CLASS ( Mesh_ ), INTENT ( INOUT ), TARGET :: MeshObj CLASS ( Element_ ), INTENT ( IN ) :: FEObj END SUBROUTINE gmsh_mesh_getelements_1 END INTERFACE !---------------------------------------------------------------------------- !                                                getElements@ElementsMethods !---------------------------------------------------------------------------- INTERFACE !! This subroutine builds a mesh of elements with same co-dimensions !> This subroutine builds a mesh of elements with same co-dimensions ! ! - For `Xidim=nsd` it returns all cell elements ! - For `Xidim=nsd-1` it returns all facet elements ! - For `Xidim=nsd-2` it returns all line elements ! - For `Xidim=nsd-3` it returns all the point elements ! ! @note ! If `offset` is present then `MeshObj` should be allocated, in that case ! first element will be placed at `MeshObj % elem( offset + 1 )`. Therefore, ! there should be sufficient space in `MeshObj` to accomodate all new ! coming elements ! @endnote MODULE SUBROUTINE gmsh_mesh_getelements_2 ( obj , MeshObj , XiDim , FEObj , Offset ) CLASS ( gmshMesh_ ), INTENT ( IN ) :: obj CLASS ( Mesh_ ), INTENT ( INOUT ), TARGET :: MeshObj INTEGER ( I4B ), INTENT ( IN ) :: XiDim CLASS ( Element_ ), INTENT ( IN ) :: FEObj INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: Offset END SUBROUTINE gmsh_mesh_getelements_2 END INTERFACE !---------------------------------------------------------------------------- !                                                getElements@ElementsMethods !---------------------------------------------------------------------------- INTERFACE !! This subroutine build a [[mesh_]] in [[domain_]] by using [[gmshMesh_]] !> This subroutine builds a mesh of elements with same co-dimensions ! ! - For `Xidim=nsd` it returns all cell elements ! - For `Xidim=nsd-1` it returns all facet elements ! - For `Xidim=nsd-2` it returns all line elements ! - For `Xidim=nsd-3` it returns all the point elements ! ! If `offset` is present then `MeshObj` should be allocated, in that case ! first element will be placed at `MeshObj % elem( offset + 1 )`. Therefore, ! there should be sufficient space in `MeshObj` to accomodate all new ! coming elements ! ! Note that this is just a wrapper for a method defined in ! [[gmshMesh_::getelements]] MODULE SUBROUTINE gmsh_mesh_getelements_2c ( Obj , Dom , indx , XiDim , FEObj , Offset ) CLASS ( gmshMesh_ ), INTENT ( IN ) :: Obj CLASS ( Domain_ ), INTENT ( INOUT ), TARGET :: Dom INTEGER ( I4B ), INTENT ( IN ) :: indx INTEGER ( I4B ), INTENT ( IN ) :: XiDim CLASS ( Element_ ), INTENT ( IN ) :: FEObj INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: Offset END SUBROUTINE gmsh_mesh_getelements_2c END INTERFACE !---------------------------------------------------------------------------- !                                                getElements@ElementsMethods !---------------------------------------------------------------------------- INTERFACE !! This subroutine returns the mesh of elements !> authors: Dr. Vikas Sharma ! ! This subroutine returns the mesh of elements; it applies two levels of ! filter ! ! - For `Xidim=nsd` it returns all cell elements ! - For `Xidim=nsd-1` it returns all facet elements ! - For `Xidim=nsd-2` it returns all line elements ! - For `Xidim=nsd-3` it returns all the point elements ! ! @note ! If `offset` is present then `MeshObj` should be allocated, in that case ! first element will be placed at `MeshObj % elem( offset + 1 )`. Therefore, ! there should be sufficient space in `MeshObj` to accomodate all new ! coming elements ! @endnote MODULE SUBROUTINE gmsh_mesh_getelements_3 ( obj , MeshObj , XiDim , Tag , FEObj ,& & Offset ) CLASS ( gmshMesh_ ), INTENT ( IN ) :: obj CLASS ( Mesh_ ), INTENT ( INOUT ), TARGET :: MeshObj INTEGER ( I4B ), INTENT ( IN ) :: XiDim , Tag ( : ) CLASS ( Element_ ), INTENT ( IN ) :: FEObj INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: Offset END SUBROUTINE gmsh_mesh_getelements_3 END INTERFACE !---------------------------------------------------------------------------- !                                                getElements@ElementsMethods !---------------------------------------------------------------------------- INTERFACE !! This subroutine build a [[mesh_]] in [[domain_]] by using [[gmshMesh_]] !> authors: Dr. Vikas Sharma ! ! This subroutine returns the mesh of elements; it applies two levels of ! filter ! ! - For `Xidim=nsd` it returns all cell elements ! - For `Xidim=nsd-1` it returns all facet elements ! - For `Xidim=nsd-2` it returns all line elements ! - For `Xidim=nsd-3` it returns all the point elements ! ! @note ! If `offset` is present then `MeshObj` should be allocated, in that case ! first element will be placed at `MeshObj % elem( offset + 1 )`. Therefore, ! there should be sufficient space in `MeshObj` to accomodate all new ! coming elements ! @endnote ! ! Note that this is just a wrapper for a method defined in ! [[gmshMesh_::getelements]] MODULE SUBROUTINE gmsh_mesh_getelements_3c ( Obj , Dom , Indx , XiDim , Tag , & & FEObj , Offset ) CLASS ( gmshMesh_ ), INTENT ( IN ) :: Obj CLASS ( Domain_ ), INTENT ( INOUT ), TARGET :: Dom INTEGER ( I4B ), INTENT ( IN ) :: Indx INTEGER ( I4B ), INTENT ( IN ) :: XiDim , Tag ( : ) CLASS ( Element_ ), INTENT ( IN ) :: FEObj INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: Offset END SUBROUTINE gmsh_mesh_getelements_3c END INTERFACE !---------------------------------------------------------------------------- !                                                getElements@ElementsMethods !---------------------------------------------------------------------------- INTERFACE !! This subroutine returns the mesh of elements !> authors: Dr. Vikas Sharma ! ! This subroutine returns the mesh of elements; it applies two levels of ! filter ! ! - For `Xidim=nsd` it returns all cell elements ! - For `Xidim=nsd-1` it returns all facet elements ! - For `Xidim=nsd-2` it returns all line elements ! - For `Xidim=nsd-3` it returns all the point elements ! ! @note ! If `offset` is present then `MeshObj` should be allocated, in that case ! first element will be placed at `MeshObj % elem( offset + 1 )`. Therefore, ! there should be sufficient space in `MeshObj` to accomodate all new ! coming elements ! @endnote MODULE SUBROUTINE gmsh_mesh_getelements_4 ( obj , MeshObj , XiDim , TagNames , & & FEObj , Offset ) CLASS ( gmshMesh_ ), INTENT ( IN ) :: obj CLASS ( Mesh_ ), INTENT ( INOUT ), TARGET :: MeshObj INTEGER ( I4B ), INTENT ( IN ) :: XiDim TYPE ( String ), INTENT ( IN ) :: TagNames ( : ) CLASS ( Element_ ), INTENT ( IN ) :: FEObj INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: Offset END SUBROUTINE gmsh_mesh_getelements_4 END INTERFACE !---------------------------------------------------------------------------- !                                                getElements@ElementsMethods !---------------------------------------------------------------------------- INTERFACE !! This subroutine build a [[mesh_]] in [[domain_]] by using [[gmshMesh_]] !> authors: Dr. Vikas Sharma ! ! This subroutine returns the mesh of elements; it applies two levels of ! filter ! ! - For `Xidim=nsd` it returns all cell elements ! - For `Xidim=nsd-1` it returns all facet elements ! - For `Xidim=nsd-2` it returns all line elements ! - For `Xidim=nsd-3` it returns all the point elements ! ! @note ! If `offset` is present then `MeshObj` should be allocated, in that case ! first element will be placed at `MeshObj % elem( offset + 1 )`. Therefore, ! there should be sufficient space in `MeshObj` to accomodate all new ! coming elements ! @endnote ! ! Note that this is just a wrapper for a method defined in ! [[gmshMesh_::getelements]] MODULE SUBROUTINE gmsh_mesh_getelements_4c ( Obj , Dom , Indx , XiDim , TagNames , & & FEObj , Offset ) CLASS ( gmshMesh_ ), INTENT ( IN ) :: Obj CLASS ( Domain_ ), INTENT ( INOUT ), TARGET :: Dom INTEGER ( I4B ), INTENT ( IN ) :: Indx INTEGER ( I4B ), INTENT ( IN ) :: XiDim TYPE ( String ), INTENT ( IN ) :: TagNames ( : ) CLASS ( Element_ ), INTENT ( IN ) :: FEObj INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: Offset END SUBROUTINE gmsh_mesh_getelements_4c END INTERFACE !---------------------------------------------------------------------------- !                                                getElements@ElementsMethods !---------------------------------------------------------------------------- INTERFACE !! This subroutine initiate [[domain_]] by reading gmshMesh file !> authors: Dr. Vikas Sharma ! ! This subroutine initiate [[domain_]] by reading gmshMesh file ! This is a high level routine ! ! - It gets all informatio from [[gmshMesh_]] and allocate `obj %  omega` ! and `obj  % boundary` MODULE SUBROUTINE dom_init_from_gmshMesh ( mshobj , obj , facetmesh ) CLASS ( gmshMesh_ ), INTENT ( IN ) :: mshobj CLASS ( Domain_ ), INTENT ( INOUT ) :: obj TYPE ( String ), OPTIONAL , INTENT ( IN ) :: facetmesh ( :, : ) END SUBROUTINE dom_init_from_gmshMesh END INTERFACE !---------------------------------------------------------------------------- !                                                      WriteMesh@Postprocess !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE gmsh_mesh_write_mesh ( obj , Path , Filename , Extension , & & Nodes ) CLASS ( gmshMesh_ ), INTENT ( IN ) :: obj CHARACTER ( LEN = * ), INTENT ( IN ) :: Path CHARACTER ( LEN = * ), INTENT ( IN ) :: FileName CHARACTER ( LEN = * ), INTENT ( IN ) :: Extension REAL ( DFP ), INTENT ( IN ) :: Nodes (:, :) END SUBROUTINE gmsh_mesh_write_mesh END INTERFACE !---------------------------------------------------------------------------- !                                                  WriteNodeData@PostProcess !---------------------------------------------------------------------------- INTERFACE !! This subroutine writes the node data information in a msh file format !> authors: Dr. Vikas Sharma ! ! This subroutine writes the nodal values of a variable `x` into msh file ! ! - `name` is the name of physical variable whose dof will be printed ! - The subroutine will decided the nature of physical variable and ! and write in msh file accordingly ! - The subroutine search for this name in [[dof_]] and if this name is ! is not present the subroutine writes nothing MODULE SUBROUTINE gmsh_mesh_write_nodedata_1 ( obj , x , dofobj , name , indx , & & local_nptrs , nodes ) CLASS ( gmshMesh_ ), INTENT ( IN ) :: obj REAL ( DFP ), INTENT ( IN ) :: x ( : ) TYPE ( DOF_ ), INTENT ( IN ) :: dofobj INTEGER ( I4B ), INTENT ( IN ) :: indx ( : ) INTEGER ( I4B ), INTENT ( IN ) :: local_nptrs ( : ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: name REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: nodes ( :, : ) END SUBROUTINE gmsh_mesh_write_nodedata_1 END INTERFACE !---------------------------------------------------------------------------- !                                                  WriteNodeData@PostProcess !---------------------------------------------------------------------------- INTERFACE !! This subroutine writes the node data information in a gmshMesh file format !> authors: Dr. Vikas Sharma ! ! This subroutine writes the nodal values of a variable `x` into gmshMesh file ! ! - It will write all the physical variables in vtk file ! - It calls [[gmsh_mesh_write_nodedata_2]] subroutine internally MODULE SUBROUTINE gmsh_mesh_write_nodedata_2 ( obj , x , dofobj , indx , & & local_nptrs , nodes ) CLASS ( gmshMesh_ ), INTENT ( IN ) :: obj REAL ( DFP ), INTENT ( IN ) :: x ( : ) TYPE ( DOF_ ), INTENT ( IN ) :: dofobj INTEGER ( I4B ), INTENT ( IN ) :: indx ( : ) INTEGER ( I4B ), INTENT ( IN ) :: local_nptrs ( : ) REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: nodes ( :, : ) END SUBROUTINE gmsh_mesh_write_nodedata_2 END INTERFACE !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- INTERFACE gmsh_mesh_Pointer MODULE PROCEDURE gmsh_mesh_constructor_1 END INTERFACE gmsh_mesh_Pointer PUBLIC :: gmsh_mesh_Pointer !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- CONTAINS !----------------------------------------------------------------------------- !                                                      gmsh_mesh_constructor_1 !----------------------------------------------------------------------------- FUNCTION gmsh_mesh_constructor_1 ( Path , FileName , Extension , NSD ) RESULT ( Obj ) ! Define intent of dummy variables CLASS ( gmshMesh_ ), POINTER :: Obj CHARACTER ( LEN = * ), INTENT ( IN ) :: FileName CHARACTER ( LEN = * ), INTENT ( IN ), OPTIONAL :: Extension , Path INTEGER ( I4B ), INTENT ( IN ) :: NSD ALLOCATE ( Obj ) CALL Obj % Initiate ( Path , FileName , Extension , NSD ) END FUNCTION gmsh_mesh_constructor_1 END MODULE gmshMesh_Class","tags":"","loc":"sourcefile/gmshmesh_class.f90.html"},{"title":"gmshCurve_Class.f90 – Fortran Program","text":"Contents Modules gmshCurve_Class Source Code gmshCurve_Class.f90 Source Code MODULE gmshCurve_Class !! This module defines a class for gmsh points USE GlobalData USE BaseType USE gmshEntity_Class IMPLICIT NONE PRIVATE !---------------------------------------------------------------------------- !                                                                 gmshCurve_ !---------------------------------------------------------------------------- TYPE , ABSTRACT , EXTENDS ( gmshEntity_ ) :: gmshCurve_ END TYPE gmshCurve_ TYPE :: gmshCurvePointer_ CLASS ( gmshCurve_ ), POINTER :: Ptr => Null ( ) END TYPE gmshCurvePointer_ PUBLIC :: gmshCurve_ PUBLIC :: gmshCurvePointer_ !---------------------------------------------------------------------------- !                                                                 gmshLine_ !---------------------------------------------------------------------------- TYPE , EXTENDS ( gmshCurve_ ) :: gmshLine_ INTEGER ( I4B ) :: startTag , endTag CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: encodedStr => line_encode END TYPE gmshLine_ TYPE :: gmshLinePointer_ CLASS ( gmshLine_ ), POINTER :: Ptr => NULL ( ) END TYPE gmshLinePointer_ PUBLIC :: gmshLine_ PUBLIC :: gmshLinePointer_ PUBLIC :: gmshLine_Pointer !---------------------------------------------------------------------------- !                                                                gmshCircle_ !---------------------------------------------------------------------------- TYPE , EXTENDS ( gmshCurve_ ) :: gmshCircle_ INTEGER ( I4B ) :: startTag , endTag , centerTag REAL ( DFP ) :: nx , ny , nz CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: encodedStr => circle_encode END TYPE gmshCircle_ TYPE :: gmshCirclePointer_ CLASS ( gmshCircle_ ), POINTER :: Ptr => NULL ( ) END TYPE gmshCirclePointer_ PUBLIC :: gmshCircle_ PUBLIC :: gmshCirclePointer_ PUBLIC :: gmshCircle_Pointer !---------------------------------------------------------------------------- !                                                                gmshEllipse_ !---------------------------------------------------------------------------- TYPE , EXTENDS ( gmshCurve_ ) :: gmshEllipse_ INTEGER ( I4B ) :: startTag , endTag , majorTag , centerTag REAL ( DFP ) :: nx , ny , nz CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: encodedStr => Ellipse_encode END TYPE gmshEllipse_ TYPE :: gmshEllipsePointer_ CLASS ( gmshEllipse_ ), POINTER :: Ptr => NULL ( ) END TYPE gmshEllipsePointer_ PUBLIC :: gmshEllipse_ PUBLIC :: gmshEllipsePointer_ PUBLIC :: gmshEllipse_Pointer !---------------------------------------------------------------------------- !                                                                gmshSpline_ !---------------------------------------------------------------------------- TYPE , EXTENDS ( gmshCurve_ ) :: gmshSpline_ INTEGER ( I4B ), ALLOCATABLE :: pointTags ( : ) CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: encodedStr => Spline_encode END TYPE gmshSpline_ TYPE :: gmshSplinePointer_ CLASS ( gmshSpline_ ), POINTER :: Ptr => NULL ( ) END TYPE gmshSplinePointer_ PUBLIC :: gmshSpline_ PUBLIC :: gmshSplinePointer_ PUBLIC :: gmshSpline_Pointer !---------------------------------------------------------------------------- !                                                        gmshCompoundSpline_ !---------------------------------------------------------------------------- TYPE , EXTENDS ( gmshCurve_ ) :: gmshCompoundSpline_ INTEGER ( I4B ), ALLOCATABLE :: curveTags ( : ) INTEGER ( I4B ) :: numIntervals CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: encodedStr => CompoundSpline_encode END TYPE gmshCompoundSpline_ TYPE :: gmshCompoundSplinePointer_ CLASS ( gmshCompoundSpline_ ), POINTER :: Ptr => NULL ( ) END TYPE gmshCompoundSplinePointer_ PUBLIC :: gmshCompoundSpline_ PUBLIC :: gmshCompoundSplinePointer_ PUBLIC :: gmshCompoundSpline_Pointer !---------------------------------------------------------------------------- !                                                       gmshCompoundBSpline_ !---------------------------------------------------------------------------- TYPE , EXTENDS ( gmshCurve_ ) :: gmshCompoundBSpline_ INTEGER ( I4B ), ALLOCATABLE :: curveTags ( : ) INTEGER ( I4B ) :: numIntervals CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: encodedStr => CompoundBSpline_encode END TYPE gmshCompoundBSpline_ TYPE :: gmshCompoundBSplinePointer_ CLASS ( gmshCompoundBSpline_ ), POINTER :: Ptr => NULL ( ) END TYPE gmshCompoundBSplinePointer_ PUBLIC :: gmshCompoundBSpline_ PUBLIC :: gmshCompoundBSplinePointer_ PUBLIC :: gmshCompoundBSpline_Pointer !---------------------------------------------------------------------------- !                                                                gmshBSpline_ !---------------------------------------------------------------------------- TYPE , EXTENDS ( gmshCurve_ ) :: gmshBSpline_ INTEGER ( I4B ), ALLOCATABLE :: pointTags ( : ) CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: encodedStr => BSpline_encode END TYPE gmshBSpline_ TYPE :: gmshBSplinePointer_ CLASS ( gmshBSpline_ ), POINTER :: Ptr => NULL ( ) END TYPE gmshBSplinePointer_ PUBLIC :: gmshBSpline_ PUBLIC :: gmshBSplinePointer_ PUBLIC :: gmshBSpline_Pointer !---------------------------------------------------------------------------- !                                                                gmshBezier_ !---------------------------------------------------------------------------- TYPE , EXTENDS ( gmshCurve_ ) :: gmshBezier_ INTEGER ( I4B ), ALLOCATABLE :: pointTags ( : ) CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: encodedStr => Bezier_encode END TYPE gmshBezier_ TYPE :: gmshBezierPointer_ CLASS ( gmshBezier_ ), POINTER :: Ptr => NULL ( ) END TYPE gmshBezierPointer_ PUBLIC :: gmshBezier_ PUBLIC :: gmshBezierPointer_ PUBLIC :: gmshBezier_Pointer !---------------------------------------------------------------------------- !                                                             gmshCurveLoop_ !---------------------------------------------------------------------------- TYPE , EXTENDS ( gmshCurve_ ) :: gmshCurveLoop_ INTEGER ( I4B ), ALLOCATABLE :: curveTags ( : ) CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: encodedStr => CurveLoop_encode END TYPE gmshCurveLoop_ TYPE :: gmshCurveLoopPointer_ CLASS ( gmshCurveLoop_ ), POINTER :: Ptr => NULL ( ) END TYPE gmshCurveLoopPointer_ PUBLIC :: gmshCurveLoop_ PUBLIC :: gmshCurveLoopPointer_ PUBLIC :: gmshCurveLoop_Pointer !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- CONTAINS !---------------------------------------------------------------------------- !                                                gmsLine_Pointer@LineMethods !---------------------------------------------------------------------------- FUNCTION gmshLine_Pointer ( startTag , endTag , uid ) RESULT ( Ans ) INTEGER ( I4B ), INTENT ( IN ) :: startTag , endTag , uid CLASS ( gmshLine_ ), POINTER :: Ans ALLOCATE ( Ans ) Ans % startTag = startTag Ans % endTag = endTag Ans % uid = uid Ans % dim = 1 END FUNCTION gmshLine_Pointer FUNCTION line_encode ( Obj ) RESULT ( Ans ) CLASS ( gmshLine_ ), INTENT ( IN ) :: obj TYPE ( String ) :: ans ans = & & \"Line( \" // & & trim ( str ( obj % uid , no_sign = . true . ) ) // & & \" ) = { \" // & & trim ( str ( obj % startTag , no_sign = . true . ) ) // & & \", \" // & & trim ( str ( obj % endTag , no_sign = . true . ) ) // & & \" };\" END FUNCTION line_encode !---------------------------------------------------------------------------- !                                           gmshCircle_Pointer@CircleMethods !---------------------------------------------------------------------------- FUNCTION gmshCircle_Pointer ( startTag , centerTag , endTag , uid , nx , ny , nz ) & & RESULT ( Ans ) INTEGER ( I4B ), INTENT ( IN ) :: startTag , endTag , centerTag , uid REAL ( DFP ), INTENT ( IN ) :: nx , ny , nz CLASS ( gmshCircle_ ), POINTER :: Ans ALLOCATE ( Ans ) Ans % startTag = startTag Ans % endTag = endTag Ans % centerTag = centerTag Ans % nx = nx Ans % ny = ny Ans % nz = nz Ans % uid = uid Ans % dim = 1 END FUNCTION gmshCircle_Pointer FUNCTION Circle_encode ( Obj ) RESULT ( Ans ) CLASS ( gmshCircle_ ), INTENT ( IN ) :: obj TYPE ( String ) :: ans ans = & & \"Circle( \" // & & trim ( str ( obj % uid , no_sign = . true . ) ) // & & \" ) = { \" // & & trim ( str ( obj % startTag , no_sign = . true . ) ) // & & \", \" // & & trim ( str ( obj % centerTag , no_sign = . true . ) ) // & & \", \" // & & trim ( str ( obj % endTag , no_sign = . true . ) ) // & & \" };\" END FUNCTION Circle_encode !---------------------------------------------------------------------------- !                                          gmshEllipse_Pointer@EllipseMethods !---------------------------------------------------------------------------- FUNCTION gmshEllipse_Pointer ( startTag , centerTag , majorTag , endTag , uid , & & nx , ny , nz ) RESULT ( Ans ) INTEGER ( I4B ), INTENT ( IN ) :: startTag , endTag , centerTag , majorTag , uid REAL ( DFP ), INTENT ( IN ) :: nx , ny , nz CLASS ( gmshEllipse_ ), POINTER :: Ans ALLOCATE ( Ans ) Ans % startTag = startTag Ans % endTag = endTag Ans % majorTag = majorTag Ans % centerTag = centerTag Ans % nx = nx Ans % ny = ny Ans % nz = nz Ans % uid = uid Ans % dim = 1 END FUNCTION gmshEllipse_Pointer FUNCTION Ellipse_encode ( Obj ) RESULT ( Ans ) CLASS ( gmshEllipse_ ), INTENT ( IN ) :: obj TYPE ( String ) :: ans ans = & & \"Ellipse( \" // & & trim ( str ( obj % uid , no_sign = . true . ) ) // & & \" ) = { \" // & & trim ( str ( obj % startTag , no_sign = . true . ) ) // & & \", \" // & & trim ( str ( obj % centerTag , no_sign = . true . ) ) // & & \", \" // & & trim ( str ( obj % majorTag , no_sign = . true . ) ) // & & \", \" // & & trim ( str ( obj % endTag , no_sign = . true . ) ) // & & \" };\" END FUNCTION Ellipse_encode !---------------------------------------------------------------------------- !                                           gmshSpline_Pointer@SplineMethods !---------------------------------------------------------------------------- FUNCTION gmshSpline_Pointer ( pointTags , uid ) RESULT ( Ans ) INTEGER ( I4B ), INTENT ( IN ) :: uid , pointTags ( : ) CLASS ( gmshSpline_ ), POINTER :: Ans ALLOCATE ( Ans ) Ans % pointTags = pointTags Ans % uid = uid Ans % dim = 1 END FUNCTION gmshSpline_Pointer FUNCTION Spline_encode ( Obj ) RESULT ( Ans ) CLASS ( gmshSpline_ ), INTENT ( IN ) :: obj TYPE ( String ) :: ans ! internal variables INTEGER ( I4B ) :: ii , n TYPE ( String ), ALLOCATABLE :: s ( : ) n = SIZE ( obj % pointTags ) ALLOCATE ( s ( n ) ) DO ii = 1 , n s ( ii ) = trim ( str ( obj % pointTags ( ii ), no_sign = . true . ) ) END DO ans = ans % join ( s , sep = \", \" ) ans = & & \"Spline( \" // & & trim ( str ( obj % uid , no_sign = . true . ) ) // & & \" ) = { \" // & & trim ( ans ) // & & \" };\" END FUNCTION Spline_encode !---------------------------------------------------------------------------- !                            gmshCompoundSpline_Pointer@CompoundSplineMethods !---------------------------------------------------------------------------- FUNCTION gmshCompoundSpline_Pointer ( curveTags , uid , numIntervals ) & & RESULT ( Ans ) INTEGER ( I4B ), INTENT ( IN ) :: uid , curveTags ( : ), numIntervals CLASS ( gmshCompoundSpline_ ), POINTER :: Ans ALLOCATE ( Ans ) Ans % curveTags = curveTags Ans % numIntervals = numIntervals Ans % uid = uid Ans % dim = 1 END FUNCTION gmshCompoundSpline_Pointer FUNCTION CompoundSpline_encode ( Obj ) RESULT ( Ans ) CLASS ( gmshCompoundSpline_ ), INTENT ( IN ) :: obj TYPE ( String ) :: ans ! internal variables INTEGER ( I4B ) :: ii , n TYPE ( String ), ALLOCATABLE :: s ( : ) n = SIZE ( obj % curveTags ) ALLOCATE ( s ( n ) ) DO ii = 1 , n s ( ii ) = trim ( str ( obj % curveTags ( ii ), no_sign = . true . ) ) END DO ans = ans % join ( s , sep = \", \" ) ans = & & \"Compound Spline( \" // & & trim ( str ( obj % uid , no_sign = . true . ) ) // & & \" ) = { \" // & & trim ( ans ) // & & \" } Using \" // & & trim ( str ( obj % numIntervals , no_sign = . true . ) ) // & & \";\" END FUNCTION CompoundSpline_encode !---------------------------------------------------------------------------- !                         gmshCompoundBSpline_Pointer@CompoundBSplineMethods !---------------------------------------------------------------------------- FUNCTION gmshCompoundBSpline_Pointer ( curveTags , uid , numIntervals ) & & RESULT ( Ans ) INTEGER ( I4B ), INTENT ( IN ) :: uid , curveTags ( : ), numIntervals CLASS ( gmshCompoundBSpline_ ), POINTER :: Ans ALLOCATE ( Ans ) Ans % curveTags = curveTags Ans % numIntervals = numIntervals Ans % uid = uid Ans % dim = 1 END FUNCTION gmshCompoundBSpline_Pointer FUNCTION CompoundBSpline_encode ( Obj ) RESULT ( Ans ) CLASS ( gmshCompoundBSpline_ ), INTENT ( IN ) :: obj TYPE ( String ) :: ans ! internal variables INTEGER ( I4B ) :: ii , n TYPE ( String ), ALLOCATABLE :: s ( : ) n = SIZE ( obj % curveTags ) ALLOCATE ( s ( n ) ) DO ii = 1 , n s ( ii ) = trim ( str ( obj % curveTags ( ii ), no_sign = . true . ) ) END DO ans = ans % join ( s , sep = \", \" ) ans = & & \"Compound BSpline( \" // & & trim ( str ( obj % uid , no_sign = . true . ) ) // & & \" ) = { \" // & & trim ( ans ) // & & \" } Using \" // & & trim ( str ( obj % numIntervals , no_sign = . true . ) ) // & & \";\" END FUNCTION CompoundBSpline_encode !---------------------------------------------------------------------------- !                                         gmshBSpline_Pointer@BSplineMethods !---------------------------------------------------------------------------- FUNCTION gmshBSpline_Pointer ( pointTags , uid ) RESULT ( Ans ) INTEGER ( I4B ), INTENT ( IN ) :: uid , pointTags ( : ) CLASS ( gmshBSpline_ ), POINTER :: Ans ALLOCATE ( Ans ) Ans % pointTags = pointTags Ans % uid = uid Ans % dim = 1 END FUNCTION gmshBSpline_Pointer FUNCTION BSpline_encode ( Obj ) RESULT ( Ans ) CLASS ( gmshBSpline_ ), INTENT ( IN ) :: obj TYPE ( String ) :: ans ! internal variables INTEGER ( I4B ) :: ii , n TYPE ( String ), ALLOCATABLE :: s ( : ) n = SIZE ( obj % pointTags ) ALLOCATE ( s ( n ) ) DO ii = 1 , n s ( ii ) = trim ( str ( obj % pointTags ( ii ), no_sign = . true . ) ) END DO ans = ans % join ( s , sep = \", \" ) ans = & & \"BSpline( \" // & & trim ( str ( obj % uid , no_sign = . true . ) ) // & & \" ) = { \" // & & trim ( ans ) // & & \" };\" END FUNCTION BSpline_encode !---------------------------------------------------------------------------- !                                           gmshBezier_Pointer@BezierMethods !---------------------------------------------------------------------------- FUNCTION gmshBezier_Pointer ( pointTags , uid ) RESULT ( Ans ) INTEGER ( I4B ), INTENT ( IN ) :: uid , pointTags ( : ) CLASS ( gmshBezier_ ), POINTER :: Ans ALLOCATE ( Ans ) Ans % pointTags = pointTags Ans % uid = uid Ans % dim = 1 END FUNCTION gmshBezier_Pointer FUNCTION Bezier_encode ( Obj ) RESULT ( Ans ) CLASS ( gmshBezier_ ), INTENT ( IN ) :: obj TYPE ( String ) :: ans ! internal variables INTEGER ( I4B ) :: ii , n TYPE ( String ), ALLOCATABLE :: s ( : ) n = SIZE ( obj % pointTags ) ALLOCATE ( s ( n ) ) DO ii = 1 , n s ( ii ) = trim ( str ( obj % pointTags ( ii ), no_sign = . true . ) ) END DO ans = ans % join ( s , sep = \", \" ) ans = & & \"Bezier( \" // & & trim ( str ( obj % uid , no_sign = . true . ) ) // & & \" ) = { \" // & & trim ( ans ) // & & \" };\" END FUNCTION Bezier_encode !---------------------------------------------------------------------------- !                                     gmshCurveLoop_Pointer@CurveLoopMethods !---------------------------------------------------------------------------- FUNCTION gmshCurveLoop_Pointer ( curveTags , uid ) RESULT ( Ans ) INTEGER ( I4B ), INTENT ( IN ) :: uid , curveTags ( : ) CLASS ( gmshCurveLoop_ ), POINTER :: Ans ALLOCATE ( Ans ) Ans % curveTags = curveTags Ans % uid = uid Ans % dim = 1 END FUNCTION gmshCurveLoop_Pointer FUNCTION CurveLoop_encode ( Obj ) RESULT ( Ans ) CLASS ( gmshCurveLoop_ ), INTENT ( IN ) :: obj TYPE ( String ) :: ans ! internal variables INTEGER ( I4B ) :: ii , n TYPE ( String ), ALLOCATABLE :: s ( : ) n = SIZE ( obj % curveTags ) ALLOCATE ( s ( n ) ) DO ii = 1 , n s ( ii ) = trim ( str ( obj % curveTags ( ii ) ) ) END DO ans = ans % join ( s , sep = \", \" ) ans = & & \"Curve Loop( \" // & & trim ( str ( obj % uid , no_sign = . true . ) ) // & & \" ) = { \" // & & trim ( ans ) // & & \" };\" END FUNCTION CurveLoop_encode END MODULE gmshCurve_Class","tags":"","loc":"sourcefile/gmshcurve_class.f90.html"},{"title":"gmshVolume_Class.f90 – Fortran Program","text":"Contents Modules gmshVolume_Class Source Code gmshVolume_Class.f90 Source Code MODULE gmshVolume_Class !! This module defines a class for gmsh Volume entities USE GlobalData USE BaseType USE gmshEntity_Class IMPLICIT NONE PRIVATE !---------------------------------------------------------------------------- !                                                               gmshVolume_ !---------------------------------------------------------------------------- TYPE , EXTENDS ( gmshEntity_ ) :: gmshVolume_ INTEGER ( I4B ), ALLOCATABLE :: shellTags ( : ) CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: encodedStr => Volume_encode END TYPE gmshVolume_ TYPE :: gmshVolumePointer_ CLASS ( gmshVolume_ ), POINTER :: Ptr => Null ( ) END TYPE gmshVolumePointer_ PUBLIC :: gmshVolume_ PUBLIC :: gmshVolumePointer_ PUBLIC :: gmshVolume_Pointer !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- CONTAINS !---------------------------------------------------------------------------- !                                          gmsVolume_Pointer@VolumeMethods !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! Add a volume (a region) defined by one or more shells shellTags. ! The first surface loop defines the exterior boundary; additional surface ! loop define holes. If tag is positive, set the tag explicitly; otherwise a !  new tag is selected automatically. Return the tag of the volume. FUNCTION gmshVolume_Pointer ( shellTags , uid ) RESULT ( Ans ) INTEGER ( I4B ), INTENT ( IN ) :: shellTags ( : ) INTEGER ( I4B ), INTENT ( IN ) :: uid CLASS ( gmshVolume_ ), POINTER :: Ans ALLOCATE ( Ans ) Ans % shellTags = shellTags Ans % uid = uid Ans % dim = 3 END FUNCTION gmshVolume_Pointer FUNCTION Volume_encode ( Obj ) RESULT ( Ans ) CLASS ( gmshVolume_ ), INTENT ( IN ) :: obj TYPE ( String ) :: ans ! internal variables INTEGER ( I4B ) :: ii , n TYPE ( String ), ALLOCATABLE :: s ( : ) n = SIZE ( obj % shellTags ) ALLOCATE ( s ( n ) ) DO ii = 1 , n s ( ii ) = trim ( str ( obj % shellTags ( ii ), no_sign = . true . )) END DO ans = ans % join ( s , sep = \", \" ) ans = & & \"Volume( \" // & & trim ( str ( obj % uid , no_sign = . true . ) ) // & & \" ) = { \" // & & trim ( ans ) // & & \" };\" END FUNCTION Volume_encode !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- END MODULE gmshVolume_Class","tags":"","loc":"sourcefile/gmshvolume_class.f90.html"},{"title":"gmshSurface_Class.f90 – Fortran Program","text":"Contents Modules gmshSurface_Class Source Code gmshSurface_Class.f90 Source Code MODULE gmshSurface_Class !! This module defines a class for gmsh Surface entities USE GlobalData USE BaseType USE gmshEntity_Class IMPLICIT NONE PRIVATE !---------------------------------------------------------------------------- !                                                                 gmshSurface_ !---------------------------------------------------------------------------- TYPE , EXTENDS ( gmshEntity_ ) :: gmshSurface_ INTEGER ( I4B ), ALLOCATABLE :: wireTags ( : ) INTEGER ( I4B ) :: sphereCenterTag = - 1 !! wireTags contains id of curve loops !! The first curve loop defines the exterior contour; !! additional curve loop define holes. CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: encodedStr => Surface_encode END TYPE gmshSurface_ TYPE :: gmshSurfacePointer_ CLASS ( gmshSurface_ ), POINTER :: Ptr => Null ( ) END TYPE gmshSurfacePointer_ PUBLIC :: gmshSurface_ PUBLIC :: gmshSurfacePointer_ PUBLIC :: gmshSurface_Pointer !---------------------------------------------------------------------------- !                                                          gmshPlaneSurface_ !---------------------------------------------------------------------------- TYPE , EXTENDS ( gmshSurface_ ) :: gmshPlaneSurface_ CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: encodedStr => PlaneSurface_encode END TYPE gmshPlaneSurface_ TYPE :: gmshPlaneSurfacePointer_ CLASS ( gmshPlaneSurface_ ), POINTER :: Ptr => NULL ( ) END TYPE gmshPlaneSurfacePointer_ PUBLIC :: gmshPlaneSurface_ PUBLIC :: gmshPlaneSurfacePointer_ PUBLIC :: gmshPlaneSurface_Pointer !---------------------------------------------------------------------------- !                                                          gmshSurfaceLoop_ !---------------------------------------------------------------------------- TYPE , EXTENDS ( gmshSurface_ ) :: gmshSurfaceLoop_ CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: encodedStr => SurfaceLoop_encode END TYPE gmshSurfaceLoop_ TYPE :: gmshSurfaceLoopPointer_ CLASS ( gmshSurfaceLoop_ ), POINTER :: Ptr => NULL ( ) END TYPE gmshSurfaceLoopPointer_ PUBLIC :: gmshSurfaceLoop_ PUBLIC :: gmshSurfaceLoopPointer_ PUBLIC :: gmshSurfaceLoop_Pointer !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- CONTAINS !---------------------------------------------------------------------------- !                                          gmsSurface_Pointer@SurfaceMethods !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! Creates a surface filling. With the built-in kernel, the first curve ! loop should be composed of either three or four curves. ! With the built-in kernel, the optional In Sphere argument forces ! the surface to be a spherical patch (the extra parameter gives the ! tag of the center of the sphere). FUNCTION gmshSurface_Pointer ( wireTags , uid , sphereCenterTag ) RESULT ( Ans ) INTEGER ( I4B ), INTENT ( IN ) :: wireTags ( : ) INTEGER ( I4B ), INTENT ( IN ) :: uid INTEGER ( I4B ), INTENT ( IN ) :: sphereCenterTag CLASS ( gmshSurface_ ), POINTER :: Ans ALLOCATE ( Ans ) Ans % wireTags = wireTags Ans % sphereCenterTag = sphereCenterTag Ans % uid = uid Ans % dim = 2 END FUNCTION gmshSurface_Pointer FUNCTION Surface_encode ( Obj ) RESULT ( Ans ) CLASS ( gmshSurface_ ), INTENT ( IN ) :: obj TYPE ( String ) :: ans ! internal variables INTEGER ( I4B ) :: ii , n TYPE ( String ), ALLOCATABLE :: s ( : ) n = SIZE ( obj % wireTags ) ALLOCATE ( s ( n ) ) DO ii = 1 , n s ( ii ) = trim ( str ( obj % wireTags ( ii ), no_sign = . true . ) ) END DO ans = ans % join ( s , sep = \", \" ) ans = & & \"Surface( \" // & & trim ( str ( obj % uid , no_sign = . true . ) ) // & & \" ) = { \" // & & trim ( ans ) // & & \" }\" IF ( obj % sphereCenterTag . LT . 0 ) THEN ans = trim ( ans ) // \";\" ELSE ans = trim ( ans ) & & // \" In Sphere \" & & // str ( obj % sphereCenterTag , no_sign = . true . ) & & // \";\" END IF END FUNCTION Surface_encode !---------------------------------------------------------------------------- !                                 gmshPlaneSurface_Pointer@PlaneSurfaceMethods !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! Reference ! Creates a plane surface. The expression inside the parentheses is the plane ! surface’s tag; the expression-list on the right hand side should contain ! the tags of all the curve loops defining the surface. The first curve loop ! defines the exterior boundary of the surface; all other curve loops define ! holes in the surface. A curve loop defining a hole should not have any ! curves in common with the exterior curve loop (in which case it is not a ! hole, and the two surfaces should be defined separately). Likewise, a ! curve loop defining a hole should not have any curves in common with ! another curve loop defining a hole in the same surface (in which case the ! two curve loops should be combined). FUNCTION gmshPlaneSurface_Pointer ( wireTags , uid ) RESULT ( Ans ) INTEGER ( I4B ), INTENT ( IN ) :: wireTags ( : ), uid CLASS ( gmshPlaneSurface_ ), POINTER :: Ans ALLOCATE ( Ans ) Ans % wireTags = wireTags Ans % uid = uid Ans % dim = 2 END FUNCTION gmshPlaneSurface_Pointer FUNCTION PlaneSurface_encode ( Obj ) RESULT ( Ans ) CLASS ( gmshPlaneSurface_ ), INTENT ( IN ) :: obj TYPE ( String ) :: ans ! internal variables INTEGER ( I4B ) :: ii , n TYPE ( String ), ALLOCATABLE :: s ( : ) n = SIZE ( obj % wireTags ) ALLOCATE ( s ( n ) ) DO ii = 1 , n s ( ii ) = trim ( str ( obj % wireTags ( ii ), no_sign = . true . ) ) END DO ans = ans % join ( s , sep = \", \" ) ans = & & \"Plane Surface( \" // & & trim ( str ( obj % uid , no_sign = . true . ) ) // & & \" ) = { \" // & & trim ( ans ) // & & \" }; \" END FUNCTION PlaneSurface_encode !---------------------------------------------------------------------------- !                                 gmshSurfaceLoop_Pointer@SurfaceLoopMethods !---------------------------------------------------------------------------- FUNCTION gmshSurfaceLoop_Pointer ( wireTags , uid ) RESULT ( Ans ) INTEGER ( I4B ), INTENT ( IN ) :: wireTags ( : ), uid CLASS ( gmshSurfaceLoop_ ), POINTER :: Ans ALLOCATE ( Ans ) Ans % wireTags = wireTags Ans % uid = uid Ans % dim = 2 END FUNCTION gmshSurfaceLoop_Pointer FUNCTION SurfaceLoop_encode ( Obj ) RESULT ( Ans ) CLASS ( gmshSurfaceLoop_ ), INTENT ( IN ) :: obj TYPE ( String ) :: ans ! internal variables INTEGER ( I4B ) :: ii , n TYPE ( String ), ALLOCATABLE :: s ( : ) n = SIZE ( obj % wireTags ) ALLOCATE ( s ( n ) ) DO ii = 1 , n s ( ii ) = trim ( str ( obj % wireTags ( ii ) )) END DO ans = ans % join ( s , sep = \", \" ) ans = & & \"Surface Loop( \" // & & trim ( str ( obj % uid , no_sign = . true . ) ) // & & \" ) = { \" // & & trim ( ans ) // & & \" }; \" END FUNCTION SurfaceLoop_encode END MODULE gmshSurface_Class","tags":"","loc":"sourcefile/gmshsurface_class.f90.html"},{"title":"gmshEntity_Class.f90 – Fortran Program","text":"Contents Modules gmshEntity_Class Source Code gmshEntity_Class.f90 Source Code MODULE gmshEntity_Class !! This module defines an abstract class for `gmshEntity_` USE GlobalData USE BaseType IMPLICIT NONE PRIVATE !---------------------------------------------------------------------------- !                                                                gmshEntity_ !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! `gmshEntity_` is an abstract class TYPE , ABSTRACT :: gmshEntity_ INTEGER ( I4B ) :: uid = 0 INTEGER ( I4B ) :: dim = 0 !! Unique id of entity CONTAINS PROCEDURE ( en_encode ), PUBLIC , DEFERRED , PASS ( obj ) :: encodedStr !! Encode the information stored in gmshEntity_ in sring and returns END TYPE gmshEntity_ !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- PUBLIC :: gmshEntity_ !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- ABSTRACT INTERFACE FUNCTION en_encode ( obj ) RESULT ( ans ) IMPORT :: gmshEntity_ , String CLASS ( gmshEntity_ ), INTENT ( IN ) :: obj TYPE ( String ) :: ans END FUNCTION en_encode END INTERFACE END MODULE gmshEntity_Class","tags":"","loc":"sourcefile/gmshentity_class.f90.html"},{"title":"gmshPoint_Class.f90 – Fortran Program","text":"Contents Modules gmshPoint_Class Source Code gmshPoint_Class.f90 Source Code MODULE gmshPoint_Class !! This module defines a class for gmsh points USE GlobalData USE BaseType USE gmshEntity_Class IMPLICIT NONE PRIVATE !---------------------------------------------------------------------------- !                                                                 gmshPoint_ !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! [[gmshPoint_]] type represent point entities in gmsh TYPE , EXTENDS ( gmshEntity_ ) :: gmshPoint_ REAL ( DFP ) :: x = 0.0 REAL ( DFP ) :: y = 0.0 REAL ( DFP ) :: z = 0.0 REAL ( DFP ) :: lc = 0.0 CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: encodedStr => point_encode END TYPE gmshPoint_ PUBLIC :: gmshPoint_ TYPE :: gmshPointPointer_ CLASS ( gmshPoint_ ), POINTER :: Ptr => Null ( ) END TYPE gmshPointPointer_ PUBLIC :: gmshPointPointer_ !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- INTERFACE gmshPoint_Pointer MODULE PROCEDURE constructor_1 END INTERFACE gmshPoint_Pointer PUBLIC :: gmshPoint_Pointer !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- CONTAINS !---------------------------------------------------------------------------- !                                                           gmsPoint_Pointer !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This function [[gmshpoint_pointer]] returns pointer to [[gmshPoint_]] FUNCTION constructor_1 ( x , y , z , lc , uid ) RESULT ( Ans ) REAL ( DFP ), INTENT ( IN ) :: x , y , z , lc INTEGER ( I4B ), INTENT ( IN ) :: uid CLASS ( gmshPoint_ ), POINTER :: Ans ALLOCATE ( Ans ) Ans % x = x Ans % y = y Ans % z = z Ans % lc = lc Ans % uid = uid Ans % dim = 0 END FUNCTION constructor_1 !---------------------------------------------------------------------------- !                                                                 encodeStr !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This function encode the information stored in [[gmshPoint_]] in a string ! data type and return it for printing FUNCTION point_encode ( Obj ) RESULT ( Ans ) CLASS ( gmshPoint_ ), INTENT ( IN ) :: obj TYPE ( String ) :: ans IF ( obj % lc . GT . 0.0_DFP ) THEN ans = & & \"Point( \" // & & trim ( str ( obj % uid , no_sign = . true . ) ) // & & \" ) = { \" // & & trim ( str ( obj % x ) ) // & & \", \" // & & trim ( str ( obj % y ) ) // & & \", \" // & & trim ( str ( obj % z ) ) // & & \", \" // & & trim ( str ( obj % lc ) ) // & & \" };\" ELSE ans = & & \"Point( \" // & & trim ( str ( obj % uid , no_sign = . true . ) ) // & & \" ) = { \" // & & trim ( str ( obj % x ) ) // & & \", \" // & & trim ( str ( obj % y ) ) // & & \", \" // & & trim ( str ( obj % z ) ) // & & \" };\" END IF END FUNCTION point_encode END MODULE gmshPoint_Class","tags":"","loc":"sourcefile/gmshpoint_class.f90.html"},{"title":"gmshGeoMesh_Class.f90 – Fortran Program","text":"Contents Modules gmshGeoMesh_Class Source Code gmshGeoMesh_Class.f90 Source Code MODULE gmshGeoMesh_Class USE BaseType USE BaseMethod IMPLICIT NONE PRIVATE !---------------------------------------------------------------------------- !                                                               gmshGeoMesh_ !---------------------------------------------------------------------------- ! gmsh / model / geo / mesh TYPE :: gmshGeoMesh_ TYPE ( Buffer_ ), POINTER :: buffer => NULL ( ) CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: write => geoMesh_write PROCEDURE , PUBLIC , PASS ( Obj ) :: setSize => geoMesh_setSize PROCEDURE , PUBLIC , PASS ( Obj ) :: setTransfiniteCurve => & & geoMesh_setTransfiniteCurve PROCEDURE , PUBLIC , PASS ( Obj ) :: setTransfiniteSurface => & & geoMesh_setTransfiniteSurface PROCEDURE , PUBLIC , PASS ( Obj ) :: setTransfiniteVolume => & & geoMesh_setTransfiniteVolume PROCEDURE , PUBLIC , PASS ( Obj ) :: setRecombine => & & geoMesh_setRecombine PROCEDURE , PUBLIC , PASS ( Obj ) :: setSmoothing => & & geoMesh_setSmoothing PROCEDURE , PUBLIC , PASS ( Obj ) :: setReverse => & & geoMesh_setReverse PROCEDURE , PUBLIC , PASS ( Obj ) :: setAlgorithm => & & geoMesh_setAlgorithm PROCEDURE , PUBLIC , PASS ( Obj ) :: setSizeFromBoundary => & & geoMesh_setSizeFromBoundary END TYPE gmshGeoMesh_ !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- PUBLIC :: gmshGeoMesh_ CONTAINS !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- FUNCTION geoMesh_write ( Obj , UnitNo ) RESULT ( Ans ) CLASS ( gmshGeoMesh_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: UnitNo INTEGER ( I4B ) :: Ans INTEGER ( I4B ) :: ii IF ( ASSOCIATED ( Obj % buffer ) ) THEN DO ii = 1 , Obj % buffer % tLine WRITE ( UnitNo , \"(DT)\" ) Obj % buffer % Line ( ii ) % Ptr END DO END IF END FUNCTION geoMesh_write !---------------------------------------------------------------------------- !                                                                   setSize !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! Set a mesh size constraint on the model entities dimTags. Currently only ! entities of dimension 0 (points) are handled. FUNCTION geoMesh_setSize ( Obj , dim , tags , meshsize ) RESULT ( Ans ) CLASS ( gmshGeoMesh_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: dim INTEGER ( I4B ), INTENT ( IN ) :: tags ( : ) REAL ( DFP ), INTENT ( IN ) :: meshsize INTEGER ( I4B ) :: Ans ! internal variables INTEGER ( I4B ) :: ii , n TYPE ( String ), ALLOCATABLE :: s ( : ) TYPE ( String ) :: ss IF ( dim . NE . 0 ) THEN CALL Display ( \"ERROR:: gmshGeoMesh_Class.f90\" ) CALL Display ( \"          geoMesh_setSize()\" ) CALL Display ( \"          only dim = 0, supported currently\" ) END IF CALL Display ( \"      gmsh%model%geo%mesh%setSize()\" ) Ans = 0 n = SIZE ( tags ) ALLOCATE ( s ( n ) ) DO ii = 1 , n s ( ii ) = trim ( str ( tags ( ii ), no_sign = . true . ) ) END DO ss = ss % join ( s , sep = \", \" ) ss = & & \"Characteristic Length { \" // & & trim ( ss ) // & & \" } =  \" // & & trim ( str ( meshsize ) ) // & & \" ;\" IF ( . NOT . ASSOCIATED ( Obj % buffer ) ) THEN ALLOCATE ( Obj % buffer ) END IF CALL APPEND ( Obj % buffer , ss ) DEALLOCATE ( s ) END FUNCTION geoMesh_setSize !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! Set a transfinite meshing constraint on the curve tag, with numNodes nodes ! distributed according to meshType and coef. Currently supported types ! are \"Progres- sion\" (geometrical progression with power coef) and \"Bump\" ! (refinement toward both extremities of the curve). FUNCTION geoMesh_setTransfiniteCurve ( Obj , tag , nPoints , meshType , & & coef ) RESULT ( Ans ) CLASS ( gmshGeoMesh_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: tag INTEGER ( I4B ), INTENT ( IN ) :: nPoints CHARACTER ( LEN = * ), INTENT ( IN ) :: meshType INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: coef INTEGER ( I4B ) :: Ans END FUNCTION geoMesh_setTransfiniteCurve !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! Set a transfinite meshing constraint on the surface tag. arrangement ! describes the arrangement of the triangles when the surface is not ! flagged as recombined: cur- rently supported values are \"Left\", \"Right\", ! \"AlternateLeft\" and \"AlternateRight\". cornerTags can be used to specify ! the (3 or 4) corners of the transfinite interpola- tion explicitly; ! specifying the corners explicitly is mandatory if the surface has more ! that 3 or 4 points on its boundary. FUNCTION geoMesh_setTransfiniteSurface ( Obj , tag , arrangement , & & cornerTags ) RESULT ( Ans ) CLASS ( gmshGeoMesh_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: tag CHARACTER ( LEN = * ), INTENT ( IN ) :: arrangement INTEGER ( I4B ), INTENT ( IN ) :: cornerTags ( : ) INTEGER ( I4B ) :: Ans END FUNCTION geoMesh_setTransfiniteSurface !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! Set a transfinite meshing constraint on the surface tag. arrangement ! describes the arrangement of the triangles when the surface is not ! flagged as recombined: cur- rently supported values are \"Left\", \"Right\", ! \"AlternateLeft\" and \"AlternateRight\". cornerTags can be used to specify ! the (3 or 4) corners of the transfinite interpola- tion explicitly; ! specifying the corners explicitly is mandatory if the surface has more ! that 3 or 4 points on its boundary. FUNCTION geoMesh_setTransfiniteVolume ( Obj , tag , & & cornerTags ) RESULT ( Ans ) CLASS ( gmshGeoMesh_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: tag INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: cornerTags ( : ) INTEGER ( I4B ) :: Ans END FUNCTION geoMesh_setTransfiniteVolume !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! Set a recombination meshing constraint on the model entity of dimension ! dim and tag tag. Currently only entities of dimension 2 ! (to recombine triangles into quadrangles) are supporte FUNCTION geoMesh_setRecombine ( Obj , dim , tag , angle ) RESULT ( Ans ) CLASS ( gmshGeoMesh_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: dim INTEGER ( I4B ), INTENT ( IN ) :: tag REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: angle INTEGER ( I4B ) :: Ans END FUNCTION geoMesh_setRecombine !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! Set a smoothing meshing constraint on the model entity of dimension dim ! and tag tag. val iterations of a Laplace smoother are applied. FUNCTION geoMesh_setSmoothing ( Obj , dim , tag , val ) RESULT ( Ans ) CLASS ( gmshGeoMesh_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: dim INTEGER ( I4B ), INTENT ( IN ) :: tag INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: val INTEGER ( I4B ) :: Ans END FUNCTION geoMesh_setSmoothing !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! Set a smoothing meshing constraint on the model entity of dimension dim ! and tag tag. val iterations of a Laplace smoother are applied. FUNCTION geoMesh_setReverse ( Obj , dim , tag , val ) RESULT ( Ans ) CLASS ( gmshGeoMesh_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: dim INTEGER ( I4B ), INTENT ( IN ) :: tag LOGICAL ( LGT ), INTENT ( IN ) :: val INTEGER ( I4B ) :: Ans END FUNCTION geoMesh_setReverse !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! Set the meshing algorithm on the model entity of dimension dim and tag tag. ! Currently only supported for dim == 2. FUNCTION geoMesh_setAlgorithm ( Obj , dim , tag , val ) RESULT ( Ans ) CLASS ( gmshGeoMesh_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: dim INTEGER ( I4B ), INTENT ( IN ) :: tag INTEGER ( I4B ), INTENT ( IN ) :: val INTEGER ( I4B ) :: Ans END FUNCTION geoMesh_setAlgorithm !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! Force the mesh size to be extended from the boundary, or not, for the model ! entity of dimension dim and tag tag. Currently only supported for dim == 2. FUNCTION geoMesh_setSizeFromBoundary ( Obj , dim , tag , val ) RESULT ( Ans ) CLASS ( gmshGeoMesh_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: dim INTEGER ( I4B ), INTENT ( IN ) :: tag INTEGER ( I4B ), INTENT ( IN ) :: val INTEGER ( I4B ) :: Ans END FUNCTION geoMesh_setSizeFromBoundary !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- END MODULE gmshGeoMesh_Class","tags":"","loc":"sourcefile/gmshgeomesh_class.f90.html"},{"title":"gmshGeo_Class.f90 – Fortran Program","text":"Contents Modules gmshGeo_Class Source Code gmshGeo_Class.f90 Source Code MODULE gmshGeo_Class !! This class is container for a geometry USE BaseType USE BaseMethod USE gmshPoint_Class USE gmshCurve_Class USE gmshSurface_Class USE gmshVolume_Class USE gmshGeoMesh_Class IMPLICIT NONE INTEGER ( I4B ), PUBLIC , PARAMETER :: def_max_point = 100 INTEGER ( I4B ), PUBLIC , PARAMETER :: def_max_curve = 100 INTEGER ( I4B ), PUBLIC , PARAMETER :: def_max_Surface = 100 INTEGER ( I4B ), PUBLIC , PARAMETER :: def_max_Volume = 100 INTEGER ( I4B ), PUBLIC , PARAMETER :: def_max_curveLoop = 100 INTEGER ( I4B ), PUBLIC , PARAMETER :: def_max_SurfaceLoop = 100 PRIVATE !---------------------------------------------------------------------------- !                                                                  gmshGeo_ !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This class is defined to contain the elements of a geometry ! which will be constructed by Gmsh inbuilt kernel TYPE :: gmshGeo_ TYPE ( Buffer_ ), POINTER :: buffer => NULL ( ) TYPE ( gmshGeoMesh_ ), POINTER :: mesh => NULL ( ) TYPE ( gmshPointPointer_ ), ALLOCATABLE :: Point ( : ) TYPE ( gmshCurvePointer_ ), ALLOCATABLE :: Curve ( : ) TYPE ( gmshSurfacePointer_ ), ALLOCATABLE :: Surface ( : ) TYPE ( gmshVolumePointer_ ), ALLOCATABLE :: Volume ( : ) TYPE ( gmshCurveLoopPointer_ ), ALLOCATABLE :: CurveLoop ( : ) TYPE ( gmshSurfaceLoopPointer_ ), ALLOCATABLE :: SurfaceLoop ( : ) INTEGER ( I4B ) :: tPoints = 0 INTEGER ( I4B ) :: tCurves = 0 INTEGER ( I4B ) :: tSurfaces = 0 INTEGER ( I4B ) :: tVolumes = 0 INTEGER ( I4B ) :: tCurveLoops = 0 INTEGER ( I4B ) :: tSurfaceLoops = 0 ! TYPE( gmshVolumePointer_ ), ALLOCATABLE :: volume( : ) CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: write => geo_write PROCEDURE , PUBLIC , PASS ( Obj ) :: addPoint => geo_add_point !! Add a point entitiy to geometry PROCEDURE , PUBLIC , PASS ( Obj ) :: addLine => geo_add_line !! Add a line entity to geometry PROCEDURE , PUBLIC , PASS ( Obj ) :: addCircleArc => geo_add_circle !! Add a Circular arc entity to geometry PROCEDURE , PUBLIC , PASS ( Obj ) :: addEllipseArc => geo_add_Ellipse !! Add a Ellipse entity to geometry PROCEDURE , PUBLIC , PASS ( Obj ) :: addSpline => geo_add_Spline !! Add a Spline entity to geometry PROCEDURE , PUBLIC , PASS ( Obj ) :: addCompoundSpline => & & geo_add_CompoundSpline !! Add a compound Spline entity to geometry PROCEDURE , PUBLIC , PASS ( Obj ) :: addBSpline => geo_add_BSpline !! Add a BSpline entity to geometry PROCEDURE , PUBLIC , PASS ( Obj ) :: addCompoundBSpline => & & geo_add_CompoundBSpline !! Add a compound BSpline entity to geometry PROCEDURE , PUBLIC , PASS ( Obj ) :: addBezier => geo_add_Bezier !! Add a Bezier entity to geometry PROCEDURE , PUBLIC , PASS ( Obj ) :: addCurveLoop => geo_add_CurveLoop !! Add a Curveloop to geometry PROCEDURE , PUBLIC , PASS ( Obj ) :: addSurfaceFilling => geo_add_SurfaceFilling !! Add surfaceFilled PROCEDURE , PUBLIC , PASS ( Obj ) :: addPlaneSurface => geo_add_PlaneSurface !! Add a plane surface entity to geometry PROCEDURE , PUBLIC , PASS ( Obj ) :: addSurfaceLoop => geo_add_SurfaceLoop END TYPE gmshGeo_ !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- PUBLIC :: gmshGeo_ ! TYPE( gmshGeo_ ), PUBLIC, PARAMETER :: TypeGmshGeo = & !   & gmshGeo_( point = NULL( ), curve = NULL( ) ) !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- CONTAINS !---------------------------------------------------------------------------- !                                                                     Write !---------------------------------------------------------------------------- FUNCTION geo_write ( Obj , UnitNo ) RESULT ( Ans ) CLASS ( gmshGeo_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: UnitNo INTEGER ( I4B ) :: Ans ! Internal variables INTEGER ( I4B ) :: ii IF ( . NOT . ASSOCIATED ( Obj % buffer ) ) THEN CALL Display ( \"ERROR:: gmshGeo_Class.f90\" ) CALL Display ( \"        geo_write()\" ) CALL Display ( \"        Obj % buffer is not associated \" ) STOP END IF IF ( Obj % buffer % tLine . EQ . 0 ) THEN CALL Display ( \"ERROR:: gmshGeo_Class.f90\" ) CALL Display ( \"        geo_write()\" ) CALL Display ( \"        Obj % buffer is empty\" ) STOP END IF DO ii = 1 , Obj % buffer % tLine IF ( ASSOCIATED ( Obj % buffer % Line ( ii ) % ptr ) ) THEN ! CALL Display( \"gmsh%model%geo:: writing gmsh%model%geo%buffer(\" & !   & // trim( str( ii ) ) // \" )\" ) WRITE ( UnitNo , \"(DT)\" ) Obj % buffer % Line ( ii ) % ptr END IF END DO WRITE ( UnitNo , \"(A)\" ) \"Coherence;\" END FUNCTION geo_write !---------------------------------------------------------------------------- !                                                                   addPoint !---------------------------------------------------------------------------- FUNCTION geo_add_point ( Obj , x , y , z , lc , uid ) RESULT ( Ans ) CLASS ( gmshGeo_ ), INTENT ( INOUT ) :: Obj REAL ( DFP ), INTENT ( IN ) :: x , y , z , lc INTEGER ( I4B ), INTENT ( IN ) :: uid INTEGER ( I4B ) :: ans ! Internal variables INTEGER ( I4B ) :: ip , n ! main code IF ( ALLOCATED ( obj % point ) ) THEN n = SIZE ( obj % point ) ! we will expand the point now to accomodate one IF ( n . EQ . obj % tPoints ) THEN BLOCK TYPE ( gmshPointPointer_ ) :: temp ( n ) INTEGER ( I4B ) :: ii DO ii = 1 , n temp ( ii ) % ptr => obj % point ( ii ) % ptr obj % point ( ii ) % ptr => NULL ( ) END DO DEALLOCATE ( obj % point ) ALLOCATE ( obj % point ( 2 * ( n + 1 ) ) ) obj % tPoints = n + 1 ip = n + 1 ! copy back DO ii = 1 , n obj % point ( ii ) % ptr => temp ( ii ) % ptr temp ( ii ) % ptr => NULL ( ) END DO END  BLOCK ELSE ! enough size is there obj % tPoints = obj % tPoints + 1 ip = obj % tPoints END IF ELSE ALLOCATE ( obj % point ( def_max_point ) ) obj % tPoints = 1 ip = 1 END IF IF ( uid . GT . 0 ) THEN obj % point ( ip ) % ptr => gmshPoint_Pointer ( x , y , z , lc , uid ) Ans = 0 ELSE obj % point ( ip ) % ptr => gmshPoint_Pointer ( x , y , z , lc , ip ) Ans = ip END IF ! append to buffer ! WRITE( obj % buffer % unitno, \"(DT)\" ) obj%point(ip)%ptr % encodedStr( ) ! CALL Display( \"    adding Point in gmsh%model%geo%buffer\") CALL APPEND ( obj % buffer , obj % point ( ip )% ptr % encodedStr ( ) ) END FUNCTION geo_add_point !---------------------------------------------------------------------------- !                                                                   addLine !---------------------------------------------------------------------------- FUNCTION geo_add_line ( Obj , startTag , endTag , uid ) RESULT ( Ans ) CLASS ( gmshGeo_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: startTag , endTag , uid INTEGER ( I4B ) :: ans ! Internal variables INTEGER ( I4B ) :: ip , n ! check IF ( . NOT . ALLOCATED ( obj % point ) ) THEN CALL Display ( \"ERROR: gmshGeo_Class.f90\" ) CALL Display ( \"       geo_add_line()\" ) CALL Display ( \"       points are not allocated\" ) STOP END IF #include \"./addcurve.inc\" IF ( uid . GT . 0 ) THEN obj % curve ( ip ) % ptr => gmshLine_Pointer ( startTag , endTag , uid ) Ans = 0 ELSE obj % curve ( ip ) % ptr => gmshLine_Pointer ( startTag , endTag , ip ) Ans = ip END IF ! append to buffer ! WRITE( obj % buffer % unitno, \"(DT)\" ) obj%curve(ip)%ptr%encodedStr( ) ! CALL Display( \"    adding Line in gmsh%model%geo%buffer\") CALL APPEND ( obj % buffer , obj % curve ( ip )% ptr % encodedStr ( ) ) END FUNCTION geo_add_line !---------------------------------------------------------------------------- !                                                               addCircleArc !---------------------------------------------------------------------------- FUNCTION geo_add_circle ( Obj , startTag , centerTag , endTag , uid , & & nx , ny , nz ) RESULT ( Ans ) CLASS ( gmshGeo_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: startTag , endTag , centerTag , uid REAL ( DFP ), OPTIONAL :: nx , ny , nz INTEGER ( I4B ) :: ans ! Internal variables INTEGER ( I4B ) :: ip , n REAL ( DFP ) :: rval ( 3 ) ! check IF ( . NOT . ALLOCATED ( obj % point ) ) THEN CALL Display ( \"ERROR: gmshGeo_Class.f90\" ) CALL Display ( \"       geo_add_line()\" ) CALL Display ( \"       points are not allocated\" ) STOP END IF #include \"./addcurve.inc\" rval = 0.0 IF ( PRESENT ( nx ) ) rval ( 1 ) = nx IF ( PRESENT ( ny ) ) rval ( 2 ) = ny IF ( PRESENT ( ny ) ) rval ( 3 ) = nz IF ( uid . GT . 0 ) THEN obj % curve ( ip ) % ptr => gmshCircle_Pointer ( startTag , & & centerTag , endTag , uid , rval ( 1 ), rval ( 2 ), rval ( 3 ) ) Ans = 0 ELSE obj % curve ( ip ) % ptr => gmshCircle_Pointer ( startTag , & & centerTag , endTag , ip , rval ( 1 ), rval ( 2 ), rval ( 3 ) ) Ans = ip END IF ! append to buffer ! CALL Display( \"    adding Circle in gmsh%model%geo%buffer\") CALL APPEND ( obj % buffer , obj % curve ( ip )% ptr % encodedStr ( ) ) END FUNCTION geo_add_circle !---------------------------------------------------------------------------- !                                                              addEllipseArc !---------------------------------------------------------------------------- FUNCTION geo_add_Ellipse ( Obj , startTag , centerTag , majorTag , endTag , uid , & & nx , ny , nz ) RESULT ( Ans ) CLASS ( gmshGeo_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: startTag , endTag , centerTag , majorTag , uid REAL ( DFP ), OPTIONAL :: nx , ny , nz INTEGER ( I4B ) :: ans ! Internal variables INTEGER ( I4B ) :: ip , n REAL ( DFP ) :: rval ( 3 ) ! check IF ( . NOT . ALLOCATED ( obj % point ) ) THEN CALL Display ( \"ERROR: gmshGeo_Class.f90\" ) CALL Display ( \"       geo_add_Ellipse()\" ) CALL Display ( \"       points are not allocated\" ) STOP END IF #include \"./addcurve.inc\" rval = 0.0 IF ( PRESENT ( nx ) ) rval ( 1 ) = nx IF ( PRESENT ( ny ) ) rval ( 2 ) = ny IF ( PRESENT ( ny ) ) rval ( 3 ) = nz IF ( uid . GT . 0 ) THEN obj % curve ( ip ) % ptr => gmshEllipse_Pointer ( startTag , & & centerTag , majorTag , endTag , uid , rval ( 1 ), rval ( 2 ), rval ( 3 ) ) Ans = 0 ELSE obj % curve ( ip ) % ptr => gmshEllipse_Pointer ( startTag , & & centerTag , majorTag , endTag , ip , rval ( 1 ), rval ( 2 ), rval ( 3 ) ) Ans = ip END IF ! append to buffer ! CALL Display( \"    adding Ellipse in gmsh%model%geo%buffer\") CALL APPEND ( obj % buffer , obj % curve ( ip )% ptr % encodedStr ( ) ) END FUNCTION geo_add_Ellipse !---------------------------------------------------------------------------- !                                                                  addSpline !---------------------------------------------------------------------------- FUNCTION geo_add_Spline ( Obj , pointTags , uid ) RESULT ( Ans ) CLASS ( gmshGeo_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: pointTags ( : ), uid INTEGER ( I4B ) :: ans ! Internal variables INTEGER ( I4B ) :: ip , n ! check IF ( . NOT . ALLOCATED ( obj % point ) ) THEN CALL Display ( \"ERROR: gmshGeo_Class.f90\" ) CALL Display ( \"       geo_add_Spline()\" ) CALL Display ( \"       points are not allocated\" ) STOP END IF #include \"./addcurve.inc\" IF ( uid . GT . 0 ) THEN obj % curve ( ip ) % ptr => gmshSpline_Pointer ( pointTags , uid ) Ans = 0 ELSE obj % curve ( ip ) % ptr => gmshSpline_Pointer ( pointTags , ip ) Ans = ip END IF ! append to buffer ! WRITE( obj % buffer % unitno, \"(DT)\" ) obj%curve(ip)%ptr%encodedStr( ) ! CALL Display( \"    adding Spline in gmsh%model%geo%buffer\") CALL APPEND ( obj % buffer , obj % curve ( ip )% ptr % encodedStr ( ) ) END FUNCTION geo_add_Spline !---------------------------------------------------------------------------- !                                                          addCompoundSpline !---------------------------------------------------------------------------- FUNCTION geo_add_CompoundSpline ( Obj , curveTags , uid , numIntervals ) & & RESULT ( Ans ) CLASS ( gmshGeo_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: curveTags ( : ), uid INTEGER ( I4B ), OPTIONAL :: numIntervals INTEGER ( I4B ) :: ans ! Internal variables INTEGER ( I4B ) :: ip , n , nI IF ( PRESENT ( numIntervals ) ) THEN nI = numIntervals ELSE nI = 5 END IF ! check IF ( . NOT . ALLOCATED ( obj % point ) ) THEN CALL Display ( \"ERROR: gmshGeo_Class.f90\" ) CALL Display ( \"       geo_add_CompoundSpline()\" ) CALL Display ( \"       points are not allocated\" ) STOP END IF #include \"./addcurve.inc\" IF ( uid . GT . 0 ) THEN obj % curve ( ip ) % ptr => gmshCompoundSpline_Pointer ( curveTags , & & uid , nI ) Ans = 0 ELSE obj % curve ( ip ) % ptr => gmshCompoundSpline_Pointer ( curveTags , & & ip , nI ) Ans = ip END IF ! append to buffer ! WRITE( obj % buffer % unitno, \"(DT)\" ) obj%curve(ip)%ptr%encodedStr( ) ! CALL Display( \"    adding CompoundSpline in gmsh%model%geo%buffer\") CALL APPEND ( obj % buffer , obj % curve ( ip )% ptr % encodedStr ( ) ) END FUNCTION geo_add_CompoundSpline !---------------------------------------------------------------------------- !                                                                  addBSpline !---------------------------------------------------------------------------- FUNCTION geo_add_BSpline ( Obj , pointTags , uid ) RESULT ( Ans ) CLASS ( gmshGeo_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: pointTags ( : ), uid INTEGER ( I4B ) :: ans ! Internal variables INTEGER ( I4B ) :: ip , n ! check IF ( . NOT . ALLOCATED ( obj % point ) ) THEN CALL Display ( \"ERROR: gmshGeo_Class.f90\" ) CALL Display ( \"       geo_add_BSpline()\" ) CALL Display ( \"       points are not allocated\" ) STOP END IF #include \"./addcurve.inc\" IF ( uid . GT . 0 ) THEN obj % curve ( ip ) % ptr => gmshBSpline_Pointer ( pointTags , uid ) Ans = 0 ELSE obj % curve ( ip ) % ptr => gmshBSpline_Pointer ( pointTags , ip ) Ans = ip END IF ! append to buffer ! WRITE( obj % buffer % unitno, \"(DT)\" ) obj%curve(ip)%ptr%encodedStr( ) ! CALL Display( \"    adding BSpline in gmsh%model%geo%buffer\") CALL APPEND ( obj % buffer , obj % curve ( ip )% ptr % encodedStr ( ) ) END FUNCTION geo_add_BSpline !---------------------------------------------------------------------------- !                                                          addCompoundBSpline !---------------------------------------------------------------------------- FUNCTION geo_add_CompoundBSpline ( Obj , curveTags , uid , numIntervals ) & & RESULT ( Ans ) CLASS ( gmshGeo_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: curveTags ( : ), uid INTEGER ( I4B ), OPTIONAL :: numIntervals INTEGER ( I4B ) :: ans ! Internal variables INTEGER ( I4B ) :: ip , n , nI IF ( PRESENT ( numIntervals ) ) THEN nI = numIntervals ELSE nI = 5 END IF ! check IF ( . NOT . ALLOCATED ( obj % point ) ) THEN CALL Display ( \"ERROR: gmshGeo_Class.f90\" ) CALL Display ( \"       geo_add_CompoundBSpline()\" ) CALL Display ( \"       points are not allocated\" ) STOP END IF #include \"./addcurve.inc\" IF ( uid . GT . 0 ) THEN obj % curve ( ip ) % ptr => gmshCompoundBSpline_Pointer ( curveTags , & & uid , nI ) Ans = 0 ELSE obj % curve ( ip ) % ptr => gmshCompoundBSpline_Pointer ( curveTags , & & ip , nI ) Ans = ip END IF ! append to buffer ! WRITE( obj % buffer % unitno, \"(DT)\" ) obj%curve(ip)%ptr%encodedStr( ) ! CALL Display( \"    adding CompoundBSpline in gmsh%model%geo%buffer\") CALL APPEND ( obj % buffer , obj % curve ( ip )% ptr % encodedStr ( ) ) END FUNCTION geo_add_CompoundBSpline !---------------------------------------------------------------------------- !                                                                  addBezier !---------------------------------------------------------------------------- FUNCTION geo_add_Bezier ( Obj , pointTags , uid ) RESULT ( Ans ) CLASS ( gmshGeo_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: pointTags ( : ), uid INTEGER ( I4B ) :: ans ! Internal variables INTEGER ( I4B ) :: ip , n ! check IF ( . NOT . ALLOCATED ( obj % point ) ) THEN CALL Display ( \"ERROR: gmshGeo_Class.f90\" ) CALL Display ( \"       geo_add_Bezier()\" ) CALL Display ( \"       points are not allocated\" ) STOP END IF #include \"./addcurve.inc\" IF ( uid . GT . 0 ) THEN obj % curve ( ip ) % ptr => gmshBezier_Pointer ( pointTags , uid ) Ans = 0 ELSE obj % curve ( ip ) % ptr => gmshBezier_Pointer ( pointTags , ip ) Ans = ip END IF ! append to buffer ! WRITE( obj % buffer % unitno, \"(DT)\" ) obj%curve(ip)%ptr%encodedStr( ) ! CALL Display( \"    adding Bezier in gmsh%model%geo%buffer\") CALL APPEND ( obj % buffer , obj % curve ( ip )% ptr % encodedStr ( ) ) END FUNCTION geo_add_Bezier !---------------------------------------------------------------------------- !                                                               addCurveLoop !---------------------------------------------------------------------------- FUNCTION geo_add_CurveLoop ( Obj , curveTags , uid ) & & RESULT ( Ans ) CLASS ( gmshGeo_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: curveTags ( : ), uid INTEGER ( I4B ) :: ans ! Internal variables INTEGER ( I4B ) :: ip , n ! check IF ( . NOT . ALLOCATED ( obj % point ) ) THEN CALL Display ( \"ERROR: gmshGeo_Class.f90\" ) CALL Display ( \"       geo_add_CurveLoop()\" ) CALL Display ( \"       points are not allocated\" ) STOP END IF ! check IF ( . NOT . ALLOCATED ( obj % curve ) ) THEN CALL Display ( \"ERROR: gmshGeo_Class.f90\" ) CALL Display ( \"       geo_add_CurveLoop()\" ) CALL Display ( \"       curve are not allocated\" ) STOP END IF #include \"./addcurveloop.inc\" IF ( uid . GT . 0 ) THEN obj % curveloop ( ip ) % ptr => gmshCurveLoop_Pointer ( curveTags , uid ) Ans = 0 ELSE obj % curveloop ( ip ) % ptr => gmshCurveLoop_Pointer ( curveTags , ip ) Ans = ip END IF ! append to buffer ! WRITE( obj % buffer % unitno, \"(DT)\" ) obj%CurveLoop(ip)%ptr%encodedStr( ) ! CALL Display( \"    adding Curveloop in gmsh%model%geo%buffer\") CALL APPEND ( obj % buffer , obj % CurveLoop ( ip )% ptr % encodedStr ( ) ) END FUNCTION geo_add_CurveLoop !---------------------------------------------------------------------------- !                                                                 addSurface !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! Add a surface filling the curve loops in wireTags. ! Currently only a single curve loop is supported; this curve loop should be ! composed by 3 or 4 curves only. If tag is positive, set the tag explicitly; ! otherwise a new tag is selected automatically. Return the tag of the surface. FUNCTION geo_add_SurfaceFilling ( Obj , wireTags , uid , sphereCenterTag ) & & RESULT ( Ans ) CLASS ( gmshGeo_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: wireTags ( : ), uid INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: sphereCenterTag INTEGER ( I4B ) :: ans ! Internal variables INTEGER ( I4B ) :: ip , n , sct IF ( PRESENT ( sphereCenterTag ) ) THEN sct = sphereCenterTag ELSE sct = - 1 END IF ! check IF ( . NOT . ALLOCATED ( obj % point ) ) THEN CALL Display ( \"ERROR: gmshGeo_Class.f90\" ) CALL Display ( \"       geo_add_SurfaceFilling()\" ) CALL Display ( \"       points are not allocated\" ) STOP END IF ! check IF ( . NOT . ALLOCATED ( obj % curve ) ) THEN CALL Display ( \"ERROR: gmshGeo_Class.f90\" ) CALL Display ( \"       geo_add_SurfaceFilling()\" ) CALL Display ( \"       curve are not allocated\" ) STOP END IF ! check IF ( . NOT . ALLOCATED ( obj % CurveLoop ) ) THEN CALL Display ( \"ERROR: gmshGeo_Class.f90\" ) CALL Display ( \"       geo_add_SurfaceFilling()\" ) CALL Display ( \"       CurveLoop are not allocated\" ) STOP END IF #include \"./addsurface.inc\" IF ( uid . GT . 0 ) THEN obj % surface ( ip ) % ptr => gmshSurface_Pointer ( wireTags , uid , sct ) Ans = 0 ELSE obj % surface ( ip ) % ptr => gmshSurface_Pointer ( wireTags , ip , sct ) Ans = ip END IF ! append to buffer ! WRITE( obj % buffer % unitno, \"(DT)\" ) obj%surface(ip)%ptr%encodedStr( ) ! CALL Display( \"    adding Surface in gmsh%model%geo%buffer\") CALL APPEND ( obj % buffer , obj % surface ( ip )% ptr % encodedStr ( ) ) END FUNCTION geo_add_SurfaceFilling !---------------------------------------------------------------------------- !                                                            addPlaneSurface !---------------------------------------------------------------------------- FUNCTION geo_add_PlaneSurface ( Obj , wireTags , uid ) & & RESULT ( Ans ) CLASS ( gmshGeo_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: wireTags ( : ), uid INTEGER ( I4B ) :: ans ! Internal variables INTEGER ( I4B ) :: ip , n ! check IF ( . NOT . ALLOCATED ( obj % point ) ) THEN CALL Display ( \"ERROR: gmshGeo_Class.f90\" ) CALL Display ( \"       geo_add_PlaneSurface()\" ) CALL Display ( \"       points are not allocated\" ) STOP END IF ! check IF ( . NOT . ALLOCATED ( obj % curve ) ) THEN CALL Display ( \"ERROR: gmshGeo_Class.f90\" ) CALL Display ( \"       geo_add_PlaneSurface()\" ) CALL Display ( \"       curve are not allocated\" ) STOP END IF ! check IF ( . NOT . ALLOCATED ( obj % CurveLoop ) ) THEN CALL Display ( \"ERROR: gmshGeo_Class.f90\" ) CALL Display ( \"       geo_add_PlaneSurface()\" ) CALL Display ( \"       CurveLoop are not allocated\" ) STOP END IF #include \"./addsurface.inc\" IF ( uid . GT . 0 ) THEN obj % surface ( ip ) % ptr => gmshPlaneSurface_Pointer ( wireTags , uid ) Ans = 0 ELSE obj % surface ( ip ) % ptr => gmshPlaneSurface_Pointer ( wireTags , ip ) Ans = ip END IF ! append to buffer ! WRITE( obj % buffer % unitno, \"(DT)\" ) obj%surface(ip)%ptr%encodedStr( ) ! CALL Display( \"    adding PlaneSurface in gmsh%model%geo%buffer\") CALL APPEND ( obj % buffer , obj % surface ( ip )% ptr % encodedStr ( ) ) END FUNCTION geo_add_PlaneSurface !---------------------------------------------------------------------------- !                                                            addSurfaceLoop !---------------------------------------------------------------------------- FUNCTION geo_add_SurfaceLoop ( Obj , surfaceTags , uid ) & & RESULT ( Ans ) CLASS ( gmshGeo_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: surfaceTags ( : ), uid INTEGER ( I4B ) :: ans ! Internal variables INTEGER ( I4B ) :: ip , n ! check IF ( . NOT . ALLOCATED ( obj % point ) ) THEN CALL Display ( \"ERROR: gmshGeo_Class.f90\" ) CALL Display ( \"       geo_add_SurfaceLoop()\" ) CALL Display ( \"       points are not allocated\" ) STOP END IF ! check IF ( . NOT . ALLOCATED ( obj % curve ) ) THEN CALL Display ( \"ERROR: gmshGeo_Class.f90\" ) CALL Display ( \"       geo_add_SurfaceLoop()\" ) CALL Display ( \"       curve are not allocated\" ) STOP END IF ! check IF ( . NOT . ALLOCATED ( obj % surface ) ) THEN CALL Display ( \"ERROR: gmshGeo_Class.f90\" ) CALL Display ( \"       geo_add_SurfaceLoop()\" ) CALL Display ( \"       surfaces are not allocated\" ) STOP END IF #include \"./addsurfaceloop.inc\" IF ( uid . GT . 0 ) THEN obj % Surfaceloop ( ip ) % ptr => gmshSurfaceLoop_Pointer ( surfaceTags , uid ) Ans = 0 ELSE obj % Surfaceloop ( ip ) % ptr => gmshSurfaceLoop_Pointer ( surfaceTags , ip ) Ans = ip END IF ! append to buffer ! WRITE( obj % buffer % unitno, \"(DT)\" ) obj%SurfaceLoop(ip)%ptr%encodedStr( ) ! CALL Display( \"    adding SurfaceLoop in gmsh%model%geo%buffer\") CALL APPEND ( obj % buffer , obj % SurfaceLoop ( ip )% ptr % encodedStr ( ) ) END FUNCTION geo_add_SurfaceLoop !---------------------------------------------------------------------------- !                                                                 addVolume !---------------------------------------------------------------------------- FUNCTION geo_add_Volume ( Obj , shellTags , uid ) & & RESULT ( Ans ) CLASS ( gmshGeo_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: shellTags ( : ), uid INTEGER ( I4B ) :: ans ! Internal variables INTEGER ( I4B ) :: ip , n ! check IF ( . NOT . ALLOCATED ( obj % point ) ) THEN CALL Display ( \"ERROR: gmshGeo_Class.f90\" ) CALL Display ( \"       geo_add_Volume()\" ) CALL Display ( \"       points are not allocated\" ) STOP END IF ! check IF ( . NOT . ALLOCATED ( obj % curve ) ) THEN CALL Display ( \"ERROR: gmshGeo_Class.f90\" ) CALL Display ( \"       geo_add_Volume()\" ) CALL Display ( \"       curve are not allocated\" ) STOP END IF ! check IF ( . NOT . ALLOCATED ( obj % surface ) ) THEN CALL Display ( \"ERROR: gmshGeo_Class.f90\" ) CALL Display ( \"       geo_add_Volume()\" ) CALL Display ( \"       surfaces are not allocated\" ) STOP END IF ! check IF ( . NOT . ALLOCATED ( obj % Surfaceloop ) ) THEN CALL Display ( \"ERROR: gmshGeo_Class.f90\" ) CALL Display ( \"       geo_add_Volume()\" ) CALL Display ( \"       surfaceLoop are not allocated\" ) STOP END IF #include \"./addvolume.inc\" IF ( uid . GT . 0 ) THEN obj % Volume ( ip ) % ptr => gmshVolume_Pointer ( shellTags , uid ) Ans = 0 ELSE obj % Volume ( ip ) % ptr => gmshVolume_Pointer ( shellTags , ip ) Ans = ip END IF ! append to buffer ! CALL Display( \"    adding Volume in gmsh%model%geo%buffer\") CALL APPEND ( obj % buffer , obj % Volume ( ip )% ptr % encodedStr ( ) ) END FUNCTION geo_add_Volume !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- END MODULE gmshGeo_Class","tags":"","loc":"sourcefile/gmshgeo_class.f90.html"},{"title":"mshFormat_Class.f90 – Fortran Program","text":"Contents Modules mshFormat_Class Source Code mshFormat_Class.f90 Source Code MODULE mshFormat_Class !! This module defines a mesh format USE BaseType USE GlobalData IMPLICIT NONE PRIVATE !---------------------------------------------------------------------------- !                                                                 mshFormat_ !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This data type stores gmsh mesh format TYPE :: mshFormat_ REAL ( DFP ) :: Version = 0.0_DFP INTEGER ( I4B ) :: FileType = 0 , DataSize = 0 LOGICAL ( LGT ) :: isASCII = . FALSE . CHARACTER ( LEN = 100 ) :: MeshFormat = \"\" CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: ReadFromFile => fmt_read_file !! Read format from a file PROCEDURE , PUBLIC , PASS ( Obj ) :: WriteToFile => fmt_write_file !! Write content to a file PROCEDURE , PUBLIC , PASS ( Obj ) :: GotoTag => fmt_goto !! Goto a tag PROCEDURE , PUBLIC , PASS ( Obj ) :: Finalize => fmt_deallocatedata !! Finalize END TYPE mshFormat_ PUBLIC :: mshFormat_ TYPE ( mshFormat_ ), PUBLIC , PARAMETER :: TypemshFormat = mshFormat_ ( ) !---------------------------------------------------------------------------- !                                                           mshFormatPointer_ !---------------------------------------------------------------------------- TYPE :: mshFormatPointer_ CLASS ( mshFormat_ ), POINTER :: Ptr => NULL () END TYPE mshFormatPointer_ PUBLIC :: mshFormatPointer_ !---------------------------------------------------------------------------- !                                                     ReadFromFile@mshFormat !---------------------------------------------------------------------------- INTERFACE !! This subroutine reads format from .msh file !> authors: Dr. Vikas Sharma ! ! This subroutine reads mesh format from .mshfile MODULE SUBROUTINE fmt_read_file ( Obj , mshFile , ierr ) CLASS ( mshFormat_ ), INTENT ( INOUT ) :: Obj TYPE ( File_ ), INTENT ( INOUT ) :: mshFile LOGICAL ( LGT ), INTENT ( INOUT ) :: ierr END SUBROUTINE fmt_read_file END INTERFACE !---------------------------------------------------------------------------- !                                                      WriteToFile@mshFormat !---------------------------------------------------------------------------- INTERFACE !! This subroutine writes mesh format to a .msh file !> authors: Dr. Vikas Sharma ! ! This subroutine writes mesh format to a .msh file MODULE SUBROUTINE fmt_write_file ( Obj , mshFile , Str , EndStr ) CLASS ( mshFormat_ ), INTENT ( INOUT ) :: Obj TYPE ( File_ ), INTENT ( INOUT ) :: mshFile CHARACTER ( LEN = * ), INTENT ( IN ), OPTIONAL :: Str , EndStr END SUBROUTINE fmt_write_file END INTERFACE !---------------------------------------------------------------------------- !                                                          Display@mshFormat !---------------------------------------------------------------------------- INTERFACE !! This subroutine display the content of [[mshFormat_]] MODULE SUBROUTINE fmt_display ( Obj , Msg , UnitNo ) CLASS ( mshFormat_ ), INTENT ( IN ) :: Obj CHARACTER ( LEN = * ), INTENT ( IN ) :: Msg INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: UnitNo END SUBROUTINE fmt_display END INTERFACE INTERFACE Display MODULE PROCEDURE fmt_display END INTERFACE Display PUBLIC :: Display !---------------------------------------------------------------------------- !                                                          GotoTag@mshFormat !---------------------------------------------------------------------------- INTERFACE !! This subroutine search the mesh format tag in the mesh file !> authors: Dr. Vikas Sharma ! ! This subroutine search the mesh format tag in the mesh file MODULE SUBROUTINE fmt_goto ( Obj , mshFile , ierr ) CLASS ( mshFormat_ ), INTENT ( IN ) :: Obj TYPE ( File_ ), INTENT ( INOUT ) :: mshFile LOGICAL ( LGT ), INTENT ( INOUT ) :: ierr END SUBROUTINE fmt_goto END INTERFACE !---------------------------------------------------------------------------- !                                                    DeallocateData@mshFormat !---------------------------------------------------------------------------- INTERFACE !! This subroutine clears the content of [[mshFormat_]] !> authors: Dr. Vikas Sharma ! ! This subroutine clears the content of [[mshFormat_]] MODULE SUBROUTINE fmt_deallocatedata ( Obj ) CLASS ( mshFormat_ ), INTENT ( INOUT ) :: Obj END SUBROUTINE fmt_deallocatedata END INTERFACE INTERFACE DeallocateData MODULE PROCEDURE fmt_deallocatedata END INTERFACE DeallocateData PUBLIC :: DeallocateData !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- END MODULE mshFormat_Class","tags":"","loc":"sourcefile/mshformat_class.f90.html"},{"title":"mshElements_Class.f90 – Fortran Program","text":"Contents Modules mshElements_Class Source Code mshElements_Class.f90 Source Code MODULE mshElements_Class !! This module defines a class to handle elements in mesh file USE BaseType USE GlobalData USE mshFormat_Class IMPLICIT NONE PRIVATE !---------------------------------------------------------------------------- !                                                              mshElements_ !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This class handles the elements present in the mesh file TYPE :: mshElements_ INTEGER ( I4B ) :: numElements = 0 INTEGER ( I4B ) :: numEntityBlocks = 0 INTEGER ( I4B ) :: minElementTag = 0 INTEGER ( I4B ) :: maxElementTag = 0 LOGICAL ( LGT ) :: isSparse = . FALSE . CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: Finalize => el_DeallocateData !! deallocate data PROCEDURE , PUBLIC , PASS ( Obj ) :: GotoTag => el_goto !! go to the tag PROCEDURE , PUBLIC , PASS ( Obj ) :: ReadFromFile => el_read_file !! Read data form file PROCEDURE , PUBLIC , PASS ( Obj ) :: WriteToFile => el_write_file !! Write data to file PROCEDURE , PUBLIC , PASS ( Obj ) :: ReadElementLine => el_read_elem_line !! Read element line PROCEDURE , PUBLIC , PASS ( Obj ) :: TotalElements => el_telements_1 !! total elements END TYPE mshElements_ !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- PUBLIC :: mshElements_ TYPE ( mshElements_ ), PUBLIC , PARAMETER :: TypemshElements = mshElements_ ( ) !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- TYPE :: mshElementsPointer_ CLASS ( mshElements_ ), POINTER :: Ptr => NULL () END TYPE mshElementsPointer_ PUBLIC :: mshElementsPointer_ !---------------------------------------------------------------------------- !                                                         GotoTag@mshElement !---------------------------------------------------------------------------- INTERFACE !! This subroutine go the location of element in mesh file !> authors: Dr. Vikas Sharma ! ! This subroutine go the location of element in mesh file MODULE SUBROUTINE el_goto ( Obj , mshFile , ierr ) CLASS ( mshElements_ ), INTENT ( IN ) :: Obj TYPE ( File_ ), INTENT ( INOUT ) :: mshFile LOGICAL ( LGT ), INTENT ( INOUT ) :: ierr END SUBROUTINE el_goto END INTERFACE !---------------------------------------------------------------------------- !                                                    ReadFromFile@mshElement !---------------------------------------------------------------------------- INTERFACE ! This subroutine reads data from a file !> authors: Dr. Vikas Sharma ! ! This subroutine reads data from a file MODULE SUBROUTINE el_read_file ( Obj , mshFile , mshFormat , ierr ) CLASS ( mshElements_ ), INTENT ( INOUT ) :: Obj TYPE ( File_ ), INTENT ( INOUT ) :: mshFile TYPE ( mshFormat_ ), INTENT ( INOUT ) :: mshFormat LOGICAL ( LGT ), INTENT ( INOUT ) :: ierr END SUBROUTINE el_read_file END INTERFACE !---------------------------------------------------------------------------- !                                                      WriteToFile@mshElement !---------------------------------------------------------------------------- INTERFACE ! This subroutine writes the data to a file !> authors: Dr. Vikas Sharma ! ! This subroutine writes the data to a file MODULE SUBROUTINE el_write_file ( Obj , mshFile , mshFormat , Str , EndStr ) CLASS ( mshElements_ ), INTENT ( INOUT ) :: Obj TYPE ( File_ ), INTENT ( INOUT ) :: mshFile CHARACTER ( LEN = * ), INTENT ( IN ), OPTIONAL :: Str , EndStr TYPE ( mshFormat_ ), INTENT ( INOUT ) :: mshFormat END SUBROUTINE el_write_file END INTERFACE !---------------------------------------------------------------------------- !                                                        Display@mshElements !---------------------------------------------------------------------------- INTERFACE ! This data displays the content of [[mshElements_]] !> authors: Dr. Vikas Sharma ! ! This data displays the content of [[mshElements_]] MODULE SUBROUTINE el_display ( Obj , Msg , UnitNo ) CLASS ( mshElements_ ), INTENT ( IN ) :: Obj CHARACTER ( LEN = * ), INTENT ( IN ) :: Msg INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: UnitNo END SUBROUTINE el_display END INTERFACE INTERFACE Display MODULE PROCEDURE el_display END INTERFACE Display PUBLIC :: Display !---------------------------------------------------------------------------- !                                                ReadElementLine@mshElements !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE el_read_elem_line ( Obj , ElemNum , ElemType , PhysicalId , & & GeometryId , MeshPartitionTags , Nptrs , mshFile ) CLASS ( mshElements_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( INOUT ), OPTIONAL :: ElemNum , ElemType , & & PhysicalId , GeometryId INTEGER ( I4B ), ALLOCATABLE , INTENT ( INOUT ), OPTIONAL :: & & MeshPartitionTags (:), Nptrs (:) TYPE ( File_ ), INTENT ( INOUT ) :: mshFile END SUBROUTINE el_read_elem_line END INTERFACE !---------------------------------------------------------------------------- !                                                  TotalElements@mshElements !---------------------------------------------------------------------------- INTERFACE ! This function returns total number of elements !> authors: Dr. Vikas Sharma ! ! This function returns total number of elements MODULE PURE FUNCTION el_telements_1 ( Obj ) RESULT ( Ans ) CLASS ( mshElements_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ) :: Ans END FUNCTION el_telements_1 END INTERFACE !---------------------------------------------------------------------------- !                                                 DeallocateData@mshElements !---------------------------------------------------------------------------- INTERFACE ! This subroutine deallocates the data from obj !> authors: Dr. Vikas Sharma ! ! This subroutine deallocates the data from obj MODULE SUBROUTINE el_deallocatedata ( Obj ) CLASS ( mshElements_ ), INTENT ( INOUT ) :: Obj END SUBROUTINE el_deallocatedata END INTERFACE INTERFACE DeallocateData MODULE PROCEDURE el_deallocatedata END INTERFACE DeallocateData PUBLIC :: DeallocateData END MODULE mshElements_Class","tags":"","loc":"sourcefile/mshelements_class.f90.html"},{"title":"mshPhysicalNames_Class.f90 – Fortran Program","text":"Contents Modules mshPhysicalNames_Class Source Code mshPhysicalNames_Class.f90 Source Code MODULE mshPhysicalNames_Class !! This module defines a data type for handling gmsh physical names USE BaseType USE GlobalData IMPLICIT NONE PRIVATE !---------------------------------------------------------------------------- !                                                          mshPhysicalNames_ !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This data type contains the Physical Names generate by gmsh TYPE :: mshPhysicalNames_ INTEGER ( I4B ), ALLOCATABLE :: NSD ( : ) !! spatial dimension of each physical group INTEGER ( I4B ), ALLOCATABLE :: Tag ( : ) !! Unit ID of each physical group INTEGER ( I4B ), ALLOCATABLE :: numElements ( : ) !! Number of elements in each physical group INTEGER ( I4B ), ALLOCATABLE :: numNodes ( : ) !! Number of nodes in each physical nodes TYPE ( IntVector_ ), ALLOCATABLE :: Entities ( : ) !! Tags of Entities in each physical group TYPE ( String ), ALLOCATABLE :: PhysicalName ( : ) !! Physical name of each physical group CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: Finalize => pn_deallocatedata !! To deallocate data PROCEDURE , PUBLIC , PASS ( Obj ) :: GotoTag => pn_goto !! Search tag for physical group in mesh file PROCEDURE , PUBLIC , PASS ( Obj ) :: ReadFromFile => pn_read_file !! Read contents from mesh file PROCEDURE , PUBLIC , PASS ( Obj ) :: WriteToFile => pn_write_file !! Write contents to a mesh file PROCEDURE , PUBLIC , PASS ( Obj ) :: SIZE => pn_get_size !! Returns total number of physical groups PROCEDURE , PUBLIC , PASS ( Obj ) :: TotalPhysicalPoints => pn_size_point !! Returns total number of physical points in mesh PROCEDURE , PUBLIC , PASS ( Obj ) :: TotalPhysicalCurves => pn_size_Curve !! Returns total number of physical curves PROCEDURE , PUBLIC , PASS ( Obj ) :: TotalPhysicalSurfaces => pn_size_Surface !! Returns total number of physical surface PROCEDURE , PUBLIC , PASS ( Obj ) :: TotalPhysicalVolumes => pn_size_Volume !! Returns total number of physical volumes GENERIC , PUBLIC :: & & getIndex => & & pn_index_a , & & pn_index_b , & & pn_index_c , & & pn_index_d PROCEDURE , PRIVATE , PASS ( Obj ) :: pn_index_a !! Returns the index of a physical group PROCEDURE , PRIVATE , PASS ( Obj ) :: pn_index_b !! Returns the index of a physical group PROCEDURE , PRIVATE , PASS ( Obj ) :: pn_index_c !! Returns the index of a physical group PROCEDURE , PRIVATE , PASS ( Obj ) :: pn_index_d !! Returns the index of a physical group PROCEDURE , PUBLIC , PASS ( Obj ) :: PhysicalPointNames => pn_point_names !! Returns the names of physical points PROCEDURE , PUBLIC , PASS ( Obj ) :: PhysicalCurveNames => pn_Curve_names !! Returns names of a physical curves PROCEDURE , PUBLIC , PASS ( Obj ) :: PhysicalSurfaceNames => pn_Surface_names !! Returns names of Physical surface PROCEDURE , PUBLIC , PASS ( Obj ) :: PhysicalVolumeNames => pn_Volume_names !! Returns names of physical volumes PROCEDURE , PUBLIC , PASS ( Obj ) :: PhysicalPointTags => pn_Point_tags !! Returns tags of physical points PROCEDURE , PUBLIC , PASS ( Obj ) :: PhysicalCurveTags => pn_Curve_tags !! Returns tags of physical points PROCEDURE , PUBLIC , PASS ( Obj ) :: PhysicalSurfaceTags => pn_Surface_tags !! Returns tags of physical surfaces PROCEDURE , PUBLIC , PASS ( Obj ) :: PhysicalVolumeTags => pn_Volume_tags !! Returns tags of physical volumes PROCEDURE , PUBLIC , PASS ( Obj ) :: WhoAmI => pn_who_am_i !! Enquire about \"volume, surface, curve, point' GENERIC , PUBLIC :: IndexOfPhysicalPoint => pn_index_point , & & pn_index_point_2 PROCEDURE , PRIVATE , PASS ( Obj ) :: pn_index_point !! Return index of physical points PROCEDURE , PRIVATE , PASS ( Obj ) :: pn_index_point_2 !! Return index of physical points GENERIC , PUBLIC :: IndexOfPhysicalCurve => & & pn_index_Curve , & & pn_index_Curve_2 PROCEDURE , PRIVATE , PASS ( Obj ) :: pn_index_Curve !! Return index of physical curve PROCEDURE , PRIVATE , PASS ( Obj ) :: pn_index_Curve_2 !! Return index of physical curve GENERIC , PUBLIC :: IndexOfPhysicalSurface => & & pn_index_Surface , & & pn_index_Surface_2 PROCEDURE , PRIVATE , PASS ( Obj ) :: pn_index_Surface !! Return index of physical surface PROCEDURE , PRIVATE , PASS ( Obj ) :: pn_index_Surface_2 !! Return index of physical surface GENERIC , PUBLIC :: IndexOfPhysicalVolume => pn_index_Volume , & & pn_index_Volume_2 PROCEDURE , PRIVATE , PASS ( Obj ) :: pn_index_Volume PROCEDURE , PRIVATE , PASS ( Obj ) :: pn_index_Volume_2 PROCEDURE , PUBLIC , PASS ( Obj ) :: OutputFileName => pn_output_file END TYPE mshPhysicalNames_ !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- PUBLIC :: mshPhysicalNames_ TYPE ( mshPhysicalNames_ ), PARAMETER , PUBLIC :: & & TypeMSHPhysicalNames = & & mshPhysicalNames_ ( & & NSD = NULL ( ), & & Tag = NULL ( ), & & numElements = NULL ( ), & & numNodes = NULL ( ), & & PhysicalName = NULL ( ), & & Entities = NULL ( ) ) !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- TYPE :: mshPhysicalNamesPointer_ CLASS ( mshPhysicalNames_ ), POINTER :: Ptr => NULL ( ) END TYPE mshPhysicalNamesPointer_ PUBLIC :: mshPhysicalNamesPointer_ !---------------------------------------------------------------------------- !                                                  GotoTag@mshPhysicalNames !---------------------------------------------------------------------------- INTERFACE !! This suboutine find the tag for Physical groups in mesh !> authors: Dr. Vikas Sharma ! ! This suboutine find the tag for Physical groups in mesh MODULE SUBROUTINE pn_goto ( Obj , mshFile , ierr ) CLASS ( mshPhysicalNames_ ), INTENT ( IN ) :: Obj TYPE ( File_ ), INTENT ( INOUT ) :: mshFile LOGICAL ( LGT ), INTENT ( INOUT ) :: ierr END SUBROUTINE pn_goto END INTERFACE !---------------------------------------------------------------------------- !                                              ReadFromFile@mshPhysicalNames !---------------------------------------------------------------------------- INTERFACE !! This subroutine reads physical groupds info from mesh file !> authors: Dr. Vikas Sharma ! ! This subroutine reads physical groupds info from mesh file MODULE SUBROUTINE pn_read_file ( Obj , mshFile , ierr ) CLASS ( mshPhysicalNames_ ), INTENT ( INOUT ) :: Obj TYPE ( File_ ), INTENT ( INOUT ) :: mshFile LOGICAL ( LGT ), INTENT ( INOUT ) :: ierr END SUBROUTINE pn_read_file END INTERFACE !---------------------------------------------------------------------------- !                                               WriteToFile@mshPhysicalNames !---------------------------------------------------------------------------- INTERFACE !! This subroutine writes physical groupds info in mesh file !> authors: Dr. Vikas Sharma ! ! This subroutine writes physical groupds info in mesh file MODULE SUBROUTINE pn_write_file ( Obj , mshFile , Str , EndStr ) CLASS ( mshPhysicalNames_ ), INTENT ( INOUT ) :: Obj TYPE ( File_ ), INTENT ( INOUT ) :: mshFile CHARACTER ( LEN = * ), OPTIONAL , INTENT ( IN ) :: Str , EndStr END SUBROUTINE pn_write_file END INTERFACE !---------------------------------------------------------------------------- !                                                   Display@mshPhysicalNames !---------------------------------------------------------------------------- INTERFACE !! This subroutine displays the content of [[mshphysicalnames_]] !> authors: Dr. Vikas Sharma ! ! This subroutine displays the content of [[mshphysicalnames_]] MODULE SUBROUTINE pn_display ( Obj , Msg , UnitNo ) CLASS ( mshPhysicalNames_ ), INTENT ( IN ) :: Obj CHARACTER ( LEN = * ), INTENT ( IN ) :: Msg INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: UnitNo END SUBROUTINE pn_display END INTERFACE INTERFACE Display MODULE PROCEDURE pn_display END INTERFACE Display PUBLIC :: Display !---------------------------------------------------------------------------- !                                                     Size@mshPhysicalNames !---------------------------------------------------------------------------- INTERFACE !! This function returns total number of physical entities !> authors: Dr. Vikas Sharma ! ! This function returns total number of physical entities MODULE PURE FUNCTION pn_get_size ( Obj ) RESULT ( Ans ) CLASS ( mshPhysicalNames_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ) :: Ans END FUNCTION pn_get_size END INTERFACE !---------------------------------------------------------------------------- !                                       TotalPhysicalPoints@mshPhysicalNames !---------------------------------------------------------------------------- INTERFACE !! This function returns total number of physical points !> authors: Dr. Vikas Sharma ! ! This function returns total number of physical points MODULE PURE FUNCTION pn_size_point ( Obj ) RESULT ( Ans ) CLASS ( mshPhysicalNames_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ) :: Ans END FUNCTION pn_size_point END INTERFACE !---------------------------------------------------------------------------- !                                       TotalPhysicalCurves@mshPhysicalNames !---------------------------------------------------------------------------- INTERFACE !! This function returns total number of physical curves !> authors: Dr. Vikas Sharma ! ! This function returns total number of physical curves MODULE PURE FUNCTION pn_size_Curve ( Obj ) RESULT ( Ans ) CLASS ( mshPhysicalNames_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ) :: Ans END FUNCTION pn_size_Curve END INTERFACE !---------------------------------------------------------------------------- !                                     TotalPhysicalSurfaces@mshPhysicalNames !---------------------------------------------------------------------------- INTERFACE !! This function returns total number of physical surfaces !> authors: Dr. Vikas Sharma ! ! This function returns total number of physical surfaces MODULE PURE FUNCTION pn_size_Surface ( Obj ) RESULT ( Ans ) CLASS ( mshPhysicalNames_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ) :: Ans END FUNCTION pn_size_Surface END INTERFACE !---------------------------------------------------------------------------- !                                      TotalPhysicalVolumes@mshPhysicalNames !---------------------------------------------------------------------------- INTERFACE !! This function returns total number of physical volumes !> authors: Dr. Vikas Sharma ! ! This function returns total number of physical volumes MODULE PURE FUNCTION pn_size_Volume ( Obj ) RESULT ( Ans ) CLASS ( mshPhysicalNames_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ) :: Ans END FUNCTION pn_size_Volume END INTERFACE !---------------------------------------------------------------------------- !                                                 getIndex@mshPhysicalNames !---------------------------------------------------------------------------- INTERFACE !! This function returns index of a given physical name !> authors: Dr. Vikas Sharma ! ! This function returns index of a given physical name MODULE PURE FUNCTION pn_index_a ( Obj , Name ) RESULT ( Ans ) CLASS ( mshPhysicalNames_ ), INTENT ( IN ) :: Obj CHARACTER ( LEN = * ), INTENT ( IN ) :: Name INTEGER ( I4B ) :: Ans END FUNCTION pn_index_a END INTERFACE !---------------------------------------------------------------------------- !                                                                 getIndex !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION pn_index_b ( Obj , Name ) RESULT ( Ans ) CLASS ( mshPhysicalNames_ ), INTENT ( IN ) :: Obj TYPE ( String ), INTENT ( IN ) :: Name ( : ) INTEGER ( I4B ) :: Ans ( SIZE ( Name ) ) END FUNCTION pn_index_b END INTERFACE !---------------------------------------------------------------------------- !                                                                 getIndex !---------------------------------------------------------------------------- INTERFACE !! This function returns index of a given physical name !> authors: Dr. Vikas Sharma ! ! This function returns index of a given physical name ! ! - `XiDimTag( 1 )` denotes the XiDImension of physical entity !     - 0 => point !     - 1 => line !     - 2 => surface !     - 3 => volume ! - `XiDimTag( 2 )` denotes the Physical Tag of physical entity MODULE PURE FUNCTION pn_index_c ( Obj , XiDimTag ) RESULT ( Ans ) CLASS ( mshPhysicalNames_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: XiDimTag ( 2 ) INTEGER ( I4B ) :: Ans END FUNCTION pn_index_c END INTERFACE !---------------------------------------------------------------------------- !                                                                 getIndex !---------------------------------------------------------------------------- INTERFACE !! This function returns index of a given physical name !> authors: Dr. Vikas Sharma ! ! This function returns index of a given physical name ! ! - `XiDim` denotes the XiDImension of physical entity ! - `XiDim` = 0 => returns indices of points ! - `XiDim` = 1 => returns indices of lines ! - `XiDim` = 2 => returns indices of surfaces ! - `XiDim` = 3 => returns indices of volumes MODULE PURE FUNCTION pn_index_d ( Obj , XiDimTag ) RESULT ( Ans ) CLASS ( mshPhysicalNames_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: XiDimTag INTEGER ( I4B ), ALLOCATABLE :: Ans ( : ) END FUNCTION pn_index_d END INTERFACE !---------------------------------------------------------------------------- !                                       PhysicalPointNames@mshPhysicalNames !---------------------------------------------------------------------------- INTERFACE !! This function returns the names of physical poins !> authors: Dr. Vikas Sharma ! ! This subroutine returns the names of physical points MODULE PURE FUNCTION pn_point_names ( Obj ) RESULT ( Ans ) CLASS ( mshPhysicalNames_ ), INTENT ( IN ) :: Obj TYPE ( String ), ALLOCATABLE :: Ans ( : ) END FUNCTION pn_point_names END INTERFACE !---------------------------------------------------------------------------- !                                       PhysicalCurveNames@mshPhysicalNames !---------------------------------------------------------------------------- INTERFACE !! This function returns the names of physical curves !> authors: Dr. Vikas Sharma ! ! This subroutine returns the names of physical curves MODULE PURE FUNCTION pn_Curve_names ( Obj ) RESULT ( Ans ) CLASS ( mshPhysicalNames_ ), INTENT ( IN ) :: Obj TYPE ( String ), ALLOCATABLE :: Ans ( : ) END FUNCTION pn_Curve_names END INTERFACE !---------------------------------------------------------------------------- !                                      PhysicalSurfaceNames@mshPhysicalNames !---------------------------------------------------------------------------- INTERFACE !! This function returns the names of physical surfaces !> authors: Dr. Vikas Sharma ! ! This subroutine returns the names of physical surfaces MODULE PURE FUNCTION pn_Surface_names ( Obj ) RESULT ( Ans ) CLASS ( mshPhysicalNames_ ), INTENT ( IN ) :: Obj TYPE ( String ), ALLOCATABLE :: Ans ( : ) END FUNCTION pn_Surface_names END INTERFACE !---------------------------------------------------------------------------- !                                       PhysicalVolumeNames@mshPhysicalNames !---------------------------------------------------------------------------- INTERFACE !! This function returns the names of physical volumes !> authors: Dr. Vikas Sharma ! ! This subroutine returns the names of physical volumes MODULE PURE FUNCTION pn_Volume_names ( Obj ) RESULT ( Ans ) CLASS ( mshPhysicalNames_ ), INTENT ( IN ) :: Obj TYPE ( String ), ALLOCATABLE :: Ans ( : ) END FUNCTION pn_Volume_names END INTERFACE !---------------------------------------------------------------------------- !                                         PhysicalPointTags@mshPhysicalNames !---------------------------------------------------------------------------- INTERFACE !! This function returns the physical tags of all physical points !> authors: Dr. Vikas Sharma ! ! This function returns the physical tags of all physical points MODULE PURE FUNCTION pn_Point_tags ( Obj ) RESULT ( Ans ) CLASS ( mshPhysicalNames_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), ALLOCATABLE :: Ans ( : ) END FUNCTION pn_Point_tags END INTERFACE !---------------------------------------------------------------------------- !                                        PhysicalCurveTags@mshPhysicalNames !---------------------------------------------------------------------------- INTERFACE !! This function returns the physical tags of all physical curves !> authors: Dr. Vikas Sharma ! ! This function returns the physical tags of all physical curves MODULE PURE FUNCTION pn_Curve_tags ( Obj ) RESULT ( Ans ) CLASS ( mshPhysicalNames_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), ALLOCATABLE :: Ans ( : ) END FUNCTION pn_Curve_tags END INTERFACE !---------------------------------------------------------------------------- !                                       PhysicalSurfaceTags@mshPhysicalNames !---------------------------------------------------------------------------- INTERFACE !! This function returns the physical tags of all physical surfaces !> authors: Dr. Vikas Sharma ! ! This function returns the physical tags of all physical surfaces MODULE PURE FUNCTION pn_Surface_tags ( Obj ) RESULT ( Ans ) CLASS ( mshPhysicalNames_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), ALLOCATABLE :: Ans ( : ) END FUNCTION pn_Surface_tags END INTERFACE !---------------------------------------------------------------------------- !                                       PhysicalVolumeTags@mshPhysicalNames !---------------------------------------------------------------------------- INTERFACE !! This function returns the physical tags of all physical volumes !> authors: Dr. Vikas Sharma ! ! This function returns the physical tags of all physical volumes MODULE PURE FUNCTION pn_Volume_tags ( Obj ) RESULT ( Ans ) CLASS ( mshPhysicalNames_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), ALLOCATABLE :: Ans ( : ) END FUNCTION pn_Volume_tags END INTERFACE !---------------------------------------------------------------------------- !                                                    WhoAmI@mshPhysicalNames !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION pn_who_am_i ( Obj , I ) RESULT ( Ans ) CLASS ( mshPhysicalNames_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: I TYPE ( String ) :: Ans END FUNCTION pn_who_am_i END INTERFACE !---------------------------------------------------------------------------- !                                      IndexOfPhysicalPoint@mshPhysicalNames !---------------------------------------------------------------------------- ! return the index of physical point from its physical id INTERFACE MODULE PURE FUNCTION pn_index_point ( Obj , Tag ) RESULT ( Ans ) CLASS ( mshPhysicalNames_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Tag INTEGER ( I4B ) :: Ans END FUNCTION pn_index_point END INTERFACE INTERFACE MODULE PURE FUNCTION pn_index_point_2 ( Obj , Tag ) RESULT ( Ans ) CLASS ( mshPhysicalNames_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Tag ( : ) INTEGER ( I4B ) :: Ans ( SIZE ( Tag ) ) END FUNCTION pn_index_point_2 END INTERFACE !---------------------------------------------------------------------------- !                                      IndexOfPhysicalCurve@mshPhysicalNames !---------------------------------------------------------------------------- INTERFACE !! This function return the index of physical Curve from its physical id !> authors: Dr. Vikas Sharma ! ! This function returns the index of physical Curve from its physical id MODULE PURE FUNCTION pn_index_Curve ( Obj , Tag ) RESULT ( Ans ) CLASS ( mshPhysicalNames_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Tag INTEGER ( I4B ) :: Ans END FUNCTION pn_index_Curve END INTERFACE !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- INTERFACE !! This function return the index of physical Curve from its physical id !> authors: Dr. Vikas Sharma ! ! This function returns the index of physical Curve from its physical id MODULE PURE FUNCTION pn_index_Curve_2 ( Obj , Tag ) RESULT ( Ans ) CLASS ( mshPhysicalNames_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Tag ( : ) INTEGER ( I4B ) :: Ans ( SIZE ( Tag ) ) END FUNCTION pn_index_Curve_2 END INTERFACE !---------------------------------------------------------------------------- !                                    IndexOfPhysicalSurface@mshPhysicalNames !---------------------------------------------------------------------------- INTERFACE !! This function return the index of physical Surface from its physical id !> authors: Dr. Vikas Sharma ! ! This function returns the index of physical Surface from its physical id MODULE PURE FUNCTION pn_index_Surface ( Obj , Tag ) RESULT ( Ans ) CLASS ( mshPhysicalNames_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Tag INTEGER ( I4B ) :: Ans END FUNCTION pn_index_Surface END INTERFACE !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION pn_index_Surface_2 ( Obj , Tag ) RESULT ( Ans ) CLASS ( mshPhysicalNames_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Tag ( : ) INTEGER ( I4B ) :: Ans ( SIZE ( Tag ) ) END FUNCTION pn_index_Surface_2 END INTERFACE !---------------------------------------------------------------------------- !                                    IndexOfPhysicalVolume@mshPhysicalNames !---------------------------------------------------------------------------- INTERFACE !! This function return the index of physical Volume from its physical id !> authors: Dr. Vikas Sharma ! ! This function returns the index of physical Volume from its physical id MODULE PURE FUNCTION pn_index_Volume ( Obj , Tag ) RESULT ( Ans ) CLASS ( mshPhysicalNames_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Tag INTEGER ( I4B ) :: Ans END FUNCTION pn_index_Volume END INTERFACE !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- INTERFACE !! This function return the index of physical Volume from its physical id !> authors: Dr. Vikas Sharma ! ! This function returns the index of physical Volume from its physical id MODULE PURE FUNCTION pn_index_Volume_2 ( Obj , Tag ) RESULT ( Ans ) CLASS ( mshPhysicalNames_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Tag ( : ) INTEGER ( I4B ) :: Ans ( SIZE ( Tag ) ) END FUNCTION pn_index_Volume_2 END INTERFACE !---------------------------------------------------------------------------- !                                            OutputFileName@mshPhysicalNames !---------------------------------------------------------------------------- INTERFACE !! This function retunrns the name of output file MODULE PURE FUNCTION pn_output_file ( Obj , mshFile , indx ) RESULT ( Ans ) CLASS ( mshPhysicalNames_ ), INTENT ( IN ) :: Obj TYPE ( File_ ), INTENT ( IN ) :: mshFile INTEGER ( I4B ), INTENT ( IN ) :: indx TYPE ( String ) :: Ans END FUNCTION pn_output_file END INTERFACE !---------------------------------------------------------------------------- !                                             DeallocateData@mshPhysicalNames !---------------------------------------------------------------------------- INTERFACE !! This subroutine deallocates the data stored in [[mshPhysicalNames_]] !> authors: Dr. Vikas Sharma ! ! This subroutine deallocates the data stored in [[mshPhysicalNames_]] MODULE SUBROUTINE pn_deallocatedata ( Obj ) CLASS ( mshPhysicalNames_ ), INTENT ( INOUT ) :: Obj END SUBROUTINE pn_deallocatedata END INTERFACE INTERFACE DeallocateData MODULE PROCEDURE pn_deallocatedata END INTERFACE DeallocateData PUBLIC :: DeallocateData END MODULE mshPhysicalNames_Class","tags":"","loc":"sourcefile/mshphysicalnames_class.f90.html"},{"title":"mshEntity_Class.f90 – Fortran Program","text":"Contents Modules mshEntity_Class Source Code mshEntity_Class.f90 Source Code MODULE mshEntity_Class !! This module contains a class to handle entities in mesh file USE BaseType USE GlobalData IMPLICIT NONE PRIVATE !---------------------------------------------------------------------------- !                                                                 mshEntity_ !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This class handles the mesh entities defined in msh file TYPE :: mshEntity_ INTEGER ( I4B ) :: uid = 0 !! unique id of entity INTEGER ( I4B ) :: XiDim = 0 !! for point=0, curve=1, surface = 2, volume = 3 INTEGER ( I4B ) :: ElemType = 0 !! element type in meshing INTEGER ( I4B ), ALLOCATABLE :: PhysicalTag ( : ) !! Physical tags associated INTEGER ( I4B ), ALLOCATABLE :: NodeNumber ( : ) !! node numbers in mesh INTEGER ( I4B ), ALLOCATABLE :: ElemNumber ( : ) !! element numbers in mesh INTEGER ( I4B ), ALLOCATABLE :: Nptrs ( :, : ) !! connectivity INTEGER ( I4B ), ALLOCATABLE :: BoundingEntity ( : ) !! tag of bounding entity REAL ( DFP ) :: minX = 0.0_DFP !! bounding box of entity REAL ( DFP ) :: minY = 0.0_DFP !! bounding box of entity REAL ( DFP ) :: minZ = 0.0_DFP !! bounding box of entity REAL ( DFP ) :: maxX = 0.0_DFP !! bounding box of entity REAL ( DFP ) :: maxY = 0.0_DFP !! bounding box of entity REAL ( DFP ) :: maxZ = 0.0_DFP !! bounding box of entity REAL ( DFP ) :: X = 0.0_DFP !! used only for point entity REAL ( DFP ) :: Y = 0.0_DFP !! used only for point entity REAL ( DFP ) :: Z = 0.0_DFP !! used only for point entity REAL ( DFP ), ALLOCATABLE :: NodeCoord ( :, : ) !! nodal coordinates in xiJ format CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: Finalize => ent_deallocateData !! To deallocate data PROCEDURE , PUBLIC , PASS ( Obj ) :: GotoTag => ent_goto !! To find tag PROCEDURE , PUBLIC , PASS ( Obj ) :: ReadPointEntity => ent_read_point !! Read the entry from file for point PROCEDURE , PUBLIC , PASS ( Obj ) :: ReadCurveEntity => ent_Read_Curve !! Read the entry from file for curve PROCEDURE , PUBLIC , PASS ( Obj ) :: ReadSurfaceEntity => ent_Read_Surface !! Read the entry from file for surface PROCEDURE , PUBLIC , PASS ( Obj ) :: ReadVolumeEntity => ent_Read_Volume !! Read the entry from file for volume PROCEDURE , PUBLIC , PASS ( Obj ) :: TotalPhysicalTags => ent_tphysicaltag !! Return total physical tags associated PROCEDURE , PUBLIC , PASS ( Obj ) :: TotalBoundingTags => ent_tboundingtag !! Returns the total bounding tags PROCEDURE , PUBLIC , PASS ( Obj ) :: TotalElements => ent_telements !! Returns the total elements PROCEDURE , PUBLIC , PASS ( Obj ) :: WriteToFile => ent_write_file !! Write data to a file END TYPE mshEntity_ !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- PUBLIC :: mshEntity_ TYPE ( mshEntity_ ), PUBLIC , PARAMETER :: & & TypeMshEntity = & & mshEntity_ ( & & PhysicalTag = NULL ( ), & & NodeNumber = NULL ( ), & & ElemNumber = NULL ( ), & & Nptrs = NULL ( ), & & NodeCoord = NULL ( ), & & BoundingEntity = NULL ( ) ) !---------------------------------------------------------------------------- !                                                          mshEntityPointer_ !---------------------------------------------------------------------------- TYPE :: mshEntityPointer_ CLASS ( mshEntity_ ), POINTER :: Ptr => NULL ( ) END TYPE mshEntityPointer_ PUBLIC :: mshEntityPointer_ !---------------------------------------------------------------------------- !                                                         GotoTag@mshEntity !---------------------------------------------------------------------------- INTERFACE !! This subroutine finds the tag in the mesh file MODULE SUBROUTINE ent_goto ( Obj , mshFile , ierr ) CLASS ( mshEntity_ ), INTENT ( IN ) :: Obj TYPE ( File_ ), INTENT ( INOUT ) :: mshFile LOGICAL ( LGT ), INTENT ( INOUT ) :: ierr END SUBROUTINE ent_goto END INTERFACE !---------------------------------------------------------------------------- !                                                  ReadPointEntity@mshEntity !---------------------------------------------------------------------------- INTERFACE !! This subroutine reads the entry for point entity !> authors: Dr. Vikas Sharma ! ! This subroutine reads the entry for point entity MODULE SUBROUTINE ent_read_point ( Obj , mshFile , readTag , ierr ) CLASS ( mshEntity_ ), INTENT ( INOUT ) :: Obj TYPE ( File_ ), INTENT ( INOUT ) :: mshFile LOGICAL ( LGT ), INTENT ( INOUT ) :: ierr LOGICAL ( LGT ), INTENT ( IN ) :: readTag END SUBROUTINE ent_read_point END INTERFACE !---------------------------------------------------------------------------- !                                                  ReadCurveEntity@mshEntity !---------------------------------------------------------------------------- INTERFACE !! This subroutine reads the entry for curve entity !> authors: Dr. Vikas Sharma ! ! This subroutine reads the entry for curve entity MODULE SUBROUTINE ent_read_Curve ( Obj , mshFile , readTag , ierr ) CLASS ( mshEntity_ ), INTENT ( INOUT ) :: Obj TYPE ( File_ ), INTENT ( INOUT ) :: mshFile LOGICAL ( LGT ), INTENT ( INOUT ) :: ierr LOGICAL ( LGT ), INTENT ( IN ) :: readTag END SUBROUTINE ent_read_Curve END INTERFACE !---------------------------------------------------------------------------- !                                               ReadSurfaceEntity@mshEntity !---------------------------------------------------------------------------- INTERFACE !! This subroutine reads the entry for surface entity !> authors: Dr. Vikas Sharma ! ! This subroutine reads the entry for surface entity MODULE SUBROUTINE ent_read_Surface ( Obj , mshFile , readTag , ierr ) CLASS ( mshEntity_ ), INTENT ( INOUT ) :: Obj TYPE ( File_ ), INTENT ( INOUT ) :: mshFile LOGICAL ( LGT ), INTENT ( INOUT ) :: ierr LOGICAL ( LGT ), INTENT ( IN ) :: readTag END SUBROUTINE ent_read_Surface END INTERFACE !---------------------------------------------------------------------------- !                                                ReadVolumeEntity@mshEntity !---------------------------------------------------------------------------- INTERFACE !! This subroutine reads the entry for volume entity !> authors: Dr. Vikas Sharma ! ! This subroutine reads the entry for volume entity MODULE SUBROUTINE ent_read_Volume ( Obj , mshFile , readTag , ierr ) CLASS ( mshEntity_ ), INTENT ( INOUT ) :: Obj TYPE ( File_ ), INTENT ( INOUT ) :: mshFile LOGICAL ( LGT ), INTENT ( INOUT ) :: ierr LOGICAL ( LGT ), INTENT ( IN ) :: readTag END SUBROUTINE ent_read_Volume END INTERFACE !---------------------------------------------------------------------------- !                                                      WriteToFile@mshEntity !---------------------------------------------------------------------------- INTERFACE !! This subroutine write the data to a file !> authors: Dr. Vikas Sharma ! ! This subroutine write the data to a file MODULE SUBROUTINE ent_write_file ( Obj , mshFile , Str , EndStr ) CLASS ( mshEntity_ ), INTENT ( INOUT ) :: Obj TYPE ( File_ ), INTENT ( INOUT ) :: mshFile CHARACTER ( LEN = * ), INTENT ( IN ), OPTIONAL :: Str , EndStr END SUBROUTINE ent_write_file END INTERFACE !---------------------------------------------------------------------------- !                                                          Display@mshEntity !---------------------------------------------------------------------------- INTERFACE ! This subroutine writes the content of [[mshEntity_]] !> authors: Dr. Vikas Sharma ! ! This subroutine writes the content of [[mshEntity_]] MODULE SUBROUTINE ent_display ( Obj , Msg , UnitNo ) CLASS ( mshEntity_ ), INTENT ( IN ) :: Obj CHARACTER ( LEN = * ), INTENT ( IN ) :: Msg INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: UnitNo END SUBROUTINE ent_display END INTERFACE INTERFACE Display MODULE PROCEDURE ent_display END INTERFACE Display PUBLIC :: Display !---------------------------------------------------------------------------- !                                                         getIndex@mshEntity !---------------------------------------------------------------------------- INTERFACE !! This function finds the index of a tag/uid in list of entities !> authors: Dr. Vikas Sharma ! ! This function finds the index of a tag/uid in the list of entities MODULE PURE FUNCTION ent_getIndex_a ( mshEntities , Uid ) RESULT ( Ans ) TYPE ( mshEntity_ ), INTENT ( IN ) :: mshEntities ( : ) INTEGER ( I4B ), INTENT ( IN ) :: Uid INTEGER ( I4B ) :: Ans END FUNCTION ent_getIndex_a END INTERFACE INTERFACE getIndex MODULE PROCEDURE ent_getIndex_a END INTERFACE getIndex PUBLIC :: getIndex !---------------------------------------------------------------------------- !                                                TotalPhysicalTags@mshEntity !---------------------------------------------------------------------------- INTERFACE !! This function returns the total number of physical tags in entity !> authors: Dr. Vikas Sharma ! ! This function returns the total number of physical tags in entity MODULE PURE FUNCTION ent_tphysicaltag ( Obj ) RESULT ( Ans ) CLASS ( mshEntity_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ) :: Ans END FUNCTION ent_tphysicaltag END INTERFACE !---------------------------------------------------------------------------- !                                                TotalBoundingTags@mshEntity !---------------------------------------------------------------------------- INTERFACE !! This function returns the total number of bounding tags in entity !> authors: Dr. Vikas Sharma ! ! This function returns the total number of bounding tags in entity MODULE PURE FUNCTION ent_tBoundingtag ( Obj ) RESULT ( Ans ) CLASS ( mshEntity_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ) :: Ans END FUNCTION ent_tBoundingtag END INTERFACE !---------------------------------------------------------------------------- !                                                    TotalElements@mshEntity !---------------------------------------------------------------------------- INTERFACE !! This function returns the total number of elements in entity !> authors: Dr. Vikas Sharma ! ! This function returns the total number of elements in entity MODULE PURE FUNCTION ent_telements ( Obj ) RESULT ( Ans ) CLASS ( mshEntity_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ) :: Ans END FUNCTION ent_telements END INTERFACE !---------------------------------------------------------------------------- !                                                    DeallocateData@mshEntity !---------------------------------------------------------------------------- INTERFACE !! This subroutine deallocate the data from [[mshentity_]] !> authors: Dr. Vikas Sharma ! ! This subroutine deallocate the data from [[mshentity_]] MODULE SUBROUTINE ent_deallocatedata ( Obj ) CLASS ( mshEntity_ ), INTENT ( INOUT ) :: Obj END SUBROUTINE ent_deallocatedata END INTERFACE INTERFACE DeallocateData MODULE PROCEDURE ent_deallocatedata END INTERFACE DeallocateData PUBLIC :: DeallocateData !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- END MODULE mshEntity_Class","tags":"","loc":"sourcefile/mshentity_class.f90.html"},{"title":"mshNodes_Class.f90 – Fortran Program","text":"Contents Modules mshNodes_Class Source Code mshNodes_Class.f90 Source Code MODULE mshNodes_Class !! This module implements a class for handling nodes in mesh file USE BaseType USE GlobalData USE mshFormat_Class IMPLICIT NONE PRIVATE !---------------------------------------------------------------------------- !                                                                 mshNodes_ !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This class is defined to handle the nodes in mesh file TYPE :: mshNodes_ INTEGER ( I4B ) :: numNodes = 0 !! number of nodes INTEGER ( I4B ) :: numEntityBlocks = 0 !msh4 !! number of entity blocks INTEGER ( I4B ) :: minNodeTag = 0 !msh4 !! minimum node number INTEGER ( I4B ) :: maxNodeTag = 0 !msh4 !! maximum node number LOGICAL ( LGT ) :: isSparse = . FALSE . !msh4 !! isSparse CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: Finalize => n_deallocateData !! DeallocateData From the object PROCEDURE , PUBLIC , PASS ( Obj ) :: GotoTag => n_goto !! Go to the node tag in mesh file PROCEDURE , PUBLIC , PASS ( Obj ) :: ReadFromFile => n_read_file !! read content from file PROCEDURE , PUBLIC , PASS ( Obj ) :: WriteToFile => n_write_file !! write data to file END TYPE mshNodes_ !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- PUBLIC :: mshNodes_ TYPE ( mshNodes_ ), PUBLIC , PARAMETER :: TypeMshNodes = mshNodes_ ( ) !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- TYPE :: mshNodesPointer_ CLASS ( mshNodes_ ), POINTER :: Ptr => NULL ( ) END TYPE mshNodesPointer_ PUBLIC :: mshNodesPointer_ !---------------------------------------------------------------------------- !                                                         GotoNodes@mshNodes !---------------------------------------------------------------------------- INTERFACE !! This subroutine go to the position where nodes are defined !> authors: Dr. Vikas Sharma ! ! This subroutine go to the position where nodes are defined MODULE SUBROUTINE n_goto ( Obj , mshFile , ierr ) CLASS ( mshNodes_ ), INTENT ( IN ) :: Obj TYPE ( File_ ), INTENT ( INOUT ) :: mshFile LOGICAL ( LGT ), INTENT ( INOUT ) :: ierr END SUBROUTINE n_goto END INTERFACE !---------------------------------------------------------------------------- !                                                      ReadFromFile@mshNodes !---------------------------------------------------------------------------- INTERFACE !! This subroutine read data from mesh file !> authors: Dr. Vikas Sharma ! ! This subroutine read data from mesh file MODULE SUBROUTINE n_read_file ( Obj , mshFile , mshFormat , ierr ) CLASS ( mshNodes_ ), INTENT ( INOUT ) :: Obj TYPE ( File_ ), INTENT ( INOUT ) :: mshFile TYPE ( mshFormat_ ), INTENT ( INOUT ) :: mshFormat LOGICAL ( LGT ), INTENT ( INOUT ) :: ierr END SUBROUTINE n_read_file END INTERFACE !---------------------------------------------------------------------------- !                                                       WriteToFile@mshNodes !---------------------------------------------------------------------------- INTERFACE !! This subroutine write data to a file !> authors: Dr. Vikas Sharma ! ! This subroutine writes data to a file MODULE SUBROUTINE n_write_file ( Obj , mshFile , mshFormat , Str , EndStr ) CLASS ( mshNodes_ ), INTENT ( INOUT ) :: Obj TYPE ( File_ ), INTENT ( INOUT ) :: mshFile CHARACTER ( LEN = * ), INTENT ( IN ), OPTIONAL :: Str , EndStr TYPE ( mshFormat_ ), INTENT ( INOUT ) :: mshFormat END SUBROUTINE n_write_file END INTERFACE !---------------------------------------------------------------------------- !                                                           Display@mshNodes !---------------------------------------------------------------------------- INTERFACE !! This subroutine display contents of [[mshNodes_]] !> authors: Dr. Vikas Sharma ! ! This subroutine displays content of [[mshNodes_]] MODULE SUBROUTINE n_display ( Obj , Msg , UnitNo ) CLASS ( mshNodes_ ), INTENT ( IN ) :: Obj CHARACTER ( LEN = * ), INTENT ( IN ) :: Msg INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: UnitNo END SUBROUTINE n_display END INTERFACE INTERFACE Display MODULE PROCEDURE n_display END INTERFACE Display PUBLIC :: Display !---------------------------------------------------------------------------- !                                                    DeallocateData@mshNodes !---------------------------------------------------------------------------- INTERFACE !! This subroutine deallocate the data form the instance !> authors: Dr. Vikas Sharma ! ! This subroutine deallocate the data from instance MODULE SUBROUTINE n_deallocatedata ( Obj ) CLASS ( mshNodes_ ), INTENT ( INOUT ) :: Obj END SUBROUTINE n_deallocatedata END INTERFACE INTERFACE DeallocateData MODULE PROCEDURE n_deallocatedata END INTERFACE DeallocateData PUBLIC :: DeallocateData END MODULE mshNodes_Class","tags":"","loc":"sourcefile/mshnodes_class.f90.html"},{"title":"gmshModel_Class.f90 – Fortran Program","text":"Contents Modules gmshModel_Class Source Code gmshModel_Class.f90 Source Code MODULE gmshModel_Class !! This class is container for all gmsh model USE BaseType USE GlobalData USE BaseMethod USE gmshGeo_Class USE gmshMesh_Class IMPLICIT NONE INTEGER ( I4B ), PARAMETER :: def_point_phy2ent = 100 INTEGER ( I4B ), PARAMETER :: def_curve_phy2ent = 100 INTEGER ( I4B ), PARAMETER :: def_surface_phy2ent = 100 INTEGER ( I4B ), PARAMETER :: def_volume_phy2ent = 100 INTEGER ( I4B ), PARAMETER :: def_point_ent2phy = 100 INTEGER ( I4B ), PARAMETER :: def_curve_ent2phy = 100 INTEGER ( I4B ), PARAMETER :: def_surface_ent2phy = 100 INTEGER ( I4B ), PARAMETER :: def_volume_ent2phy = 100 PRIVATE !---------------------------------------------------------------------------- !                                                                  gmshModel_ !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This data type is container for all the gmsh models TYPE :: gmshModel_ TYPE ( Buffer_ ), POINTER :: buffer => NULL ( ) CHARACTER ( LEN = 5 ) :: name = \"\" !! We can use this file two take backups and write content of model TYPE ( gmshGeo_ ), POINTER :: geo => NULL ( ) !! geometry due to internal kernel ! TYPE( gmshOCC_ ), POINTER :: occ => NULL( ) !! This experimental feature TYPE ( gmshMesh_ ), POINTER :: mesh => NULL ( ) TYPE ( String ), ALLOCATABLE :: EntityPointName ( : ) TYPE ( String ), ALLOCATABLE :: EntityCurveName ( : ) TYPE ( String ), ALLOCATABLE :: EntitySurfaceName ( : ) TYPE ( String ), ALLOCATABLE :: EntityVolumeName ( : ) TYPE ( String ), ALLOCATABLE :: PhysicalPointName ( : ) TYPE ( String ), ALLOCATABLE :: PhysicalCurveName ( : ) TYPE ( String ), ALLOCATABLE :: PhysicalSurfaceName ( : ) TYPE ( String ), ALLOCATABLE :: PhysicalVolumeName ( : ) INTEGER ( I4B ), ALLOCATABLE :: PhysicalPointUID ( : ) INTEGER ( I4B ), ALLOCATABLE :: PhysicalCurveUID ( : ) INTEGER ( I4B ), ALLOCATABLE :: PhysicalSurfaceUID ( : ) INTEGER ( I4B ), ALLOCATABLE :: PhysicalVolumeUID ( : ) TYPE ( IntVectorPointer_ ), ALLOCATABLE :: Point_PhysicalToEntity ( : ) TYPE ( IntVectorPointer_ ), ALLOCATABLE :: Curve_PhysicalToEntity ( : ) TYPE ( IntVectorPointer_ ), ALLOCATABLE :: Surface_PhysicalToEntity ( : ) TYPE ( IntVectorPointer_ ), ALLOCATABLE :: Volume_PhysicalToEntity ( : ) TYPE ( IntVectorPointer_ ), ALLOCATABLE :: Point_EntityToPhysical ( : ) TYPE ( IntVectorPointer_ ), ALLOCATABLE :: Curve_EntityToPhysical ( : ) TYPE ( IntVectorPointer_ ), ALLOCATABLE :: Surface_EntityToPhysical ( : ) TYPE ( IntVectorPointer_ ), ALLOCATABLE :: Volume_EntityToPhysical ( : ) TYPE ( gmshModel_ ), POINTER :: next => NULL ( ) !! Pointer to the next model for linked list CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: add => model_add ! PROCEDURE, PUBLIC, PASS( Obj ) :: remove => model_remove ! PROCEDURE, PUBLIC, PASS( Obj ) :: list => model_list ! PROCEDURE, PUBLIC, PASS( Obj ) :: getCurrent => model_getCurrent ! PROCEDURE, PUBLIC, PASS( Obj ) :: setCurrent => model_setCurrent PROCEDURE , PUBLIC , PASS ( Obj ) :: write => model_write PROCEDURE , PUBLIC , PASS ( Obj ) :: getEntities => model_getEntities PROCEDURE , PUBLIC , PASS ( Obj ) :: setEntityName => model_setEntityName PROCEDURE , PUBLIC , PASS ( Obj ) :: getEntityName => model_getEntityName PROCEDURE , PUBLIC , PASS ( Obj ) :: addPhysicalGroup => & & model_addPhysicalGroup PROCEDURE , PUBLIC , PASS ( Obj ) :: getPhysicalGroups => & & model_getPhysicalGroups PROCEDURE , PUBLIC , PASS ( Obj ) :: getEntitiesForPhysicalGroup => & & model_getEntitiesForPhysicalGroup PROCEDURE , PUBLIC , PASS ( Obj ) :: getPhysicalGroupsForEntity => & & model_getPhysicalGroupsForEntity PROCEDURE , PUBLIC , PASS ( Obj ) :: setPhysicalName => & & model_setPhysicalName PROCEDURE , PUBLIC , PASS ( Obj ) :: getPhysicalName => & & model_getPhysicalName END TYPE gmshModel_ PUBLIC :: gmshModel_ !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- CONTAINS FUNCTION model_write ( Obj , UnitNo ) RESULT ( Ans ) CLASS ( gmshModel_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: UnitNo INTEGER ( I4B ) :: Ans ! internal variables INTEGER ( I4B ) :: ii Ans = 0 IF ( . NOT . ASSOCIATED ( Obj % geo ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"        Model_write()\" ) CALL Display ( \"          Obj % geo not allocated\" ) STOP END IF ! CALL Display( \"gmsh%model:: calling gmsh%model%geo%write()\" ) Ans = Obj % geo % write ( UnitNo ) IF ( ASSOCIATED ( Obj % buffer ) ) THEN ! CALL Display( \"gmsh%model:: writing gmsh%model%buffer()\" ) DO ii = 1 , Obj % Buffer % tLine WRITE ( UnitNo , \"(DT)\" ) Obj % Buffer % Line ( ii ) % Ptr END DO END IF IF ( ASSOCIATED ( Obj % geo % mesh ) ) THEN ! CALL Display( \"gmsh%model:: calling gmsh%model%geo%mesh%write()\" ) Ans = Obj % geo % mesh % write ( UnitNo ) END IF IF ( ASSOCIATED ( Obj % mesh ) ) THEN ! CALL Display( \"gmsh%model:: calling gmsh%model%mesh%write()\" ) Ans = Obj % mesh % write ( UnitNo ) END IF END FUNCTION model_write !---------------------------------------------------------------------------- !                                                                       add !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This function add the model ! Currently only one model can be added FUNCTION model_add ( Obj , Name ) RESULT ( Ans ) CLASS ( gmshModel_ ), TARGET , INTENT ( INOUT ) :: Obj CHARACTER ( LEN = * ), INTENT ( IN ) :: Name INTEGER ( I4B ) :: Ans CALL Display ( \"gmsh%model:: Model \" // trim ( Name ) // \" added\" ) Ans = 0 CALL Display ( \"gmsh%model:: setting name of Model\" ) Obj % name = trim ( name ) obj % next => NULL ( ) ! model % geo CALL Display ( \"gmsh%model:: allocating obj%geo\" ) ALLOCATE ( obj % geo ) ! model model % geo % mesh CALL Display ( \"gmsh%model:: allocating obj%geo%mesh\" ) ALLOCATE ( obj % geo % mesh ) ! allocate obj % geo % buffer CALL Display ( \"gmsh%model:: allocating obj%geo%buffer\" ) ALLOCATE ( obj % geo % buffer ) ! model % mesh CALL Display ( \"gmsh%model:: allocating obj%mesh\" ) ALLOCATE ( obj % mesh ) !! model_name_buffer.txt CALL Display ( \"gmsh%model:: allocating obj%buffer\" ) ALLOCATE ( obj % buffer ) END FUNCTION model_add !---------------------------------------------------------------------------- !                                                                 getEntities !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! Get all the entities in the current model. If dim is >= 0, return only ! the entities of the specified dimension (e.g. points if dim == 0). ! The entities are returned as a vector of (dim, tag) integer pairs. FUNCTION model_getEntities ( Obj , dim ) RESULT ( Ans ) CLASS ( gmshModel_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: dim INTEGER ( I4B ), ALLOCATABLE :: Ans ( :, : ) ! internal variables INTEGER ( I4B ) :: ii , n , jj IF ( . NOT . ASSOCIATED ( Obj % geo ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"        model_getEntities()\" ) CALL Display ( \"          Obj % geo not associated\" ) STOP END IF SELECT CASE ( dim ) CASE ( 3 ) IF ( Obj % geo % tVolumes . NE . 0 ) THEN n = Obj % geo % tVolumes ALLOCATE ( Ans ( n , 2 ) ) Ans = 0 DO ii = 1 , n Ans ( ii , 1 ) = dim Ans ( ii , 2 ) = Obj % geo % Volume ( ii ) % Ptr % Uid END DO ELSE CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"        model_getEntities()\" ) CALL Display ( \"          Obj % geo % Volume not associated\" ) STOP END IF CASE ( 2 ) IF ( Obj % geo % tSurfaces . NE . 0 ) THEN n = Obj % geo % tSurfaces ALLOCATE ( Ans ( n , 2 ) ) Ans = 0 DO ii = 1 , n Ans ( ii , 1 ) = dim Ans ( ii , 2 ) = Obj % geo % Surface ( ii ) % Ptr % Uid END DO ELSE CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"        model_getEntities()\" ) CALL Display ( \"          Obj % geo % Surface not associated\" ) STOP END IF CASE ( 1 ) IF ( Obj % geo % tCurves . NE . 0 ) THEN n = Obj % geo % tCurves ALLOCATE ( Ans ( n , 2 ) ) Ans = 0 DO ii = 1 , n Ans ( ii , 1 ) = dim Ans ( ii , 2 ) = Obj % geo % Curve ( ii ) % Ptr % Uid END DO ELSE CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"        model_getEntities()\" ) CALL Display ( \"          Obj % geo % Curve not associated\" ) STOP END IF CASE ( 0 ) IF ( Obj % geo % tPoints . NE . 0 ) THEN n = Obj % geo % tPoints ALLOCATE ( Ans ( n , 2 ) ) Ans = 0 DO ii = 1 , n Ans ( ii , 1 ) = dim Ans ( ii , 2 ) = Obj % geo % Point ( ii ) % Ptr % Uid END DO ELSE CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"        model_getEntities()\" ) CALL Display ( \"          Obj % geo % Point not associated\" ) STOP END IF CASE DEFAULT n = Obj % geo % tPoints + Obj % geo % tCurves & & + Obj % geo % tSurfaces + Obj % geo % tVolumes IF ( n . NE . 0 ) THEN ALLOCATE ( Ans ( n , 2 ) ) ELSE CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"        model_getEntities()\" ) CALL Display ( \"          Obj % geo seems empty\" ) STOP END IF DO ii = 1 , Obj % geo % tPoints Ans ( ii , 1 ) = 0 Ans ( ii , 2 ) = Obj % geo % Point ( ii ) % Ptr % Uid END DO DO ii = 1 , Obj % geo % tCurves jj = ii + Obj % geo % tPoints Ans ( jj , 1 ) = 1 Ans ( jj , 2 ) = Obj % geo % Curve ( ii ) % Ptr % Uid END DO DO ii = 1 , Obj % geo % tSurfaces jj = ii + Obj % geo % tPoints + Obj % geo % tCurves Ans ( jj , 1 ) = 2 Ans ( jj , 2 ) = Obj % geo % Surface ( ii ) % Ptr % Uid END DO DO ii = 1 , Obj % geo % tVolumes jj = ii + Obj % geo % tPoints + Obj % geo % tCurves & + Obj % geo % tSurfaces Ans ( jj , 1 ) = 3 Ans ( jj , 2 ) = Obj % geo % Volume ( ii ) % Ptr % Uid END DO END SELECT END FUNCTION model_getEntities !---------------------------------------------------------------------------- !                                                              setEntityName !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! Set the name of the entity of dimension dim and tag tag FUNCTION model_setEntityName ( Obj , dim , tag , name ) RESULT ( Ans ) CLASS ( gmshModel_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: dim , tag CHARACTER ( LEN = * ), INTENT ( IN ) :: name INTEGER ( I4B ) :: Ans !internal variables INTEGER ( I4B ) :: ii SELECT CASE ( dim ) CASE ( 0 ) DO ii = 1 , obj % geo % tPoints IF ( obj % geo % point ( ii ) % ptr % uid . EQ . tag ) THEN obj % EntityPointName ( ii ) = name END IF END DO CASE ( 1 ) DO ii = 1 , obj % geo % tCurves IF ( obj % geo % Curve ( ii ) % ptr % uid . EQ . tag ) THEN obj % EntityCurveName ( ii ) = name END IF END DO CASE ( 2 ) DO ii = 1 , obj % geo % tSurfaces IF ( obj % geo % Surface ( ii ) % ptr % uid . EQ . tag ) THEN obj % EntitySurfaceName ( ii ) = name END IF END DO CASE ( 3 ) DO ii = 1 , obj % geo % tVolumes IF ( obj % geo % Volume ( ii ) % ptr % uid . EQ . tag ) THEN obj % EntityVolumeName ( ii ) = name END IF END DO END SELECT END FUNCTION model_setEntityName !---------------------------------------------------------------------------- !                                                              getEntityName !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! get the name of the entity of dimension dim and tag tag FUNCTION model_getEntityName ( Obj , dim , tag ) RESULT ( Ans ) CLASS ( gmshModel_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: dim , tag TYPE ( String ) :: Ans !internal variables INTEGER ( I4B ) :: ii SELECT CASE ( dim ) CASE ( 0 ) DO ii = 1 , obj % geo % tPoints IF ( obj % geo % point ( ii ) % ptr % uid . EQ . tag ) THEN Ans = obj % EntityPointName ( ii ) END IF END DO CASE ( 1 ) DO ii = 1 , obj % geo % tCurves IF ( obj % geo % Curve ( ii ) % ptr % uid . EQ . tag ) THEN Ans = obj % EntityCurveName ( ii ) END IF END DO CASE ( 2 ) DO ii = 1 , obj % geo % tSurfaces IF ( obj % geo % Surface ( ii ) % ptr % uid . EQ . tag ) THEN Ans = obj % EntitySurfaceName ( ii ) END IF END DO CASE ( 3 ) DO ii = 1 , obj % geo % tVolumes IF ( obj % geo % Volume ( ii ) % ptr % uid . EQ . tag ) THEN Ans = obj % EntityVolumeName ( ii ) END IF END DO END SELECT END FUNCTION model_getEntityName !---------------------------------------------------------------------------- !                                                           addPhysicalGroup !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! Add a physical group of dimension dim, grouping the model entities with ! tags tags. Return the tag of the physical group, equal to tag if tag is ! positive, or a new tag if tag < 0. FUNCTION model_addPhysicalGroup ( Obj , dim , tags , uid ) RESULT ( Ans ) CLASS ( gmshModel_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: dim INTEGER ( I4B ), INTENT ( IN ) :: tags ( : ) INTEGER ( I4B ), INTENT ( IN ) :: uid INTEGER ( I4B ) :: Ans ! internal variables INTEGER ( I4B ) :: ii , n , te2p , tp2e , jj TYPE ( String ), ALLOCATABLE :: s ( : ) TYPE ( String ) :: ss IF ( uid . LT . 0 ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"        model_addPhysicalGroup( )\" ) CALL Display ( \"          negative uid not supported\" ) STOP END IF ! internal variables SELECT CASE ( dim ) CASE ( 0 ) ! CALL Display( \"gmsh%model:: adding physical point\") #include \"./addphysicalpoint.inc\" CASE ( 1 ) ! CALL Display( \"gmsh%model:: adding physical curve\") #include \"./addphysicalcurve.inc\" CASE ( 2 ) ! CALL Display( \"gmsh%model:: adding physical surface\") #include \"./addphysicalsurface.inc\" CASE ( 3 ) ! CALL Display( \"gmsh%model:: adding physical volume\") #include \"./addphysicalvolume.inc\" END SELECT END FUNCTION model_addPhysicalGroup !---------------------------------------------------------------------------- !                                                          getPhysicalGroups !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! Get all the physical groups in the current model. If dim is >= 0, return ! only the entities of the specified dimension (e.g. physical points ! if dim == 0). The entities are returned as a vector of (dim, tag) ! integer pairs. FUNCTION model_getPhysicalGroups ( Obj , dim ) RESULT ( Ans ) CLASS ( gmshModel_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: dim INTEGER ( I4B ), ALLOCATABLE :: Ans ( :,: ) ! internal variables INTEGER ( I4B ) :: ii , n , jj , i ( 0 : 3 ) SELECT CASE ( dim ) CASE ( 3 ) IF ( . NOT . ALLOCATED ( Obj % PhysicalVolumeUID ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"        model_getPhysicalGroups()\" ) CALL Display ( \"          Obj % PhysicalVolumeUID not allocated\" ) CALL Display ( \"          Seems no Physical Volume present\" ) STOP END IF n = SIZE ( Obj % PhysicalVolumeUID ) ALLOCATE ( Ans ( n , 2 ) ) Ans = 0 DO ii = 1 , n Ans ( ii , 1 ) = dim Ans ( ii , 2 ) = Obj % PhysicalVolumeUID ( ii ) END DO CASE ( 2 ) IF ( . NOT . ALLOCATED ( Obj % PhysicalSurfaceUID ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"        model_getPhysicalGroups()\" ) CALL Display ( \"          Obj % PhysicalSurfaceUID not allocated\" ) CALL Display ( \"          Seems no Physical Surface present\" ) STOP END IF n = SIZE ( Obj % PhysicalSurfaceUID ) ALLOCATE ( Ans ( n , 2 ) ) Ans = 0 DO ii = 1 , n Ans ( ii , 1 ) = dim Ans ( ii , 2 ) = Obj % PhysicalSurfaceUID ( ii ) END DO CASE ( 1 ) IF ( . NOT . ALLOCATED ( Obj % PhysicalCurveUID ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"        model_getPhysicalGroups()\" ) CALL Display ( \"          Obj % PhysicalCurveUID not allocated\" ) CALL Display ( \"          Seems no Physical Curve present\" ) STOP END IF n = SIZE ( Obj % PhysicalCurveUID ) ALLOCATE ( Ans ( n , 2 ) ) Ans = 0 DO ii = 1 , n Ans ( ii , 1 ) = dim Ans ( ii , 2 ) = Obj % PhysicalCurveUID ( ii ) END DO CASE ( 0 ) IF ( . NOT . ALLOCATED ( Obj % PhysicalPointUID ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"        model_getPhysicalGroups()\" ) CALL Display ( \"          Obj % PhysicalPointUID not allocated\" ) CALL Display ( \"          Seems no Physical Point present\" ) STOP END IF n = SIZE ( Obj % PhysicalPointUID ) ALLOCATE ( Ans ( n , 2 ) ) Ans = 0 DO ii = 1 , n Ans ( ii , 1 ) = dim Ans ( ii , 2 ) = Obj % PhysicalPointUID ( ii ) END DO CASE DEFAULT i = 0 IF ( ALLOCATED ( Obj % PhysicalPointUID ) ) THEN i ( 0 ) = SIZE ( Obj % PhysicalPointUID ) END IF IF ( ALLOCATED ( Obj % PhysicalCurveUID ) ) THEN i ( 1 ) = SIZE ( Obj % PhysicalCurveUID ) END IF IF ( ALLOCATED ( Obj % PhysicalSurfaceUID ) ) THEN i ( 2 ) = SIZE ( Obj % PhysicalSurfaceUID ) END IF IF ( ALLOCATED ( Obj % PhysicalVolumeUID ) ) THEN i ( 3 ) = SIZE ( Obj % PhysicalVolumeUID ) END IF n = SUM ( i ) IF ( n . NE . 0 ) THEN ALLOCATE ( Ans ( n , 2 ) ) ELSE CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"        model_getEntities()\" ) CALL Display ( \"          Seems no Physical groupd defined\" ) STOP END IF DO ii = 1 , i ( 0 ) Ans ( ii , 1 ) = 0 Ans ( ii , 2 ) = Obj % PhysicalPointUID ( ii ) END DO DO ii = 1 , i ( 1 ) jj = ii + i ( 0 ) Ans ( jj , 1 ) = 1 Ans ( jj , 2 ) = Obj % PhysicalCurveUID ( ii ) END DO DO ii = 1 , i ( 2 ) jj = ii + i ( 0 ) + i ( 1 ) Ans ( jj , 1 ) = 2 Ans ( jj , 2 ) = Obj % PhysicalSurfaceUID ( ii ) END DO DO ii = 1 , i ( 3 ) jj = ii + SUM ( i ( 0 : 2 ) ) Ans ( jj , 1 ) = 3 Ans ( jj , 2 ) = Obj % PhysicalVolumeUID ( ii ) END DO END SELECT END FUNCTION model_getPhysicalGroups !---------------------------------------------------------------------------- !                                               getEntitiesForPhysicalGroup !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! Get the tags of the model entities making up the physical group of ! dimension dim and tag tag. FUNCTION model_getEntitiesForPhysicalGroup ( Obj , dim , tag ) RESULT ( Ans ) CLASS ( gmshModel_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: dim , tag INTEGER ( I4B ), ALLOCATABLE :: Ans ( : ) ! define internal variables INTEGER ( I4B ) :: ii , n SELECT CASE ( dim ) CASE ( 0 ) IF ( . NOT . ALLOCATED ( Obj % PhysicalPointUID ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"          model_getEntitiesForPhysicalGroup()\" ) CALL Display ( \"          Physical points are not defined\" ) STOP END IF n = SIZE ( Obj % PhysicalPointUID ) DO ii = 1 , n IF ( Obj % PhysicalPointUID ( ii ) . EQ . tag ) THEN CALL Convert ( From = Obj % Point_PhysicalToEntity ( ii ) % Ptr , & & TO = Ans ) EXIT END IF END DO CASE ( 1 ) IF ( . NOT . ALLOCATED ( Obj % PhysicalCurveUID ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"          model_getEntitiesForPhysicalGroup()\" ) CALL Display ( \"          Physical Curves are not defined\" ) STOP END IF n = SIZE ( Obj % PhysicalCurveUID ) DO ii = 1 , n IF ( Obj % PhysicalCurveUID ( ii ) . EQ . tag ) THEN CALL Convert ( From = Obj % Curve_PhysicalToEntity ( ii ) % Ptr , & & TO = Ans ) EXIT END IF END DO CASE ( 2 ) IF ( . NOT . ALLOCATED ( Obj % PhysicalSurfaceUID ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"          model_getEntitiesForPhysicalGroup()\" ) CALL Display ( \"          Physical Surfaces are not defined\" ) STOP END IF n = SIZE ( Obj % PhysicalSurfaceUID ) DO ii = 1 , n IF ( Obj % PhysicalSurfaceUID ( ii ) . EQ . tag ) THEN CALL Convert ( From = Obj % Surface_PhysicalToEntity ( ii ) % Ptr , & & TO = Ans ) EXIT END IF END DO CASE ( 3 ) IF ( . NOT . ALLOCATED ( Obj % PhysicalVolumeUID ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"          model_getEntitiesForPhysicalGroup()\" ) CALL Display ( \"          Physical Volumes are not defined\" ) STOP END IF n = SIZE ( Obj % PhysicalVolumeUID ) DO ii = 1 , n IF ( Obj % PhysicalVolumeUID ( ii ) . EQ . tag ) THEN CALL Convert ( From = Obj % Volume_PhysicalToEntity ( ii ) % Ptr , & & TO = Ans ) EXIT END IF END DO END SELECT END FUNCTION model_getEntitiesForPhysicalGroup !---------------------------------------------------------------------------- !                                               getPhysicalGroupsForEntity !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! Get the tags of the physical groups (if any) to which the model entity of ! dimension dim and tag tag belongs. FUNCTION model_getPhysicalGroupsForEntity ( Obj , dim , tag ) RESULT ( Ans ) CLASS ( gmshModel_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: dim , tag INTEGER ( I4B ), ALLOCATABLE :: Ans ( : ) ! define internal variables INTEGER ( I4B ) :: ii , n SELECT CASE ( dim ) CASE ( 0 ) IF ( . NOT . ALLOCATED ( Obj % geo % Point ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"          model_getPhysicalGroupsForEntity()\" ) CALL Display ( \"          Points are not added in geometry\" ) STOP END IF n = Obj % geo % tPoints DO ii = 1 , n IF ( Obj % geo % Point ( ii ) % ptr % uid . EQ . tag ) THEN CALL Convert ( From = Obj % Point_EntityToPhysical ( ii ) % Ptr , & & TO = Ans ) EXIT END IF END DO CASE ( 1 ) IF ( . NOT . ALLOCATED ( Obj % geo % Curve ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"          model_getPhysicalGroupsForEntity()\" ) CALL Display ( \"          Curves are not added in geometry\" ) STOP END IF n = Obj % geo % tCurves DO ii = 1 , n IF ( Obj % geo % Curve ( ii ) % ptr % uid . EQ . tag ) THEN CALL Convert ( From = Obj % Curve_EntityToPhysical ( ii ) % Ptr , & & TO = Ans ) EXIT END IF END DO CASE ( 2 ) IF ( . NOT . ALLOCATED ( Obj % geo % Surface ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"          model_getPhysicalGroupsForEntity()\" ) CALL Display ( \"          Surfaces are not added in geometry\" ) STOP END IF n = Obj % geo % tSurfaces DO ii = 1 , n IF ( Obj % geo % Surface ( ii ) % ptr % uid . EQ . tag ) THEN CALL Convert ( From = Obj % Surface_EntityToPhysical ( ii ) % Ptr , & & TO = Ans ) EXIT END IF END DO CASE ( 3 ) IF ( . NOT . ALLOCATED ( Obj % geo % Volume ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"          model_getPhysicalGroupsForEntity()\" ) CALL Display ( \"          Volumes are not added in geometry\" ) STOP END IF n = Obj % geo % tVolumes DO ii = 1 , n IF ( Obj % geo % Volume ( ii ) % ptr % uid . EQ . tag ) THEN CALL Convert ( From = Obj % Volume_EntityToPhysical ( ii ) % Ptr , & & TO = Ans ) EXIT END IF END DO END SELECT END FUNCTION model_getPhysicalGroupsForEntity !---------------------------------------------------------------------------- !                                                             setPhysicalName !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! Set the name of the physical group of dimension dim and tag tag. FUNCTION model_setPhysicalName ( Obj , dim , tag , name ) RESULT ( Ans ) CLASS ( gmshModel_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: dim , tag CHARACTER ( LEN = * ), INTENT ( IN ) :: name INTEGER ( I4B ) :: Ans ! internal varialbles INTEGER ( I4B ) :: ii , n TYPE ( String ), ALLOCATABLE :: s ( : ) TYPE ( String ) :: ss INTEGER ( I4B ), ALLOCATABLE :: tags ( : ) Ans = 0 SELECT CASE ( dim ) CASE ( 0 ) IF ( . NOT . ALLOCATED ( Obj % PhysicalPointName ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"          model_setPhysicalName()\" ) CALL Display ( \"          Physical Points are not set\" ) STOP END IF n = SIZE ( Obj % PhysicalPointName ) DO ii = 1 , n IF ( Obj % PhysicalPointUID ( ii ) . EQ . tag ) THEN Obj % PhysicalPointName ( ii ) = trim ( name ) CALL Convert ( From = Obj % Point_PhysicalToEntity ( ii ) % ptr , & & To = tags ) EXIT END IF END DO IF ( . NOT . ALLOCATED ( tags ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"          model_setPhysicalName()\" ) CALL Display ( \"          Given dim tag not found\" ) STOP END IF n = SIZE ( tags ) ALLOCATE ( s ( n ) ) DO ii = 1 , n s ( ii ) = trim ( str ( tags ( ii ), no_sign = . true . ) ) END DO ss = ss % join ( s , sep = \", \" ) ss = & & \"Physical Point( \" // & & '\"' // trim ( name ) // '\"' // & & \", \" // & & trim ( str ( tag , no_sign = . true . ) ) // & & \" ) = { \" // & & trim ( ss ) // & & \" };\" DEALLOCATE ( s , tags ) ! CALL Display( \"gmsh%model:: adding physical point to buffer\") CALL APPEND ( Obj % geo % buffer , ss ) CASE ( 1 ) IF ( . NOT . ALLOCATED ( Obj % PhysicalCurveName ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"          model_setPhysicalName()\" ) CALL Display ( \"          Physical Curves are not set\" ) STOP END IF n = SIZE ( Obj % PhysicalCurveName ) DO ii = 1 , n IF ( Obj % PhysicalCurveUID ( ii ) . EQ . tag ) THEN Obj % PhysicalCurveName ( ii ) = trim ( name ) CALL Convert ( From = Obj % Curve_PhysicalToEntity ( ii ) % ptr , & & To = tags ) EXIT END IF END DO IF ( . NOT . ALLOCATED ( tags ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"          model_setPhysicalName()\" ) CALL Display ( \"          Given dim tag not found\" ) STOP END IF n = SIZE ( tags ) ALLOCATE ( s ( n ) ) DO ii = 1 , n s ( ii ) = trim ( str ( tags ( ii ), no_sign = . true . ) ) END DO ss = ss % join ( s , sep = \", \" ) ss = & & \"Physical Curve( \" // & & '\"' // trim ( name ) // '\"' // & & \", \" // & & trim ( str ( tag , no_sign = . true . ) ) // & & \" ) = { \" // & & trim ( ss ) // & & \" };\" DEALLOCATE ( s , tags ) ! CALL Display( \"gmsh%model:: adding physical curve to buffer\") CALL APPEND ( Obj % geo % buffer , ss ) CASE ( 2 ) IF ( . NOT . ALLOCATED ( Obj % PhysicalSurfaceName ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"          model_setPhysicalName()\" ) CALL Display ( \"          Physical Surfaces are not set\" ) STOP END IF n = SIZE ( Obj % PhysicalSurfaceName ) DO ii = 1 , n IF ( Obj % PhysicalSurfaceUID ( ii ) . EQ . tag ) THEN Obj % PhysicalSurfaceName ( ii ) = trim ( name ) CALL Convert ( From = Obj % Surface_PhysicalToEntity ( ii ) % ptr , & & To = tags ) EXIT END IF END DO IF ( . NOT . ALLOCATED ( tags ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"          model_setPhysicalName()\" ) CALL Display ( \"          Given dim tag not found\" ) STOP END IF n = SIZE ( tags ) ALLOCATE ( s ( n ) ) DO ii = 1 , n s ( ii ) = trim ( str ( tags ( ii ), no_sign = . true . ) ) END DO ss = ss % join ( s , sep = \", \" ) ss = & & \"Physical Surface( \" // & & '\"' // trim ( name ) // '\"' // & & \", \" // & & trim ( str ( tag , no_sign = . true . ) ) // & & \" ) = { \" // & & trim ( ss ) // & & \" };\" DEALLOCATE ( s , tags ) ! CALL Display( \"gmsh%model:: adding physical surface to buffer\") CALL APPEND ( Obj % geo % buffer , ss ) CASE ( 3 ) IF ( . NOT . ALLOCATED ( Obj % PhysicalVolumeName ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"          model_setPhysicalName()\" ) CALL Display ( \"          Physical Volumes are not set\" ) STOP END IF n = SIZE ( Obj % PhysicalVolumeName ) DO ii = 1 , n IF ( Obj % PhysicalVolumeUID ( ii ) . EQ . tag ) THEN Obj % PhysicalVolumeName ( ii ) = trim ( name ) CALL Convert ( From = Obj % Volume_PhysicalToEntity ( ii ) % ptr , & & To = tags ) EXIT END IF END DO IF ( . NOT . ALLOCATED ( tags ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"          model_setPhysicalName()\" ) CALL Display ( \"          Given dim tag not found\" ) STOP END IF n = SIZE ( tags ) ALLOCATE ( s ( n ) ) DO ii = 1 , n s ( ii ) = trim ( str ( tags ( ii ), no_sign = . true . ) ) END DO ss = ss % join ( s , sep = \", \" ) ss = & & \"Physical Volume( \" // & & '\"' // trim ( name ) // '\"' // & & \", \" // & & trim ( str ( tag , no_sign = . true . ) ) // & & \" ) = { \" // & & trim ( ss ) // & & \" };\" DEALLOCATE ( s , tags ) ! WRITE( obj % buffer % unitno, \"(DT)\" ) ss ! CALL Display( \"gmsh%model:: adding physical volume to buffer\") CALL APPEND ( Obj % geo % buffer , ss ) END SELECT END FUNCTION model_setPhysicalName !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- FUNCTION model_getPhysicalName ( Obj , dim , tag ) RESULT ( Ans ) CLASS ( gmshModel_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ) :: dim , tag TYPE ( String ) :: Ans INTEGER ( I4B ) :: ii , n SELECT CASE ( dim ) CASE ( 0 ) IF ( . NOT . ALLOCATED ( Obj % PhysicalPointName ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"          model_getPhysicalName()\" ) CALL Display ( \"          Physical Points are not set\" ) STOP END IF n = SIZE ( Obj % PhysicalPointName ) DO ii = 1 , n IF ( Obj % PhysicalPointUID ( ii ) . EQ . tag ) THEN Ans = Obj % PhysicalPointName ( ii ) EXIT END IF END DO CASE ( 1 ) IF ( . NOT . ALLOCATED ( Obj % PhysicalCurveName ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"          model_getPhysicalName()\" ) CALL Display ( \"          Physical Curves are not set\" ) STOP END IF n = SIZE ( Obj % PhysicalCurveName ) DO ii = 1 , n IF ( Obj % PhysicalCurveUID ( ii ) . EQ . tag ) THEN Ans = Obj % PhysicalCurveName ( ii ) EXIT END IF END DO CASE ( 2 ) IF ( . NOT . ALLOCATED ( Obj % PhysicalSurfaceName ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"          model_getPhysicalName()\" ) CALL Display ( \"          Physical Surfaces are not set\" ) STOP END IF n = SIZE ( Obj % PhysicalSurfaceName ) DO ii = 1 , n IF ( Obj % PhysicalSurfaceUID ( ii ) . EQ . tag ) THEN Ans = Obj % PhysicalSurfaceName ( ii ) EXIT END IF END DO CASE ( 3 ) IF ( . NOT . ALLOCATED ( Obj % PhysicalVolumeName ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"          model_getPhysicalName()\" ) CALL Display ( \"          Physical Volumes are not set\" ) STOP END IF n = SIZE ( Obj % PhysicalVolumeName ) DO ii = 1 , n IF ( Obj % PhysicalVolumeUID ( ii ) . EQ . tag ) THEN Ans = Obj % PhysicalVolumeName ( ii ) EXIT END IF END DO END SELECT END FUNCTION model_getPhysicalName !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- END MODULE gmshModel_Class","tags":"","loc":"sourcefile/gmshmodel_class.f90.html"},{"title":"SFCCModel_Class.f90 – Fortran Program","text":"Contents Modules SFCCModel_Class Source Code SFCCModel_Class.f90 Source Code !> authors: Dr. Vikas Sharma ! !  This module consists of volumetric heat capacity model for porous media ! MODULE SFCCModel_Class USE GlobalData IMPLICIT NONE PRIVATE #include \"./PMDefine.inc\" !---------------------------------------------------------------------------- !                                                         PMVolHeatCapModel_ !---------------------------------------------------------------------------- TYPE , ABSTRACT :: SFCCModel_ PROCEDURE ( ExpSFCC_get_val ), POINTER , PASS ( Obj ) :: getValue => NULL () PROCEDURE ( ExpSFCC_get_slope ), POINTER , PASS ( Obj ) :: getSlope => NULL () PROCEDURE ( ExpSFCC_PhaseInfo ), POINTER , PASS ( Obj ) :: PhaseInfo => NULL () END TYPE SFCCModel_ PUBLIC :: SFCCModel_ !---------------------------------------------------------------------------- !                                                          SFCCModelPointer_ !---------------------------------------------------------------------------- TYPE :: SFCCModelPointer_ CLASS ( SFCCModel_ ), POINTER :: Ptr => NULL () END TYPE SFCCModelPointer_ PUBLIC :: SFCCModelPointer_ !---------------------------------------------------------------------------- !                                                                   ExpSFCC_ !---------------------------------------------------------------------------- TYPE , EXTENDS ( SFCCModel_ ) :: ExpSFCC_ REAL ( DFP ) :: Theta_r = 0.0_DFP !! residual REAL ( DFP ) :: Theta_w = 0.0_DFP !! TotalWater content REAL ( DFP ) :: Temp_l = 0.0_DFP !! Freezing temp liquid side REAL ( DFP ) :: Temp_s = 0.0_DFP !! Freezing temp solid dide REAL ( DFP ) :: Coeff = 1.0_DFP !! exponent END TYPE ExpSFCC_ PUBLIC :: ExpSFCC_ TYPE ( ExpSFCC_ ), PUBLIC , PARAMETER :: TypeExpSFCC = ExpSFCC_ () !---------------------------------------------------------------------------- !                                                                 UserSFCC_ !---------------------------------------------------------------------------- TYPE , EXTENDS ( SFCCModel_ ) :: UserSFCC_ END TYPE UserSFCC_ PUBLIC :: UserSFCC_ TYPE ( UserSFCC_ ), PUBLIC , PARAMETER :: TypeUserSFCC = UserSFCC_ () !---------------------------------------------------------------------------- !                                                              UserSFCC@User !---------------------------------------------------------------------------- INTERFACE MODULE FUNCTION UserSFCC_Pointer ( ) RESULT ( Ans ) CLASS ( UserSFCC_ ), POINTER :: Ans END FUNCTION UserSFCC_Pointer END INTERFACE PUBLIC :: UserSFCC_Pointer !---------------------------------------------------------------------------- !                                                        Constructor@ExpSFCC !---------------------------------------------------------------------------- INTERFACE MODULE FUNCTION ExpSFCC_Pointer ( Theta_r , Theta_w , Temp_l , Temp_s , & & Coeff ) RESULT ( Ans ) CLASS ( ExpSFCC_ ), POINTER :: Ans REAL ( DFP ), INTENT ( IN ) :: Theta_r REAL ( DFP ), INTENT ( IN ) :: Theta_w REAL ( DFP ), INTENT ( IN ) :: Temp_l REAL ( DFP ), INTENT ( IN ) :: Temp_s REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: Coeff END FUNCTION ExpSFCC_Pointer END INTERFACE PUBLIC :: ExpSFCC_Pointer !---------------------------------------------------------------------------- !                                                           getValue@expSFCC !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION ExpSFCC_get_val ( Obj , Temp ) RESULT ( Ans ) CLASS ( SFCCModel_ ), INTENT ( IN ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Temp REAL ( DFP ) :: Ans END FUNCTION ExpSFCC_get_val END INTERFACE !---------------------------------------------------------------------------- !                                                           getSlope@expSFCC !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION ExpSFCC_get_slope ( Obj , Temp ) RESULT ( Ans ) CLASS ( SFCCModel_ ), INTENT ( IN ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Temp REAL ( DFP ) :: Ans END FUNCTION ExpSFCC_get_slope END INTERFACE !---------------------------------------------------------------------------- !                                                    PhaseInfo@expSFCC !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION ExpSFCC_PhaseInfo ( Obj , Temp ) RESULT ( Ans ) CLASS ( SFCCModel_ ), INTENT ( IN ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Temp CHARACTER ( LEN = 1 ) :: Ans END FUNCTION ExpSFCC_PhaseInfo END INTERFACE !---------------------------------------------------------------------------- !                                                           getSlope@ExpSFCC !---------------------------------------------------------------------------- END MODULE SFCCModel_Class","tags":"","loc":"sourcefile/sfccmodel_class.f90.html"},{"title":"VolHeatCapModel_Class.f90 – Fortran Program","text":"Contents Modules VolHeatCapModel_Class Source Code VolHeatCapModel_Class.f90 Source Code !> authors: Dr. Vikas Sharma ! !  This module consists of volumetric heat capacity model for porous media ! MODULE VolHeatCapModel_Class USE GlobalData IMPLICIT NONE PRIVATE #include \"./PMDefine.inc\" !---------------------------------------------------------------------------- !                                                           VolHeatCapModel_ !---------------------------------------------------------------------------- TYPE , ABSTRACT :: VolHeatCapModel_ REAL ( DFP ) :: ConstVolHeatCapVal = 0.0_DFP REAL ( DFP ) :: volHeatCap_solid = 265 0.0_DFP * 73 3.0_DFP LOGICAL ( LGT ) :: is_volHeatCap_solid_given = . FALSE . PROCEDURE ( mixvolheatcap_getval ), POINTER , PASS ( Obj ) :: & & getValue => NULL () END TYPE VolHeatCapModel_ PUBLIC :: VolHeatCapModel_ !---------------------------------------------------------------------------- !                                                   VolHeatCapModelPointer_ !---------------------------------------------------------------------------- TYPE :: VolHeatCapModelPointer_ CLASS ( VolHeatCapModel_ ), POINTER :: Ptr => NULL () END TYPE VolHeatCapModelPointer_ PUBLIC :: VolHeatCapModelPointer_ !---------------------------------------------------------------------------- !                                                      UserVolHeatCapModel_ !---------------------------------------------------------------------------- TYPE , EXTENDS ( volHeatCapModel_ ) :: UserVolHeatCap_ END TYPE UserVolHeatCap_ TYPE ( UserVolHeatCap_ ), PARAMETER , PUBLIC :: & & TypeUserVolHeatCap = UserVolHeatCap_ () !---------------------------------------------------------------------------- !                                                UserVolHeatCap_Pointer@User !---------------------------------------------------------------------------- INTERFACE MODULE FUNCTION UserVolHeatCap_Pointer ( ) RESULT ( Ans ) CLASS ( UserVolHeatCap_ ), POINTER :: Ans END FUNCTION UserVolHeatCap_Pointer END INTERFACE PUBLIC :: UserVolHeatCap_Pointer !---------------------------------------------------------------------------- !                                                 userVolHeatCap_getval@User !---------------------------------------------------------------------------- INTERFACE !! This function returns the volumetric heat capacity values MODULE PURE FUNCTION userVolHeatCap_getval ( Obj , volFrac_solid , & & volFrac_water , volFrac_ice , volFrac_air , Temp , x , y , z ) RESULT ( Ans ) CLASS ( VolHeatCapModel_ ), INTENT ( IN ) :: Obj REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: volFrac_solid REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: volFrac_water REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: volFrac_ice REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: volFrac_air REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: Temp REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: x REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: y REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: z REAL ( DFP ) :: Ans END FUNCTION userVolHeatCap_getval END INTERFACE !---------------------------------------------------------------------------- !                                                             MixVolHeatCap_ !---------------------------------------------------------------------------- TYPE , EXTENDS ( VolHeatCapModel_ ) :: MixVolHeatCap_ INTEGER ( I4B ) :: State = STATE_UNFROZEN INTEGER ( I4B ) :: Frozen = STATE_FROZEN INTEGER ( I4B ) :: Unfrozen = STATE_UNFROZEN END TYPE MixVolHeatCap_ PUBLIC :: MixVolHeatCap_ TYPE ( MixVolHeatCap_ ), PUBLIC , PARAMETER :: TypeVolHeatCap = MixVolHeatCap_ () !---------------------------------------------------------------------------- !                                                       Constructor@mixModel !---------------------------------------------------------------------------- INTERFACE MODULE FUNCTION MixVolHeatCap_Pointer ( volHeatCap_solid , SoilState ) & & RESULT ( Ans ) CLASS ( MixVolHeatCap_ ), POINTER :: Ans REAL ( DFP ), OPTIONAL :: volHeatCap_solid INTEGER ( I4B ), OPTIONAL :: SoilState END FUNCTION MixVolHeatCap_Pointer END INTERFACE PUBLIC :: MixVolHeatCap_Pointer !---------------------------------------------------------------------------- !                                                         getValue@mixModel !---------------------------------------------------------------------------- INTERFACE !! This function returns the volumetric heat capacity values MODULE PURE FUNCTION mixvolheatcap_getval ( Obj , volFrac_solid , & & volFrac_water , volFrac_ice , volFrac_air , Temp , x , y , z ) RESULT ( Ans ) CLASS ( VolHeatCapModel_ ), INTENT ( IN ) :: Obj REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: volFrac_solid REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: volFrac_water REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: volFrac_ice REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: volFrac_air REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: Temp REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: x REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: y REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: z REAL ( DFP ) :: Ans END FUNCTION mixvolheatcap_getval END INTERFACE !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- END MODULE VolHeatCapModel_Class","tags":"","loc":"sourcefile/volheatcapmodel_class.f90.html"},{"title":"ThermCondModel_Class.f90 – Fortran Program","text":"Contents Modules ThermCondModel_Class Source Code ThermCondModel_Class.f90 Source Code !> authors: Dr. Vikas Sharma ! !  This module consists of several thermal conductivity model for porous ! medium ! MODULE ThermCondModel_Class USE GlobalData IMPLICIT NONE PRIVATE #include \"./PMDefine.inc\" !---------------------------------------------------------------------------- !                                                           ThermCondModel_ !---------------------------------------------------------------------------- TYPE , ABSTRACT :: ThermCondModel_ REAL ( DFP ) :: ConstThermCondVal = 0.0_DFP PROCEDURE ( johansen_getval ), POINTER , PASS ( Obj ) :: getValue => NULL () END TYPE ThermCondModel_ PUBLIC :: ThermCondModel_ !---------------------------------------------------------------------------- !                                                     ThermCondModelPointer_ !---------------------------------------------------------------------------- TYPE :: ThermCondModelPointer_ CLASS ( ThermCondModel_ ), POINTER :: Ptr => NULL () END TYPE ThermCondModelPointer_ PUBLIC :: ThermCondModelPointer_ !---------------------------------------------------------------------------- !                                                             UserThermCond_ !---------------------------------------------------------------------------- TYPE , EXTENDS ( ThermCondModel_ ) :: UserThermCond_ END TYPE UserThermCond_ PUBLIC :: UserThermCond_ TYPE ( UserThermCond_ ), PUBLIC , PARAMETER :: TypeUserThermCond = UserThermCond_ () !---------------------------------------------------------------------------- !                                                         UserThermCond@User !---------------------------------------------------------------------------- INTERFACE MODULE FUNCTION UserThermCond_Pointer ( ) RESULT ( Ans ) CLASS ( UserThermCond_ ), POINTER :: Ans END FUNCTION UserThermCond_Pointer END INTERFACE PUBLIC :: UserThermCond_Pointer !---------------------------------------------------------------------------- !                                                              getValue@User !---------------------------------------------------------------------------- INTERFACE !! This function returns the thermal conductivity values !> authors: Dr. Vikas Sharma ! ! This function returns the thermal conductivity values ! - `volFrac` contains volumetric fraction of solid, water, ice, air MODULE PURE FUNCTION UserThermCond_getval ( Obj , volFrac_solid , & & volFrac_water , volFrac_ice , volFrac_air , Temp , x , y , z ) RESULT ( Ans ) CLASS ( ThermCondModel_ ), INTENT ( IN ) :: Obj REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: volFrac_solid REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: volFrac_water REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: volFrac_ice REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: volFrac_air REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: Temp REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: x REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: y REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: z REAL ( DFP ) :: Ans END FUNCTION UserThermCond_getval END INTERFACE !---------------------------------------------------------------------------- !                                                          JohansenThermCond_ !---------------------------------------------------------------------------- TYPE , EXTENDS ( ThermCondModel_ ) :: JohansenThermCond_ INTEGER ( I4B ) :: State = STATE_UNFROZEN INTEGER ( I4B ) :: Frozen = STATE_FROZEN INTEGER ( I4B ) :: Unfrozen = STATE_UNFROZEN INTEGER ( I4B ) :: SoilType = SOIL_COARSE_GRAINED INTEGER ( I4B ) :: FineGrained = SOIL_FINE_GRAINED INTEGER ( I4B ) :: CoarseGrained = SOIL_COARSE_GRAINED INTEGER ( I4B ) :: Peat = SOIL_PEAT REAL ( DFP ) :: Lambda_Sat = 0.0_DFP REAL ( DFP ) :: Lambda_Dry = 0.0_DFP REAL ( DFP ) :: Lambda_e = 0.0_DFP REAL ( DFP ) :: Lambda_s = 0.0_DFP LOGICAL :: isLambda_sat_given = . FALSE . LOGICAL :: isLambda_dry_given = . FALSE . LOGICAL :: isLambda_e_given = . FALSE . REAL ( DFP ) :: Gamma_d = 160 0.0_DFP REAL ( DFP ) :: QuartzContent = 1.0_DFP END TYPE JohansenThermCond_ PUBLIC :: JohansenThermCond_ TYPE ( JohansenThermCond_ ), PUBLIC , PARAMETER :: TypeJohansenThermCond & & = JohansenThermCond_ () !---------------------------------------------------------------------------- !                                                        Constructor@Johansen !---------------------------------------------------------------------------- INTERFACE MODULE FUNCTION JohansenThermCond_Pointer ( Lambda_Sat , Lambda_Dry , & & Lambda_e , Gamma_d , QuartzContent , SoilState , SoilType ) & & RESULT ( Ans ) CLASS ( JohansenThermCond_ ), POINTER :: Ans REAL ( DFP ), OPTIONAL :: Lambda_Sat REAL ( DFP ), OPTIONAL :: Lambda_Dry REAL ( DFP ), OPTIONAL :: Lambda_e REAL ( DFP ), OPTIONAL :: Gamma_d REAL ( DFP ), OPTIONAL :: QuartzContent INTEGER ( I4B ), OPTIONAL :: SoilState INTEGER ( I4B ), OPTIONAL :: SoilType END FUNCTION JohansenThermCond_Pointer END INTERFACE PUBLIC :: JohansenThermCond_Pointer !---------------------------------------------------------------------------- !                                                           getValue@Johansen !---------------------------------------------------------------------------- INTERFACE !! This function returns the thermal conductivity values !> authors: Dr. Vikas Sharma ! ! This function returns the thermal conductivity values ! - `volFrac` contains volumetric fraction of solid, water, ice, air MODULE PURE FUNCTION johansen_getval ( Obj , volFrac_solid , volFrac_water , & & volFrac_ice , volFrac_air , Temp , x , y , z ) RESULT ( Ans ) CLASS ( ThermCondModel_ ), INTENT ( IN ) :: Obj REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: volFrac_solid REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: volFrac_water REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: volFrac_ice REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: volFrac_air REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: Temp REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: x REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: y REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: z REAL ( DFP ) :: Ans END FUNCTION johansen_getval END INTERFACE END MODULE ThermCondModel_Class","tags":"","loc":"sourcefile/thermcondmodel_class.f90.html"},{"title":"LinSolver_Class.f90 – Fortran Program","text":"Contents Modules LinSolver_Class Source Code LinSolver_Class.f90 Source Code MODULE LinSolver_Class !! This module defines an abstract class for a linear solver USE GlobalData USE BaseType #include \"lisf.h\" IMPLICIT NONE PRIVATE INTEGER ( I4B ), PARAMETER , PUBLIC :: & & lis_cg = 1 , & & lis_bcg = 2 , lis_bicg = 2 , & & lis_cgs = 3 , & & lis_bcgstab = 4 , lis_bicgstab = 4 , & & lis_bcgstabl = 5 , lis_bicgstabl = 5 , & & lis_gpbicg = 6 , & & lis_tfqmr = 7 , & & lis_omn = 8 , lis_fom = 8 , lis_orthomin = 8 , & & lis_gmres = 9 , lis_gmr = 9 , & & lis_jacobi = 10 , & & lis_gs = 11 , & & lis_sor = 12 , & & lis_bicgsafe = 13 , & & lis_cr = 14 , & & lis_bicr = 15 , & & lis_crs = 16 , & & lis_bicrstab = 17 , & & lis_gpbicr = 18 , & & lis_bicrsafe = 19 , & & lis_fgmres = 20 , & & lis_idrs = 21 , & & lis_idr1 = 22 , & & lis_minres = 23 , & & lis_cocg = 24 , & & lis_cocr = 25 , & & lis_cgnr = 26 , lis_cgn = 26 , & & lis_dbcg = 27 , & & lis_dqgmres = 28 INTEGER ( I4B ), PARAMETER , PUBLIC :: & & p_none = 0 , & & p_jacobi = 1 , & & p_iluk = 2 , & & p_ssor = 3 , & & p_hybrid = 4 , & & p_is = 5 , & & p_sainv = 6 , & & p_saamg = 7 , & & p_iluc = 8 , & & p_ilut = 9 , & & p_ilutp = 10 , & & p_ilud = 11 , & & p_iludp = 12 , & & p_ilu0 = 13 !---------------------------------------------------------------------------- !                                                                 Linsolver_ !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! [[linsolver_]] is an abstract class for solving system of linear equation ! ! @note ! It is important to node that [[linsolver_]] is created just to create an ! interface between `EASIFEM` library and other existing open-source ! and powerful linear solver libraries. ! @endnote ! !### Usage ! ! ```fortran !\tCALL Obj % Initiate( Obj, SolverName, MaxIter, SolverName & !    & <, diagScale, ipar, fpar> ) ! CALL Obj % setPrecondition( Obj, precondtype <,ipar, fpar> ) ! CALL Obj % setSparsity( From ) ! CALL Obj % setDirichletBCNodes( Nptrs, dofs ) ! CALL Obj % setMatrix( From ) ! CALL Obj % solve( sol, rhs ) ! CALL Obj % Display( msg <,unitno > ) ! CALL Obj % writeResidueHistory( path, prefix, fmt, iter ) ! CALL Obj % DeallocateData( ) ! ``` TYPE , ABSTRACT :: LinSolver_ INTEGER ( I4B ) :: solverName = 0 !! Solver name INTEGER ( I4B ) :: ierr = 0 !! error code returned by the solver INTEGER ( I4B ) :: tdof = 1 !! Total number of degrees of freedom per node INTEGER ( I4B ), ALLOCATABLE :: tNodes ( : ) !! Total number of spatial nodes in each dof INTEGER ( I4B ) :: storageFMT = Nodes_FMT !! storageFMT INTEGER ( I4B ) :: precondType = 0 !! Name of preconditioner INTEGER ( I4B ) :: myRank = 0 !! MPI Rank INTEGER ( I4B ) :: comm = 0 !! MPI COMM INTEGER ( I4B ) :: numproc = 0 !! Number of processor running CHARACTER ( LEN = 5 ) :: Matrixprop = \"UNSYM\" !! Matrix Property CONTAINS PROCEDURE ( ls_init ), PUBLIC , DEFERRED , PASS ( Obj ) :: Initiate !! Initiate the object PROCEDURE ( ls_set_precon ), PUBLIC , DEFERRED , PASS ( Obj ) :: setPrecondition !! Set preconditioner and its properties PROCEDURE ( ls_set_sparsity ), PUBLIC , DEFERRED , PASS ( To ) :: setSparsity !! Set sparsity pattern PROCEDURE ( ls_set_dbc_1 ), PUBLIC , DEFERRED , PASS ( Obj ) :: set_dbcNodes_1 !! Set Dirichlet boundary condition information PROCEDURE ( ls_set_dbc_2 ), PUBLIC , DEFERRED , PASS ( Obj ) :: set_dbcNodes_2 !! Set Dirichlet boundary condition information GENERIC , PUBLIC :: setDirichletBCNodes => set_dbcNodes_1 , set_dbcNodes_2 !! Set Dirichlet boundary condition information PROCEDURE ( ls_set_matrix ), PUBLIC , DEFERRED , PASS ( To ) :: setMatrix !! Set the matrix PROCEDURE ( ls_solve ), PUBLIC , DEFERRED , PASS ( Obj ) :: Solve !! Solve system of linear equation PROCEDURE ( ls_display ), PUBLIC , DEFERRED , PASS ( Obj ) :: Display !! Display the content PROCEDURE ( ls_w_res ), PUBLIC , DEFERRED , PASS ( Obj ) :: writeResidueHistory !! Write the residue history to a file PROCEDURE ( ls_deallocate ), PUBLIC , DEFERRED , PASS ( Obj ) :: DeallocateData !! Deallocate Data END TYPE LinSolver_ PUBLIC :: LinSolver_ !> This data type contains pointer to [[linsolver_]] TYPE :: LinSolverPointer_ CLASS ( LinSolver_ ), POINTER :: Ptr => NULL ( ) END TYPE LinSolverPointer_ !---------------------------------------------------------------------------- !                                                                 Sparsekit_ !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! [[Sparsekit_]] data type is a container around Yusef Saad's SparseKit ! lib. ! ! - Reference : https://www-users.cs.umn.edu/~saad/software/SPARSKIT/ ! - This class interface sparsekit and `EASIFEM` ! !### Usage ! ! ```fortran !\tCALL Obj % Initiate( Obj, SolverName, MaxIter, SolverName & !    & <, diagScale, ipar, fpar> ) ! CALL Obj % setPrecondition( Obj, precondtype <,ipar, fpar> ) ! CALL Obj % setSparsity( From ) ! CALL Obj % setDirichletBCNodes( Nptrs, dofs ) ! CALL Obj % setMatrix( From ) ! CALL Obj % solve( sol, rhs ) ! CALL Obj % Display( msg <,unitno > ) ! CALL Obj % writeResidueHistory( path, prefix, fmt, iter ) ! CALL Obj % DeallocateData( ) ! ``` ! !### Solver name ! ! !### Precondition Name ! ! !### Todo ! !@todo ! - Implement `ilutp` ans `iludp` preconditioners !@endtodo TYPE , EXTENDS ( LinSolver_ ) :: Sparsekit_ INTEGER ( I4B ), ALLOCATABLE :: dbcNptrs ( : ) !! Ids of nodal variables where Dirichlet boundary condition is imposed INTEGER ( I4B ), ALLOCATABLE :: dbcIndx ( : ) INTEGER ( I4B ), ALLOCATABLE :: dbcJA ( : ) INTEGER ( I4B ), ALLOCATABLE :: dbcIA ( : ) INTEGER ( I4B ), POINTER :: IA ( : ) => NULL ( ) !! CSR format INTEGER ( I4B ), POINTER :: JA ( : ) => NULL ( ) !! CSR format INTEGER ( I4B ), ALLOCATABLE :: JLU ( : ) !! Internal var INTEGER ( I4B ), ALLOCATABLE :: JU ( : ) !! Internal var INTEGER ( I4B ), ALLOCATABLE :: IPERM ( : ) !! Internal var INTEGER ( I4B ), ALLOCATABLE :: JW ( : ) !! Internal var REAL ( DFP ), POINTER :: A ( : ) => NULL ( ) !! CSR format REAL ( DFP ), ALLOCATABLE :: ALU ( : ) REAL ( DFP ), ALLOCATABLE :: WK ( : ) REAL ( DFP ), ALLOCATABLE :: W ( : ) REAL ( DFP ), ALLOCATABLE :: RES ( : ) REAL ( DFP ) :: fpar ( 14 ) = 0.0_DFP REAL ( DFP ) :: droptol = 0.0 REAL ( DFP ) :: permtol = 0.0 REAL ( DFP ) :: alpha = 0.0 INTEGER ( I4B ) :: ipar ( 14 ) = 0 INTEGER ( I4B ) :: lfil = 0 INTEGER ( I4B ) :: mbloc = 0 CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: Initiate => skit_initiate !! Initiate object PROCEDURE , PUBLIC , PASS ( Obj ) :: setPrecondition => skit_setprecond !! Set preconditioner properties PROCEDURE , PUBLIC , PASS ( To ) :: setSparsity => skit_set_sparsity !! Set sparsity pattern related information of tangent matrix PROCEDURE , PUBLIC , PASS ( Obj ) :: set_dbcNodes_1 => skit_setDBC_1 !! set Information about the Dirichlet boundary nodes PROCEDURE , PUBLIC , PASS ( Obj ) :: set_dbcNodes_2 => skit_setDBC_2 !! set Information about the Dirichlet boundary nodes PROCEDURE , PUBLIC , PASS ( To ) :: setMatrix => skit_setmatrix !! set/link tangent matrix to the linear solver engine PROCEDURE , PUBLIC , PASS ( Obj ) :: Solve => skit_solve !! Solve the system of linear equation PROCEDURE , PUBLIC , PASS ( Obj ) :: Display => skit_display !! Display the contents PROCEDURE , PUBLIC , PASS ( Obj ) :: writeResidueHistory => skit_write_res_his !! Output the residue history PROCEDURE , PUBLIC , PASS ( Obj ) :: DeallocateData => skit_deallocatedata !! DeallocateData END TYPE Sparsekit_ PUBLIC :: Sparsekit_ TYPE ( Sparsekit_ ), PUBLIC , PARAMETER :: & & TypeSparsekit = Sparsekit_ ( & & dbcNptrs = NULL ( ), & & dbcIndx = NULL ( ), & & dbcJA = NULL ( ), & & dbcIA = NULL ( ), & & JLU = null ( ), & & JU = null ( ), & & IPERM = null ( ), & & JW = NULL ( ), & & ALU = null ( ), & & WK = null ( ), & & W = null ( ), & & RES = null ( ) ) TYPE :: SparsekitPointer_ CLASS ( Sparsekit_ ), POINTER :: Ptr => NULL ( ) END TYPE SparsekitPointer_ PUBLIC :: SparsekitPointer_ !---------------------------------------------------------------------------- !                                                                      LIS_ !---------------------------------------------------------------------------- TYPE , EXTENDS ( LinSolver_ ) :: LIS_ TYPE ( LIS_MATRIX ) :: lis_mat = 0 TYPE ( LIS_VECTOR ) :: lis_rhs = 0 TYPE ( LIS_VECTOR ) :: lis_sol = 0 TYPE ( LIS_VECTOR ) :: lis_res = 0 TYPE ( LIS_PRECON ) :: lis_precon = 0 TYPE ( LIS_SOLVER ) :: lis_solver = 0 REAL ( DFP ), ALLOCATABLE :: A ( : ) INTEGER ( I4B ), ALLOCATABLE :: IA ( : ) INTEGER ( I4B ), ALLOCATABLE :: JA ( : ) INTEGER ( I4B ), ALLOCATABLE :: dbcNptrs ( : ) INTEGER ( I4B ), ALLOCATABLE :: dbcIndx ( : ) INTEGER ( I4B ), ALLOCATABLE :: dbcJA ( : ) INTEGER ( I4B ), ALLOCATABLE :: dbcIA ( : ) CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: Initiate => lis_initiate !! Initiate object PROCEDURE , PUBLIC , PASS ( Obj ) :: setPrecondition => lis_setprecond !! Set preconditioner properties PROCEDURE , PUBLIC , PASS ( To ) :: setSparsity => lis_set_sparsity !! Set sparsity pattern related information of tangent matrix PROCEDURE , PUBLIC , PASS ( Obj ) :: set_dbcNodes_1 => lis_setDBC_1 !! set Information about the Dirichlet boundary nodes PROCEDURE , PUBLIC , PASS ( Obj ) :: set_dbcNodes_2 => lis_setDBC_2 !! set Information about the Dirichlet boundary nodes PROCEDURE , PUBLIC , PASS ( To ) :: setMatrix => lis_setmatrix !! set/link tangent matrix to the linear solver engine PROCEDURE , PUBLIC , PASS ( Obj ) :: Solve => lis_solve_1 !! Solve the system of linear equation PROCEDURE , PUBLIC , PASS ( Obj ) :: Display => lis_display !! Display the contents PROCEDURE , PUBLIC , PASS ( Obj ) :: writeResidueHistory => lis_write_res_his !! Output the residue history PROCEDURE , PUBLIC , PASS ( Obj ) :: DeallocateData => lis_deallocatedata !! Deallocate Data END TYPE LIS_ PUBLIC :: LIS_ TYPE ( LIS_ ), PARAMETER , PUBLIC :: & & TypeLIS = LIS_ ( & & A = NULL ( ), & & IA = NULL ( ), & & JA = NULL ( ), & & dbcNptrs = NULL ( ), & & dbcIndx = NULL ( ), & & dbcJA = NULL ( ), & & dbcIA = NULL ( ) ) TYPE :: LisPointer_ CLASS ( Lis_ ), POINTER :: Ptr => NULL ( ) END TYPE LisPointer_ PUBLIC :: LisPointer_ !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- !---------------------------------------------------------------------------- !                                                                   Initiate !---------------------------------------------------------------------------- ABSTRACT INTERFACE SUBROUTINE ls_init ( Obj , SolverName , MaxIter , Tol , diagScale , ipar , fpar ) IMPORT :: LinSolver_ , DFP , I4B CLASS ( Linsolver_ ), INTENT ( INOUT ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Tol INTEGER ( I4B ), INTENT ( IN ) :: MaxIter INTEGER ( I4B ), INTENT ( IN ) :: SolverName INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: ipar ( : ) INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: diagScale REAL ( DFP ) , OPTIONAL , INTENT ( IN ) :: fpar ( : ) END SUBROUTINE ls_init END INTERFACE !---------------------------------------------------------------------------- !                                                            setPrecondioning !---------------------------------------------------------------------------- ABSTRACT INTERFACE SUBROUTINE ls_set_precon ( Obj , precondtype , ipar , fpar ) IMPORT :: LinSolver_ , DFP , I4B CLASS ( LinSolver_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: precondtype INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: ipar ( : ) REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: fpar ( : ) END SUBROUTINE ls_set_precon END INTERFACE !---------------------------------------------------------------------------- !                                                                setSparsity !---------------------------------------------------------------------------- ABSTRACT INTERFACE SUBROUTINE ls_set_sparsity ( From , To ) IMPORT :: LinSolver_ , SparseMatrix_ CLASS ( LinSolver_ ), INTENT ( INOUT ) :: To TYPE ( SparseMatrix_ ), INTENT ( IN ), TARGET :: From END SUBROUTINE ls_set_sparsity END INTERFACE !---------------------------------------------------------------------------- !                                                        setDirichletBCNodes !---------------------------------------------------------------------------- ABSTRACT INTERFACE SUBROUTINE ls_set_dbc_1 ( Obj , Nptrs , dofs ) IMPORT :: LinSolver_ , I4B CLASS ( LinSolver_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Nptrs ( : ), dofs ( : ) END SUBROUTINE ls_set_dbc_1 END INTERFACE ABSTRACT INTERFACE SUBROUTINE ls_set_dbc_2 ( Obj , Nptrs , dofs ) IMPORT :: LinSolver_ , IntVector_ , I4B CLASS ( LinSolver_ ), INTENT ( INOUT ) :: Obj TYPE ( IntVector_ ), INTENT ( IN ) :: Nptrs ( : ) INTEGER ( I4B ), INTENT ( IN ) :: dofs ( : ) END SUBROUTINE ls_set_dbc_2 END INTERFACE !---------------------------------------------------------------------------- !                                                                    Convert !---------------------------------------------------------------------------- ABSTRACT INTERFACE SUBROUTINE ls_set_matrix ( From , To ) IMPORT :: LinSolver_ , SparseMatrix_ CLASS ( LinSolver_ ), INTENT ( INOUT ) :: To TYPE ( SparseMatrix_ ), INTENT ( IN ), TARGET :: From END SUBROUTINE ls_set_matrix END INTERFACE !---------------------------------------------------------------------------- !                                                                       Solve !---------------------------------------------------------------------------- ! sol contains the initial guess ABSTRACT INTERFACE SUBROUTINE ls_solve ( Obj , sol , rhs ) IMPORT :: LinSolver_ , DFP CLASS ( LinSolver_ ), INTENT ( INOUT ) :: Obj REAL ( DFP ), INTENT ( INOUT ) :: sol ( : ) REAL ( DFP ), INTENT ( INOUT ) :: rhs ( : ) END SUBROUTINE ls_solve END INTERFACE !---------------------------------------------------------------------------- !                                                                    Display !---------------------------------------------------------------------------- ABSTRACT INTERFACE SUBROUTINE ls_display ( Obj , msg , unitno ) IMPORT :: LinSolver_ , I4B CLASS ( LinSolver_ ), INTENT ( IN ) :: Obj CHARACTER ( LEN = * ), INTENT ( IN ) :: msg INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: Unitno END SUBROUTINE ls_display END INTERFACE !---------------------------------------------------------------------------- !                                                          WriteResidueHisory !---------------------------------------------------------------------------- ABSTRACT INTERFACE SUBROUTINE ls_w_res ( Obj , path , prefix , fmt , iter ) IMPORT :: LinSolver_ , I4B CLASS ( LinSolver_ ), INTENT ( IN ) :: Obj CHARACTER ( LEN = * ), INTENT ( IN ) :: path , prefix , fmt INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: iter END SUBROUTINE ls_w_res END INTERFACE !---------------------------------------------------------------------------- !                                                             DeallocateData !---------------------------------------------------------------------------- ABSTRACT INTERFACE SUBROUTINE ls_deallocate ( Obj ) IMPORT :: LinSolver_ CLASS ( LinSolver_ ), INTENT ( INOUT ) :: Obj END SUBROUTINE ls_deallocate END INTERFACE !----------------------------------------------------------------------------- !                                                           Initiate@Methods !----------------------------------------------------------------------------- INTERFACE !! Initiate [[sparsekit_]] !> authors: Dr. Vikas Sharma ! ! This subroutine initiate the [[sparsekit_]] object ! ! - It sets the name of the solver ! - It sets the parameters related to the solver ! ! If name of the solver is `lis_gmres`, `lis_fgmres`, `lis_dqgmres`, ! or `lis_om` then `ipar(1)` denotes the number of restarts required in ! these algorithms. Default value is set to 20. MODULE SUBROUTINE skit_initiate ( Obj , SolverName , MaxIter , Tol , & & diagScale , ipar , fpar ) CLASS ( Sparsekit_ ), INTENT ( INOUT ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Tol INTEGER ( I4B ), INTENT ( IN ) :: MaxIter INTEGER ( I4B ), INTENT ( IN ) :: SolverName INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: ipar ( : ) INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: diagScale REAL ( DFP ) , OPTIONAL , INTENT ( IN ) :: fpar ( : ) END SUBROUTINE skit_initiate END INTERFACE !> Generic subroutine to initiate [[sparsekit_]] INTERFACE Initiate MODULE PROCEDURE skit_initiate END INTERFACE Initiate PUBLIC :: Initiate !---------------------------------------------------------------------------- !                                                  setPrecondioning@Methods !---------------------------------------------------------------------------- INTERFACE !! Set preconditioners in [[sparsekit_]] !> authors: Dr. Vikas Sharma ! ! This subroutine set the preconditioner required to solve system of ! linear equations by using the ! ! - For `precondType=p_ilut` `ipar( 1 )` denotes number of fills and `fpar(1)` ! denotes the dropping tolerance ! - For `p_ilutp`: !   - `ipar(1)` number of fills default is 10 !   - `ipar(2)` mbloc, default is size of problem !   - `fpar(1)` drop tolerance, default is 1.0E-4 !   - `fpar(2)` permutation tolerance, default is 0.5 ! - For `p_ilud` !   - `fpar(1)` denotes drop tolerance !   - `fpar(2)` denotes value of alpha ! - For `p_iludp` !   - `ipar(1)` denotes mbloc !   - `fpar(1)` denotes drop tolerance !   - `fpar(2)` denotes value of alpha !   - `fpar(3)` denotes permutation tolerance MODULE SUBROUTINE skit_setprecond ( Obj , precondtype , ipar , fpar ) CLASS ( Sparsekit_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: precondtype INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: ipar ( : ) REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: fpar ( : ) END SUBROUTINE skit_setprecond END INTERFACE !---------------------------------------------------------------------------- !                                                      setSparsity@Methods !---------------------------------------------------------------------------- INTERFACE !! Set sparsity pattern in [[sparsekit_]] !> authors: Dr. Vikas Sharma ! ! This subroutine set the sparsity pattern in [[sparsekit_]] MODULE SUBROUTINE skit_set_sparsity ( From , To ) CLASS ( Sparsekit_ ), INTENT ( INOUT ) :: To TYPE ( SparseMatrix_ ), INTENT ( IN ), TARGET :: From END SUBROUTINE skit_set_sparsity END INTERFACE !---------------------------------------------------------------------------- !                                              setDirichletBCNodes@Methods !---------------------------------------------------------------------------- INTERFACE !! set Dirichlet boundary condition information !> authors: Dr. Vikas Sharma ! ! This subroutine set the Dirichlet boundary condition in the linear solver ! In this case all DOFs have the same dirichlet nodes pointers ! `Nptrs` denotes the dirichlet node numbers ! `storageFMT` can be `DOF_FMT` or `Nodes_FMT` MODULE SUBROUTINE skit_setDBC_1 ( Obj , Nptrs , dofs ) CLASS ( Sparsekit_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Nptrs ( : ) INTEGER ( I4B ), INTENT ( IN ) :: dofs ( : ) END SUBROUTINE skit_setDBC_1 END INTERFACE INTERFACE !! set Dirichlet boundary condition information MODULE SUBROUTINE skit_setDBC_2 ( Obj , Nptrs , dofs ) CLASS ( Sparsekit_ ), INTENT ( INOUT ) :: Obj TYPE ( IntVector_ ), INTENT ( IN ) :: Nptrs ( : ) INTEGER ( I4B ), INTENT ( IN ) :: dofs ( : ) END SUBROUTINE skit_setDBC_2 END INTERFACE !---------------------------------------------------------------------------- !                                                          Convert@Methods !---------------------------------------------------------------------------- INTERFACE !! set Matrix MODULE SUBROUTINE skit_setmatrix ( From , To ) CLASS ( Sparsekit_ ), INTENT ( INOUT ) :: To TYPE ( SparseMatrix_ ), INTENT ( IN ), TARGET :: From END SUBROUTINE skit_setmatrix END INTERFACE !---------------------------------------------------------------------------- !                                                             Solve@Methods !---------------------------------------------------------------------------- ! sol contains the initial guess INTERFACE MODULE SUBROUTINE skit_solve ( Obj , sol , rhs ) CLASS ( Sparsekit_ ), INTENT ( INOUT ) :: Obj REAL ( DFP ), INTENT ( INOUT ) :: sol ( : ) REAL ( DFP ), INTENT ( INOUT ) :: rhs ( : ) END SUBROUTINE skit_solve END INTERFACE !---------------------------------------------------------------------------- !                                                          Display@Sparsekit !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE skit_display ( Obj , msg , unitno ) CLASS ( Sparsekit_ ), INTENT ( IN ) :: Obj CHARACTER ( LEN = * ), INTENT ( IN ) :: msg INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: Unitno END SUBROUTINE skit_display END INTERFACE INTERFACE Display MODULE PROCEDURE skit_display END INTERFACE Display PUBLIC :: Display !---------------------------------------------------------------------------- !                                                WriteResidueHisory@Sparsekit !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE skit_write_res_his ( Obj , path , prefix , fmt , iter ) CLASS ( Sparsekit_ ), INTENT ( IN ) :: Obj CHARACTER ( LEN = * ), INTENT ( IN ) :: path , prefix , fmt INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: iter END SUBROUTINE skit_write_res_his END INTERFACE !---------------------------------------------------------------------------- !                                                   DeallocateData@Sparsekit !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE skit_deallocatedata ( Obj ) CLASS ( Sparsekit_ ), INTENT ( INOUT ) :: Obj END SUBROUTINE skit_deallocatedata END INTERFACE INTERFACE DeallocateData MODULE PROCEDURE skit_deallocatedata END INTERFACE DeallocateData PUBLIC :: DeallocateData !---------------------------------------------------------------------------- !                                                        Initiate@Sparsekitt !---------------------------------------------------------------------------- !<--- tInit : denotes the diagonal scaling 0-> no; 1->Right; 2-> symm !<--- ipar( 1 ) : contains ell or restart or irestart !<--- fpar( 1 ) : contains value of omega INTERFACE MODULE SUBROUTINE lis_initiate ( Obj , SolverName , MaxIter , Tol , & & diagScale , ipar , fpar ) CLASS ( LIS_ ), INTENT ( INOUT ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Tol INTEGER ( I4B ), INTENT ( IN ) :: MaxIter , SolverName INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: ipar ( : ), diagScale REAL ( DFP ) , OPTIONAL , INTENT ( IN ) :: fpar ( : ) END SUBROUTINE lis_initiate END INTERFACE INTERFACE Initiate MODULE PROCEDURE lis_initiate END INTERFACE Initiate !---------------------------------------------------------------------------- !                                                 setPreconditioning@Methods !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE lis_setprecond ( Obj , precondtype , ipar , fpar ) CLASS ( LIS_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: precondtype INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: ipar ( : ) REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: fpar ( : ) END SUBROUTINE lis_setprecond END INTERFACE !---------------------------------------------------------------------------- !                                                        setSparsity@Methods !---------------------------------------------------------------------------- !<--- allocate Obj % A, Obj % IA, Obj % JA !<--- set size of Obj % lis_rhs, lis_sol, lis_mat !<--- set all values of lis_rhs and lis_sol to zero !<--- set csr INTERFACE MODULE SUBROUTINE lis_set_sparsity ( From , To ) CLASS ( LIS_ ), INTENT ( INOUT ) :: To TYPE ( SparseMatrix_ ), INTENT ( IN ), TARGET :: From END SUBROUTINE lis_set_sparsity END INTERFACE !---------------------------------------------------------------------------- !                                                setDirichletBCNodes@Methods !---------------------------------------------------------------------------- !<--- initiate dbcNptrs, dbcJA, dbcIndx, dbcIA INTERFACE MODULE SUBROUTINE lis_setDBC_1 ( Obj , Nptrs , dofs ) CLASS ( LIS_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Nptrs ( : ) INTEGER ( I4B ), INTENT ( IN ) :: dofs ( : ) END SUBROUTINE lis_setDBC_1 END INTERFACE INTERFACE MODULE SUBROUTINE lis_setDBC_2 ( Obj , Nptrs , dofs ) CLASS ( LIS_ ), INTENT ( INOUT ) :: Obj TYPE ( IntVector_ ), INTENT ( IN ) :: Nptrs ( : ) INTEGER ( I4B ), INTENT ( IN ) :: dofs ( : ) END SUBROUTINE lis_setDBC_2 END INTERFACE !---------------------------------------------------------------------------- !                                                            Convert@Methods !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE lis_setmatrix ( From , To ) CLASS ( LIS_ ), INTENT ( INOUT ) :: To TYPE ( SparseMatrix_ ), INTENT ( IN ), TARGET :: From END SUBROUTINE lis_setmatrix END INTERFACE !---------------------------------------------------------------------------- !                                                              Solve@Methods !---------------------------------------------------------------------------- ! sol contains the initial guess INTERFACE MODULE SUBROUTINE lis_solve_1 ( Obj , sol , rhs ) CLASS ( LIS_ ), INTENT ( INOUT ) :: Obj REAL ( DFP ), INTENT ( INOUT ) :: sol ( : ) REAL ( DFP ), INTENT ( INOUT ) :: rhs ( : ) END SUBROUTINE lis_solve_1 END INTERFACE !---------------------------------------------------------------------------- !                                                            Display@Methods !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE lis_display ( Obj , msg , unitno ) CLASS ( LIS_ ), INTENT ( IN ) :: Obj CHARACTER ( LEN = * ), INTENT ( IN ) :: msg INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: unitno END SUBROUTINE lis_display END INTERFACE INTERFACE Display MODULE PROCEDURE lis_display END INTERFACE Display !---------------------------------------------------------------------------- !                                                WriteResidueHistory@Methods !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE lis_write_res_his ( Obj , path , prefix , fmt , iter ) CLASS ( LIS_ ), INTENT ( IN ) :: Obj CHARACTER ( LEN = * ), INTENT ( IN ) :: path , prefix , fmt INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: iter END SUBROUTINE lis_write_res_his END INTERFACE !---------------------------------------------------------------------------- !                                                      DeallocateData@Methods !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE lis_deallocatedata ( Obj ) CLASS ( LIS_ ), INTENT ( INOUT ) :: Obj END SUBROUTINE lis_deallocatedata END INTERFACE INTERFACE DeallocateData MODULE PROCEDURE lis_deallocatedata END INTERFACE DeallocateData END MODULE LinSolver_Class","tags":"","loc":"sourcefile/linsolver_class.f90.html"},{"title":"Material_Class.f90 – Fortran Program","text":"Contents Modules Material_Class Source Code Material_Class.f90 Source Code MODULE Material_Class USE GlobalData USE ThermCondModel_Class USE volHeatCapModel_Class USE SFCCModel_Class IMPLICIT NONE PRIVATE !---------------------------------------------------------------------------- !                                                                  Material_ !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! `Material_` type contains materials properties TYPE :: Material_ REAL ( DFP ) :: thermCond = 0.0_DFP REAL ( DFP ) :: specificHeatCap = 0.0_DFP REAL ( DFP ) :: volHeatCap = 0.0_DFP REAL ( DFP ) :: thermDiffusivity = 0.0_DFP REAL ( DFP ) :: density = 0.0_DFP REAL ( DFP ) :: DynamicViscosity = 0.0_DFP REAL ( DFP ) :: meltTemp = 0.0_DFP REAL ( DFP ) :: boilTemp = 0.0_DFP REAL ( DFP ) :: criticalTemp = 0.0_DFP REAL ( DFP ) :: criticalPressure = 0.0_DFP REAL ( DFP ) :: triplePointPressure = 0.0_DFP REAL ( DFP ) :: triplePointTemp = 0.0_DFP REAL ( DFP ) :: latentHeatMelt = 0.0_DFP REAL ( DFP ) :: latentHeatBoil = 0.0_DFP REAL ( DFP ) :: volThermCoeff = 0.0_DFP REAL ( DFP ) :: bulkModulus = 0.0_DFP END TYPE Material_ PUBLIC :: Material_ TYPE ( Material_ ), PARAMETER , PUBLIC :: TypeMaterial = Material_ ( ) !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- TYPE :: MatetrialPointer_ CLASS ( Material_ ), POINTER :: Ptr => NULL ( ) END TYPE MatetrialPointer_ PUBLIC :: MatetrialPointer_ !---------------------------------------------------------------------------- !                                                                    Soil_ !---------------------------------------------------------------------------- #include \"./soils_define.inc\" #include \"./soil.inc\" END MODULE Material_Class","tags":"","loc":"sourcefile/material_class.f90.html"},{"title":"StdMaterials.f90 – Fortran Program","text":"Contents Modules StdMaterials Source Code StdMaterials.f90 Source Code MODULE StdMaterials USE GlobalData USE Material_Class #include \"./water.inc\" #include \"./ice.inc\" #include \"./air.inc\" #include \"./mineral.inc\" CONTAINS #include \"./waterfunctions.inc\" #include \"./icefunctions.inc\" #include \"./airfunctions.inc\" #include \"./mineralfunctions.inc\" END MODULE StdMaterials","tags":"","loc":"sourcefile/stdmaterials.f90.html"},{"title":"Material_Class_old.f90 – Fortran Program","text":"Contents Modules Material_Class Source Code Material_Class_old.f90 Source Code MODULE Material_Class USE BaseType USE GlobalData IMPLICIT NONE PRIVATE !---------------------------------------------------------------------------- !                                                                  Material_ !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! `Material_` type contains materials properties TYPE :: Material_ TYPE ( KeyValue_ ), ALLOCATABLE :: Props ( : ) !! Each entry in prop denotes a material parameter CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: Initiate => mat_initiate !! Construct the object PROCEDURE , PUBLIC , PASS ( Obj ) :: Append => mat_append !! Append value to the list PROCEDURE , PUBLIC , PASS ( Obj ) :: Size => mat_size !! get total number of properties/parameters PROCEDURE , PUBLIC , PASS ( Obj ) :: Property => mat_get_prop !! Returns property as a [keyvalue_] instance END TYPE Material_ PUBLIC :: Material_ TYPE ( Material_ ), PARAMETER , PUBLIC :: TypeMaterial = & & Material_ ( Props = NULL ( ) ) !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- INTERFACE !! Subroutine that constructs [[material_]] MODULE PURE SUBROUTINE mat_initiate ( Obj , tprop ) CLASS ( Material_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: tprop END SUBROUTINE mat_initiate END INTERFACE !> Generic subroutine to construct [[material_]] INTERFACE Initiate MODULE PROCEDURE mat_initiate END INTERFACE Initiate PUBLIC :: Initiate !---------------------------------------------------------------------------- !                                                                     Append !---------------------------------------------------------------------------- INTERFACE !! Append keyval object to [[material_]] MODULE PURE SUBROUTINE mat_append ( Obj , KeyValObj ) CLASS ( Material_ ), INTENT ( INOUT ) :: Obj TYPE ( KeyValue_ ), INTENT ( IN ) :: KeyValObj END SUBROUTINE mat_append END INTERFACE !---------------------------------------------------------------------------- !                                                                       Size !---------------------------------------------------------------------------- INTERFACE !! Get total number of parameters stored in [[material_]] MODULE PURE FUNCTION mat_size ( Obj ) RESULT ( Ans ) CLASS ( Material_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ) :: Ans END FUNCTION mat_size END INTERFACE !---------------------------------------------------------------------------- !                                                                   Property !---------------------------------------------------------------------------- INTERFACE !! Function that return a property as an instance of [[keyvalue_]] MODULE PURE FUNCTION mat_get_prop ( Obj , Key ) RESULT ( Ans ) CLASS ( Material_ ), INTENT ( IN ) :: Obj CHARACTER ( LEN = * ), INTENT ( IN ) :: Key TYPE ( KeyValue_ ) :: Ans END FUNCTION mat_get_prop END INTERFACE !---------------------------------------------------------------------------- !                                                             DeallocateData !---------------------------------------------------------------------------- INTERFACE !! Deallocate data stored in [[material_]] MODULE PURE SUBROUTINE mat_deallocate ( Obj ) CLASS ( Material_ ), INTENT ( INOUT ) :: Obj END SUBROUTINE mat_deallocate END INTERFACE INTERFACE DeallocateData MODULE PROCEDURE mat_deallocate END INTERFACE DeallocateData PUBLIC :: DeallocateData !---------------------------------------------------------------------------- !                                                                    Display !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE mat_display ( Obj , msg , unitno ) CLASS ( Material_ ), INTENT ( IN ) :: Obj CHARACTER ( LEN = * ), INTENT ( IN ) :: msg INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: unitno END SUBROUTINE mat_display END INTERFACE INTERFACE MODULE SUBROUTINE mat_display_vec ( Obj , msg , unitno ) TYPE ( Material_ ), INTENT ( IN ) :: Obj ( : ) CHARACTER ( LEN = * ), INTENT ( IN ) :: msg INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: unitno END SUBROUTINE mat_display_vec END INTERFACE INTERFACE Display MODULE PROCEDURE mat_display , mat_display_vec END INTERFACE Display PUBLIC :: Display !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- TYPE :: MatetrialPointer_ CLASS ( Material_ ), POINTER :: Ptr => NULL ( ) END TYPE MatetrialPointer_ PUBLIC :: MatetrialPointer_ END MODULE Material_Class","tags":"","loc":"sourcefile/material_class_old.f90.html"},{"title":"Kernel_Class.f90 – Fortran Program","text":"Contents Modules Kernel_Class Source Code Kernel_Class.f90 Source Code MODULE Kernel_Class USE EASIFEM IMPLICIT NONE PRIVATE #include \"./Kernel_Def.inc\" !---------------------------------------------------------------------------- !                                                                   Kernel_ !---------------------------------------------------------------------------- TYPE :: Kernel_ INTEGER ( I4B ) :: STATIC = ALGO_OPT_STATIC INTEGER ( I4B ) :: TRANSIENT = ALGO_OPT_TRANSIENT INTEGER ( I4B ) :: NSD = 2 !! Spatial dimension of problem INTEGER ( I4B ) :: NNT = 2 !! number of nodes in time finite element method INTEGER ( I4B ) :: tNODES = 0 !! total number of nodes in problem INTEGER ( I4B ) :: tELEMENTS = 0 !! total elements INTEGER ( I4B ) :: tDOF = 0 !! total number of degrees of freedom per node INTEGER ( I4B ) :: SpatialCoordType = 0 !! Spatial coordinate type INTEGER ( I4B ) :: OneD_Horizontal = NSD_1_HORIZONTAL INTEGER ( I4B ) :: OneD_Vertical = NSD_1_VERTICAL INTEGER ( I4B ) :: TwoD_Cartesian = NSD_2_CARTESIAN INTEGER ( I4B ) :: TwoD_AxiSymmetric = NSD_2_AXISYMMETRIC INTEGER ( I4B ) :: ThreeD = NSD_3 INTEGER ( I4B ), ALLOCATABLE :: OmegaNoToMaterials ( : ) !! Mesh region to material mapping INTEGER ( I4B ) :: tMaterials = 1 !! Total number of materials REAL ( DFP ) :: dt = 0.01_DFP , tn = 0.0_DFP , err = 0.0_DFP , err0 = 0.0_DFP REAL ( DFP ) :: err_res = 0.0_DFP , err0_res = 0.0_DFP REAL ( DFP ) :: tol_res = 1.0E-5 , tol_sol = 1.0E-5 !! Time step for solving dynamic/ transient problems REAL ( DFP ), ALLOCATABLE :: matprops ( :, : ) !! material properties INTEGER ( I4B ) :: ITER = 0 INTEGER ( I4B ) :: MAXITER = 100 INTEGER ( I4B ) :: ITS = 0 INTEGER ( I4B ) :: NTS = 0 !! maximum iteration number for linear iterative solver INTEGER ( I4B ) :: solverName = LIS_CG !! linear iterative solver name REAL ( DFP ) :: TOL = 1.0E-5 !! tolerance for linear iterative solver INTEGER ( I4B ) :: LIS_IPAR ( LIS_IPAR_LEN ) = 0 !! integer parameters for linear iterative solver REAL ( DFP ) :: LIS_FPAR ( LIS_FPAR_LEN ) = 0.0 !! real parameters for linear iterative solver INTEGER ( I4B ) :: precondType = P_ILUD !! linear iterative solver preconditioning INTEGER ( I4B ) :: PRECOND_IPAR ( LIS_PRECOND_IPAR_LEN ) = 0 !! integer parameters for linear iterative solver REAL ( DFP ) :: PRECOND_FPAR ( LIS_PRECOND_FPAR_LEN ) = 0.0 !! real parameter for linear iterative solver INTEGER ( I4B ), ALLOCATABLE :: OmegaNo (:) !! Id of cell mesh in domain INTEGER ( I4B ), ALLOCATABLE :: DBCinfo (:) !! Boundary info INTEGER ( I4B ), ALLOCATABLE :: Nptrs ( : ) !! Global Nptrs INTEGER ( I4B ), ALLOCATABLE :: local_nptrs ( : ) !! Local Nptrs TYPE ( IntVector_ ), ALLOCATABLE :: DB (:) !! DB(1) uniform pressure DB !! DB(2) hydrostate pressure DB !! DB(3) uniform discharge/flux NB !! DB(4) drainage/ filter / robin/ boundary NB TYPE ( RealVector_ ), ALLOCATABLE :: nodalVar ( : ) !! nodalVar( 1 ) :: pressure !! nodalVar( 2 ) :: right hand side (residual) !! nodalVar( 3 ) :: velocity TYPE ( DOF_ ), ALLOCATABLE :: dof ( : ) !! dof( 1 ) :: pressure !! dof( 2 ) :: right hand side (residual) !! dof( 3 ) :: velocity TYPE ( IntVector_ ), ALLOCATABLE :: intvec ( : ) CLASS ( Domain_ ), POINTER :: Dom => NULL ( ) CLASS ( SparseMatrix_ ), POINTER :: tanmat => NULL ( ) CLASS ( LinSolver_ ), POINTER :: linsol => NULL ( ) REAL ( DFP ), ALLOCATABLE :: meshq (:) ! TYPE( QuadratureVariables_ ) :: meshq !! Mesh quality PROCEDURE ( kernel_set_kernel ), POINTER , PASS ( Obj ) :: setKernel => NULL () PROCEDURE ( kernel_assemble ), POINTER , PASS ( Obj ) :: Assemble => NULL () PROCEDURE ( kernel_assemble ), POINTER , PASS ( Obj ) :: AssembleTanMat => NULL () PROCEDURE ( kernel_assemble ), POINTER , PASS ( Obj ) :: AssembleRHS => NULL () PROCEDURE ( kernel_solve ), POINTER , PASS ( Obj ) :: Solve => NULL () PROCEDURE ( kernel_update ), POINTER , PASS ( Obj ) :: Update => NULL () PROCEDURE ( kernel_isconverg ), POINTER , PASS ( Obj ) :: isConverged => NULL () PROCEDURE ( kernel_writedata ), POINTER , PASS ( Obj ) :: & & WriteData => NULL () PROCEDURE ( kernel_savestate ), POINTER , PASS ( Obj ) :: saveState => NULL () CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: Initiate => kernel_init PROCEDURE , PUBLIC , PASS ( Obj ) :: SetDomain => kernel_setdomain PROCEDURE , PUBLIC , PASS ( Obj ) :: setAlgorithm => kernel_setalgo PROCEDURE , PUBLIC , PASS ( Obj ) :: setLinearSolver => kernel_setlinsol PROCEDURE , PUBLIC , PASS ( Obj ) :: setPrecondition => kernel_setprecond PROCEDURE , PUBLIC , PASS ( Obj ) :: setTanMat => kernel_settanmat PROCEDURE , PUBLIC , PASS ( Obj ) :: Finalize => kernel_dealloc PROCEDURE , PUBLIC , PASS ( Obj ) :: getMeshQuality => kernel_mesh_quality PROCEDURE , PUBLIC , PASS ( Obj ) :: setTotalMaterials => set_total_materials PROCEDURE , PUBLIC , PASS ( Obj ) :: setMaterial => set_material END TYPE Kernel_ PUBLIC :: Kernel_ TYPE :: KernelPointer_ CLASS ( Kernel_ ), POINTER :: Ptr => NULL ( ) END TYPE KernelPointer_ PUBLIC :: KernelPointer_ !---------------------------------------------------------------------------- !                                                                   Initiate !---------------------------------------------------------------------------- INTERFACE !! This subroutine initiate the Kernel !> authors: Dr. Vikas Sharma ! ! This subroutine initiate the kernel ! - If `NNT` (num of nodes in time domain) is not given then `NNT=1` ! - `NSD` is the spatial dimension of the problem ! - `dt` is the time step size; default value is '1.0' MODULE SUBROUTINE kernel_init ( Obj , nsd , nnt , dt , SpatialCoordType , tn , & & NTS , tol_res , tol_sol ) CLASS ( Kernel_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: nsd INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: nnt REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: dt INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: SpatialCoordType INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: NTS REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: tn REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: tol_res REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: tol_sol END SUBROUTINE kernel_init END INTERFACE !---------------------------------------------------------------------------- !                                                                 SetDomain !---------------------------------------------------------------------------- INTERFACE !! This subroutine set the domain to the kernel !> authors: Dr. Vikas Sharma ! ! This subroutine set the domain to the kernel ! - Here `dom` is the `domain_` datatype ! - `omegaNo` is the IDs of regions which is required in the analysis ! - This subroutine will store information of `omegano` ! - It also prepares the mapping between local and global node numbers ! - Information such as, `obj%tnodes` and `obj%telements` are also stored ! inside the kernel ! ! Make sure that ! - `dom%omega` is allocated ! - `dom%nodes` is associated ! - `dom%omegano` contains valid pointer to elements of `dom%omega(:)` ! - `dom%omegano` contains MODULE SUBROUTINE kernel_setdomain ( Obj , dom , omegaNo ) CLASS ( Kernel_ ), INTENT ( INOUT ) :: Obj CLASS ( Domain_ ), TARGET , INTENT ( INOUT ) :: dom INTEGER ( I4B ), INTENT ( IN ) :: omegaNo (:) END SUBROUTINE kernel_setdomain END INTERFACE !---------------------------------------------------------------------------- !                                                      setMaterialProperties !---------------------------------------------------------------------------- INTERFACE !! This subroutine set the material propeties in the kernel !> authors: Dr. Vikas Sharma ! ! This subroutine set the material properties in the kernel ! `matprops` contains information about different materials ! Each column of `matprops` denote a material type ! This method can be extended by the other kernels MODULE SUBROUTINE kernel_setmatprops ( Obj , matprops ) CLASS ( Kernel_ ), INTENT ( INOUT ) :: Obj REAL ( DFP ), INTENT ( IN ) :: matprops (:,:) END SUBROUTINE kernel_setmatprops END INTERFACE !---------------------------------------------------------------------------- !                                                              setAlgorithm !---------------------------------------------------------------------------- INTERFACE !! This subroutine set the algorithm for the kernel !> authors: Dr. Vikas Sharma ! ! This subroutine set the algorithm of the Kernel ! This subroutine should be defined by specific kernel MODULE SUBROUTINE kernel_setalgo ( Obj , mainOption , extraOption ) CLASS ( Kernel_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: mainOption ( : ) INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: extraOption ( : ) END SUBROUTINE kernel_setalgo END INTERFACE !---------------------------------------------------------------------------- !                                                                 isConverge !---------------------------------------------------------------------------- ABSTRACT INTERFACE FUNCTION kernel_isconverg ( Obj , relTol , abstol , convergeInRes , convergeInSol ) & & RESULT ( Ans ) IMPORT :: Kernel_ , DFP , LGT CLASS ( Kernel_ ), INTENT ( INOUT ) :: Obj REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: relTol REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: absTol LOGICAL ( LGT ), OPTIONAL , INTENT ( IN ) :: convergeInRes LOGICAL ( LGT ), OPTIONAL , INTENT ( IN ) :: convergeInSol LOGICAL ( LGT ) :: Ans END FUNCTION kernel_isconverg END INTERFACE !---------------------------------------------------------------------------- !                                                                 setKernel !---------------------------------------------------------------------------- ABSTRACT INTERFACE SUBROUTINE kernel_set_kernel ( Obj ) IMPORT :: Kernel_ CLASS ( Kernel_ ), INTENT ( INOUT ) :: Obj END SUBROUTINE kernel_set_kernel END INTERFACE !---------------------------------------------------------------------------- !                                                                  Assemble !---------------------------------------------------------------------------- ABSTRACT INTERFACE SUBROUTINE kernel_assemble ( Obj ) IMPORT :: Kernel_ CLASS ( Kernel_ ), INTENT ( INOUT ) :: Obj END SUBROUTINE kernel_assemble END INTERFACE !---------------------------------------------------------------------------- !                                                                     Solve !---------------------------------------------------------------------------- ABSTRACT INTERFACE SUBROUTINE kernel_solve ( Obj ) IMPORT :: Kernel_ CLASS ( Kernel_ ), INTENT ( INOUT ) :: Obj END SUBROUTINE kernel_solve END INTERFACE !---------------------------------------------------------------------------- !                                                                     Update !---------------------------------------------------------------------------- ABSTRACT INTERFACE SUBROUTINE kernel_update ( Obj , reset ) IMPORT :: Kernel_ , LGT CLASS ( Kernel_ ), INTENT ( INOUT ) :: Obj LOGICAL ( LGT ), INTENT ( IN ) :: reset END SUBROUTINE kernel_update END INTERFACE !---------------------------------------------------------------------------- !                                                                 WriteData !---------------------------------------------------------------------------- ABSTRACT INTERFACE SUBROUTINE kernel_writedata ( Obj , gmsh , path , filename , extension , indx ) IMPORT :: Kernel_ , I4B , gmsh_ CLASS ( Kernel_ ), INTENT ( INOUT ) :: Obj TYPE ( gmsh_ ), OPTIONAL , INTENT ( INOUT ) :: gmsh CHARACTER ( LEN = * ), OPTIONAL , INTENT ( IN ) :: path , filename , extension INTEGER ( I4B ), INTENT ( IN ) :: indx (:) END SUBROUTINE kernel_writedata END INTERFACE !---------------------------------------------------------------------------- !                                                                 SaveState !---------------------------------------------------------------------------- ABSTRACT INTERFACE SUBROUTINE kernel_savestate ( Obj , Path , Filename , Extension , timestep ) IMPORT :: Kernel_ , I4B CLASS ( Kernel_ ), INTENT ( INOUT ) :: Obj CHARACTER ( LEN = * ), INTENT ( IN ) :: Path CHARACTER ( LEN = * ), INTENT ( IN ) :: Filename CHARACTER ( LEN = * ), INTENT ( IN ) :: Extension INTEGER ( I4B ), INTENT ( IN ) :: timestep END SUBROUTINE kernel_savestate END INTERFACE !---------------------------------------------------------------------------- !                                                            setLinearSolver !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE kernel_setlinsol ( Obj , name , maxiter , tol , fpar , ipar ) CLASS ( Kernel_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: name INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: maxiter INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: ipar ( : ) REAL ( DFP ) , OPTIONAL , INTENT ( IN ) :: tol REAL ( DFP ) , OPTIONAL , INTENT ( IN ) :: fpar ( : ) END SUBROUTINE kernel_setlinsol END INTERFACE !---------------------------------------------------------------------------- !                                                            setLinearSolver !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE kernel_setprecond ( Obj , name , fpar , ipar ) CLASS ( Kernel_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: name INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: ipar ( : ) REAL ( DFP ) , OPTIONAL , INTENT ( IN ) :: fpar ( : ) END SUBROUTINE kernel_setprecond END INTERFACE !---------------------------------------------------------------------------- !                                                           setTangentMatrix !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE kernel_settanmat ( Obj ) CLASS ( Kernel_ ), INTENT ( INOUT ) :: Obj END SUBROUTINE kernel_settanmat END INTERFACE !---------------------------------------------------------------------------- !                                                                   Finalize !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE kernel_dealloc ( Obj ) CLASS ( Kernel_ ), INTENT ( INOUT ) :: Obj END SUBROUTINE kernel_dealloc END INTERFACE !---------------------------------------------------------------------------- !                                                            getMeshQuality !---------------------------------------------------------------------------- INTERFACE !! This subroutine computes the mesh quality !> authors: Dr. Vikas Sharma ! ! This subroutine computes the mesh quality ! - if `q` is present then mesh-quality of each element will be returned in it !   otherwise meshquality will be stored in `obj%meshq` ! - `qmin` `qmax` and `qavg` are statistical parameters ! -`measure` is quality measure which can be !     - meshquality%area !     - meshquality%minAngle !     - meshquality%maxAngle !     - meshquality%angleRatio !     - meshquality%radiusRatio !     - meshquality%edgeRatio !     - meshquality%aspectRatio !     - meshquality%scaledJacobian ! - if `nodes` are not present then `dom%nodes` are used MODULE SUBROUTINE kernel_mesh_quality ( Obj , qmin , qmax , qavg , measure , q , & & nodes ) CLASS ( Kernel_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: measure REAL ( DFP ), INTENT ( INOUT ) :: qmin REAL ( DFP ), INTENT ( INOUT ) :: qmax REAL ( DFP ), INTENT ( INOUT ) :: qavg REAL ( DFP ), ALLOCATABLE , OPTIONAL , INTENT ( INOUT ) :: q ( : ) REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: nodes ( :, : ) END SUBROUTINE kernel_mesh_quality END INTERFACE !---------------------------------------------------------------------------- !                                              setTotalMaterials@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE set_total_materials ( Obj , tMaterials ) CLASS ( Kernel_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: tMaterials END SUBROUTINE set_total_materials END INTERFACE !---------------------------------------------------------------------------- !                                                    setMaterial@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE set_material ( Obj , materialNo ) CLASS ( Kernel_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: materialNo (:) END SUBROUTINE set_material END INTERFACE END MODULE Kernel_Class","tags":"","loc":"sourcefile/kernel_class.f90.html"},{"title":"BaseMethod.f90 – Fortran Program","text":"Contents Modules BaseMethod Source Code BaseMethod.f90 Source Code MODULE BaseMethod USE GlobalData USE IO USE Buffer_Method USE Utility USE ErrorHandling USE File_Method USE BoundingBox_Method USE AbstractArray_Method USE AbstractMatrix_Method USE AbstractVector_Method USE RealVector_Method USE IntVector_Method USE RealMatrix_Method USE SparseMatrix_Method USE IndexValue_Method USE DOF_Method USE IterationData_Method USE DISPMODULE USE KeyValue_Method USE Random_Method ! Tensor related USE VoigtRank2Tensor_Method USE Rank2Tensor_Method ! FE related USE ReferenceElement_Method ! Quadrature Point USE QuadraturePoint_Method ! Elemshapedata USE Elemshapedata_Method ! FE variable USE FEVariable_Method ! FE Matrix USE FEMatrix_Module END MODULE BaseMethod","tags":"","loc":"sourcefile/basemethod.f90.html"},{"title":"BaseType.f90 – Fortran Program","text":"Contents Modules BaseType Source Code BaseType.f90 Source Code MODULE BaseType USE GlobalData USE StringiFor , ONLY : string , adjustl , adjustr , count , index , len_trim , & & repeat , scan , trim , verify , read_file , read_lines , write_file , & & write_lines USE PENF , ONLY : STR , STRZ , CTON , BSTR , BCTON IMPLICIT NONE PRIVATE PUBLIC :: string , adjustl , adjustr , count , index , len_trim , & & repeat , scan , trim , verify , read_file , read_lines , write_file , & & write_lines PUBLIC :: STR , STRZ , CTON , BSTR , BCTON TYPE ( String ), PARAMETER , PUBLIC :: TypeString = String ( raw = NULL () ) !---------------------------------------------------------------------------- !                                                              StringPointer_ !---------------------------------------------------------------------------- TYPE :: StringPointer_ TYPE ( String ), POINTER :: Ptr => NULL () END TYPE StringPointer_ PUBLIC :: StringPointer_ !---------------------------------------------------------------------------- !                                                                   Buffer_ !---------------------------------------------------------------------------- TYPE :: Buffer_ TYPE ( StringPointer_ ), ALLOCATABLE :: Line ( : ) INTEGER ( I4B ) :: tLine = 0 END TYPE Buffer_ PUBLIC :: Buffer_ !---------------------------------------------------------------------------- !                                                                      File_ !---------------------------------------------------------------------------- TYPE :: File_ TYPE ( String ) :: FileName , Path , Extension , ACTION , STATUS , ACCESS INTEGER ( I4B ) :: UnitNo = 1 , WriteNo = 1 , IOSTAT = 1 LOGICAL ( LGT ) :: isOpen = . FALSE ., isBinary = . FALSE . CHARACTER ( LEN = 1 ) :: Comment = \"#\" CHARACTER ( LEN = 1 ) :: Separator = \",\" END TYPE File_ PUBLIC :: File_ TYPE ( File_ ), PUBLIC , PARAMETER :: TypeFile = & & File_ ( FileName = TypeString , Path = TypeString , Extension = TypeString , & & ACTION = TypeString , STATUS = TypeString , ACCESS = TypeString , & & UnitNo = - 1 , WriteNo = - 1 , IOSTAT = - 1 , isOpen = . FALSE . ) TYPE :: FilePointer_ CLASS ( File_ ), POINTER :: Ptr => NULL ( ) END TYPE FilePointer_ PUBLIC :: FilePointer_ !---------------------------------------------------------------------------- !                                                               BoundingBox_ !---------------------------------------------------------------------------- TYPE :: BoundingBox_ INTEGER ( I4B ) :: NSD REAL ( DFP ) :: Box ( 2 , 3 ) END TYPE BoundingBox_ PUBLIC :: BoundingBox_ TYPE ( BoundingBox_ ), PUBLIC , PARAMETER :: TypeBoundingBox = & & BoundingBox_ ( NSD = 0 , Box = 0 ) TYPE :: BoundingBoxPointer_ CLASS ( BoundingBoxPointer_ ), POINTER :: Ptr => NULL ( ) END TYPE BoundingBoxPointer_ PUBLIC :: BoundingBoxPointer_ !---------------------------------------------------------------------------- !                                                           AbstractArray_ !---------------------------------------------------------------------------- PUBLIC :: AbstractArray_ TYPE :: AbstractArray_ INTEGER ( I4B ) :: tDimension = 0_I4B END TYPE AbstractArray_ TYPE :: AbstractArrayPointer_ CLASS ( AbstractArray_ ), POINTER :: Ptr => NULL ( ) END TYPE AbstractArrayPointer_ PUBLIC :: AbstractArrayPointer_ !---------------------------------------------------------------------------- !                                                          AbstractMatrix_ !---------------------------------------------------------------------------- TYPE , EXTENDS ( AbstractArray_ ) :: AbstractMatrix_ END TYPE AbstractMatrix_ PUBLIC :: AbstractMatrix_ TYPE :: AbstractMatrixPointer_ CLASS ( AbstractMatrix_ ), POINTER :: Ptr => NULL ( ) END TYPE AbstractMatrixPointer_ PUBLIC :: AbstractMatrixPointer_ !---------------------------------------------------------------------------- !                                                                    Matrix_ !---------------------------------------------------------------------------- TYPE , EXTENDS ( AbstractMatrix_ ) :: RealMatrix_ REAL ( DFP ), ALLOCATABLE :: Val ( :, : ) CHARACTER ( LEN = 5 ) :: MatrixProp = 'UNSYM' END TYPE RealMatrix_ PUBLIC :: RealMatrix_ TYPE ( RealMatrix_ ), PUBLIC , PARAMETER :: & & TypeRealMatrix = RealMatrix_ ( & & Val = NULL () ) TYPE :: RealMatrixPointer_ CLASS ( RealMatrix_ ), POINTER :: Ptr => NULL ( ) END TYPE RealMatrixPointer_ PUBLIC :: RealMatrixPointer_ ! for matrix conversion ( dense to dense ) ! element matrix storage may differ from global matrix storage format INTEGER ( I4B ), PARAMETER , PUBLIC :: DofToNodes = 0 , NONE = - 1 , NodesToDOF = 1 INTEGER ( I4B ), PARAMETER , PUBLIC :: DOF_FMT = 0 INTEGER ( I4B ), PARAMETER , PUBLIC :: NODES_FMT = 1 INTEGER ( I4B ), PARAMETER , PUBLIC :: FMT_DOF = 0 INTEGER ( I4B ), PARAMETER , PUBLIC :: FMT_NODES = 1 !---------------------------------------------------------------------------- !                                                              SparseMatrix_ !---------------------------------------------------------------------------- TYPE , EXTENDS ( AbstractMatrix_ ) :: SparseMatrix_ TYPE ( IntVector_ ), ALLOCATABLE :: Row ( : ) INTEGER ( I4B ), ALLOCATABLE :: IA ( : ) INTEGER ( I4B ), ALLOCATABLE :: JA ( : ) INTEGER ( I4B ), ALLOCATABLE :: ColSize ( : ) INTEGER ( I4B ), ALLOCATABLE :: RowSize ( : ) INTEGER ( I4B ), ALLOCATABLE :: DiagIndx ( : ) REAL ( DFP ), ALLOCATABLE :: A ( : ), Diag ( : ) INTEGER ( I4B ) :: tDOF = 1 INTEGER ( I4B ) :: tNodes = 0 INTEGER ( I4B ) :: nnz = 0 INTEGER ( I4B ) :: ncol = 0 INTEGER ( I4B ) :: nrow = 0 CHARACTER ( LEN = 5 ) :: MatrixProp = 'UNSYM' INTEGER ( I4B ) :: StorageFMT = Nodes_FMT END TYPE SparseMatrix_ PUBLIC :: SparseMatrix_ TYPE ( SparseMatrix_ ), PUBLIC , PARAMETER :: & & TypeSparseMatrix = SparseMatrix_ ( & & Row = NULL ( ), & & IA = NULL ( ), & & JA = NULL ( ), & & ColSize = NULL ( ), & & RowSize = NULL ( ), & & DiagIndx = NULL ( ), & & A = NULL ( ), & & Diag = NULL ( ) ) TYPE :: SparseMatrixPointer_ CLASS ( SparseMatrix_ ), POINTER :: Ptr => NULL ( ) END TYPE SparseMatrixPointer_ PUBLIC :: SparseMatrixPointer_ !---------------------------------------------------------------------------- !                                                          AbstractVector_ !---------------------------------------------------------------------------- TYPE , EXTENDS ( AbstractArray_ ) :: AbstractVector_ END TYPE AbstractVector_ PUBLIC :: AbstractVector_ TYPE :: AbstractVectorPointer_ CLASS ( AbstractVector_ ), POINTER :: Ptr => NULL ( ) END TYPE AbstractVectorPointer_ !---------------------------------------------------------------------------- !                                                             IntVector_ !---------------------------------------------------------------------------- TYPE , EXTENDS ( AbstractVector_ ) :: IntVector_ INTEGER ( I4B ), ALLOCATABLE :: Val ( : ) END TYPE IntVector_ PUBLIC :: IntVector_ TYPE ( IntVector_ ), PUBLIC , PARAMETER :: TypeIntVector = IntVector_ ( & tDimension = 1_I4B , Val = NULL ( ) ) TYPE :: IntVectorPointer_ CLASS ( IntVector_ ), POINTER :: Ptr => NULL ( ) END TYPE IntVectorPointer_ PUBLIC :: IntVectorPointer_ !---------------------------------------------------------------------------- !                                                             RealVector_ !---------------------------------------------------------------------------- TYPE , EXTENDS ( AbstractVector_ ) :: RealVector_ REAL ( DFP ), ALLOCATABLE :: Val ( : ) END TYPE RealVector_ PUBLIC :: RealVector_ TYPE ( RealVector_ ), PUBLIC , PARAMETER :: TypeRealVector = RealVector_ ( & tDimension = 1_I4B , Val = NULL ( ) ) TYPE :: RealVectorPointer_ CLASS ( RealVector_ ), POINTER :: Ptr => NULL ( ) END TYPE RealVectorPointer_ PUBLIC :: RealVectorPointer_ !---------------------------------------------------------------------------- !                                                              IndexValue_ !---------------------------------------------------------------------------- TYPE :: IndexValue_ INTEGER ( I4B ) :: Indx REAL ( DFP ) :: Val END TYPE PUBLIC :: IndexValue_ TYPE ( IndexValue_ ), PUBLIC , PARAMETER :: TypeIndexValue = & & IndexValue_ ( Indx = 0 , Val = 0.0_DFP ) TYPE :: IndexValuePointer_ CLASS ( IndexValue_ ), POINTER :: Ptr => NULL ( ) END TYPE IndexValuePointer_ PUBLIC :: IndexValuePointer_ !---------------------------------------------------------------------------- !                                                                     DOF_ !---------------------------------------------------------------------------- TYPE :: DOF_ INTEGER ( I4B ), ALLOCATABLE :: MAP ( :, : ) INTEGER ( I4B ), ALLOCATABLE :: ValMap ( : ) INTEGER ( I4B ) :: StorageFMT = Nodes_FMT END TYPE DOF_ PUBLIC :: DOF_ TYPE ( DOF_ ), PUBLIC , PARAMETER :: TypeDOF = DOF_ ( MAP = NULL (), & ValMap = NULL (), StorageFMT = Nodes_FMT ) TYPE :: DOFPointer_ CLASS ( DOF_ ), POINTER :: Ptr => NULL ( ) END TYPE DOFPointer_ PUBLIC :: DOFPointer_ !---------------------------------------------------------------------------- !                                                             IterationData_ !---------------------------------------------------------------------------- TYPE :: IterationData_ INTEGER ( I4B ) :: MaxIter = 100 , IterationNumber = 0 REAL ( DFP ) :: Tolerance = 1.0E-5 REAL ( DFP ) :: ErrorAtStart = 0.0 , ErrorAtEnd = 0.0 REAL ( DFP ) :: TimeAtStart = 0.0 , TimeAtEnd = 0.0 INTEGER ( I4B ) :: ConvergenceType = RelativeConvergence INTEGER ( I4B ) :: ConvergenceIn = ConvergenceInRes INTEGER ( I4B ) :: NormType = NormL2 LOGICAL ( LGT ) :: Converged = . FALSE . END TYPE IterationData_ PUBLIC :: IterationData_ TYPE ( IterationData_ ), PUBLIC , PARAMETER :: TypeIterationData = & & IterationData_ ( ) TYPE :: IterationDataPointer_ CLASS ( IterationData_ ), POINTER :: Ptr => NULL ( ) END TYPE IterationDataPointer_ PUBLIC :: IterationDataPointer_ !---------------------------------------------------------------------------- !                                                  TensorRelatedParameters !---------------------------------------------------------------------------- INTEGER ( I4B ), PARAMETER , PUBLIC :: SymTensor = 1 , SkewSymTensor = - 1 , & & GeneralTensor = 0 , StressTypeVoigt = 1 , StrainTypeVoigt = - 1 , & & WithSpectral = 1 , WithoutSpectral = - 1 , SineLode = 1 , CosineLode = 0 !---------------------------------------------------------------------------- !                                                       VoigtRank2Tensor_ !---------------------------------------------------------------------------- TYPE :: VoigtRank2Tensor_ REAL ( DFP ) :: V ( 9 ) END TYPE VoigtRank2Tensor_ PUBLIC :: VoigtRank2Tensor_ TYPE ( VoigtRank2Tensor_ ), PARAMETER , PUBLIC :: & & TypeVoigtRank2Tensor = VoigtRank2Tensor_ ( V = 0.0_DFP ) TYPE :: VoigtRank2TensorPointer CLASS ( VoigtRank2Tensor_ ), POINTER :: Ptr => NULL ( ) END TYPE VoigtRank2TensorPointer PUBLIC :: VoigtRank2TensorPointer !---------------------------------------------------------------------------- !                                                                  Tensor_ !---------------------------------------------------------------------------- TYPE :: Tensor_ END TYPE Tensor_ !---------------------------------------------------------------------------- !                                                              Rank2Tensor_ !---------------------------------------------------------------------------- TYPE , EXTENDS ( Tensor_ ) :: Rank2Tensor_ REAL ( DFP ) :: T ( 3 , 3 ) END TYPE Rank2Tensor_ PUBLIC :: Rank2Tensor_ TYPE ( Rank2Tensor_ ), PARAMETER , PUBLIC :: & & TypeRank2Tensor = Rank2Tensor_ ( T = 0.0_DFP ) TYPE :: Rank2TensorPointer_ CLASS ( Rank2Tensor_ ), POINTER :: Ptr => NULL ( ) END TYPE Rank2TensorPointer_ PUBLIC :: Rank2TensorPointer_ !---------------------------------------------------------------------------- !                                                       ReferenceTopology_ !---------------------------------------------------------------------------- TYPE :: ReferenceTopology_ INTEGER ( I4B ), ALLOCATABLE :: Nptrs ( : ) INTEGER ( I4B ) :: Name , XiDimension END TYPE ReferenceTopology_ PUBLIC :: ReferenceTopology_ TYPE :: ReferenceTopologyPointer_ CLASS ( ReferenceTopology_ ), POINTER :: Ptr => NULL ( ) END TYPE ReferenceTopologyPointer_ PUBLIC :: ReferenceTopologyPointer_ !---------------------------------------------------------------------------- !                                                        ReferenceElement_ !---------------------------------------------------------------------------- TYPE :: ReferenceElement_ REAL ( DFP ), ALLOCATABLE :: XiJ ( :, : ) INTEGER ( I4B ) :: EntityCounts ( 4 ) INTEGER ( I4B ) :: XiDimension , Name , Order , NSD TYPE ( ReferenceTopology_ ), ALLOCATABLE :: Topology ( : ) CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: LagrangePoints => lp_refelem PROCEDURE , PUBLIC , PASS ( Obj ) :: LagrangeElement => lag_elem_refelem END TYPE ReferenceElement_ PUBLIC :: ReferenceElement_ TYPE :: ReferenceElementPointer_ CLASS ( ReferenceElement_ ), POINTER :: Ptr => NULL ( ) END TYPE ReferenceElementPointer_ PUBLIC :: ReferenceElementPointer_ INTERFACE MODULE PURE FUNCTION lp_refelem ( Obj , Order ) RESULT ( Ans ) CLASS ( ReferenceElement_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Order REAL ( DFP ), ALLOCATABLE :: Ans ( :, : ) END FUNCTION lp_refelem MODULE FUNCTION lag_elem_refelem ( Obj , Order ) RESULT ( Ans ) CLASS ( ReferenceElement_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Order CLASS ( ReferenceElement_ ), POINTER :: Ans END FUNCTION lag_elem_refelem END INTERFACE !---------------------------------------------------------------------------- !                                                          ReferenceLine_ !---------------------------------------------------------------------------- TYPE , EXTENDS ( ReferenceElement_ ) :: ReferenceLine_ CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: LagrangePoints => lp_refelem_line PROCEDURE , PUBLIC , PASS ( Obj ) :: LagrangeElement => lag_elem_refLine END TYPE ReferenceLine_ PUBLIC :: ReferenceLine_ TYPE ( ReferenceLine_ ), PARAMETER , PUBLIC :: & & TypeReferenceLine = ReferenceLine_ ( & & XiJ = NULL ( ), EntityCounts = [ 0 , 0 , 0 , 0 ], XiDimension = 0 , Name = 0 , & & Topology = NULL ( ), Order = 0 , NSD = 0 ) INTERFACE MODULE PURE FUNCTION lp_refelem_line ( Obj , Order ) RESULT ( Ans ) CLASS ( ReferenceLine_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Order REAL ( DFP ), ALLOCATABLE :: Ans ( :, : ) END FUNCTION lp_refelem_line MODULE FUNCTION lag_elem_refline ( Obj , Order ) RESULT ( Ans ) CLASS ( ReferenceLine_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Order CLASS ( ReferenceElement_ ), POINTER :: Ans END FUNCTION lag_elem_refline END INTERFACE !---------------------------------------------------------------------------- !                                                      ReferenceTriangle_ !---------------------------------------------------------------------------- TYPE , EXTENDS ( ReferenceElement_ ) :: ReferenceTriangle_ CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: LagrangePoints => lp_refelem_Triangle PROCEDURE , PUBLIC , PASS ( Obj ) :: LagrangeElement => lag_elem_refTriangle END TYPE ReferenceTriangle_ PUBLIC :: ReferenceTriangle_ TYPE ( ReferenceTriangle_ ), PARAMETER , PUBLIC :: & & TypeReferenceTriangle = ReferenceTriangle_ ( & & XiJ = NULL ( ), EntityCounts = [ 0 , 0 , 0 , 0 ], XiDimension = 0 , Name = 0 , & & Topology = NULL ( ), Order = 0 , NSD = 0 ) INTERFACE MODULE PURE FUNCTION lp_refelem_Triangle ( Obj , Order ) RESULT ( Ans ) CLASS ( ReferenceTriangle_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Order REAL ( DFP ), ALLOCATABLE :: Ans ( :, : ) END FUNCTION lp_refelem_Triangle MODULE FUNCTION lag_elem_refTriangle ( Obj , Order ) RESULT ( Ans ) CLASS ( ReferenceTriangle_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Order CLASS ( ReferenceElement_ ), POINTER :: Ans END FUNCTION lag_elem_refTriangle END INTERFACE !---------------------------------------------------------------------------- !                                                    ReferenceQuadrangle_ !---------------------------------------------------------------------------- TYPE , EXTENDS ( ReferenceElement_ ) :: ReferenceQuadrangle_ CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: LagrangePoints => lp_refelem_Quadrangle PROCEDURE , PUBLIC , PASS ( Obj ) :: LagrangeElement => lag_elem_refQuadrangle END TYPE ReferenceQuadrangle_ PUBLIC :: ReferenceQuadrangle_ TYPE ( ReferenceQuadrangle_ ), PARAMETER , PUBLIC :: & & TypeReferenceQuadrangle & & = ReferenceQuadrangle_ ( & & XiJ = NULL ( ), EntityCounts = [ 0 , 0 , 0 , 0 ], XiDimension = 0 , Name = 0 , & & Topology = NULL ( ), Order = 0 , NSD = 0 ) INTERFACE MODULE PURE FUNCTION lp_refelem_Quadrangle ( Obj , Order ) RESULT ( Ans ) CLASS ( ReferenceQuadrangle_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Order REAL ( DFP ), ALLOCATABLE :: Ans ( :, : ) END FUNCTION lp_refelem_Quadrangle MODULE FUNCTION lag_elem_refQuadrangle ( Obj , Order ) RESULT ( Ans ) CLASS ( ReferenceQuadrangle_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Order CLASS ( ReferenceElement_ ), POINTER :: Ans END FUNCTION lag_elem_refQuadrangle END INTERFACE !---------------------------------------------------------------------------- !                                                    ReferenceTetrahedron_ !---------------------------------------------------------------------------- TYPE , EXTENDS ( ReferenceElement_ ) :: ReferenceTetrahedron_ CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: LagrangePoints => lp_refelem_Tetrahedron PROCEDURE , PUBLIC , PASS ( Obj ) :: LagrangeElement => lag_elem_refTetrahedron END TYPE ReferenceTetrahedron_ PUBLIC :: ReferenceTetrahedron_ TYPE ( ReferenceTetrahedron_ ), PARAMETER , PUBLIC :: & & TypeReferenceTetrahedron & & = ReferenceTetrahedron_ ( & & XiJ = NULL ( ), EntityCounts = [ 0 , 0 , 0 , 0 ], XiDimension = 0 , Name = 0 , & & Topology = NULL ( ), Order = 0 , NSD = 0 ) INTERFACE MODULE PURE FUNCTION lp_refelem_Tetrahedron ( Obj , Order ) RESULT ( Ans ) CLASS ( ReferenceTetrahedron_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Order REAL ( DFP ), ALLOCATABLE :: Ans ( :, : ) END FUNCTION lp_refelem_Tetrahedron MODULE FUNCTION lag_elem_refTetrahedron ( Obj , Order ) RESULT ( Ans ) CLASS ( ReferenceTetrahedron_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Order CLASS ( ReferenceElement_ ), POINTER :: Ans END FUNCTION lag_elem_refTetrahedron END INTERFACE !---------------------------------------------------------------------------- !                                                     ReferenceHexahedron_ !---------------------------------------------------------------------------- TYPE , EXTENDS ( ReferenceElement_ ) :: ReferenceHexahedron_ CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: LagrangePoints => lp_refelem_Hexahedron PROCEDURE , PUBLIC , PASS ( Obj ) :: LagrangeElement => lag_elem_refHexahedron END TYPE ReferenceHexahedron_ PUBLIC :: ReferenceHexahedron_ TYPE ( ReferenceHexahedron_ ), PARAMETER , PUBLIC :: & & TypeReferenceHexahedron & & = ReferenceHexahedron_ ( & & XiJ = NULL ( ), EntityCounts = [ 0 , 0 , 0 , 0 ], XiDimension = 0 , Name = 0 , & & Topology = NULL ( ), Order = 0 , NSD = 0 ) INTERFACE MODULE PURE FUNCTION lp_refelem_Hexahedron ( Obj , Order ) RESULT ( Ans ) CLASS ( ReferenceHexahedron_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Order REAL ( DFP ), ALLOCATABLE :: Ans ( :, : ) END FUNCTION lp_refelem_Hexahedron MODULE FUNCTION lag_elem_refHexahedron ( Obj , Order ) RESULT ( Ans ) CLASS ( ReferenceHexahedron_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Order CLASS ( ReferenceElement_ ), POINTER :: Ans END FUNCTION lag_elem_refHexahedron END INTERFACE !---------------------------------------------------------------------------- !                                                            ReferencePrism_ !---------------------------------------------------------------------------- TYPE , EXTENDS ( ReferenceElement_ ) :: ReferencePrism_ CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: LagrangePoints => lp_refelem_Prism PROCEDURE , PUBLIC , PASS ( Obj ) :: LagrangeElement => lag_elem_refPrism END TYPE ReferencePrism_ PUBLIC :: ReferencePrism_ TYPE ( ReferencePrism_ ), PARAMETER , PUBLIC :: TypeReferencePrism & & = ReferencePrism_ ( & & XiJ = NULL ( ), EntityCounts = [ 0 , 0 , 0 , 0 ], XiDimension = 0 , Name = 0 , & & Topology = NULL ( ), Order = 0 , NSD = 0 ) INTERFACE MODULE PURE FUNCTION lp_refelem_Prism ( Obj , Order ) RESULT ( Ans ) CLASS ( ReferencePrism_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Order REAL ( DFP ), ALLOCATABLE :: Ans ( :, : ) END FUNCTION lp_refelem_Prism MODULE FUNCTION lag_elem_refPrism ( Obj , Order ) RESULT ( Ans ) CLASS ( ReferencePrism_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Order CLASS ( ReferenceElement_ ), POINTER :: Ans END FUNCTION lag_elem_refPrism END INTERFACE !---------------------------------------------------------------------------- !                                                          ReferencePyramid_ !---------------------------------------------------------------------------- TYPE , EXTENDS ( ReferenceElement_ ) :: ReferencePyramid_ CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: LagrangePoints => lp_refelem_Pyramid PROCEDURE , PUBLIC , PASS ( Obj ) :: LagrangeElement => lag_elem_refPyramid END TYPE ReferencePyramid_ PUBLIC :: ReferencePyramid_ TYPE ( ReferencePyramid_ ), PARAMETER , PUBLIC :: TypeReferencePyramid & & = ReferencePyramid_ ( & & XiJ = NULL ( ), EntityCounts = [ 0 , 0 , 0 , 0 ], & & XiDimension = 0 , Name = 0 , & & Topology = NULL ( ), Order = 0 , NSD = 0 ) INTERFACE MODULE PURE FUNCTION lp_refelem_Pyramid ( Obj , Order ) RESULT ( Ans ) CLASS ( ReferencePyramid_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Order REAL ( DFP ), ALLOCATABLE :: Ans ( :, : ) END FUNCTION lp_refelem_Pyramid MODULE FUNCTION lag_elem_refPyramid ( Obj , Order ) RESULT ( Ans ) CLASS ( ReferencePyramid_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Order CLASS ( ReferenceElement_ ), POINTER :: Ans END FUNCTION lag_elem_refPyramid END INTERFACE !---------------------------------------------------------------------------- !                                                                 KeyValue_ !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! [[keyvalue_]] is a poor implementation of dict TYPE :: KeyValue_ INTEGER ( I4B ) :: DataType = 0 TYPE ( String ) :: Key REAL ( DFP ), ALLOCATABLE :: Value ( :, : ) END TYPE KeyValue_ PUBLIC :: KeyValue_ TYPE ( KeyValue_ ), PARAMETER , PUBLIC :: TypeKeyValue = & & KeyValue_ ( Value = NULL ( ), Key = TypeString ) !---------------------------------------------------------------------------- !                                                                FEVariable_ !---------------------------------------------------------------------------- TYPE :: FEVariable_ REAL ( DFP ), ALLOCATABLE :: R1 ( : ), R2 ( :, : ), R3 ( :, :, : ), & & R4 ( :, :, :, :) REAL ( DFP ) :: R0 = 0. INTEGER ( I4B ) :: DefineOn = 0 !Nodal, Quadrature INTEGER ( I4B ) :: VarType = 0 !Space, SpaceTime, Constant INTEGER ( I4B ) :: Rank = 0 ! Scalar, Vector, Matrix INTEGER ( I4B ) :: CaseType = 0 END TYPE FEVariable_ PUBLIC :: FEVariable_ TYPE ( FEVariable_ ), PARAMETER , PUBLIC :: TypeFEVariable = & & FEVariable_ ( R1 = NULL ( ), R2 = NULL ( ), R3 = NULL ( ), & & R4 = NULL ( ) ) INTEGER ( I4B ), PARAMETER , PUBLIC :: Constant = 0 INTEGER ( I4B ), PARAMETER , PUBLIC :: Space = 1 INTEGER ( I4B ), PARAMETER , PUBLIC :: SpaceTime = 2 INTEGER ( I4B ), PARAMETER , PUBLIC :: Time = 3 INTEGER ( I4B ), PARAMETER , PUBLIC :: Scalar = 0 , Vector = 1 , Matrix = 2 INTEGER ( I4B ), PARAMETER , PUBLIC :: Nodal = 1 , Quadrature = 2 !---------------------------------------------------------------------------- !                                                         FEVariableConstant_ !---------------------------------------------------------------------------- TYPE :: FEVariableConstant_ INTEGER ( I4B ) :: Val = 1 END TYPE FEVariableConstant_ PUBLIC :: FEVariableConstant_ TYPE ( FEVariableConstant_ ), PARAMETER , PUBLIC :: TypeFEVariableConstant = & & FEVariableConstant_ ( 1_I4B ) TYPE ( FEVariableConstant_ ), PARAMETER , PUBLIC :: TypeVariableConstant = & & FEVariableConstant_ ( 1_I4B ) !---------------------------------------------------------------------------- !                                                           FEVariableSpace_ !---------------------------------------------------------------------------- TYPE :: FEVariableSpace_ INTEGER ( I4B ) :: Val = 2 END TYPE FEVariableSpace_ PUBLIC :: FEVariableSpace_ TYPE ( FEVariableSpace_ ), PARAMETER , PUBLIC :: TypeFEVariableSpace = & & FEVariableSpace_ ( 2_I4B ) TYPE ( FEVariableSpace_ ), PARAMETER , PUBLIC :: TypeVariableSpace = & & FEVariableSpace_ ( 2_I4B ) !---------------------------------------------------------------------------- !                                                       FEVariableSpaceTime_ !---------------------------------------------------------------------------- TYPE :: FEVariableSpaceTime_ INTEGER ( I4B ) :: Val = 3 END TYPE FEVariableSpaceTime_ PUBLIC :: FEVariableSpaceTime_ TYPE ( FEVariableSpaceTime_ ), PARAMETER , PUBLIC :: & & TypeFEVariableSpaceTime = FEVariableSpaceTime_ ( 3_I4B ) TYPE ( FEVariableSpaceTime_ ), PARAMETER , PUBLIC :: & & TypeVariableSpaceTime = FEVariableSpaceTime_ ( 3_I4B ) !---------------------------------------------------------------------------- !                                                            FEVariableTime_ !---------------------------------------------------------------------------- TYPE :: FEVariableTime_ INTEGER ( I4B ) :: Val = 4 END TYPE FEVariableTime_ PUBLIC :: FEVariableTime_ TYPE ( FEVariableTime_ ), PARAMETER , PUBLIC :: TypeFEVariableTime = & & FEVariableTime_ ( 4_I4B ) TYPE ( FEVariableTime_ ), PARAMETER , PUBLIC :: TypeVariableTime = & & FEVariableTime_ ( 4_I4B ) !---------------------------------------------------------------------------- !                                                          FEVariableScalar_ !---------------------------------------------------------------------------- TYPE :: FEVariableScalar_ INTEGER ( I4B ) :: Val = 0 END TYPE FEVariableScalar_ PUBLIC :: FEVariableScalar_ TYPE ( FEVariableScalar_ ), PARAMETER , PUBLIC :: & & TypeFEVariableScalar = FEVariableScalar_ ( 0_I4B ) TYPE ( FEVariableScalar_ ), PARAMETER , PUBLIC :: & & TypeVariableScalar = FEVariableScalar_ ( 0_I4B ) !---------------------------------------------------------------------------- !                                                          FEVariableVector_ !---------------------------------------------------------------------------- TYPE :: FEVariableVector_ INTEGER ( I4B ) :: Val = 1 END TYPE FEVariableVector_ PUBLIC :: FEVariableVector_ TYPE ( FEVariableVector_ ), PARAMETER , PUBLIC :: & & TypeFEVariableVector = FEVariableVector_ ( 1_I4B ) TYPE ( FEVariableVector_ ), PARAMETER , PUBLIC :: & & TypeVariableVector = FEVariableVector_ ( 1_I4B ) !---------------------------------------------------------------------------- !                                                          FEVariableMatrix_ !---------------------------------------------------------------------------- TYPE :: FEVariableMatrix_ INTEGER ( I4B ) :: Val = 2 END TYPE FEVariableMatrix_ PUBLIC :: FEVariableMatrix_ TYPE ( FEVariableMatrix_ ), PARAMETER , PUBLIC :: & & TypeFEVariableMatrix = FEVariableMatrix_ ( 2_I4B ) TYPE ( FEVariableMatrix_ ), PARAMETER , PUBLIC :: & & TypeVariableMatrix = FEVariableMatrix_ ( 2_I4B ) !---------------------------------------------------------------------------- !                                                           QuadraturePoint_ !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! [[QuadraturePoint_]] data type contains the quadrature point information ! ! - Each of column of `Points` corresponds to a quadrature point ! - `Points(1:tXi, :)` contains information of quarature points ! - The last row contains the information about the weighths TYPE :: QuadraturePoint_ REAL ( DFP ), ALLOCATABLE :: Points ( :, : ) INTEGER ( I4B ) :: tXi = 0 END TYPE QuadraturePoint_ PUBLIC :: QuadraturePoint_ TYPE ( QuadraturePoint_ ), PUBLIC , PARAMETER :: & & TypeQuadraturePoint = QuadraturePoint_ ( Points = NULL ( ) ) TYPE :: QuadraturePointPointer_ CLASS ( QuadraturePoint_ ), POINTER :: Ptr => NULL ( ) END TYPE QuadraturePointPointer_ PUBLIC :: QuadraturePointPointer_ !---------------------------------------------------------------------------- !                                                         BasisInterpolation_ !---------------------------------------------------------------------------- TYPE :: BaseInterpolation_ END TYPE BaseInterpolation_ PUBLIC :: BaseInterpolation_ !---------------------------------------------------------------------------- !                                                     LagrangeInterpolation_ !---------------------------------------------------------------------------- TYPE , EXTENDS ( BaseInterpolation_ ) :: LagrangeInterpolation_ END TYPE LagrangeInterpolation_ PUBLIC :: LagrangeInterpolation_ TYPE ( LagrangeInterpolation_ ), PARAMETER , PUBLIC :: & & TypeLagrangeInterpolation = LagrangeInterpolation_ () !---------------------------------------------------------------------------- !                                                       HermitInterpolation_ !---------------------------------------------------------------------------- TYPE , EXTENDS ( BaseInterpolation_ ) :: HermitInterpolation_ END TYPE HermitInterpolation_ PUBLIC :: HermitInterpolation_ TYPE ( HermitInterpolation_ ), PARAMETER , PUBLIC :: & & TypeHermitInterpolation = HermitInterpolation_ () !---------------------------------------------------------------------------- !                                                  SerendipityInterpolation_ !---------------------------------------------------------------------------- TYPE , EXTENDS ( BaseInterpolation_ ) :: SerendipityInterpolation_ END TYPE SerendipityInterpolation_ PUBLIC :: SerendipityInterpolation_ TYPE ( SerendipityInterpolation_ ), PARAMETER , PUBLIC :: & & TypeSerendipityInterpolation = SerendipityInterpolation_ () !---------------------------------------------------------------------------- !                                                    HierarchyInterpolation_ !---------------------------------------------------------------------------- TYPE , EXTENDS ( BaseInterpolation_ ) :: HierarchyInterpolation_ END TYPE HierarchyInterpolation_ PUBLIC :: HierarchyInterpolation_ TYPE ( HierarchyInterpolation_ ), PARAMETER , PUBLIC :: & & TypeHierarchyInterpolation = HierarchyInterpolation_ () !---------------------------------------------------------------------------- !                                                          BasisContinuity_ !---------------------------------------------------------------------------- TYPE :: BasisContinuity_ END TYPE BasisContinuity_ PUBLIC :: BasisContinuity_ TYPE ( BasisContinuity_ ), PARAMETER , PUBLIC :: & & TypeBasisContinuity = BasisContinuity_ ( ) !---------------------------------------------------------------------------- !                                                                     H1_ !---------------------------------------------------------------------------- TYPE , EXTENDS ( BasisContinuity_ ) :: H1_ END TYPE H1_ PUBLIC :: H1_ TYPE ( H1_ ), PARAMETER , PUBLIC :: & & TypeH1 = H1_ () !---------------------------------------------------------------------------- !                                                                   H1DIV_ !---------------------------------------------------------------------------- TYPE , EXTENDS ( BasisContinuity_ ) :: H1DIV_ END TYPE H1DIV_ PUBLIC :: H1DIV_ TYPE ( H1DIV_ ), PARAMETER , PUBLIC :: & & TypeH1DIV = H1DIV_ () !---------------------------------------------------------------------------- !                                                                   H1CURL_ !---------------------------------------------------------------------------- TYPE , EXTENDS ( BasisContinuity_ ) :: H1CURL_ END TYPE H1CURL_ PUBLIC :: H1CURL_ TYPE ( H1CURL_ ), PARAMETER , PUBLIC :: & & TypeH1CURL = H1CURL_ () !---------------------------------------------------------------------------- !                                                                      DG_ !---------------------------------------------------------------------------- TYPE , EXTENDS ( BasisContinuity_ ) :: DG_ END TYPE DG_ PUBLIC :: DG_ TYPE ( DG_ ), PARAMETER , PUBLIC :: & & TypeDG = DG_ () !---------------------------------------------------------------------------- !                                                            ElementData_ !---------------------------------------------------------------------------- TYPE :: ElementData_ INTEGER ( I4B ) :: NSD , NNE , NNS , NNT , XiDimension , ElemTopology , & & SpaceElemTopo , TimeElemTopo , ElemType , MAT_Type END TYPE ElementData_ PUBLIC :: ElementData_ TYPE ( ElementData_ ), PARAMETER , PUBLIC :: TypeElementData & & = ElementData_ ( NSD = - 1 , NNE = - 1 , NNS = - 1 , NNT = - 1 , & & XiDimension = - 1 , ElemTopology = - 1 , SpaceElemTopo = - 1 , & & TimeElemTopo = - 1 , ElemType = - 1 , MAT_Type = - 1 ) TYPE :: ElementDataPointer_ CLASS ( ElementData_ ), POINTER :: Ptr => NULL ( ) END TYPE ElementDataPointer_ PUBLIC :: ElementDataPointer_ !---------------------------------------------------------------------------- !                                                              ShapeData_ !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This Class bundles all required variables(related to shapefunctions) ! at a Gauss Point TYPE :: ShapeData_ REAL ( DFP ) :: Ws = 0.0_DFP REAL ( DFP ) :: Js = 0.0_DFP REAL ( DFP ) :: Thickness = 1.0_DFP REAL ( DFP ) :: Xi ( 3 ) = 0.0_DFP REAL ( DFP ) :: XBar ( 3 ) = 0.0_DFP REAL ( DFP ) :: Normal ( 3 ) = 0.0_DFP INTEGER ( I4B ) :: ElemTopology = 0 INTEGER ( I4B ) :: NSD = 0 REAL ( DFP ), ALLOCATABLE :: N ( : ) REAL ( DFP ), ALLOCATABLE :: dNdXi ( :, : ) REAL ( DFP ), ALLOCATABLE :: dNdXt ( :, : ) REAL ( DFP ), ALLOCATABLE :: Jacobian ( :, : ) END TYPE ShapeData_ PUBLIC :: ShapeData_ TYPE ( ShapeData_ ), PARAMETER , PUBLIC :: & & TypeShapeData = ShapeData_ ( & & N = NULL ( ), & & dNdXi = NULL ( ), & & dNdXt = NULL ( ), & & Jacobian = NULL ( ) ) TYPE :: ShapeDataPointer_ CLASS ( ShapeDataPointer_ ), POINTER :: Ptr => NULL ( ) END TYPE ShapeDataPointer_ PUBLIC :: ShapeDataPointer_ !---------------------------------------------------------------------------- !                                                               STShapeData_ !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This class extends [[shapedata_]] class to space-time FEM applcation TYPE , EXTENDS ( ShapeData_ ) :: STShapeData_ REAL ( DFP ) :: Theta = 0.0 REAL ( DFP ) :: Wt = 0.0 REAL ( DFP ) :: Jt = 0.0 INTEGER ( I4B ) :: SpaceElemTopo = 0 INTEGER ( I4B ) :: TimeElemTopo = 0 REAL ( DFP ), ALLOCATABLE :: T (:) !! values of shape function at different time nodes REAL ( DFP ), ALLOCATABLE :: dTdTheta ( : ) !! Value of local time derivative of T at time gauss point REAL ( DFP ), ALLOCATABLE :: dNTdt ( :, : ) !! Value of global time derivative of T at time gauss points REAL ( DFP ), ALLOCATABLE :: dNTdXt ( :, :, : ) !! Spatial gradient of the shape functions at space-time gauss points END TYPE STShapeData_ PUBLIC :: STShapeData_ TYPE :: STShapeDataPointer_ CLASS ( STShapeData_ ), POINTER :: Ptr => NULL ( ) END TYPE STShapeDataPointer_ PUBLIC :: STShapeDataPointer_ !---------------------------------------------------------------------------- !                                                           ElemShapeData_ !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This data type contains shapefunction related data defined ! at all gauss points of an elements TYPE :: ElemShapeData_ REAL ( DFP ), ALLOCATABLE :: N ( :, : ) !! Shape function value `N(I,ips)` REAL ( DFP ), ALLOCATABLE :: dNdXi ( :, :, : ) !! Local derivative of a shape function REAL ( DFP ), ALLOCATABLE :: Jacobian ( :, :, : ) !! Jacobian of mapping `J(:,:,ips)` also $\\mathbf{F}_{\\Xi x}$ REAL ( DFP ), ALLOCATABLE :: Js ( : ) !! Determinant of Jacobian at ips REAL ( DFP ), ALLOCATABLE :: Ws ( : ) !! Weighting functions REAL ( DFP ), ALLOCATABLE :: dNdXt ( :, :, : ) !! Spatial derivative of shape function REAL ( DFP ), ALLOCATABLE :: Thickness ( : ) !! Thickness of element REAL ( DFP ), ALLOCATABLE :: Coord ( :, : ) !! Barycentric coordinate REAL ( DFP ), ALLOCATABLE :: Normal ( :, : ) !! Normal in case of facet element TYPE ( ReferenceElement_ ) :: RefElem !! Refererece element TYPE ( QuadraturePoint_ ) :: Quad !! Quadrature points END TYPE ElemShapeData_ PUBLIC :: ElemShapeData_ TYPE ( ElemShapeData_ ), PUBLIC , PARAMETER :: & & TypeElemShapeData = ElemShapeData_ ( & & N = NULL ( ), & & dNdXi = NULL ( ), & & Jacobian = NULL ( ), & & Js = NULL ( ), & & Ws = NULL ( ), & & dNdXt = NULL ( ), & & Thickness = NULL ( ), & & Coord = NULL ( ), & & Normal = NULL ( ) ) TYPE :: ElemShapeDataPointer_ CLASS ( ShapeDataPointer_ ), POINTER :: Ptr => NULL ( ) END TYPE ElemShapeDataPointer_ PUBLIC :: ElemShapeDataPointer_ !---------------------------------------------------------------------------- !                                                           STElemShapeData_ !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This data type contains shapefunction related data defined ! at all gauss points of an elements ! ! ## How to initiate local shape data ! ! ```fortran ! program main !   !! This program shows how to use space-time element shape data ! use easifem ! implicit none !   !line order 1 !   type( stelemshapedata_ ), allocatable :: obj( : ) !   type( elemshapedata_ ) :: elemsd !   type( quadraturepoint_ ) :: quad !   class( referenceElement_ ), pointer :: refelem !   integer( i4b ) :: orderInTime, ii !   real( dfp ) :: xiJ( 1, 2 ) !   orderInTime = 2 !   ALLOCATE( ReferenceLine_ :: refelem ) !   refelem = ReferenceLine( nsd = 1 ) !   quad = GaussLegendreQuadrature(refelem=refelem,order=orderInTime ) !   ! higher order lagrange element !   SELECT TYPE( refelem ) !   TYPE IS ( ReferenceLine_  ) !     refelem = LagrangeElement( refelem = refelem, order = 1 ) !   END SELECT !   call initiate( & !     & obj = elemsd, quad = quad, refelem = refelem, & !     & ContinuityType= typeH1, InterpolType = TypeLagrangeInterpolation ) !   call initiate( obj = obj, elemsd = elemsd ) !   !! Generating shape functions for space element !   ALLOCATE( ReferenceTriangle_ :: refelem ) !   refelem = ReferenceTriangle( nsd = 2 ) !   quad = GaussLegendreQuadrature( refelem=refelem, order = 2 ) !   do ii = 1, size( obj ) !     call initiate( & !       & obj = obj( ii ), quad = quad, refelem = refelem, & !       & ContinuityType= typeH1, InterpolType = TypeLagrangeInterpolation ) !     call display( obj( ii ), \"ii :: \"// str( ii ) ) !   end do ! end program !``` TYPE , EXTENDS ( ElemShapeData_ ) :: STElemShapeData_ REAL ( DFP ) :: Wt = 0.0 !! Weight of gauss point in time domain REAL ( DFP ) :: Theta = 0.0 !! Gauss point in time domain REAL ( DFP ) :: Jt = 0.0 !! Jacobian $\\frac{dt}{d\\theta}$ REAL ( DFP ), ALLOCATABLE :: T ( : ) !! Shape function in time domain REAL ( DFP ), ALLOCATABLE :: dTdTheta ( : ) !! Local shape function derivative in time domain REAL ( DFP ), ALLOCATABLE :: dNTdt ( :, :, : ) REAL ( DFP ), ALLOCATABLE :: dNTdXt ( :, :, :, : ) END TYPE STElemShapeData_ PUBLIC :: STElemShapeData_ TYPE ( STElemShapeData_ ), PUBLIC , PARAMETER :: & & TypeSTElemShapeData = STElemShapeData_ ( & & N = NULL ( ), & & dNdXi = NULL ( ), & & Jacobian = NULL ( ), & & Js = NULL ( ), & & Ws = NULL ( ), & & dNdXt = NULL ( ), & & Thickness = NULL ( ), & & Coord = NULL ( ), & & Normal = NULL ( ), & & T = NULL ( ), & & dTdTheta = NULL ( ), & & dNTdt = NULL ( ), & & dNTdXt = NULL ( ) ) !---------------------------------------------------------------------------- !                                                              Meshquality_ !---------------------------------------------------------------------------- TYPE :: QualityMeasure_ INTEGER ( I4B ), PUBLIC :: area = 100 INTEGER ( I4B ), PUBLIC :: maxAngle = 101 INTEGER ( I4B ), PUBLIC :: minAngle = 102 INTEGER ( I4B ), PUBLIC :: AngleRatio = 103 INTEGER ( I4B ), PUBLIC :: RadiusRatio = 104 INTEGER ( I4B ), PUBLIC :: EdgeRatio = 105 INTEGER ( I4B ), PUBLIC :: AspectRatio = 106 INTEGER ( I4B ), PUBLIC :: ScaledJacobian = 107 INTEGER ( I4B ), PUBLIC :: Default = 106 END TYPE QualityMeasure_ TYPE ( QualityMeasure_ ), PARAMETER , PUBLIC :: & & QualityMeasure = QualityMeasure_ () !---------------------------------------------------------------------------- !                                                                    Random_ !---------------------------------------------------------------------------- TYPE :: Random_ INTEGER ( I4B ) :: random_int = 100 INTEGER ( I4B ), ALLOCATABLE :: random_int_seed (:) INTEGER ( I4B ), ALLOCATABLE :: random_int_vec (:) REAL ( DFP ) :: random_real = 0.0_DFP REAL ( DFP ), ALLOCATABLE :: random_real_vec (:) END TYPE PUBLIC :: Random_ TYPE ( Random_ ), PARAMETER , PUBLIC :: & & TypeRandom = Random_ ( random_int_seed = NULL ( ), & & random_int_vec = NULL ( ), & & random_real_vec = NULL ( ) ) !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- END MODULE BaseType","tags":"","loc":"sourcefile/basetype.f90.html"},{"title":"GlobalData.f90 – Fortran Program","text":"Contents Modules GlobalData Source Code GlobalData.f90 Source Code ! EASIFEM ! By Vikas Sharma MODULE GlobalData USE , INTRINSIC :: ISO_FORTRAN_ENV , ONLY : stdin => input_unit , & & stdout => output_unit , stderr => error_unit IMPLICIT NONE PUBLIC SAVE LOGICAL :: is_initialized = . FALSE ., Error_Flag = . FALSE . INTEGER , PARAMETER :: endianL = 1 INTEGER , PARAMETER :: endianB = 0 INTEGER :: endian = endianL !$OMP THREADPRIVATE(is_initialized,endian, Error_Flag) #ifdef Real128 INTEGER , PARAMETER :: Real128 = SELECTED_REAL_KIND ( 33 , 4931 ) #else INTEGER , PARAMETER :: Real128 = SELECTED_REAL_KIND ( 15 , 307 ) #endif INTEGER , PARAMETER :: Real64 = SELECTED_REAL_KIND ( 15 , 307 ) INTEGER , PARAMETER :: Real32 = SELECTED_REAL_KIND ( 6 , 37 ) INTEGER , PARAMETER :: Float = Real64 ! Default INTEGER , PARAMETER :: DFP = Real64 ! Default INTEGER , PARAMETER :: Int64 = SELECTED_INT_KIND ( 18 ) INTEGER , PARAMETER :: Int32 = SELECTED_INT_KIND ( 9 ) INTEGER , PARAMETER :: Int16 = SELECTED_INT_KIND ( 4 ) INTEGER , PARAMETER :: Int8 = SELECTED_INT_KIND ( 2 ) INTEGER , PARAMETER :: DIP = Int32 ! Default INTEGER , PARAMETER :: I4B = Int32 ! Default INTEGER , PARAMETER :: SP = Real32 INTEGER , PARAMETER :: DP = Real64 INTEGER , PARAMETER :: DFPC = KIND (( 1.0D0 , 1.0D0 )) !Default Kind cmplx INTEGER , PARAMETER :: SPC = KIND (( 1.0 , 1.0 )) !Single Precision cmplx INTEGER , PARAMETER :: DPC = KIND (( 1.0D0 , 1.0D0 )) !Double Precision cmplx INTEGER , PARAMETER :: LGT = KIND (. true .) !Logical ! Format parameters #ifdef Real128 CHARACTER ( * ), PARAMETER :: FReal128 = '(E42.33E4)' #else CHARACTER ( * ), PARAMETER :: FReal128 = '(E23.15E3)' #endif CHARACTER ( * ), PARAMETER :: FReal64 = '(E23.15E3)' CHARACTER ( * ), PARAMETER :: FReal32 = '(E13.6E2)' CHARACTER ( * ), PARAMETER :: FReal = FReal64 ! Default CHARACTER ( * ), PARAMETER :: FFloat = FReal64 ! Default CHARACTER ( * ), PARAMETER :: FDFP = FReal64 ! Default CHARACTER ( * ), PARAMETER :: FInt64 = '(I20)' CHARACTER ( * ), PARAMETER :: FInt64ZP = '(I20.19)' CHARACTER ( * ), PARAMETER :: FInt32 = '(I11)' CHARACTER ( * ), PARAMETER :: FInt32ZP = '(I11.10)' CHARACTER ( * ), PARAMETER :: FInt16 = '(I6)' CHARACTER ( * ), PARAMETER :: FInt16ZP = '(I6.5)' CHARACTER ( * ), PARAMETER :: FInt8 = '(I4)' CHARACTER ( * ), PARAMETER :: FInt8ZP = '(I4.3)' CHARACTER ( * ), PARAMETER :: FInt = FInt32 !Default CHARACTER ( * ), PARAMETER :: FI4B = FInt32 !Default CHARACTER ( * ), PARAMETER :: FI4BZP = FInt32ZP CHARACTER ( * ), PARAMETER :: FIntZP = FInt32ZP ! Length (number of digits) of formatted numbers #ifdef Real128 INTEGER , PARAMETER :: DReal128 = 42 #else INTEGER , PARAMETER :: DReal128 = 23 #endif INTEGER , PARAMETER :: DReal64 = 23 INTEGER , PARAMETER :: DReal32 = 13 INTEGER , PARAMETER :: DReal = DReal64 !Default INTEGER , PARAMETER :: DFloat = DReal64 !Default INTEGER , PARAMETER :: DDFP = DReal64 !Default INTEGER , PARAMETER :: DInt64 = 20 INTEGER , PARAMETER :: DInt32 = 11 INTEGER , PARAMETER :: DInt16 = 6 INTEGER , PARAMETER :: DInt8 = 4 INTEGER , PARAMETER :: DInt = DInt32 !Default INTEGER , PARAMETER :: DI4B = DInt32 !Default ! List of kinds INTEGER , PARAMETER :: REAL_KINDS_LIST ( 1 : 4 ) & & = [ Real128 , Real64 , Real32 , Float ] CHARACTER ( * ), PARAMETER :: REAL_FORMATS_LIST ( 1 : 4 ) & & = [ FReal128 , FReal64 , FReal32 // ' ' , FReal ] INTEGER , PARAMETER :: INTEGER_KINDS_LIST ( 1 : 5 ) & & = [ Int64 , Int32 , Int16 , Int8 , DIP ] CHARACTER ( * ), PARAMETER :: INTEGER_FORMATS_LIST ( 1 : 5 ) = & & [ FInt64 , FInt32 , FInt16 // ' ' , FInt8 // ' ' , FInt ] ! Minimum and maximum (representable) values REAL ( Real128 ), PARAMETER :: TypeReal128 = 1.0 REAL ( Real128 ), PARAMETER :: MinReal128 = - huge ( 1._Real128 ) REAL ( Real128 ), PARAMETER :: MaxReal128 = huge ( 1._Real128 ) REAL ( Real64 ), PARAMETER :: TypeReal64 = 1.0 REAL ( Real64 ), PARAMETER :: MinReal64 = - huge ( 1._Real64 ) REAL ( Real64 ), PARAMETER :: MaxReal64 = huge ( 1._Real64 ) REAL ( Real32 ), PARAMETER :: TypeReal32 = 1.0 REAL ( Real32 ), PARAMETER :: MinReal32 = - huge ( 1._Real32 ) REAL ( Real32 ), PARAMETER :: MaxReal32 = huge ( 1._Real32 ) REAL ( Float ), PARAMETER :: MinFloat = MinReal64 ! default REAL ( Float ), PARAMETER :: MinReal = MinReal64 ! default REAL ( Float ), PARAMETER :: MaxFloat = MaxReal64 ! default REAL ( Float ), PARAMETER :: MaxReal = MaxReal64 ! default REAL ( Float ), PARAMETER :: MinDFP = MinReal64 ! default REAL ( Float ), PARAMETER :: MaxDFP = MaxReal64 ! default REAL ( Float ), PARAMETER :: TypeReal = 1.0 , TypeDFP = 1.0 , TypeFloat = 1.0 INTEGER ( Int64 ), PARAMETER :: MinInt64 = - huge ( 1_Int64 ), TypeInt64 = 1 INTEGER ( Int32 ), PARAMETER :: MinInt32 = - huge ( 1_Int32 ), TypeInt32 = 1 INTEGER ( Int16 ), PARAMETER :: MinInt16 = - huge ( 1_Int16 ), TypeInt16 = 1 INTEGER ( Int8 ), PARAMETER :: MinInt8 = - huge ( 1_Int8 ), TypeInt8 = 1 INTEGER ( DIP ), PARAMETER :: MinInt = MinInt32 , TypeInt = 1 ! default INTEGER ( I4B ), PARAMETER :: MinI4B = MinInt32 , TypeIntI4B = 1 ! default INTEGER ( Int64 ), PARAMETER :: MaxInt64 = huge ( 1_Int64 ) INTEGER ( Int32 ), PARAMETER :: MaxInt32 = huge ( 1_Int32 ) INTEGER ( Int16 ), PARAMETER :: MaxInt16 = huge ( 1_Int16 ) INTEGER ( Int8 ), PARAMETER :: MaxInt8 = huge ( 1_Int8 ) INTEGER ( DIP ), PARAMETER :: MaxI4B = MaxInt32 !default INTEGER ( DIP ), PARAMETER :: MaxInt = MaxInt32 !default ! Real smallest (representable) values REAL ( Real128 ), PARAMETER :: smallReal128 = tiny ( 1._Real128 ) REAL ( Real64 ), PARAMETER :: smallReal64 = tiny ( 1._Real64 ) REAL ( Real32 ), PARAMETER :: smallReal32 = tiny ( 1._Real32 ) REAL ( Float ), PARAMETER :: smallFloat = smallReal64 !default REAL ( Float ), PARAMETER :: smallReal = smallReal64 !default REAL ( Float ), PARAMETER :: smallDFP = smallReal64 !default ! Smallest REAL representable difference by the running calculator REAL ( Real128 ), PARAMETER :: ZeroReal128 = nearest ( 1._Real128 , 1._Real128 ) - & & nearest ( 1._Real128 , - 1._Real128 ) REAL ( Real64 ), PARAMETER :: ZeroReal64 = nearest ( 1._Real64 , 1._Real64 ) - & & nearest ( 1._Real64 , - 1._Real64 ) REAL ( Real32 ), PARAMETER :: ZeroReal32 = nearest ( 1._Real32 , 1._Real32 ) - & & nearest ( 1._Real32 , - 1._Real32 ) REAL ( Float ), PARAMETER :: Zero = ZeroReal64 ! Bits/bytes memory requirements (REAL variables (R?P) must be computed at runtime) INTEGER ( Int16 ) :: BIReal128 INTEGER ( Int8 ) :: BIReal64 INTEGER ( Int8 ) :: BIReal32 INTEGER ( Int8 ) :: BIFloat !default in bits INTEGER ( Int8 ) :: BIReal !default in bits INTEGER ( Int8 ) :: BIDFP !default in bytes INTEGER ( Int16 ) :: BYReal128 INTEGER ( Int8 ) :: BYReal64 INTEGER ( Int8 ) :: BYReal32 INTEGER ( Int8 ) :: BYFloat !default INTEGER ( Int8 ) :: BYReal !default INTEGER ( Int8 ) :: BYDFP !default INTEGER ( Int64 ), PARAMETER :: BIInt64 = bit_size ( MaxInt64 ) INTEGER ( Int32 ), PARAMETER :: BIInt32 = bit_size ( MaxInt32 ) INTEGER ( Int16 ), PARAMETER :: BIInt16 = bit_size ( MaxInt16 ) INTEGER ( Int8 ), PARAMETER :: BIInt8 = bit_size ( MaxInt8 ) INTEGER ( DIP ), PARAMETER :: BIInt = bit_size ( MaxInt ) !default in bits INTEGER ( DIP ), PARAMETER :: BII4B = bit_size ( MaxInt ) !default in bits INTEGER ( Int64 ), PARAMETER :: BYInt64 = bit_size ( MaxInt64 ) / 8_Int64 INTEGER ( Int32 ), PARAMETER :: BYInt32 = bit_size ( MaxInt32 ) / 8_Int32 INTEGER ( Int16 ), PARAMETER :: BYInt16 = bit_size ( MaxInt16 ) / 8_Int16 INTEGER ( Int8 ), PARAMETER :: BYInt8 = bit_size ( MaxInt8 ) / 8_Int8 INTEGER ( DIP ), PARAMETER :: BYInt = bit_size ( MaxInt ) / 8_DIP !default in bytes INTEGER ( DIP ), PARAMETER :: BYI4B = bit_size ( MaxInt ) / 8_DIP ! default in bytes REAL ( DFP ), PARAMETER :: Pi = 3.14159265359_DFP REAL ( DFP ), DIMENSION ( 3 , 3 ) :: Eye3 = RESHAPE (& ( / 1.0_DFP , 0.0_DFP , 0.0_DFP ,& 0.0_DFP , 1.0_DFP , 0.0_DFP ,& 0.0_DFP , 0.0_DFP , 1.0_DFP / ),( / 3 , 3 / )) REAL ( DFP ), DIMENSION ( 2 , 2 ) :: Eye2 = RESHAPE (& ( / 1.0_DFP , 0.0_DFP , 0.0_DFP , 1.0_DFP / ),( / 2 , 2 / )) ! Parameters for iteration data INTEGER ( I4B ), PARAMETER :: RelativeConvergence = 1 , ConvergenceInRes = 1 INTEGER ( I4B ), PARAMETER :: AbsoluteConvergence = 2 , ConvergenceInSol = 2 INTEGER ( I4B ), PARAMETER :: NormL1 = 1 , NormL2 = 2 , NormInfinity = 3 ! Precondition sides INTEGER ( I4B ), PARAMETER :: NoPrecond = 0 , PrecondLeft = 1 , PrecondRight = 2 ! Type of shape functions INTEGER ( I4B ), PARAMETER :: LagrangePolynomial = 1 INTEGER ( I4B ), PARAMETER :: SerendipityPolynomial = 2 INTEGER ( I4B ), PARAMETER :: HeirarchicalPolynomial = 3 INTEGER ( I4B ), PARAMETER :: Equidistance = 1 INTEGER ( I4B ), PARAMETER :: GaussLegendre = 2 INTEGER ( I4B ), PARAMETER :: GaussLobatto = 3 INTEGER ( I4B ), PARAMETER :: Chebyshev = 4 ! Type of Lagrange Interpolation Poitns INTEGER ( I4B ), PARAMETER :: EquidistanceLIP = Equidistance INTEGER ( I4B ), PARAMETER :: GaussLobattoLIP = GaussLobatto INTEGER ( I4B ), PARAMETER :: GaussLegendreLIP = GaussLegendre INTEGER ( I4B ), PARAMETER :: ChebyshevLIP = Chebyshev ! Type of quadrature points INTEGER ( I4B ), PARAMETER :: GaussLegendreQP = GaussLegendre INTEGER ( I4B ), PARAMETER :: GaussLobattoQP = GaussLobatto INTEGER ( I4B ), PARAMETER :: ChebyshevQP = Chebyshev ! Types of Elements INTEGER ( I4B ), PARAMETER :: Line = 1 INTEGER ( I4B ), PARAMETER :: Line2 = 1 INTEGER ( I4B ), PARAMETER :: Line3 = 8 INTEGER ( I4B ), PARAMETER :: Line4 = 26 INTEGER ( I4B ), PARAMETER :: Line5 = 27 INTEGER ( I4B ), PARAMETER :: Line6 = 28 INTEGER ( I4B ), PARAMETER :: Triangle = 2 INTEGER ( I4B ), PARAMETER :: Triangle3 = 2 INTEGER ( I4B ), PARAMETER :: Triangle6 = 9 INTEGER ( I4B ), PARAMETER :: Triangle9 = 20 INTEGER ( I4B ), PARAMETER :: Triangle10 = 21 INTEGER ( I4B ), PARAMETER :: Triangle12 = 22 INTEGER ( I4B ), PARAMETER :: Triangle15a = 23 INTEGER ( I4B ), PARAMETER :: Triangle15b = 24 INTEGER ( I4B ), PARAMETER :: Triangle15 = 24 INTEGER ( I4B ), PARAMETER :: Triangle21 = 25 INTEGER ( I4B ), PARAMETER :: Quadrangle = 3 INTEGER ( I4B ), PARAMETER :: Quadrangle4 = 3 INTEGER ( I4B ), PARAMETER :: Quadrangle9 = 10 INTEGER ( I4B ), PARAMETER :: Quadrangle8 = 16 INTEGER ( I4B ), PARAMETER :: Tetrahedron = 4 INTEGER ( I4B ), PARAMETER :: Tetrahedron4 = 4 INTEGER ( I4B ), PARAMETER :: Tetrahedron10 = 11 INTEGER ( I4B ), PARAMETER :: Tetrahedron20 = 29 INTEGER ( I4B ), PARAMETER :: Tetrahedron35 = 30 INTEGER ( I4B ), PARAMETER :: Tetrahedron56 = 31 INTEGER ( I4B ), PARAMETER :: Hexahedron = 5 INTEGER ( I4B ), PARAMETER :: Hexahedron8 = 5 INTEGER ( I4B ), PARAMETER :: Hexahedron27 = 12 INTEGER ( I4B ), PARAMETER :: Hexahedron20 = 17 INTEGER ( I4B ), PARAMETER :: Hexahedron64 = 92 INTEGER ( I4B ), PARAMETER :: Hexahedron125 = 93 INTEGER ( I4B ), PARAMETER :: Prism = 6 INTEGER ( I4B ), PARAMETER :: Prism6 = 6 INTEGER ( I4B ), PARAMETER :: Prism18 = 13 INTEGER ( I4B ), PARAMETER :: Prism15 = 18 INTEGER ( I4B ), PARAMETER :: Pyramid = 7 INTEGER ( I4B ), PARAMETER :: Pyramid5 = 7 INTEGER ( I4B ), PARAMETER :: Pyramid14 = 14 INTEGER ( I4B ), PARAMETER :: Pyramid13 = 19 INTEGER ( I4B ), PARAMETER :: Point = 15 INTEGER ( I4B ), PARAMETER :: Point1 = 15 ! Read material data from ? INTEGER ( I4B ), PARAMETER :: PhysicalTag = 1 INTEGER ( I4B ), PARAMETER :: GeometryTag = 2 ! Constraint type INTEGER ( I4B ), PARAMETER :: StrongBC = 1 , & NitscheBC = 2 , & LagrangeMultiplierBC = 3 , & PenaltyBC = 4 , & AugmentedBC = 5 ! Symmetric and Skewsymmertic Nitsche Formulation INTEGER ( I4B ), PARAMETER :: SkewSymNitsch = 1 , SymNitsche = 2 ! ScalarDOF INTEGER ( I4B ), PARAMETER :: ScalarDOF = - 1 END MODULE GlobalData","tags":"","loc":"sourcefile/globaldata.f90.html"},{"title":"BaseType@AdditionalMethods.f90 – Fortran Program","text":"Contents Submodules AdditionalMethods Source Code BaseType@AdditionalMethods.f90 Source Code SUBMODULE ( BaseType ) AdditionalMethods USE ReferenceElement_Method , ONLY : LagrangePoints , LagrangeElement , Initiate IMPLICIT NONE CONTAINS !------------------------------------------------------------------------------ !                                                                   lp_refelem !------------------------------------------------------------------------------ MODULE PROCEDURE lp_refelem END PROCEDURE lp_refelem !------------------------------------------------------------------------------ !                                                              lp_refelem_line !------------------------------------------------------------------------------ MODULE PROCEDURE lp_refelem_line SELECT TYPE ( Obj ) TYPE IS ( ReferenceLine_ ) Ans = LagrangePoints ( Obj , Order ) END SELECT END PROCEDURE lp_refelem_line !------------------------------------------------------------------------------ !                                                          lp_refelem_Triangle !------------------------------------------------------------------------------ MODULE PROCEDURE lp_refelem_Triangle SELECT TYPE ( Obj ) TYPE IS ( ReferenceTriangle_ ) Ans = LagrangePoints ( Obj , Order ) END SELECT END PROCEDURE lp_refelem_Triangle !------------------------------------------------------------------------------ !                                                       lp_refelem_Quadrangle !------------------------------------------------------------------------------ MODULE PROCEDURE lp_refelem_Quadrangle SELECT TYPE ( Obj ) TYPE IS ( ReferenceQuadrangle_ ) Ans = LagrangePoints ( Obj , Order ) END SELECT END PROCEDURE lp_refelem_Quadrangle !------------------------------------------------------------------------------ !                                                       lp_refelem_Tetrahedron !------------------------------------------------------------------------------ MODULE PROCEDURE lp_refelem_Tetrahedron SELECT TYPE ( Obj ) TYPE IS ( ReferenceTetrahedron_ ) Ans = LagrangePoints ( Obj , Order ) END SELECT END PROCEDURE lp_refelem_Tetrahedron !------------------------------------------------------------------------------ !                                                       lp_refelem_Hexahedron !------------------------------------------------------------------------------ MODULE PROCEDURE lp_refelem_Hexahedron SELECT TYPE ( Obj ) TYPE IS ( ReferenceHexahedron_ ) Ans = LagrangePoints ( Obj , Order ) END SELECT END PROCEDURE lp_refelem_Hexahedron !------------------------------------------------------------------------------ !                                                           lp_refelem_Pyramid !------------------------------------------------------------------------------ MODULE PROCEDURE lp_refelem_Pyramid SELECT TYPE ( Obj ) TYPE IS ( ReferencePyramid_ ) Ans = LagrangePoints ( Obj , Order ) END SELECT END PROCEDURE lp_refelem_Pyramid !------------------------------------------------------------------------------ !                                                             lp_refelem_Prism !------------------------------------------------------------------------------ MODULE PROCEDURE lp_refelem_Prism SELECT TYPE ( Obj ) TYPE IS ( ReferencePrism_ ) Ans = LagrangePoints ( Obj , Order ) END SELECT END PROCEDURE lp_refelem_Prism !------------------------------------------------------------------------------ !                                                            lag_elem_refelem !------------------------------------------------------------------------------ MODULE PROCEDURE lag_elem_refelem END PROCEDURE lag_elem_refelem !------------------------------------------------------------------------------ !                                                            lag_elem_refLine !------------------------------------------------------------------------------ MODULE PROCEDURE lag_elem_refLine SELECT TYPE ( Obj ) TYPE IS ( ReferenceLine_ ) ALLOCATE ( Ans ) CALL Initiate ( Ans , LagrangeElement ( Obj , Order ) ) END SELECT END PROCEDURE lag_elem_refLine !------------------------------------------------------------------------------ !                                                         lag_elem_refTriangle !------------------------------------------------------------------------------ MODULE PROCEDURE lag_elem_refTriangle SELECT TYPE ( Obj ) TYPE IS ( ReferenceTriangle_ ) ALLOCATE ( Ans ) CALL Initiate ( Ans , LagrangeElement ( Obj , Order ) ) END SELECT END PROCEDURE lag_elem_refTriangle !------------------------------------------------------------------------------ !                                                      lag_elem_refQuadrangle !------------------------------------------------------------------------------ MODULE PROCEDURE lag_elem_refQuadrangle SELECT TYPE ( Obj ) TYPE IS ( ReferenceQuadrangle_ ) ALLOCATE ( Ans ) CALL Initiate ( Ans , LagrangeElement ( Obj , Order ) ) END SELECT END PROCEDURE lag_elem_refQuadrangle !------------------------------------------------------------------------------ !                                                      lag_elem_refTetrahedron !------------------------------------------------------------------------------ MODULE PROCEDURE lag_elem_refTetrahedron SELECT TYPE ( Obj ) TYPE IS ( ReferenceTetrahedron_ ) ALLOCATE ( Ans ) CALL Initiate ( Ans , LagrangeElement ( Obj , Order ) ) END SELECT END PROCEDURE lag_elem_refTetrahedron !------------------------------------------------------------------------------ !                                                       lag_elem_refHexahedron !------------------------------------------------------------------------------ MODULE PROCEDURE lag_elem_refHexahedron SELECT TYPE ( Obj ) TYPE IS ( ReferenceHexahedron_ ) ALLOCATE ( Ans ) CALL Initiate ( Ans , LagrangeElement ( Obj , Order ) ) END SELECT END PROCEDURE lag_elem_refHexahedron !------------------------------------------------------------------------------ !                                                           lag_elem_refPrism !------------------------------------------------------------------------------ MODULE PROCEDURE lag_elem_refPrism SELECT TYPE ( Obj ) TYPE IS ( ReferencePrism_ ) ALLOCATE ( Ans ) CALL Initiate ( Ans , LagrangeElement ( Obj , Order ) ) END SELECT END PROCEDURE lag_elem_refPrism !------------------------------------------------------------------------------ !                                                         lag_elem_refPyramid !------------------------------------------------------------------------------ MODULE PROCEDURE lag_elem_refPyramid SELECT TYPE ( Obj ) TYPE IS ( ReferencePyramid_ ) ALLOCATE ( Ans ) CALL Initiate ( Ans , LagrangeElement ( Obj , Order ) ) END SELECT END PROCEDURE lag_elem_refPyramid END SUBMODULE AdditionalMethods","tags":"","loc":"sourcefile/basetype@additionalmethods.f90.html"},{"title":"AbstractMatrix_Method.f90 – Fortran Program","text":"Contents Modules AbstractMatrix_Method Source Code AbstractMatrix_Method.f90 Source Code MODULE AbstractMatrix_Method USE GlobalData USE BaseType , ONLY : AbstractMatrix_ IMPLICIT NONE PRIVATE INTERFACE Shape MODULE PROCEDURE get_shape END INTERFACE Shape PUBLIC :: Shape INTERFACE Size MODULE PROCEDURE get_size END INTERFACE Size PUBLIC :: Size CONTAINS PURE FUNCTION get_shape ( Obj ) RESULT ( Ans ) TYPE ( AbstractMatrix_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ) :: Ans ( 2 ) Ans = 0_I4B END FUNCTION get_shape !<--------------------------------------------------------------------->| ! !<--------------------------------------------------------------------->| PURE FUNCTION get_size ( Obj , Dims ) RESULT ( Ans ) TYPE ( AbstractMatrix_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: Dims INTEGER ( I4B ) :: Ans Ans = 0 END FUNCTION get_size END MODULE AbstractMatrix_Method","tags":"","loc":"sourcefile/abstractmatrix_method.f90.html"},{"title":"BLASInterface.f90 – Fortran Program","text":"Contents Modules BLASInterface Source Code BLASInterface.f90 Source Code ! !------------------------------------------------------------------------------ !                      Author: Vikas sharma !                    Position: DOctral Student !                Institute: Kyoto Univeristy, Japan !                   Program name:  BLASInterface.f90 !                   Last Update:  March-08-2017 ! !------------------------------------------------------------------------------ !                       Details of Program !============================================================================== ! !   Type:: Module ! !   Info::  -   Interface to BLAS Level-1, Level-2, Level-3 ! !   USE association: !           -   Global Data !           -   IO ! !   Content Information: ! !============================================================================== ! MODULE BLASInterface IMPLICIT NONE !=============================================================================== ! Copyright 2005-2018 Intel Corporation. ! ! This software and the related documents are Intel copyrighted  materials,  and ! your use of  them is  governed by the  express license  under which  they were ! provided to you (License).  Unless the License provides otherwise, you may not ! use, modify, copy, publish, distribute,  disclose or transmit this software or ! the related documents without Intel's prior written permission. ! ! This software and the related documents  are provided as  is,  with no express ! or implied  warranties,  other  than those  that are  expressly stated  in the ! License. !=============================================================================== !  Content: !       Intel(R) MKL BLAS77 interface as prototypes for !       Intel(R) MKL BLAS95 interfaces ! !******************************************************************************* INTERFACE XERBLA PURE SUBROUTINE XERBLA ( NAME , INFO ) CHARACTER ( LEN =* ), INTENT ( IN ) :: NAME INTEGER , INTENT ( IN ) :: INFO END SUBROUTINE XERBLA END INTERFACE XERBLA ! BLAS level 1 INTERFACE ASUM PURE FUNCTION SASUM ( N , X , INCX ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) REAL ( WP ) :: SASUM REAL ( WP ), INTENT ( IN ) :: X ( * ) INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N END FUNCTION SASUM PURE FUNCTION SCASUM ( N , X , INCX ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) REAL ( WP ) :: SCASUM COMPLEX ( WP ), INTENT ( IN ) :: X ( * ) INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N END FUNCTION SCASUM PURE FUNCTION DASUM ( N , X , INCX ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) REAL ( WP ) :: DASUM REAL ( WP ), INTENT ( IN ) :: X ( * ) INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N END FUNCTION DASUM PURE FUNCTION DZASUM ( N , X , INCX ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) REAL ( WP ) :: DZASUM COMPLEX ( WP ), INTENT ( IN ) :: X ( * ) INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N END FUNCTION DZASUM END INTERFACE ASUM INTERFACE AXPY PURE SUBROUTINE SAXPY ( N , A , X , INCX , Y , INCY ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) REAL ( WP ), INTENT ( IN ) :: X ( * ) REAL ( WP ), INTENT ( INOUT ) :: Y ( * ) REAL ( WP ), INTENT ( IN ) :: A INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N END SUBROUTINE SAXPY PURE SUBROUTINE DAXPY ( N , A , X , INCX , Y , INCY ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) REAL ( WP ), INTENT ( IN ) :: X ( * ) REAL ( WP ), INTENT ( INOUT ) :: Y ( * ) REAL ( WP ), INTENT ( IN ) :: A INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N END SUBROUTINE DAXPY PURE SUBROUTINE CAXPY ( N , A , X , INCX , Y , INCY ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) COMPLEX ( WP ), INTENT ( IN ) :: X ( * ) COMPLEX ( WP ), INTENT ( INOUT ) :: Y ( * ) COMPLEX ( WP ), INTENT ( IN ) :: A INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N END SUBROUTINE CAXPY PURE SUBROUTINE ZAXPY ( N , A , X , INCX , Y , INCY ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) COMPLEX ( WP ), INTENT ( IN ) :: X ( * ) COMPLEX ( WP ), INTENT ( INOUT ) :: Y ( * ) COMPLEX ( WP ), INTENT ( IN ) :: A INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N END SUBROUTINE ZAXPY END INTERFACE AXPY INTERFACE COPY PURE SUBROUTINE SCOPY ( N , X , INCX , Y , INCY ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) REAL ( WP ), INTENT ( IN ) :: X ( * ) REAL ( WP ), INTENT ( INOUT ) :: Y ( * ) INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N END SUBROUTINE SCOPY PURE SUBROUTINE DCOPY ( N , X , INCX , Y , INCY ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) REAL ( WP ), INTENT ( IN ) :: X ( * ) REAL ( WP ), INTENT ( INOUT ) :: Y ( * ) INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N END SUBROUTINE DCOPY PURE SUBROUTINE CCOPY ( N , X , INCX , Y , INCY ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) COMPLEX ( WP ), INTENT ( IN ) :: X ( * ) COMPLEX ( WP ), INTENT ( INOUT ) :: Y ( * ) INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N END SUBROUTINE CCOPY PURE SUBROUTINE ZCOPY ( N , X , INCX , Y , INCY ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) COMPLEX ( WP ), INTENT ( IN ) :: X ( * ) COMPLEX ( WP ), INTENT ( INOUT ) :: Y ( * ) INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N END SUBROUTINE ZCOPY END INTERFACE COPY INTERFACE DOT PURE FUNCTION SDOT ( N , X , INCX , Y , INCY ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) REAL ( WP ) :: SDOT REAL ( WP ), INTENT ( IN ) :: X ( * ) REAL ( WP ), INTENT ( IN ) :: Y ( * ) INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N END FUNCTION SDOT PURE FUNCTION DDOT ( N , X , INCX , Y , INCY ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) REAL ( WP ) :: DDOT REAL ( WP ), INTENT ( IN ) :: X ( * ) REAL ( WP ), INTENT ( IN ) :: Y ( * ) INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N END FUNCTION DDOT END INTERFACE DOT INTERFACE SDOT PURE FUNCTION SDSDOT ( N , SB , SX , INCX , SY , INCY ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) REAL ( WP ) :: SDSDOT REAL ( WP ), INTENT ( IN ) :: SX ( * ) REAL ( WP ), INTENT ( IN ) :: SY ( * ) REAL ( WP ), INTENT ( IN ) :: SB INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N END FUNCTION SDSDOT PURE FUNCTION DSDOT ( N , SX , INCX , SY , INCY ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) INTEGER , PARAMETER :: SP = KIND ( 1.0E0 ) REAL ( WP ) :: DSDOT REAL ( SP ), INTENT ( IN ) :: SX ( * ) REAL ( SP ), INTENT ( IN ) :: SY ( * ) INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N END FUNCTION DSDOT END INTERFACE SDOT INTERFACE DOTC PURE FUNCTION CDOTC ( N , X , INCX , Y , INCY ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) COMPLEX ( WP ) :: CDOTC COMPLEX ( WP ), INTENT ( IN ) :: X ( * ) COMPLEX ( WP ), INTENT ( IN ) :: Y ( * ) INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N END FUNCTION CDOTC PURE FUNCTION ZDOTC ( N , X , INCX , Y , INCY ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) COMPLEX ( WP ) :: ZDOTC COMPLEX ( WP ), INTENT ( IN ) :: X ( * ) COMPLEX ( WP ), INTENT ( IN ) :: Y ( * ) INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N END FUNCTION ZDOTC END INTERFACE DOTC INTERFACE DOTU PURE FUNCTION CDOTU ( N , X , INCX , Y , INCY ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) COMPLEX ( WP ) :: CDOTU COMPLEX ( WP ), INTENT ( IN ) :: X ( * ) COMPLEX ( WP ), INTENT ( IN ) :: Y ( * ) INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N END FUNCTION CDOTU PURE FUNCTION ZDOTU ( N , X , INCX , Y , INCY ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) COMPLEX ( WP ) :: ZDOTU COMPLEX ( WP ), INTENT ( IN ) :: X ( * ) COMPLEX ( WP ), INTENT ( IN ) :: Y ( * ) INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N END FUNCTION ZDOTU END INTERFACE DOTU INTERFACE NRM2 PURE FUNCTION SNRM2 ( N , X , INCX ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) REAL ( WP ) :: SNRM2 REAL ( WP ), INTENT ( IN ) :: X ( * ) INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N END FUNCTION SNRM2 PURE FUNCTION DNRM2 ( N , X , INCX ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) REAL ( WP ) :: DNRM2 REAL ( WP ), INTENT ( IN ) :: X ( * ) INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N END FUNCTION DNRM2 PURE FUNCTION SCNRM2 ( N , X , INCX ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) REAL ( WP ) :: SCNRM2 COMPLEX ( WP ), INTENT ( IN ) :: X ( * ) INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N END FUNCTION SCNRM2 PURE FUNCTION DZNRM2 ( N , X , INCX ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) REAL ( WP ) :: DZNRM2 COMPLEX ( WP ), INTENT ( IN ) :: X ( * ) INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N END FUNCTION DZNRM2 END INTERFACE NRM2 INTERFACE ROT PURE SUBROUTINE SROT ( N , X , INCX , Y , INCY , C , S ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) REAL ( WP ), INTENT ( INOUT ) :: X ( * ) REAL ( WP ), INTENT ( INOUT ) :: Y ( * ) REAL ( WP ), INTENT ( IN ) :: C REAL ( WP ), INTENT ( IN ) :: S INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N END SUBROUTINE SROT PURE SUBROUTINE DROT ( N , X , INCX , Y , INCY , C , S ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) REAL ( WP ), INTENT ( INOUT ) :: X ( * ) REAL ( WP ), INTENT ( INOUT ) :: Y ( * ) REAL ( WP ), INTENT ( IN ) :: C REAL ( WP ), INTENT ( IN ) :: S INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N END SUBROUTINE DROT PURE SUBROUTINE CSROT ( N , X , INCX , Y , INCY , C , S ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) COMPLEX ( WP ), INTENT ( INOUT ) :: X ( * ) COMPLEX ( WP ), INTENT ( INOUT ) :: Y ( * ) REAL ( WP ), INTENT ( IN ) :: C REAL ( WP ), INTENT ( IN ) :: S INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N END SUBROUTINE CSROT PURE SUBROUTINE ZDROT ( N , X , INCX , Y , INCY , C , S ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) COMPLEX ( WP ), INTENT ( INOUT ) :: X ( * ) COMPLEX ( WP ), INTENT ( INOUT ) :: Y ( * ) REAL ( WP ), INTENT ( IN ) :: C REAL ( WP ), INTENT ( IN ) :: S INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N END SUBROUTINE ZDROT END INTERFACE ROT INTERFACE ROTG PURE SUBROUTINE SROTG ( A , B , C , S ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) REAL ( WP ), INTENT ( INOUT ) :: A REAL ( WP ), INTENT ( INOUT ) :: B REAL ( WP ), INTENT ( OUT ) :: C REAL ( WP ), INTENT ( OUT ) :: S END SUBROUTINE SROTG PURE SUBROUTINE DROTG ( A , B , C , S ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) REAL ( WP ), INTENT ( INOUT ) :: A REAL ( WP ), INTENT ( INOUT ) :: B REAL ( WP ), INTENT ( OUT ) :: C REAL ( WP ), INTENT ( OUT ) :: S END SUBROUTINE DROTG PURE SUBROUTINE CROTG ( A , B , C , S ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) COMPLEX ( WP ), INTENT ( INOUT ) :: A COMPLEX ( WP ), INTENT ( INOUT ) :: B REAL ( WP ), INTENT ( OUT ) :: C COMPLEX ( WP ), INTENT ( OUT ) :: S END SUBROUTINE CROTG PURE SUBROUTINE ZROTG ( A , B , C , S ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) COMPLEX ( WP ), INTENT ( INOUT ) :: A COMPLEX ( WP ), INTENT ( INOUT ) :: B REAL ( WP ), INTENT ( OUT ) :: C COMPLEX ( WP ), INTENT ( OUT ) :: S END SUBROUTINE ZROTG END INTERFACE ROTG INTERFACE ROTM PURE SUBROUTINE SROTM ( N , X , INCX , Y , INCY , PARAM ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) REAL ( WP ), INTENT ( INOUT ) :: X ( * ) REAL ( WP ), INTENT ( INOUT ) :: Y ( * ) REAL ( WP ), INTENT ( IN ) :: PARAM ( 5 ) INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N END SUBROUTINE SROTM PURE SUBROUTINE DROTM ( N , X , INCX , Y , INCY , PARAM ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) REAL ( WP ), INTENT ( INOUT ) :: X ( * ) REAL ( WP ), INTENT ( INOUT ) :: Y ( * ) REAL ( WP ), INTENT ( IN ) :: PARAM ( 5 ) INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N END SUBROUTINE DROTM END INTERFACE ROTM INTERFACE ROTMG PURE SUBROUTINE SROTMG ( D1 , D2 , X1 , Y1 , PARAM ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) REAL ( WP ), INTENT ( INOUT ) :: D1 REAL ( WP ), INTENT ( INOUT ) :: D2 REAL ( WP ), INTENT ( INOUT ) :: X1 REAL ( WP ), INTENT ( IN ) :: Y1 REAL ( WP ), INTENT ( OUT ) :: PARAM ( 5 ) END SUBROUTINE SROTMG PURE SUBROUTINE DROTMG ( D1 , D2 , X1 , Y1 , PARAM ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) REAL ( WP ), INTENT ( INOUT ) :: D1 REAL ( WP ), INTENT ( INOUT ) :: D2 REAL ( WP ), INTENT ( INOUT ) :: X1 REAL ( WP ), INTENT ( IN ) :: Y1 REAL ( WP ), INTENT ( OUT ) :: PARAM ( 5 ) END SUBROUTINE DROTMG END INTERFACE ROTMG INTERFACE SCAL PURE SUBROUTINE SSCAL ( N , A , X , INCX ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) REAL ( WP ), INTENT ( INOUT ) :: X ( * ) REAL ( WP ), INTENT ( IN ) :: A INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N END SUBROUTINE SSCAL PURE SUBROUTINE DSCAL ( N , A , X , INCX ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) REAL ( WP ), INTENT ( INOUT ) :: X ( * ) REAL ( WP ), INTENT ( IN ) :: A INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N END SUBROUTINE DSCAL PURE SUBROUTINE CSCAL ( N , A , X , INCX ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) COMPLEX ( WP ), INTENT ( INOUT ) :: X ( * ) COMPLEX ( WP ), INTENT ( IN ) :: A INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N END SUBROUTINE CSCAL PURE SUBROUTINE ZSCAL ( N , A , X , INCX ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) COMPLEX ( WP ), INTENT ( INOUT ) :: X ( * ) COMPLEX ( WP ), INTENT ( IN ) :: A INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N END SUBROUTINE ZSCAL PURE SUBROUTINE CSSCAL ( N , A , X , INCX ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) COMPLEX ( WP ), INTENT ( INOUT ) :: X ( * ) REAL ( WP ), INTENT ( IN ) :: A INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N END SUBROUTINE CSSCAL PURE SUBROUTINE ZDSCAL ( N , A , X , INCX ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) COMPLEX ( WP ), INTENT ( INOUT ) :: X ( * ) REAL ( WP ), INTENT ( IN ) :: A INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N END SUBROUTINE ZDSCAL END INTERFACE SCAL INTERFACE SWAP PURE SUBROUTINE SSWAP ( N , X , INCX , Y , INCY ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) REAL ( WP ), INTENT ( INOUT ) :: X ( * ) REAL ( WP ), INTENT ( INOUT ) :: Y ( * ) INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N END SUBROUTINE SSWAP PURE SUBROUTINE DSWAP ( N , X , INCX , Y , INCY ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) REAL ( WP ), INTENT ( INOUT ) :: X ( * ) REAL ( WP ), INTENT ( INOUT ) :: Y ( * ) INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N END SUBROUTINE DSWAP PURE SUBROUTINE CSWAP ( N , X , INCX , Y , INCY ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) COMPLEX ( WP ), INTENT ( INOUT ) :: X ( * ) COMPLEX ( WP ), INTENT ( INOUT ) :: Y ( * ) INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N END SUBROUTINE CSWAP PURE SUBROUTINE ZSWAP ( N , X , INCX , Y , INCY ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) COMPLEX ( WP ), INTENT ( INOUT ) :: X ( * ) COMPLEX ( WP ), INTENT ( INOUT ) :: Y ( * ) INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N END SUBROUTINE ZSWAP END INTERFACE SWAP INTERFACE IAMAX PURE FUNCTION ISAMAX ( N , X , INCX ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) INTEGER :: ISAMAX REAL ( WP ), INTENT ( IN ) :: X ( * ) INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N END FUNCTION ISAMAX PURE FUNCTION IDAMAX ( N , X , INCX ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) INTEGER :: IDAMAX REAL ( WP ), INTENT ( IN ) :: X ( * ) INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N END FUNCTION IDAMAX PURE FUNCTION ICAMAX ( N , X , INCX ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) INTEGER :: ICAMAX COMPLEX ( WP ), INTENT ( IN ) :: X ( * ) INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N END FUNCTION ICAMAX PURE FUNCTION IZAMAX ( N , X , INCX ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) INTEGER :: IZAMAX COMPLEX ( WP ), INTENT ( IN ) :: X ( * ) INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N END FUNCTION IZAMAX END INTERFACE IAMAX INTERFACE IAMIN PURE FUNCTION ISAMIN ( N , X , INCX ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) INTEGER :: ISAMIN REAL ( WP ), INTENT ( IN ) :: X ( * ) INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N END FUNCTION ISAMIN PURE FUNCTION IDAMIN ( N , X , INCX ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) INTEGER :: IDAMIN REAL ( WP ), INTENT ( IN ) :: X ( * ) INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N END FUNCTION IDAMIN PURE FUNCTION ICAMIN ( N , X , INCX ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) INTEGER :: ICAMIN COMPLEX ( WP ), INTENT ( IN ) :: X ( * ) INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N END FUNCTION ICAMIN PURE FUNCTION IZAMIN ( N , X , INCX ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) INTEGER :: IZAMIN COMPLEX ( WP ), INTENT ( IN ) :: X ( * ) INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N END FUNCTION IZAMIN END INTERFACE IAMIN INTERFACE CABS1 PURE FUNCTION SCABS1 ( C ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) REAL ( WP ) :: SCABS1 COMPLEX ( WP ), INTENT ( IN ) :: C END FUNCTION SCABS1 PURE FUNCTION DCABS1 ( Z ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) REAL ( WP ) :: DCABS1 COMPLEX ( WP ), INTENT ( IN ) :: Z END FUNCTION DCABS1 END INTERFACE CABS1 INTERFACE GBMV PURE SUBROUTINE SGBMV ( TRANS , M , N , KL , KU , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) REAL ( WP ), INTENT ( IN ) :: A ( LDA , * ) REAL ( WP ), INTENT ( IN ) :: X ( * ) REAL ( WP ), INTENT ( INOUT ) :: Y ( * ) INTEGER , INTENT ( IN ) :: KL INTEGER , INTENT ( IN ) :: M REAL ( WP ), INTENT ( IN ) :: ALPHA REAL ( WP ), INTENT ( IN ) :: BETA CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANS INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: KU INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE SGBMV PURE SUBROUTINE DGBMV ( TRANS , M , N , KL , KU , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) REAL ( WP ), INTENT ( IN ) :: A ( LDA , * ) REAL ( WP ), INTENT ( IN ) :: X ( * ) REAL ( WP ), INTENT ( INOUT ) :: Y ( * ) INTEGER , INTENT ( IN ) :: KL INTEGER , INTENT ( IN ) :: M REAL ( WP ), INTENT ( IN ) :: ALPHA REAL ( WP ), INTENT ( IN ) :: BETA CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANS INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: KU INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE DGBMV PURE SUBROUTINE CGBMV ( TRANS , M , N , KL , KU , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) COMPLEX ( WP ), INTENT ( IN ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( IN ) :: X ( * ) COMPLEX ( WP ), INTENT ( INOUT ) :: Y ( * ) INTEGER , INTENT ( IN ) :: KL INTEGER , INTENT ( IN ) :: M COMPLEX ( WP ), INTENT ( IN ) :: ALPHA COMPLEX ( WP ), INTENT ( IN ) :: BETA CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANS INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: KU INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE CGBMV PURE SUBROUTINE ZGBMV ( TRANS , M , N , KL , KU , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) COMPLEX ( WP ), INTENT ( IN ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( IN ) :: X ( * ) COMPLEX ( WP ), INTENT ( INOUT ) :: Y ( * ) INTEGER , INTENT ( IN ) :: KL INTEGER , INTENT ( IN ) :: M COMPLEX ( WP ), INTENT ( IN ) :: ALPHA COMPLEX ( WP ), INTENT ( IN ) :: BETA CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANS INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: KU INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE ZGBMV END INTERFACE GBMV INTERFACE GEMV PURE SUBROUTINE SGEMV ( TRANS , M , N , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) REAL ( WP ), INTENT ( IN ) :: A ( LDA , * ) REAL ( WP ), INTENT ( IN ) :: X ( * ) REAL ( WP ), INTENT ( INOUT ) :: Y ( * ) REAL ( WP ), INTENT ( IN ) :: ALPHA REAL ( WP ), INTENT ( IN ) :: BETA CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANS INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: M INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE SGEMV PURE SUBROUTINE DGEMV ( TRANS , M , N , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) REAL ( WP ), INTENT ( IN ) :: A ( LDA , * ) REAL ( WP ), INTENT ( IN ) :: X ( * ) REAL ( WP ), INTENT ( INOUT ) :: Y ( * ) REAL ( WP ), INTENT ( IN ) :: ALPHA REAL ( WP ), INTENT ( IN ) :: BETA CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANS INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: M INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE DGEMV PURE SUBROUTINE CGEMV ( TRANS , M , N , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) COMPLEX ( WP ), INTENT ( IN ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( IN ) :: X ( * ) COMPLEX ( WP ), INTENT ( INOUT ) :: Y ( * ) COMPLEX ( WP ), INTENT ( IN ) :: ALPHA COMPLEX ( WP ), INTENT ( IN ) :: BETA CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANS INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: M INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE CGEMV PURE SUBROUTINE ZGEMV ( TRANS , M , N , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) COMPLEX ( WP ), INTENT ( IN ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( IN ) :: X ( * ) COMPLEX ( WP ), INTENT ( INOUT ) :: Y ( * ) COMPLEX ( WP ), INTENT ( IN ) :: ALPHA COMPLEX ( WP ), INTENT ( IN ) :: BETA CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANS INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: M INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE ZGEMV PURE SUBROUTINE SCGEMV ( TRANS , M , N , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) REAL ( WP ), INTENT ( IN ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( IN ) :: X ( * ) COMPLEX ( WP ), INTENT ( INOUT ) :: Y ( * ) COMPLEX ( WP ), INTENT ( IN ) :: ALPHA COMPLEX ( WP ), INTENT ( IN ) :: BETA CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANS INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: M INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE SCGEMV PURE SUBROUTINE DZGEMV ( TRANS , M , N , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) REAL ( WP ), INTENT ( IN ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( IN ) :: X ( * ) COMPLEX ( WP ), INTENT ( INOUT ) :: Y ( * ) COMPLEX ( WP ), INTENT ( IN ) :: ALPHA COMPLEX ( WP ), INTENT ( IN ) :: BETA CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANS INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: M INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE DZGEMV END INTERFACE GEMV INTERFACE GER PURE SUBROUTINE SGER ( M , N , ALPHA , X , INCX , Y , INCY , A , LDA ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) REAL ( WP ), INTENT ( INOUT ) :: A ( LDA , * ) REAL ( WP ), INTENT ( IN ) :: X ( * ) REAL ( WP ), INTENT ( IN ) :: Y ( * ) REAL ( WP ), INTENT ( IN ) :: ALPHA INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: M INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE SGER PURE SUBROUTINE DGER ( M , N , ALPHA , X , INCX , Y , INCY , A , LDA ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) REAL ( WP ), INTENT ( INOUT ) :: A ( LDA , * ) REAL ( WP ), INTENT ( IN ) :: X ( * ) REAL ( WP ), INTENT ( IN ) :: Y ( * ) REAL ( WP ), INTENT ( IN ) :: ALPHA INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: M INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE DGER END INTERFACE GER INTERFACE GERC PURE SUBROUTINE CGERC ( M , N , ALPHA , X , INCX , Y , INCY , A , LDA ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) COMPLEX ( WP ), INTENT ( INOUT ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( IN ) :: X ( * ) COMPLEX ( WP ), INTENT ( IN ) :: Y ( * ) COMPLEX ( WP ), INTENT ( IN ) :: ALPHA INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: M INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE CGERC PURE SUBROUTINE ZGERC ( M , N , ALPHA , X , INCX , Y , INCY , A , LDA ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) COMPLEX ( WP ), INTENT ( INOUT ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( IN ) :: X ( * ) COMPLEX ( WP ), INTENT ( IN ) :: Y ( * ) COMPLEX ( WP ), INTENT ( IN ) :: ALPHA INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: M INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE ZGERC END INTERFACE GERC INTERFACE GERU PURE SUBROUTINE CGERU ( M , N , ALPHA , X , INCX , Y , INCY , A , LDA ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) COMPLEX ( WP ), INTENT ( INOUT ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( IN ) :: X ( * ) COMPLEX ( WP ), INTENT ( IN ) :: Y ( * ) COMPLEX ( WP ), INTENT ( IN ) :: ALPHA INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: M INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE CGERU PURE SUBROUTINE ZGERU ( M , N , ALPHA , X , INCX , Y , INCY , A , LDA ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) COMPLEX ( WP ), INTENT ( INOUT ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( IN ) :: X ( * ) COMPLEX ( WP ), INTENT ( IN ) :: Y ( * ) COMPLEX ( WP ), INTENT ( IN ) :: ALPHA INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: M INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE ZGERU END INTERFACE GERU INTERFACE HBMV PURE SUBROUTINE CHBMV ( UPLO , N , K , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) COMPLEX ( WP ), INTENT ( IN ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( IN ) :: X ( * ) COMPLEX ( WP ), INTENT ( INOUT ) :: Y ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO COMPLEX ( WP ), INTENT ( IN ) :: ALPHA COMPLEX ( WP ), INTENT ( IN ) :: BETA INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: K INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE CHBMV PURE SUBROUTINE ZHBMV ( UPLO , N , K , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) COMPLEX ( WP ), INTENT ( IN ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( IN ) :: X ( * ) COMPLEX ( WP ), INTENT ( INOUT ) :: Y ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO COMPLEX ( WP ), INTENT ( IN ) :: ALPHA COMPLEX ( WP ), INTENT ( IN ) :: BETA INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: K INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE ZHBMV END INTERFACE HBMV INTERFACE HEMV PURE SUBROUTINE CHEMV ( UPLO , N , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) COMPLEX ( WP ), INTENT ( IN ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( IN ) :: X ( * ) COMPLEX ( WP ), INTENT ( INOUT ) :: Y ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO COMPLEX ( WP ), INTENT ( IN ) :: ALPHA COMPLEX ( WP ), INTENT ( IN ) :: BETA INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE CHEMV PURE SUBROUTINE ZHEMV ( UPLO , N , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) COMPLEX ( WP ), INTENT ( IN ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( IN ) :: X ( * ) COMPLEX ( WP ), INTENT ( INOUT ) :: Y ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO COMPLEX ( WP ), INTENT ( IN ) :: ALPHA COMPLEX ( WP ), INTENT ( IN ) :: BETA INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE ZHEMV END INTERFACE HEMV INTERFACE HER PURE SUBROUTINE CHER ( UPLO , N , ALPHA , X , INCX , A , LDA ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) COMPLEX ( WP ), INTENT ( INOUT ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( IN ) :: X ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO REAL ( WP ), INTENT ( IN ) :: ALPHA INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE CHER PURE SUBROUTINE ZHER ( UPLO , N , ALPHA , X , INCX , A , LDA ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) COMPLEX ( WP ), INTENT ( INOUT ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( IN ) :: X ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO REAL ( WP ), INTENT ( IN ) :: ALPHA INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE ZHER END INTERFACE HER INTERFACE HER2 PURE SUBROUTINE CHER2 ( UPLO , N , ALPHA , X , INCX , Y , INCY , A , LDA ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) COMPLEX ( WP ), INTENT ( INOUT ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( IN ) :: X ( * ) COMPLEX ( WP ), INTENT ( IN ) :: Y ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO COMPLEX ( WP ), INTENT ( IN ) :: ALPHA INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE CHER2 PURE SUBROUTINE ZHER2 ( UPLO , N , ALPHA , X , INCX , Y , INCY , A , LDA ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) COMPLEX ( WP ), INTENT ( INOUT ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( IN ) :: X ( * ) COMPLEX ( WP ), INTENT ( IN ) :: Y ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO COMPLEX ( WP ), INTENT ( IN ) :: ALPHA INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE ZHER2 END INTERFACE HER2 INTERFACE HPMV PURE SUBROUTINE CHPMV ( UPLO , N , ALPHA , AP , X , INCX , BETA , Y , INCY ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) COMPLEX ( WP ), INTENT ( IN ) :: AP ( * ) COMPLEX ( WP ), INTENT ( IN ) :: X ( * ) COMPLEX ( WP ), INTENT ( INOUT ) :: Y ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO COMPLEX ( WP ), INTENT ( IN ) :: ALPHA COMPLEX ( WP ), INTENT ( IN ) :: BETA INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N END SUBROUTINE CHPMV PURE SUBROUTINE ZHPMV ( UPLO , N , ALPHA , AP , X , INCX , BETA , Y , INCY ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) COMPLEX ( WP ), INTENT ( IN ) :: AP ( * ) COMPLEX ( WP ), INTENT ( IN ) :: X ( * ) COMPLEX ( WP ), INTENT ( INOUT ) :: Y ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO COMPLEX ( WP ), INTENT ( IN ) :: ALPHA COMPLEX ( WP ), INTENT ( IN ) :: BETA INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N END SUBROUTINE ZHPMV END INTERFACE HPMV INTERFACE HPR PURE SUBROUTINE CHPR ( UPLO , N , ALPHA , X , INCX , AP ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) COMPLEX ( WP ), INTENT ( INOUT ) :: AP ( * ) COMPLEX ( WP ), INTENT ( IN ) :: X ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO REAL ( WP ), INTENT ( IN ) :: ALPHA INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N END SUBROUTINE CHPR PURE SUBROUTINE ZHPR ( UPLO , N , ALPHA , X , INCX , AP ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) COMPLEX ( WP ), INTENT ( INOUT ) :: AP ( * ) COMPLEX ( WP ), INTENT ( IN ) :: X ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO REAL ( WP ), INTENT ( IN ) :: ALPHA INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N END SUBROUTINE ZHPR END INTERFACE HPR INTERFACE HPR2 PURE SUBROUTINE CHPR2 ( UPLO , N , ALPHA , X , INCX , Y , INCY , AP ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) COMPLEX ( WP ), INTENT ( INOUT ) :: AP ( * ) COMPLEX ( WP ), INTENT ( IN ) :: X ( * ) COMPLEX ( WP ), INTENT ( IN ) :: Y ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO COMPLEX ( WP ), INTENT ( IN ) :: ALPHA INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N END SUBROUTINE CHPR2 PURE SUBROUTINE ZHPR2 ( UPLO , N , ALPHA , X , INCX , Y , INCY , AP ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) COMPLEX ( WP ), INTENT ( INOUT ) :: AP ( * ) COMPLEX ( WP ), INTENT ( IN ) :: X ( * ) COMPLEX ( WP ), INTENT ( IN ) :: Y ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO COMPLEX ( WP ), INTENT ( IN ) :: ALPHA INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N END SUBROUTINE ZHPR2 END INTERFACE HPR2 INTERFACE SBMV PURE SUBROUTINE SSBMV ( UPLO , N , K , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) REAL ( WP ), INTENT ( IN ) :: A ( LDA , * ) REAL ( WP ), INTENT ( IN ) :: X ( * ) REAL ( WP ), INTENT ( INOUT ) :: Y ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO REAL ( WP ), INTENT ( IN ) :: ALPHA REAL ( WP ), INTENT ( IN ) :: BETA INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: K INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE SSBMV PURE SUBROUTINE DSBMV ( UPLO , N , K , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) REAL ( WP ), INTENT ( IN ) :: A ( LDA , * ) REAL ( WP ), INTENT ( IN ) :: X ( * ) REAL ( WP ), INTENT ( INOUT ) :: Y ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO REAL ( WP ), INTENT ( IN ) :: ALPHA REAL ( WP ), INTENT ( IN ) :: BETA INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: K INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE DSBMV END INTERFACE SBMV INTERFACE SPMV PURE SUBROUTINE SSPMV ( UPLO , N , ALPHA , AP , X , INCX , BETA , Y , INCY ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) REAL ( WP ), INTENT ( IN ) :: AP ( * ) REAL ( WP ), INTENT ( IN ) :: X ( * ) REAL ( WP ), INTENT ( INOUT ) :: Y ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO REAL ( WP ), INTENT ( IN ) :: ALPHA REAL ( WP ), INTENT ( IN ) :: BETA INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N END SUBROUTINE SSPMV PURE SUBROUTINE DSPMV ( UPLO , N , ALPHA , AP , X , INCX , BETA , Y , INCY ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) REAL ( WP ), INTENT ( IN ) :: AP ( * ) REAL ( WP ), INTENT ( IN ) :: X ( * ) REAL ( WP ), INTENT ( INOUT ) :: Y ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO REAL ( WP ), INTENT ( IN ) :: ALPHA REAL ( WP ), INTENT ( IN ) :: BETA INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N END SUBROUTINE DSPMV END INTERFACE SPMV INTERFACE SPR PURE SUBROUTINE SSPR ( UPLO , N , ALPHA , X , INCX , AP ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) REAL ( WP ), INTENT ( INOUT ) :: AP ( * ) REAL ( WP ), INTENT ( IN ) :: X ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO REAL ( WP ), INTENT ( IN ) :: ALPHA INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N END SUBROUTINE SSPR PURE SUBROUTINE DSPR ( UPLO , N , ALPHA , X , INCX , AP ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) REAL ( WP ), INTENT ( INOUT ) :: AP ( * ) REAL ( WP ), INTENT ( IN ) :: X ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO REAL ( WP ), INTENT ( IN ) :: ALPHA INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N END SUBROUTINE DSPR END INTERFACE SPR INTERFACE SPR2 PURE SUBROUTINE SSPR2 ( UPLO , N , ALPHA , X , INCX , Y , INCY , AP ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) REAL ( WP ), INTENT ( INOUT ) :: AP ( * ) REAL ( WP ), INTENT ( IN ) :: X ( * ) REAL ( WP ), INTENT ( IN ) :: Y ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO REAL ( WP ), INTENT ( IN ) :: ALPHA INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N END SUBROUTINE SSPR2 PURE SUBROUTINE DSPR2 ( UPLO , N , ALPHA , X , INCX , Y , INCY , AP ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) REAL ( WP ), INTENT ( INOUT ) :: AP ( * ) REAL ( WP ), INTENT ( IN ) :: X ( * ) REAL ( WP ), INTENT ( IN ) :: Y ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO REAL ( WP ), INTENT ( IN ) :: ALPHA INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N END SUBROUTINE DSPR2 END INTERFACE SPR2 INTERFACE SYMV PURE SUBROUTINE SSYMV ( UPLO , N , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) REAL ( WP ), INTENT ( IN ) :: A ( LDA , * ) REAL ( WP ), INTENT ( IN ) :: X ( * ) REAL ( WP ), INTENT ( INOUT ) :: Y ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO REAL ( WP ), INTENT ( IN ) :: ALPHA REAL ( WP ), INTENT ( IN ) :: BETA INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE SSYMV PURE SUBROUTINE DSYMV ( UPLO , N , ALPHA , A , LDA , X , INCX , BETA , Y , INCY ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) REAL ( WP ), INTENT ( IN ) :: A ( LDA , * ) REAL ( WP ), INTENT ( IN ) :: X ( * ) REAL ( WP ), INTENT ( INOUT ) :: Y ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO REAL ( WP ), INTENT ( IN ) :: ALPHA REAL ( WP ), INTENT ( IN ) :: BETA INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE DSYMV END INTERFACE SYMV INTERFACE SYR PURE SUBROUTINE SSYR ( UPLO , N , ALPHA , X , INCX , A , LDA ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) REAL ( WP ), INTENT ( INOUT ) :: A ( LDA , * ) REAL ( WP ), INTENT ( IN ) :: X ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO REAL ( WP ), INTENT ( IN ) :: ALPHA INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE SSYR PURE SUBROUTINE DSYR ( UPLO , N , ALPHA , X , INCX , A , LDA ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) REAL ( WP ), INTENT ( INOUT ) :: A ( LDA , * ) REAL ( WP ), INTENT ( IN ) :: X ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO REAL ( WP ), INTENT ( IN ) :: ALPHA INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE DSYR END INTERFACE SYR INTERFACE SYR2 PURE SUBROUTINE SSYR2 ( UPLO , N , ALPHA , X , INCX , Y , INCY , A , LDA ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) REAL ( WP ), INTENT ( INOUT ) :: A ( LDA , * ) REAL ( WP ), INTENT ( IN ) :: X ( * ) REAL ( WP ), INTENT ( IN ) :: Y ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO REAL ( WP ), INTENT ( IN ) :: ALPHA INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE SSYR2 PURE SUBROUTINE DSYR2 ( UPLO , N , ALPHA , X , INCX , Y , INCY , A , LDA ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) REAL ( WP ), INTENT ( INOUT ) :: A ( LDA , * ) REAL ( WP ), INTENT ( IN ) :: X ( * ) REAL ( WP ), INTENT ( IN ) :: Y ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO REAL ( WP ), INTENT ( IN ) :: ALPHA INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE DSYR2 END INTERFACE SYR2 INTERFACE TBMV PURE SUBROUTINE STBMV ( UPLO , TRANS , DIAG , N , K , A , LDA , X , INCX ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) REAL ( WP ), INTENT ( IN ) :: A ( LDA , * ) REAL ( WP ), INTENT ( INOUT ) :: X ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANS CHARACTER ( LEN = 1 ), INTENT ( IN ) :: DIAG INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: K INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE STBMV PURE SUBROUTINE DTBMV ( UPLO , TRANS , DIAG , N , K , A , LDA , X , INCX ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) REAL ( WP ), INTENT ( IN ) :: A ( LDA , * ) REAL ( WP ), INTENT ( INOUT ) :: X ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANS CHARACTER ( LEN = 1 ), INTENT ( IN ) :: DIAG INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: K INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE DTBMV PURE SUBROUTINE CTBMV ( UPLO , TRANS , DIAG , N , K , A , LDA , X , INCX ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) COMPLEX ( WP ), INTENT ( IN ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( INOUT ) :: X ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANS CHARACTER ( LEN = 1 ), INTENT ( IN ) :: DIAG INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: K INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE CTBMV PURE SUBROUTINE ZTBMV ( UPLO , TRANS , DIAG , N , K , A , LDA , X , INCX ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) COMPLEX ( WP ), INTENT ( IN ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( INOUT ) :: X ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANS CHARACTER ( LEN = 1 ), INTENT ( IN ) :: DIAG INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: K INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE ZTBMV END INTERFACE TBMV INTERFACE TBSV PURE SUBROUTINE STBSV ( UPLO , TRANS , DIAG , N , K , A , LDA , X , INCX ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) REAL ( WP ), INTENT ( IN ) :: A ( LDA , * ) REAL ( WP ), INTENT ( INOUT ) :: X ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANS CHARACTER ( LEN = 1 ), INTENT ( IN ) :: DIAG INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: K INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE STBSV PURE SUBROUTINE DTBSV ( UPLO , TRANS , DIAG , N , K , A , LDA , X , INCX ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) REAL ( WP ), INTENT ( IN ) :: A ( LDA , * ) REAL ( WP ), INTENT ( INOUT ) :: X ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANS CHARACTER ( LEN = 1 ), INTENT ( IN ) :: DIAG INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: K INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE DTBSV PURE SUBROUTINE CTBSV ( UPLO , TRANS , DIAG , N , K , A , LDA , X , INCX ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) COMPLEX ( WP ), INTENT ( IN ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( INOUT ) :: X ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANS CHARACTER ( LEN = 1 ), INTENT ( IN ) :: DIAG INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: K INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE CTBSV PURE SUBROUTINE ZTBSV ( UPLO , TRANS , DIAG , N , K , A , LDA , X , INCX ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) COMPLEX ( WP ), INTENT ( IN ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( INOUT ) :: X ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANS CHARACTER ( LEN = 1 ), INTENT ( IN ) :: DIAG INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: K INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE ZTBSV END INTERFACE TBSV INTERFACE TPMV PURE SUBROUTINE STPMV ( UPLO , TRANS , DIAG , N , AP , X , INCX ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) REAL ( WP ), INTENT ( IN ) :: AP ( * ) REAL ( WP ), INTENT ( INOUT ) :: X ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANS CHARACTER ( LEN = 1 ), INTENT ( IN ) :: DIAG INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N END SUBROUTINE STPMV PURE SUBROUTINE DTPMV ( UPLO , TRANS , DIAG , N , AP , X , INCX ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) REAL ( WP ), INTENT ( IN ) :: AP ( * ) REAL ( WP ), INTENT ( INOUT ) :: X ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANS CHARACTER ( LEN = 1 ), INTENT ( IN ) :: DIAG INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N END SUBROUTINE DTPMV PURE SUBROUTINE CTPMV ( UPLO , TRANS , DIAG , N , AP , X , INCX ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) COMPLEX ( WP ), INTENT ( IN ) :: AP ( * ) COMPLEX ( WP ), INTENT ( INOUT ) :: X ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANS CHARACTER ( LEN = 1 ), INTENT ( IN ) :: DIAG INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N END SUBROUTINE CTPMV PURE SUBROUTINE ZTPMV ( UPLO , TRANS , DIAG , N , AP , X , INCX ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) COMPLEX ( WP ), INTENT ( IN ) :: AP ( * ) COMPLEX ( WP ), INTENT ( INOUT ) :: X ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANS CHARACTER ( LEN = 1 ), INTENT ( IN ) :: DIAG INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N END SUBROUTINE ZTPMV END INTERFACE TPMV INTERFACE TPSV PURE SUBROUTINE STPSV ( UPLO , TRANS , DIAG , N , AP , X , INCX ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) REAL ( WP ), INTENT ( IN ) :: AP ( * ) REAL ( WP ), INTENT ( INOUT ) :: X ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANS CHARACTER ( LEN = 1 ), INTENT ( IN ) :: DIAG INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N END SUBROUTINE STPSV PURE SUBROUTINE DTPSV ( UPLO , TRANS , DIAG , N , AP , X , INCX ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) REAL ( WP ), INTENT ( IN ) :: AP ( * ) REAL ( WP ), INTENT ( INOUT ) :: X ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANS CHARACTER ( LEN = 1 ), INTENT ( IN ) :: DIAG INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N END SUBROUTINE DTPSV PURE SUBROUTINE CTPSV ( UPLO , TRANS , DIAG , N , AP , X , INCX ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) COMPLEX ( WP ), INTENT ( IN ) :: AP ( * ) COMPLEX ( WP ), INTENT ( INOUT ) :: X ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANS CHARACTER ( LEN = 1 ), INTENT ( IN ) :: DIAG INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N END SUBROUTINE CTPSV PURE SUBROUTINE ZTPSV ( UPLO , TRANS , DIAG , N , AP , X , INCX ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) COMPLEX ( WP ), INTENT ( IN ) :: AP ( * ) COMPLEX ( WP ), INTENT ( INOUT ) :: X ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANS CHARACTER ( LEN = 1 ), INTENT ( IN ) :: DIAG INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N END SUBROUTINE ZTPSV END INTERFACE TPSV INTERFACE TRMV PURE SUBROUTINE STRMV ( UPLO , TRANS , DIAG , N , A , LDA , X , INCX ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) REAL ( WP ), INTENT ( IN ) :: A ( LDA , * ) REAL ( WP ), INTENT ( INOUT ) :: X ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANS CHARACTER ( LEN = 1 ), INTENT ( IN ) :: DIAG INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE STRMV PURE SUBROUTINE DTRMV ( UPLO , TRANS , DIAG , N , A , LDA , X , INCX ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) REAL ( WP ), INTENT ( IN ) :: A ( LDA , * ) REAL ( WP ), INTENT ( INOUT ) :: X ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANS CHARACTER ( LEN = 1 ), INTENT ( IN ) :: DIAG INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE DTRMV PURE SUBROUTINE CTRMV ( UPLO , TRANS , DIAG , N , A , LDA , X , INCX ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) COMPLEX ( WP ), INTENT ( IN ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( INOUT ) :: X ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANS CHARACTER ( LEN = 1 ), INTENT ( IN ) :: DIAG INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE CTRMV PURE SUBROUTINE ZTRMV ( UPLO , TRANS , DIAG , N , A , LDA , X , INCX ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) COMPLEX ( WP ), INTENT ( IN ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( INOUT ) :: X ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANS CHARACTER ( LEN = 1 ), INTENT ( IN ) :: DIAG INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE ZTRMV END INTERFACE TRMV INTERFACE TRSV PURE SUBROUTINE STRSV ( UPLO , TRANS , DIAG , N , A , LDA , X , INCX ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) REAL ( WP ), INTENT ( IN ) :: A ( LDA , * ) REAL ( WP ), INTENT ( INOUT ) :: X ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANS CHARACTER ( LEN = 1 ), INTENT ( IN ) :: DIAG INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE STRSV PURE SUBROUTINE DTRSV ( UPLO , TRANS , DIAG , N , A , LDA , X , INCX ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) REAL ( WP ), INTENT ( IN ) :: A ( LDA , * ) REAL ( WP ), INTENT ( INOUT ) :: X ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANS CHARACTER ( LEN = 1 ), INTENT ( IN ) :: DIAG INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE DTRSV PURE SUBROUTINE CTRSV ( UPLO , TRANS , DIAG , N , A , LDA , X , INCX ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) COMPLEX ( WP ), INTENT ( IN ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( INOUT ) :: X ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANS CHARACTER ( LEN = 1 ), INTENT ( IN ) :: DIAG INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE CTRSV PURE SUBROUTINE ZTRSV ( UPLO , TRANS , DIAG , N , A , LDA , X , INCX ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) COMPLEX ( WP ), INTENT ( IN ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( INOUT ) :: X ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANS CHARACTER ( LEN = 1 ), INTENT ( IN ) :: DIAG INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE ZTRSV END INTERFACE TRSV INTERFACE GEMM PURE SUBROUTINE SGEMM ( TRANSA , TRANSB , M , N , K , ALPHA , A , LDA , B , LDB , BETA , C , & & LDC ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) REAL ( WP ), INTENT ( IN ) :: A ( LDA , * ) REAL ( WP ), INTENT ( IN ) :: B ( LDB , * ) REAL ( WP ), INTENT ( INOUT ) :: C ( LDC , * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANSA CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANSB REAL ( WP ), INTENT ( IN ) :: ALPHA REAL ( WP ), INTENT ( IN ) :: BETA INTEGER , INTENT ( IN ) :: M INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: K INTEGER , INTENT ( IN ) :: LDA INTEGER , INTENT ( IN ) :: LDB INTEGER , INTENT ( IN ) :: LDC END SUBROUTINE SGEMM PURE SUBROUTINE DGEMM ( TRANSA , TRANSB , M , N , K , ALPHA , A , LDA , B , LDB , BETA , C , & & LDC ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) REAL ( WP ), INTENT ( IN ) :: A ( LDA , * ) REAL ( WP ), INTENT ( IN ) :: B ( LDB , * ) REAL ( WP ), INTENT ( INOUT ) :: C ( LDC , * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANSA CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANSB REAL ( WP ), INTENT ( IN ) :: ALPHA REAL ( WP ), INTENT ( IN ) :: BETA INTEGER , INTENT ( IN ) :: M INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: K INTEGER , INTENT ( IN ) :: LDA INTEGER , INTENT ( IN ) :: LDB INTEGER , INTENT ( IN ) :: LDC END SUBROUTINE DGEMM PURE SUBROUTINE CGEMM ( TRANSA , TRANSB , M , N , K , ALPHA , A , LDA , B , LDB , BETA , C , & & LDC ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) COMPLEX ( WP ), INTENT ( IN ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( IN ) :: B ( LDB , * ) COMPLEX ( WP ), INTENT ( INOUT ) :: C ( LDC , * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANSA CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANSB COMPLEX ( WP ), INTENT ( IN ) :: ALPHA COMPLEX ( WP ), INTENT ( IN ) :: BETA INTEGER , INTENT ( IN ) :: M INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: K INTEGER , INTENT ( IN ) :: LDA INTEGER , INTENT ( IN ) :: LDB INTEGER , INTENT ( IN ) :: LDC END SUBROUTINE CGEMM PURE SUBROUTINE ZGEMM ( TRANSA , TRANSB , M , N , K , ALPHA , A , LDA , B , LDB , BETA , C , & & LDC ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) COMPLEX ( WP ), INTENT ( IN ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( IN ) :: B ( LDB , * ) COMPLEX ( WP ), INTENT ( INOUT ) :: C ( LDC , * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANSA CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANSB COMPLEX ( WP ), INTENT ( IN ) :: ALPHA COMPLEX ( WP ), INTENT ( IN ) :: BETA INTEGER , INTENT ( IN ) :: M INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: K INTEGER , INTENT ( IN ) :: LDA INTEGER , INTENT ( IN ) :: LDB INTEGER , INTENT ( IN ) :: LDC END SUBROUTINE ZGEMM PURE SUBROUTINE SCGEMM ( TRANSA , TRANSB , M , N , K , ALPHA , A , LDA , B , LDB , BETA , C , & & LDC ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) REAL ( WP ), INTENT ( IN ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( IN ) :: B ( LDB , * ) COMPLEX ( WP ), INTENT ( INOUT ) :: C ( LDC , * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANSA CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANSB COMPLEX ( WP ), INTENT ( IN ) :: ALPHA COMPLEX ( WP ), INTENT ( IN ) :: BETA INTEGER , INTENT ( IN ) :: M INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: K INTEGER , INTENT ( IN ) :: LDA INTEGER , INTENT ( IN ) :: LDB INTEGER , INTENT ( IN ) :: LDC END SUBROUTINE SCGEMM PURE SUBROUTINE DZGEMM ( TRANSA , TRANSB , M , N , K , ALPHA , A , LDA , B , LDB , BETA , C , & & LDC ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) REAL ( WP ), INTENT ( IN ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( IN ) :: B ( LDB , * ) COMPLEX ( WP ), INTENT ( INOUT ) :: C ( LDC , * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANSA CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANSB COMPLEX ( WP ), INTENT ( IN ) :: ALPHA COMPLEX ( WP ), INTENT ( IN ) :: BETA INTEGER , INTENT ( IN ) :: M INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: K INTEGER , INTENT ( IN ) :: LDA INTEGER , INTENT ( IN ) :: LDB INTEGER , INTENT ( IN ) :: LDC END SUBROUTINE DZGEMM END INTERFACE GEMM INTERFACE HEMM PURE SUBROUTINE CHEMM ( SIDE , UPLO , M , N , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) COMPLEX ( WP ), INTENT ( IN ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( IN ) :: B ( LDB , * ) COMPLEX ( WP ), INTENT ( INOUT ) :: C ( LDC , * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: SIDE CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO COMPLEX ( WP ), INTENT ( IN ) :: ALPHA COMPLEX ( WP ), INTENT ( IN ) :: BETA INTEGER , INTENT ( IN ) :: M INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: LDA INTEGER , INTENT ( IN ) :: LDB INTEGER , INTENT ( IN ) :: LDC END SUBROUTINE CHEMM PURE SUBROUTINE ZHEMM ( SIDE , UPLO , M , N , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) COMPLEX ( WP ), INTENT ( IN ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( IN ) :: B ( LDB , * ) COMPLEX ( WP ), INTENT ( INOUT ) :: C ( LDC , * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: SIDE CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO COMPLEX ( WP ), INTENT ( IN ) :: ALPHA COMPLEX ( WP ), INTENT ( IN ) :: BETA INTEGER , INTENT ( IN ) :: M INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: LDA INTEGER , INTENT ( IN ) :: LDB INTEGER , INTENT ( IN ) :: LDC END SUBROUTINE ZHEMM END INTERFACE HEMM INTERFACE HERK PURE SUBROUTINE CHERK ( UPLO , TRANS , N , K , ALPHA , A , LDA , BETA , C , LDC ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) COMPLEX ( WP ), INTENT ( IN ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( INOUT ) :: C ( LDC , * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANS REAL ( WP ), INTENT ( IN ) :: ALPHA REAL ( WP ), INTENT ( IN ) :: BETA INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: K INTEGER , INTENT ( IN ) :: LDA INTEGER , INTENT ( IN ) :: LDC END SUBROUTINE CHERK PURE SUBROUTINE ZHERK ( UPLO , TRANS , N , K , ALPHA , A , LDA , BETA , C , LDC ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) COMPLEX ( WP ), INTENT ( IN ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( INOUT ) :: C ( LDC , * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANS REAL ( WP ), INTENT ( IN ) :: ALPHA REAL ( WP ), INTENT ( IN ) :: BETA INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: K INTEGER , INTENT ( IN ) :: LDA INTEGER , INTENT ( IN ) :: LDC END SUBROUTINE ZHERK END INTERFACE HERK INTERFACE HER2K PURE SUBROUTINE CHER2K ( UPLO , TRANS , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) COMPLEX ( WP ), INTENT ( IN ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( IN ) :: B ( LDB , * ) COMPLEX ( WP ), INTENT ( INOUT ) :: C ( LDC , * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANS COMPLEX ( WP ), INTENT ( IN ) :: ALPHA REAL ( WP ), INTENT ( IN ) :: BETA INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: K INTEGER , INTENT ( IN ) :: LDA INTEGER , INTENT ( IN ) :: LDB INTEGER , INTENT ( IN ) :: LDC END SUBROUTINE CHER2K PURE SUBROUTINE ZHER2K ( UPLO , TRANS , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) COMPLEX ( WP ), INTENT ( IN ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( IN ) :: B ( LDB , * ) COMPLEX ( WP ), INTENT ( INOUT ) :: C ( LDC , * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANS COMPLEX ( WP ), INTENT ( IN ) :: ALPHA REAL ( WP ), INTENT ( IN ) :: BETA INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: K INTEGER , INTENT ( IN ) :: LDA INTEGER , INTENT ( IN ) :: LDB INTEGER , INTENT ( IN ) :: LDC END SUBROUTINE ZHER2K END INTERFACE HER2K INTERFACE SYMM PURE SUBROUTINE SSYMM ( SIDE , UPLO , M , N , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) REAL ( WP ), INTENT ( IN ) :: A ( LDA , * ) REAL ( WP ), INTENT ( IN ) :: B ( LDB , * ) REAL ( WP ), INTENT ( INOUT ) :: C ( LDC , * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: SIDE CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO REAL ( WP ), INTENT ( IN ) :: ALPHA REAL ( WP ), INTENT ( IN ) :: BETA INTEGER , INTENT ( IN ) :: M INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: LDA INTEGER , INTENT ( IN ) :: LDB INTEGER , INTENT ( IN ) :: LDC END SUBROUTINE SSYMM PURE SUBROUTINE DSYMM ( SIDE , UPLO , M , N , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) REAL ( WP ), INTENT ( IN ) :: A ( LDA , * ) REAL ( WP ), INTENT ( IN ) :: B ( LDB , * ) REAL ( WP ), INTENT ( INOUT ) :: C ( LDC , * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: SIDE CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO REAL ( WP ), INTENT ( IN ) :: ALPHA REAL ( WP ), INTENT ( IN ) :: BETA INTEGER , INTENT ( IN ) :: M INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: LDA INTEGER , INTENT ( IN ) :: LDB INTEGER , INTENT ( IN ) :: LDC END SUBROUTINE DSYMM PURE SUBROUTINE CSYMM ( SIDE , UPLO , M , N , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) COMPLEX ( WP ), INTENT ( IN ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( IN ) :: B ( LDB , * ) COMPLEX ( WP ), INTENT ( INOUT ) :: C ( LDC , * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: SIDE CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO COMPLEX ( WP ), INTENT ( IN ) :: ALPHA COMPLEX ( WP ), INTENT ( IN ) :: BETA INTEGER , INTENT ( IN ) :: M INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: LDA INTEGER , INTENT ( IN ) :: LDB INTEGER , INTENT ( IN ) :: LDC END SUBROUTINE CSYMM PURE SUBROUTINE ZSYMM ( SIDE , UPLO , M , N , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) COMPLEX ( WP ), INTENT ( IN ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( IN ) :: B ( LDB , * ) COMPLEX ( WP ), INTENT ( INOUT ) :: C ( LDC , * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: SIDE CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO COMPLEX ( WP ), INTENT ( IN ) :: ALPHA COMPLEX ( WP ), INTENT ( IN ) :: BETA INTEGER , INTENT ( IN ) :: M INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: LDA INTEGER , INTENT ( IN ) :: LDB INTEGER , INTENT ( IN ) :: LDC END SUBROUTINE ZSYMM END INTERFACE SYMM INTERFACE SYRK PURE SUBROUTINE SSYRK ( UPLO , TRANS , N , K , ALPHA , A , LDA , BETA , C , LDC ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) REAL ( WP ), INTENT ( IN ) :: A ( LDA , * ) REAL ( WP ), INTENT ( INOUT ) :: C ( LDC , * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANS REAL ( WP ), INTENT ( IN ) :: ALPHA REAL ( WP ), INTENT ( IN ) :: BETA INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: K INTEGER , INTENT ( IN ) :: LDA INTEGER , INTENT ( IN ) :: LDC END SUBROUTINE SSYRK PURE SUBROUTINE DSYRK ( UPLO , TRANS , N , K , ALPHA , A , LDA , BETA , C , LDC ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) REAL ( WP ), INTENT ( IN ) :: A ( LDA , * ) REAL ( WP ), INTENT ( INOUT ) :: C ( LDC , * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANS REAL ( WP ), INTENT ( IN ) :: ALPHA REAL ( WP ), INTENT ( IN ) :: BETA INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: K INTEGER , INTENT ( IN ) :: LDA INTEGER , INTENT ( IN ) :: LDC END SUBROUTINE DSYRK PURE SUBROUTINE CSYRK ( UPLO , TRANS , N , K , ALPHA , A , LDA , BETA , C , LDC ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) COMPLEX ( WP ), INTENT ( IN ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( INOUT ) :: C ( LDC , * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANS COMPLEX ( WP ), INTENT ( IN ) :: ALPHA COMPLEX ( WP ), INTENT ( IN ) :: BETA INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: K INTEGER , INTENT ( IN ) :: LDA INTEGER , INTENT ( IN ) :: LDC END SUBROUTINE CSYRK PURE SUBROUTINE ZSYRK ( UPLO , TRANS , N , K , ALPHA , A , LDA , BETA , C , LDC ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) COMPLEX ( WP ), INTENT ( IN ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( INOUT ) :: C ( LDC , * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANS COMPLEX ( WP ), INTENT ( IN ) :: ALPHA COMPLEX ( WP ), INTENT ( IN ) :: BETA INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: K INTEGER , INTENT ( IN ) :: LDA INTEGER , INTENT ( IN ) :: LDC END SUBROUTINE ZSYRK END INTERFACE SYRK INTERFACE SYR2K PURE SUBROUTINE SSYR2K ( UPLO , TRANS , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) REAL ( WP ), INTENT ( IN ) :: A ( LDA , * ) REAL ( WP ), INTENT ( IN ) :: B ( LDB , * ) REAL ( WP ), INTENT ( INOUT ) :: C ( LDC , * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANS REAL ( WP ), INTENT ( IN ) :: ALPHA REAL ( WP ), INTENT ( IN ) :: BETA INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: K INTEGER , INTENT ( IN ) :: LDA INTEGER , INTENT ( IN ) :: LDB INTEGER , INTENT ( IN ) :: LDC END SUBROUTINE SSYR2K PURE SUBROUTINE DSYR2K ( UPLO , TRANS , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) REAL ( WP ), INTENT ( IN ) :: A ( LDA , * ) REAL ( WP ), INTENT ( IN ) :: B ( LDB , * ) REAL ( WP ), INTENT ( INOUT ) :: C ( LDC , * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANS REAL ( WP ), INTENT ( IN ) :: ALPHA REAL ( WP ), INTENT ( IN ) :: BETA INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: K INTEGER , INTENT ( IN ) :: LDA INTEGER , INTENT ( IN ) :: LDB INTEGER , INTENT ( IN ) :: LDC END SUBROUTINE DSYR2K PURE SUBROUTINE CSYR2K ( UPLO , TRANS , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) COMPLEX ( WP ), INTENT ( IN ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( IN ) :: B ( LDB , * ) COMPLEX ( WP ), INTENT ( INOUT ) :: C ( LDC , * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANS COMPLEX ( WP ), INTENT ( IN ) :: ALPHA COMPLEX ( WP ), INTENT ( IN ) :: BETA INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: K INTEGER , INTENT ( IN ) :: LDA INTEGER , INTENT ( IN ) :: LDB INTEGER , INTENT ( IN ) :: LDC END SUBROUTINE CSYR2K PURE SUBROUTINE ZSYR2K ( UPLO , TRANS , N , K , ALPHA , A , LDA , B , LDB , BETA , C , LDC ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) COMPLEX ( WP ), INTENT ( IN ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( IN ) :: B ( LDB , * ) COMPLEX ( WP ), INTENT ( INOUT ) :: C ( LDC , * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANS COMPLEX ( WP ), INTENT ( IN ) :: ALPHA COMPLEX ( WP ), INTENT ( IN ) :: BETA INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: K INTEGER , INTENT ( IN ) :: LDA INTEGER , INTENT ( IN ) :: LDB INTEGER , INTENT ( IN ) :: LDC END SUBROUTINE ZSYR2K END INTERFACE SYR2K INTERFACE TRMM PURE SUBROUTINE STRMM ( SIDE , UPLO , TRANSA , DIAG , M , N , ALPHA , A , LDA , B , LDB ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) REAL ( WP ), INTENT ( IN ) :: A ( LDA , * ) REAL ( WP ), INTENT ( INOUT ) :: B ( LDB , * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: SIDE CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANSA CHARACTER ( LEN = 1 ), INTENT ( IN ) :: DIAG REAL ( WP ), INTENT ( IN ) :: ALPHA INTEGER , INTENT ( IN ) :: M INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: LDA INTEGER , INTENT ( IN ) :: LDB END SUBROUTINE STRMM PURE SUBROUTINE DTRMM ( SIDE , UPLO , TRANSA , DIAG , M , N , ALPHA , A , LDA , B , LDB ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) REAL ( WP ), INTENT ( IN ) :: A ( LDA , * ) REAL ( WP ), INTENT ( INOUT ) :: B ( LDB , * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: SIDE CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANSA CHARACTER ( LEN = 1 ), INTENT ( IN ) :: DIAG REAL ( WP ), INTENT ( IN ) :: ALPHA INTEGER , INTENT ( IN ) :: M INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: LDA INTEGER , INTENT ( IN ) :: LDB END SUBROUTINE DTRMM PURE SUBROUTINE CTRMM ( SIDE , UPLO , TRANSA , DIAG , M , N , ALPHA , A , LDA , B , LDB ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) COMPLEX ( WP ), INTENT ( IN ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( INOUT ) :: B ( LDB , * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: SIDE CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANSA CHARACTER ( LEN = 1 ), INTENT ( IN ) :: DIAG COMPLEX ( WP ), INTENT ( IN ) :: ALPHA INTEGER , INTENT ( IN ) :: M INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: LDA INTEGER , INTENT ( IN ) :: LDB END SUBROUTINE CTRMM PURE SUBROUTINE ZTRMM ( SIDE , UPLO , TRANSA , DIAG , M , N , ALPHA , A , LDA , B , LDB ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) COMPLEX ( WP ), INTENT ( IN ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( INOUT ) :: B ( LDB , * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: SIDE CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANSA CHARACTER ( LEN = 1 ), INTENT ( IN ) :: DIAG COMPLEX ( WP ), INTENT ( IN ) :: ALPHA INTEGER , INTENT ( IN ) :: M INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: LDA INTEGER , INTENT ( IN ) :: LDB END SUBROUTINE ZTRMM END INTERFACE TRMM INTERFACE TRSM PURE SUBROUTINE STRSM ( SIDE , UPLO , TRANSA , DIAG , M , N , ALPHA , A , LDA , B , LDB ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) REAL ( WP ), INTENT ( IN ) :: A ( LDA , * ) REAL ( WP ), INTENT ( INOUT ) :: B ( LDB , * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: SIDE CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANSA CHARACTER ( LEN = 1 ), INTENT ( IN ) :: DIAG REAL ( WP ), INTENT ( IN ) :: ALPHA INTEGER , INTENT ( IN ) :: M INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: LDA INTEGER , INTENT ( IN ) :: LDB END SUBROUTINE STRSM PURE SUBROUTINE DTRSM ( SIDE , UPLO , TRANSA , DIAG , M , N , ALPHA , A , LDA , B , LDB ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) REAL ( WP ), INTENT ( IN ) :: A ( LDA , * ) REAL ( WP ), INTENT ( INOUT ) :: B ( LDB , * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: SIDE CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANSA CHARACTER ( LEN = 1 ), INTENT ( IN ) :: DIAG REAL ( WP ), INTENT ( IN ) :: ALPHA INTEGER , INTENT ( IN ) :: M INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: LDA INTEGER , INTENT ( IN ) :: LDB END SUBROUTINE DTRSM PURE SUBROUTINE CTRSM ( SIDE , UPLO , TRANSA , DIAG , M , N , ALPHA , A , LDA , B , LDB ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) COMPLEX ( WP ), INTENT ( IN ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( INOUT ) :: B ( LDB , * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: SIDE CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANSA CHARACTER ( LEN = 1 ), INTENT ( IN ) :: DIAG COMPLEX ( WP ), INTENT ( IN ) :: ALPHA INTEGER , INTENT ( IN ) :: M INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: LDA INTEGER , INTENT ( IN ) :: LDB END SUBROUTINE CTRSM PURE SUBROUTINE ZTRSM ( SIDE , UPLO , TRANSA , DIAG , M , N , ALPHA , A , LDA , B , LDB ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) COMPLEX ( WP ), INTENT ( IN ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( INOUT ) :: B ( LDB , * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: SIDE CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANSA CHARACTER ( LEN = 1 ), INTENT ( IN ) :: DIAG COMPLEX ( WP ), INTENT ( IN ) :: ALPHA INTEGER , INTENT ( IN ) :: M INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: LDA INTEGER , INTENT ( IN ) :: LDB END SUBROUTINE ZTRSM END INTERFACE TRSM INTERFACE AXPYI PURE SUBROUTINE SAXPYI ( NZ , A , X , INDX , Y ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) REAL ( WP ), INTENT ( IN ) :: X ( * ) INTEGER , INTENT ( IN ) :: INDX ( * ) REAL ( WP ), INTENT ( INOUT ) :: Y ( * ) REAL ( WP ), INTENT ( IN ) :: A INTEGER , INTENT ( IN ) :: NZ END SUBROUTINE SAXPYI PURE SUBROUTINE DAXPYI ( NZ , A , X , INDX , Y ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) REAL ( WP ), INTENT ( IN ) :: X ( * ) INTEGER , INTENT ( IN ) :: INDX ( * ) REAL ( WP ), INTENT ( INOUT ) :: Y ( * ) REAL ( WP ), INTENT ( IN ) :: A INTEGER , INTENT ( IN ) :: NZ END SUBROUTINE DAXPYI PURE SUBROUTINE CAXPYI ( NZ , A , X , INDX , Y ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) COMPLEX ( WP ), INTENT ( IN ) :: X ( * ) INTEGER , INTENT ( IN ) :: INDX ( * ) COMPLEX ( WP ), INTENT ( INOUT ) :: Y ( * ) COMPLEX ( WP ), INTENT ( IN ) :: A INTEGER , INTENT ( IN ) :: NZ END SUBROUTINE CAXPYI PURE SUBROUTINE ZAXPYI ( NZ , A , X , INDX , Y ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) COMPLEX ( WP ), INTENT ( IN ) :: X ( * ) INTEGER , INTENT ( IN ) :: INDX ( * ) COMPLEX ( WP ), INTENT ( INOUT ) :: Y ( * ) COMPLEX ( WP ), INTENT ( IN ) :: A INTEGER , INTENT ( IN ) :: NZ END SUBROUTINE ZAXPYI END INTERFACE AXPYI INTERFACE DOTI PURE FUNCTION SDOTI ( NZ , X , INDX , Y ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) REAL ( WP ) :: SDOTI REAL ( WP ), INTENT ( IN ) :: X ( * ) INTEGER , INTENT ( IN ) :: INDX ( * ) REAL ( WP ), INTENT ( IN ) :: Y ( * ) INTEGER , INTENT ( IN ) :: NZ END FUNCTION SDOTI PURE FUNCTION DDOTI ( NZ , X , INDX , Y ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) REAL ( WP ) :: DDOTI REAL ( WP ), INTENT ( IN ) :: X ( * ) INTEGER , INTENT ( IN ) :: INDX ( * ) REAL ( WP ), INTENT ( IN ) :: Y ( * ) INTEGER , INTENT ( IN ) :: NZ END FUNCTION DDOTI END INTERFACE DOTI INTERFACE DOTCI PURE FUNCTION CDOTCI ( NZ , X , INDX , Y ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) COMPLEX ( WP ) :: CDOTCI COMPLEX ( WP ), INTENT ( IN ) :: X ( * ) INTEGER , INTENT ( IN ) :: INDX ( * ) COMPLEX ( WP ), INTENT ( IN ) :: Y ( * ) INTEGER , INTENT ( IN ) :: NZ END FUNCTION CDOTCI PURE FUNCTION ZDOTCI ( NZ , X , INDX , Y ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) COMPLEX ( WP ) :: ZDOTCI COMPLEX ( WP ), INTENT ( IN ) :: X ( * ) INTEGER , INTENT ( IN ) :: INDX ( * ) COMPLEX ( WP ), INTENT ( IN ) :: Y ( * ) INTEGER , INTENT ( IN ) :: NZ END FUNCTION ZDOTCI END INTERFACE DOTCI INTERFACE DOTUI PURE FUNCTION CDOTUI ( NZ , X , INDX , Y ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) COMPLEX ( WP ) :: CDOTUI COMPLEX ( WP ), INTENT ( IN ) :: X ( * ) INTEGER , INTENT ( IN ) :: INDX ( * ) COMPLEX ( WP ), INTENT ( IN ) :: Y ( * ) INTEGER , INTENT ( IN ) :: NZ END FUNCTION CDOTUI PURE FUNCTION ZDOTUI ( NZ , X , INDX , Y ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) COMPLEX ( WP ) :: ZDOTUI COMPLEX ( WP ), INTENT ( IN ) :: X ( * ) INTEGER , INTENT ( IN ) :: INDX ( * ) COMPLEX ( WP ), INTENT ( IN ) :: Y ( * ) INTEGER , INTENT ( IN ) :: NZ END FUNCTION ZDOTUI END INTERFACE DOTUI INTERFACE GTHR PURE SUBROUTINE SGTHR ( NZ , Y , X , INDX ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) REAL ( WP ), INTENT ( OUT ) :: X ( * ) INTEGER , INTENT ( IN ) :: INDX ( * ) REAL ( WP ), INTENT ( IN ) :: Y ( * ) INTEGER , INTENT ( IN ) :: NZ END SUBROUTINE SGTHR PURE SUBROUTINE DGTHR ( NZ , Y , X , INDX ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) REAL ( WP ), INTENT ( OUT ) :: X ( * ) INTEGER , INTENT ( IN ) :: INDX ( * ) REAL ( WP ), INTENT ( IN ) :: Y ( * ) INTEGER , INTENT ( IN ) :: NZ END SUBROUTINE DGTHR PURE SUBROUTINE CGTHR ( NZ , Y , X , INDX ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) COMPLEX ( WP ), INTENT ( OUT ) :: X ( * ) INTEGER , INTENT ( IN ) :: INDX ( * ) COMPLEX ( WP ), INTENT ( IN ) :: Y ( * ) INTEGER , INTENT ( IN ) :: NZ END SUBROUTINE CGTHR PURE SUBROUTINE ZGTHR ( NZ , Y , X , INDX ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) COMPLEX ( WP ), INTENT ( OUT ) :: X ( * ) INTEGER , INTENT ( IN ) :: INDX ( * ) COMPLEX ( WP ), INTENT ( IN ) :: Y ( * ) INTEGER , INTENT ( IN ) :: NZ END SUBROUTINE ZGTHR END INTERFACE GTHR INTERFACE GTHRZ PURE SUBROUTINE SGTHRZ ( NZ , Y , X , INDX ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) REAL ( WP ), INTENT ( OUT ) :: X ( * ) INTEGER , INTENT ( IN ) :: INDX ( * ) REAL ( WP ), INTENT ( INOUT ) :: Y ( * ) INTEGER , INTENT ( IN ) :: NZ END SUBROUTINE SGTHRZ PURE SUBROUTINE DGTHRZ ( NZ , Y , X , INDX ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) REAL ( WP ), INTENT ( OUT ) :: X ( * ) INTEGER , INTENT ( IN ) :: INDX ( * ) REAL ( WP ), INTENT ( INOUT ) :: Y ( * ) INTEGER , INTENT ( IN ) :: NZ END SUBROUTINE DGTHRZ PURE SUBROUTINE CGTHRZ ( NZ , Y , X , INDX ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) COMPLEX ( WP ), INTENT ( OUT ) :: X ( * ) INTEGER , INTENT ( IN ) :: INDX ( * ) COMPLEX ( WP ), INTENT ( INOUT ) :: Y ( * ) INTEGER , INTENT ( IN ) :: NZ END SUBROUTINE CGTHRZ PURE SUBROUTINE ZGTHRZ ( NZ , Y , X , INDX ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) COMPLEX ( WP ), INTENT ( OUT ) :: X ( * ) INTEGER , INTENT ( IN ) :: INDX ( * ) COMPLEX ( WP ), INTENT ( INOUT ) :: Y ( * ) INTEGER , INTENT ( IN ) :: NZ END SUBROUTINE ZGTHRZ END INTERFACE GTHRZ INTERFACE ROTI PURE SUBROUTINE SROTI ( NZ , X , INDX , Y , C , S ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) REAL ( WP ), INTENT ( INOUT ) :: X ( * ) INTEGER , INTENT ( IN ) :: INDX ( * ) REAL ( WP ), INTENT ( IN ) :: Y ( * ) REAL ( WP ), INTENT ( IN ) :: C REAL ( WP ), INTENT ( IN ) :: S INTEGER , INTENT ( IN ) :: NZ END SUBROUTINE SROTI PURE SUBROUTINE DROTI ( NZ , X , INDX , Y , C , S ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) REAL ( WP ), INTENT ( INOUT ) :: X ( * ) INTEGER , INTENT ( IN ) :: INDX ( * ) REAL ( WP ), INTENT ( IN ) :: Y ( * ) REAL ( WP ), INTENT ( IN ) :: C REAL ( WP ), INTENT ( IN ) :: S INTEGER , INTENT ( IN ) :: NZ END SUBROUTINE DROTI END INTERFACE ROTI INTERFACE SCTR PURE SUBROUTINE SSCTR ( NZ , X , INDX , Y ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) REAL ( WP ), INTENT ( IN ) :: X ( * ) INTEGER , INTENT ( IN ) :: INDX ( * ) REAL ( WP ), INTENT ( OUT ) :: Y ( * ) INTEGER , INTENT ( IN ) :: NZ END SUBROUTINE SSCTR PURE SUBROUTINE DSCTR ( NZ , X , INDX , Y ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) REAL ( WP ), INTENT ( IN ) :: X ( * ) INTEGER , INTENT ( IN ) :: INDX ( * ) REAL ( WP ), INTENT ( OUT ) :: Y ( * ) INTEGER , INTENT ( IN ) :: NZ END SUBROUTINE DSCTR PURE SUBROUTINE CSCTR ( NZ , X , INDX , Y ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) COMPLEX ( WP ), INTENT ( IN ) :: X ( * ) INTEGER , INTENT ( IN ) :: INDX ( * ) COMPLEX ( WP ), INTENT ( OUT ) :: Y ( * ) INTEGER , INTENT ( IN ) :: NZ END SUBROUTINE CSCTR PURE SUBROUTINE ZSCTR ( NZ , X , INDX , Y ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) COMPLEX ( WP ), INTENT ( IN ) :: X ( * ) INTEGER , INTENT ( IN ) :: INDX ( * ) COMPLEX ( WP ), INTENT ( OUT ) :: Y ( * ) INTEGER , INTENT ( IN ) :: NZ END SUBROUTINE ZSCTR END INTERFACE SCTR INTERFACE GEMM3M PURE SUBROUTINE CGEMM3M ( TRANSA , TRANSB , M , N , K , ALPHA , A , LDA , B , LDB , BETA , C , & & LDC ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) COMPLEX ( WP ), INTENT ( IN ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( IN ) :: B ( LDB , * ) COMPLEX ( WP ), INTENT ( INOUT ) :: C ( LDC , * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANSA CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANSB COMPLEX ( WP ), INTENT ( IN ) :: ALPHA COMPLEX ( WP ), INTENT ( IN ) :: BETA INTEGER , INTENT ( IN ) :: M INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: K INTEGER , INTENT ( IN ) :: LDA INTEGER , INTENT ( IN ) :: LDB INTEGER , INTENT ( IN ) :: LDC END SUBROUTINE CGEMM3M PURE SUBROUTINE ZGEMM3M ( TRANSA , TRANSB , M , N , K , ALPHA , A , LDA , B , LDB , BETA , C , & & LDC ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) COMPLEX ( WP ), INTENT ( IN ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( IN ) :: B ( LDB , * ) COMPLEX ( WP ), INTENT ( INOUT ) :: C ( LDC , * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANSA CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANSB COMPLEX ( WP ), INTENT ( IN ) :: ALPHA COMPLEX ( WP ), INTENT ( IN ) :: BETA INTEGER , INTENT ( IN ) :: M INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: K INTEGER , INTENT ( IN ) :: LDA INTEGER , INTENT ( IN ) :: LDB INTEGER , INTENT ( IN ) :: LDC END SUBROUTINE ZGEMM3M END INTERFACE GEMM3M INTERFACE GEMMT PURE SUBROUTINE SGEMMT ( UPLO , TRANSA , TRANSB , N , K , ALPHA , A , LDA , B , LDB , BETA , & & C , LDC ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) REAL ( WP ), INTENT ( IN ) :: A ( LDA , * ) REAL ( WP ), INTENT ( IN ) :: B ( LDB , * ) REAL ( WP ), INTENT ( INOUT ) :: C ( LDC , * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANSA CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANSB REAL ( WP ), INTENT ( IN ) :: ALPHA REAL ( WP ), INTENT ( IN ) :: BETA INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: K INTEGER , INTENT ( IN ) :: LDA INTEGER , INTENT ( IN ) :: LDB INTEGER , INTENT ( IN ) :: LDC END SUBROUTINE SGEMMT PURE SUBROUTINE DGEMMT ( UPLO , TRANSA , TRANSB , N , K , ALPHA , A , LDA , B , LDB , BETA , & & C , LDC ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) REAL ( WP ), INTENT ( IN ) :: A ( LDA , * ) REAL ( WP ), INTENT ( IN ) :: B ( LDB , * ) REAL ( WP ), INTENT ( INOUT ) :: C ( LDC , * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANSA CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANSB REAL ( WP ), INTENT ( IN ) :: ALPHA REAL ( WP ), INTENT ( IN ) :: BETA INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: K INTEGER , INTENT ( IN ) :: LDA INTEGER , INTENT ( IN ) :: LDB INTEGER , INTENT ( IN ) :: LDC END SUBROUTINE DGEMMT PURE SUBROUTINE CGEMMT ( UPLO , TRANSA , TRANSB , N , K , ALPHA , A , LDA , B , LDB , BETA , & & C , LDC ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) COMPLEX ( WP ), INTENT ( IN ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( IN ) :: B ( LDB , * ) COMPLEX ( WP ), INTENT ( INOUT ) :: C ( LDC , * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANSA CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANSB COMPLEX ( WP ), INTENT ( IN ) :: ALPHA COMPLEX ( WP ), INTENT ( IN ) :: BETA INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: K INTEGER , INTENT ( IN ) :: LDA INTEGER , INTENT ( IN ) :: LDB INTEGER , INTENT ( IN ) :: LDC END SUBROUTINE CGEMMT PURE SUBROUTINE ZGEMMT ( UPLO , TRANSA , TRANSB , N , K , ALPHA , A , LDA , B , LDB , BETA , & & C , LDC ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) COMPLEX ( WP ), INTENT ( IN ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( IN ) :: B ( LDB , * ) COMPLEX ( WP ), INTENT ( INOUT ) :: C ( LDC , * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANSA CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANSB COMPLEX ( WP ), INTENT ( IN ) :: ALPHA COMPLEX ( WP ), INTENT ( IN ) :: BETA INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: K INTEGER , INTENT ( IN ) :: LDA INTEGER , INTENT ( IN ) :: LDB INTEGER , INTENT ( IN ) :: LDC END SUBROUTINE ZGEMMT END INTERFACE GEMMT INTERFACE AXPBY PURE SUBROUTINE SAXPBY ( N , ALPHA , X , INCX , BETA , Y , INCY ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) REAL ( WP ), INTENT ( IN ) :: X ( * ) REAL ( WP ), INTENT ( INOUT ) :: Y ( * ) REAL ( WP ), INTENT ( IN ) :: ALPHA REAL ( WP ), INTENT ( IN ) :: BETA INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N END SUBROUTINE SAXPBY PURE SUBROUTINE DAXPBY ( N , ALPHA , X , INCX , BETA , Y , INCY ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) REAL ( WP ), INTENT ( IN ) :: X ( * ) REAL ( WP ), INTENT ( INOUT ) :: Y ( * ) REAL ( WP ), INTENT ( IN ) :: ALPHA REAL ( WP ), INTENT ( IN ) :: BETA INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N END SUBROUTINE DAXPBY PURE SUBROUTINE CAXPBY ( N , ALPHA , X , INCX , BETA , Y , INCY ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) COMPLEX ( WP ), INTENT ( IN ) :: X ( * ) COMPLEX ( WP ), INTENT ( INOUT ) :: Y ( * ) COMPLEX ( WP ), INTENT ( IN ) :: ALPHA COMPLEX ( WP ), INTENT ( IN ) :: BETA INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N END SUBROUTINE CAXPBY PURE SUBROUTINE ZAXPBY ( N , ALPHA , X , INCX , BETA , Y , INCY ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) COMPLEX ( WP ), INTENT ( IN ) :: X ( * ) COMPLEX ( WP ), INTENT ( INOUT ) :: Y ( * ) COMPLEX ( WP ), INTENT ( IN ) :: ALPHA COMPLEX ( WP ), INTENT ( IN ) :: BETA INTEGER , INTENT ( IN ) :: INCX INTEGER , INTENT ( IN ) :: INCY INTEGER , INTENT ( IN ) :: N END SUBROUTINE ZAXPBY END INTERFACE AXPBY INTERFACE GEM2V PURE SUBROUTINE SGEM2VU ( M , N , ALPHA , A , LDA , X1 , INCX1 , X2 , INCX2 , BETA , Y1 , & & INCY1 , Y2 , INCY2 ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) REAL ( WP ), INTENT ( IN ) :: A ( LDA , * ) REAL ( WP ), INTENT ( IN ) :: X1 ( * ) REAL ( WP ), INTENT ( IN ) :: X2 ( * ) REAL ( WP ), INTENT ( INOUT ) :: Y1 ( * ) REAL ( WP ), INTENT ( INOUT ) :: Y2 ( * ) REAL ( WP ), INTENT ( IN ) :: ALPHA REAL ( WP ), INTENT ( IN ) :: BETA INTEGER , INTENT ( IN ) :: INCX1 INTEGER , INTENT ( IN ) :: INCX2 INTEGER , INTENT ( IN ) :: INCY1 INTEGER , INTENT ( IN ) :: INCY2 INTEGER , INTENT ( IN ) :: M INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE SGEM2VU PURE SUBROUTINE DGEM2VU ( M , N , ALPHA , A , LDA , X1 , INCX1 , X2 , INCX2 , BETA , Y1 , & & INCY1 , Y2 , INCY2 ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) REAL ( WP ), INTENT ( IN ) :: A ( LDA , * ) REAL ( WP ), INTENT ( IN ) :: X1 ( * ) REAL ( WP ), INTENT ( IN ) :: X2 ( * ) REAL ( WP ), INTENT ( INOUT ) :: Y1 ( * ) REAL ( WP ), INTENT ( INOUT ) :: Y2 ( * ) REAL ( WP ), INTENT ( IN ) :: ALPHA REAL ( WP ), INTENT ( IN ) :: BETA INTEGER , INTENT ( IN ) :: INCX1 INTEGER , INTENT ( IN ) :: INCX2 INTEGER , INTENT ( IN ) :: INCY1 INTEGER , INTENT ( IN ) :: INCY2 INTEGER , INTENT ( IN ) :: M INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE DGEM2VU PURE SUBROUTINE CGEM2VC ( M , N , ALPHA , A , LDA , X1 , INCX1 , X2 , INCX2 , BETA , Y1 , & & INCY1 , Y2 , INCY2 ) INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) COMPLEX ( WP ), INTENT ( IN ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( IN ) :: X1 ( * ) COMPLEX ( WP ), INTENT ( IN ) :: X2 ( * ) COMPLEX ( WP ), INTENT ( INOUT ) :: Y1 ( * ) COMPLEX ( WP ), INTENT ( INOUT ) :: Y2 ( * ) COMPLEX ( WP ), INTENT ( IN ) :: ALPHA COMPLEX ( WP ), INTENT ( IN ) :: BETA INTEGER , INTENT ( IN ) :: INCX1 INTEGER , INTENT ( IN ) :: INCX2 INTEGER , INTENT ( IN ) :: INCY1 INTEGER , INTENT ( IN ) :: INCY2 INTEGER , INTENT ( IN ) :: M INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE CGEM2VC PURE SUBROUTINE ZGEM2VC ( M , N , ALPHA , A , LDA , X1 , INCX1 , X2 , INCX2 , BETA , Y1 , & & INCY1 , Y2 , INCY2 ) INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) COMPLEX ( WP ), INTENT ( IN ) :: A ( LDA , * ) COMPLEX ( WP ), INTENT ( IN ) :: X1 ( * ) COMPLEX ( WP ), INTENT ( IN ) :: X2 ( * ) COMPLEX ( WP ), INTENT ( INOUT ) :: Y1 ( * ) COMPLEX ( WP ), INTENT ( INOUT ) :: Y2 ( * ) COMPLEX ( WP ), INTENT ( IN ) :: ALPHA COMPLEX ( WP ), INTENT ( IN ) :: BETA INTEGER , INTENT ( IN ) :: INCX1 INTEGER , INTENT ( IN ) :: INCX2 INTEGER , INTENT ( IN ) :: INCY1 INTEGER , INTENT ( IN ) :: INCY2 INTEGER , INTENT ( IN ) :: M INTEGER , INTENT ( IN ) :: N INTEGER , INTENT ( IN ) :: LDA END SUBROUTINE ZGEM2VC END INTERFACE GEM2V INTERFACE GEMM_BATCH PURE SUBROUTINE SGEMM_BATCH ( TRANSA_ARRAY , TRANSB_ARRAY , M_ARRAY , N_ARRAY ,& & K_ARRAY , ALPHA_ARRAY , A_ARRAY , LDA_ARRAY , & & B_ARRAY , LDB_ARRAY , BETA_ARRAY , C_ARRAY , & & LDC_ARRAY , GROUP_COUNT , GROUP_SIZE ) use , intrinsic :: ISO_C_BINDING INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) INTEGER ( KIND = C_SIZE_T ), INTENT ( IN ) :: A_ARRAY ( * ) INTEGER ( KIND = C_SIZE_T ), INTENT ( IN ) :: B_ARRAY ( * ) INTEGER ( KIND = C_SIZE_T ), INTENT ( INOUT ) :: C_ARRAY ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANSA_ARRAY ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANSB_ARRAY ( * ) REAL ( WP ), INTENT ( IN ) :: ALPHA_ARRAY ( * ) REAL ( WP ), INTENT ( IN ) :: BETA_ARRAY ( * ) INTEGER , INTENT ( IN ) :: M_ARRAY ( * ) INTEGER , INTENT ( IN ) :: N_ARRAY ( * ) INTEGER , INTENT ( IN ) :: K_ARRAY ( * ) INTEGER , INTENT ( IN ) :: LDA_ARRAY ( * ) INTEGER , INTENT ( IN ) :: LDB_ARRAY ( * ) INTEGER , INTENT ( IN ) :: LDC_ARRAY ( * ) INTEGER , INTENT ( IN ) :: GROUP_COUNT INTEGER , INTENT ( IN ) :: GROUP_SIZE ( * ) END SUBROUTINE SGEMM_BATCH PURE SUBROUTINE DGEMM_BATCH ( TRANSA_ARRAY , TRANSB_ARRAY , M_ARRAY , N_ARRAY ,& & K_ARRAY , ALPHA_ARRAY , A_ARRAY , LDA_ARRAY , & & B_ARRAY , LDB_ARRAY , BETA_ARRAY , C_ARRAY , & & LDC_ARRAY , GROUP_COUNT , GROUP_SIZE ) use , intrinsic :: ISO_C_BINDING INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) INTEGER ( KIND = C_SIZE_T ), INTENT ( IN ) :: A_ARRAY ( * ) INTEGER ( KIND = C_SIZE_T ), INTENT ( IN ) :: B_ARRAY ( * ) INTEGER ( KIND = C_SIZE_T ), INTENT ( INOUT ) :: C_ARRAY ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANSA_ARRAY ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANSB_ARRAY ( * ) REAL ( WP ), INTENT ( IN ) :: ALPHA_ARRAY ( * ) REAL ( WP ), INTENT ( IN ) :: BETA_ARRAY ( * ) INTEGER , INTENT ( IN ) :: M_ARRAY ( * ) INTEGER , INTENT ( IN ) :: N_ARRAY ( * ) INTEGER , INTENT ( IN ) :: K_ARRAY ( * ) INTEGER , INTENT ( IN ) :: LDA_ARRAY ( * ) INTEGER , INTENT ( IN ) :: LDB_ARRAY ( * ) INTEGER , INTENT ( IN ) :: LDC_ARRAY ( * ) INTEGER , INTENT ( IN ) :: GROUP_COUNT INTEGER , INTENT ( IN ) :: GROUP_SIZE ( * ) END SUBROUTINE DGEMM_BATCH PURE SUBROUTINE CGEMM_BATCH ( TRANSA_ARRAY , TRANSB_ARRAY , M_ARRAY , N_ARRAY ,& & K_ARRAY , ALPHA_ARRAY , A_ARRAY , LDA_ARRAY , & & B_ARRAY , LDB_ARRAY , BETA_ARRAY , C_ARRAY , & & LDC_ARRAY , GROUP_COUNT , GROUP_SIZE ) use , intrinsic :: ISO_C_BINDING INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) INTEGER ( KIND = C_SIZE_T ), INTENT ( IN ) :: A_ARRAY ( * ) INTEGER ( KIND = C_SIZE_T ), INTENT ( IN ) :: B_ARRAY ( * ) INTEGER ( KIND = C_SIZE_T ), INTENT ( INOUT ) :: C_ARRAY ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANSA_ARRAY ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANSB_ARRAY ( * ) COMPLEX ( WP ), INTENT ( IN ) :: ALPHA_ARRAY ( * ) COMPLEX ( WP ), INTENT ( IN ) :: BETA_ARRAY ( * ) INTEGER , INTENT ( IN ) :: M_ARRAY ( * ) INTEGER , INTENT ( IN ) :: N_ARRAY ( * ) INTEGER , INTENT ( IN ) :: K_ARRAY ( * ) INTEGER , INTENT ( IN ) :: LDA_ARRAY ( * ) INTEGER , INTENT ( IN ) :: LDB_ARRAY ( * ) INTEGER , INTENT ( IN ) :: LDC_ARRAY ( * ) INTEGER , INTENT ( IN ) :: GROUP_COUNT INTEGER , INTENT ( IN ) :: GROUP_SIZE ( * ) END SUBROUTINE CGEMM_BATCH PURE SUBROUTINE ZGEMM_BATCH ( TRANSA_ARRAY , TRANSB_ARRAY , M_ARRAY , N_ARRAY ,& & K_ARRAY , ALPHA_ARRAY , A_ARRAY , LDA_ARRAY , & & B_ARRAY , LDB_ARRAY , BETA_ARRAY , C_ARRAY , & & LDC_ARRAY , GROUP_COUNT , GROUP_SIZE ) use , intrinsic :: ISO_C_BINDING INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) INTEGER ( KIND = C_SIZE_T ), INTENT ( IN ) :: A_ARRAY ( * ) INTEGER ( KIND = C_SIZE_T ), INTENT ( IN ) :: B_ARRAY ( * ) INTEGER ( KIND = C_SIZE_T ), INTENT ( INOUT ) :: C_ARRAY ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANSA_ARRAY ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANSB_ARRAY ( * ) COMPLEX ( WP ), INTENT ( IN ) :: ALPHA_ARRAY ( * ) COMPLEX ( WP ), INTENT ( IN ) :: BETA_ARRAY ( * ) INTEGER , INTENT ( IN ) :: M_ARRAY ( * ) INTEGER , INTENT ( IN ) :: N_ARRAY ( * ) INTEGER , INTENT ( IN ) :: K_ARRAY ( * ) INTEGER , INTENT ( IN ) :: LDA_ARRAY ( * ) INTEGER , INTENT ( IN ) :: LDB_ARRAY ( * ) INTEGER , INTENT ( IN ) :: LDC_ARRAY ( * ) INTEGER , INTENT ( IN ) :: GROUP_COUNT INTEGER , INTENT ( IN ) :: GROUP_SIZE ( * ) END SUBROUTINE ZGEMM_BATCH END INTERFACE GEMM_BATCH INTERFACE GEMM3M_BATCH PURE SUBROUTINE CGEMM3M_BATCH ( TRANSA_ARRAY , TRANSB_ARRAY , M_ARRAY , & & N_ARRAY , K_ARRAY , ALPHA_ARRAY , A_ARRAY , & & LDA_ARRAY , B_ARRAY , LDB_ARRAY , BETA_ARRAY , & & C_ARRAY , LDC_ARRAY , GROUP_COUNT , GROUP_SIZE ) use , intrinsic :: ISO_C_BINDING INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) INTEGER ( KIND = C_SIZE_T ), INTENT ( IN ) :: A_ARRAY ( * ) INTEGER ( KIND = C_SIZE_T ), INTENT ( IN ) :: B_ARRAY ( * ) INTEGER ( KIND = C_SIZE_T ), INTENT ( INOUT ) :: C_ARRAY ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANSA_ARRAY ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANSB_ARRAY ( * ) COMPLEX ( WP ), INTENT ( IN ) :: ALPHA_ARRAY ( * ) COMPLEX ( WP ), INTENT ( IN ) :: BETA_ARRAY ( * ) INTEGER , INTENT ( IN ) :: M_ARRAY ( * ) INTEGER , INTENT ( IN ) :: N_ARRAY ( * ) INTEGER , INTENT ( IN ) :: K_ARRAY ( * ) INTEGER , INTENT ( IN ) :: LDA_ARRAY ( * ) INTEGER , INTENT ( IN ) :: LDB_ARRAY ( * ) INTEGER , INTENT ( IN ) :: LDC_ARRAY ( * ) INTEGER , INTENT ( IN ) :: GROUP_COUNT INTEGER , INTENT ( IN ) :: GROUP_SIZE ( * ) END SUBROUTINE CGEMM3M_BATCH PURE SUBROUTINE ZGEMM3M_BATCH ( TRANSA_ARRAY , TRANSB_ARRAY , M_ARRAY , & & N_ARRAY , K_ARRAY , ALPHA_ARRAY , A_ARRAY , & & LDA_ARRAY , B_ARRAY , LDB_ARRAY , BETA_ARRAY , & & C_ARRAY , LDC_ARRAY , GROUP_COUNT , GROUP_SIZE ) use , intrinsic :: ISO_C_BINDING INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) INTEGER ( KIND = C_SIZE_T ), INTENT ( IN ) :: A_ARRAY ( * ) INTEGER ( KIND = C_SIZE_T ), INTENT ( IN ) :: B_ARRAY ( * ) INTEGER ( KIND = C_SIZE_T ), INTENT ( INOUT ) :: C_ARRAY ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANSA_ARRAY ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANSB_ARRAY ( * ) COMPLEX ( WP ), INTENT ( IN ) :: ALPHA_ARRAY ( * ) COMPLEX ( WP ), INTENT ( IN ) :: BETA_ARRAY ( * ) INTEGER , INTENT ( IN ) :: M_ARRAY ( * ) INTEGER , INTENT ( IN ) :: N_ARRAY ( * ) INTEGER , INTENT ( IN ) :: K_ARRAY ( * ) INTEGER , INTENT ( IN ) :: LDA_ARRAY ( * ) INTEGER , INTENT ( IN ) :: LDB_ARRAY ( * ) INTEGER , INTENT ( IN ) :: LDC_ARRAY ( * ) INTEGER , INTENT ( IN ) :: GROUP_COUNT INTEGER , INTENT ( IN ) :: GROUP_SIZE ( * ) END SUBROUTINE ZGEMM3M_BATCH END INTERFACE GEMM3M_BATCH INTERFACE TRSM_BATCH PURE SUBROUTINE STRSM_BATCH ( SIDE_ARRAY , UPLO_ARRAY , TRANSA_ARRAY , DIAG_ARRAY ,& & M_ARRAY , N_ARRAY , ALPHA_ARRAY , A_ARRAY , LDA_ARRAY ,& & B_ARRAY , LDB_ARRAY , GROUP_COUNT , GROUP_SIZE ) use , intrinsic :: ISO_C_BINDING INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) INTEGER ( KIND = C_SIZE_T ), INTENT ( IN ) :: A_ARRAY ( * ) INTEGER ( KIND = C_SIZE_T ), INTENT ( IN ) :: B_ARRAY ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: SIDE_ARRAY ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO_ARRAY ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANSA_ARRAY ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: DIAG_ARRAY ( * ) REAL ( WP ), INTENT ( IN ) :: ALPHA_ARRAY ( * ) INTEGER , INTENT ( IN ) :: M_ARRAY ( * ) INTEGER , INTENT ( IN ) :: N_ARRAY ( * ) INTEGER , INTENT ( IN ) :: LDA_ARRAY ( * ) INTEGER , INTENT ( IN ) :: LDB_ARRAY ( * ) INTEGER , INTENT ( IN ) :: GROUP_COUNT INTEGER , INTENT ( IN ) :: GROUP_SIZE ( * ) END SUBROUTINE STRSM_BATCH PURE SUBROUTINE DTRSM_BATCH ( SIDE_ARRAY , UPLO_ARRAY , TRANSA_ARRAY , DIAG_ARRAY ,& & M_ARRAY , N_ARRAY , ALPHA_ARRAY , A_ARRAY , LDA_ARRAY ,& & B_ARRAY , LDB_ARRAY , GROUP_COUNT , GROUP_SIZE ) use , intrinsic :: ISO_C_BINDING INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) INTEGER ( KIND = C_SIZE_T ), INTENT ( IN ) :: A_ARRAY ( * ) INTEGER ( KIND = C_SIZE_T ), INTENT ( IN ) :: B_ARRAY ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: SIDE_ARRAY ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO_ARRAY ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANSA_ARRAY ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: DIAG_ARRAY ( * ) REAL ( WP ), INTENT ( IN ) :: ALPHA_ARRAY ( * ) INTEGER , INTENT ( IN ) :: M_ARRAY ( * ) INTEGER , INTENT ( IN ) :: N_ARRAY ( * ) INTEGER , INTENT ( IN ) :: LDA_ARRAY ( * ) INTEGER , INTENT ( IN ) :: LDB_ARRAY ( * ) INTEGER , INTENT ( IN ) :: GROUP_COUNT INTEGER , INTENT ( IN ) :: GROUP_SIZE ( * ) END SUBROUTINE DTRSM_BATCH PURE SUBROUTINE CTRSM_BATCH ( SIDE_ARRAY , UPLO_ARRAY , TRANSA_ARRAY , DIAG_ARRAY ,& & M_ARRAY , N_ARRAY , ALPHA_ARRAY , A_ARRAY , LDA_ARRAY ,& & B_ARRAY , LDB_ARRAY , GROUP_COUNT , GROUP_SIZE ) use , intrinsic :: ISO_C_BINDING INTEGER , PARAMETER :: WP = KIND ( 1.0E0 ) INTEGER ( KIND = C_SIZE_T ), INTENT ( IN ) :: A_ARRAY ( * ) INTEGER ( KIND = C_SIZE_T ), INTENT ( IN ) :: B_ARRAY ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: SIDE_ARRAY ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO_ARRAY ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANSA_ARRAY ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: DIAG_ARRAY ( * ) COMPLEX ( WP ), INTENT ( IN ) :: ALPHA_ARRAY ( * ) INTEGER , INTENT ( IN ) :: M_ARRAY ( * ) INTEGER , INTENT ( IN ) :: N_ARRAY ( * ) INTEGER , INTENT ( IN ) :: LDA_ARRAY ( * ) INTEGER , INTENT ( IN ) :: LDB_ARRAY ( * ) INTEGER , INTENT ( IN ) :: GROUP_COUNT INTEGER , INTENT ( IN ) :: GROUP_SIZE ( * ) END SUBROUTINE CTRSM_BATCH PURE SUBROUTINE ZTRSM_BATCH ( SIDE_ARRAY , UPLO_ARRAY , TRANSA_ARRAY , DIAG_ARRAY ,& & M_ARRAY , N_ARRAY , ALPHA_ARRAY , A_ARRAY , LDA_ARRAY ,& & B_ARRAY , LDB_ARRAY , GROUP_COUNT , GROUP_SIZE ) use , intrinsic :: ISO_C_BINDING INTEGER , PARAMETER :: WP = KIND ( 1.0D0 ) INTEGER ( KIND = C_SIZE_T ), INTENT ( IN ) :: A_ARRAY ( * ) INTEGER ( KIND = C_SIZE_T ), INTENT ( IN ) :: B_ARRAY ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: SIDE_ARRAY ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: UPLO_ARRAY ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: TRANSA_ARRAY ( * ) CHARACTER ( LEN = 1 ), INTENT ( IN ) :: DIAG_ARRAY ( * ) COMPLEX ( WP ), INTENT ( IN ) :: ALPHA_ARRAY ( * ) INTEGER , INTENT ( IN ) :: M_ARRAY ( * ) INTEGER , INTENT ( IN ) :: N_ARRAY ( * ) INTEGER , INTENT ( IN ) :: LDA_ARRAY ( * ) INTEGER , INTENT ( IN ) :: LDB_ARRAY ( * ) INTEGER , INTENT ( IN ) :: GROUP_COUNT INTEGER , INTENT ( IN ) :: GROUP_SIZE ( * ) END SUBROUTINE ZTRSM_BATCH END INTERFACE TRSM_BATCH END MODULE BLASInterface","tags":"","loc":"sourcefile/blasinterface.f90.html"},{"title":"ErrorHandling.f90 – Fortran Program","text":"Contents Modules ErrorHandling Source Code ErrorHandling.f90 Source Code MODULE ErrorHandling !!Module contains error handling procedures USE GlobalData USE IO IMPLICIT NONE PRIVATE INTEGER ( I4B ), PARAMETER , PUBLIC :: IO_OPEN = 1 !! Constant for file open used by fErr INTEGER ( I4B ), PARAMETER , PUBLIC :: IO_READ = 2 !! Constant for file read used by fErr INTEGER ( I4B ), PARAMETER , PUBLIC :: IO_WRITE = 3 !! Constant for file write used by fErr INTEGER ( I4B ), PARAMETER , PUBLIC :: IO_CLOSE = 4 !! Constant for file close used by fErr INTEGER ( I4B ), PARAMETER , PUBLIC :: OPT_ALLOC = 1 INTEGER ( I4B ), PARAMETER , PUBLIC :: OPT_DEALLOC = 2 PUBLIC :: ErrorMSG , WarningMSG , FileError , AllocationErr CONTAINS !---------------------------------------------------------------------------- !                                                                 ErrorMsg !---------------------------------------------------------------------------- SUBROUTINE ErrorMSG ( Msg , File , Routine , Line , UnitNo ) !! Write a message CHARACTER ( LEN = * ), INTENT ( IN ) :: Msg , File , Routine !! Message to write INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: UnitNo !! file id to write the message to INTEGER ( I4B ), INTENT ( IN ) :: Line !! Line number INTEGER ( I4B ) :: Unit_No IF ( PRESENT ( UnitNo ) ) THEN Unit_No = UnitNo ELSE Unit_No = stdout END IF CALL Display ( FILE , \"Error:: In File \" , UnitNo = Unit_No ) CALL Display ( LINE , \"Line number = \" , UnitNo = Unit_No ) CALL Display ( \" \" , \"Routine named \" // TRIM ( Routine ) // & & \" has ERROR with message \" , UnitNo = Unit_No ) CALL Display ( Msg , UnitNo = Unit_No ) END SUBROUTINE ErrorMSG !---------------------------------------------------------------------------- !                                                                WarningMSG !---------------------------------------------------------------------------- SUBROUTINE WarningMSG ( Msg , File , Routine , Line , UnitNo ) !! This subroutine prints the warning message CHARACTER ( LEN = * ), INTENT ( IN ) :: Msg , File , Routine !! Message to write INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: UnitNo !! file id to write the message to INTEGER ( I4B ), INTENT ( IN ) :: Line !! Line number INTEGER ( I4B ) :: Unit_No IF ( PRESENT ( UnitNo ) ) THEN Unit_No = UnitNo ELSE Unit_No = stdout END IF CALL Display ( FILE , \"Warning:: In File \" , UnitNo = Unit_No ) CALL Display ( LINE , \"Line number = \" , UnitNo = Unit_No ) CALL Display ( \" \" , \"Routine named \" // TRIM ( Routine ) // & & \" has ERROR with message \" , UnitNo = Unit_No ) CALL Display ( Msg , UnitNo = Unit_No ) END SUBROUTINE WarningMSG !---------------------------------------------------------------------------- !                                                                 FileError !---------------------------------------------------------------------------- SUBROUTINE FileError ( istat , fname , flg , UnitNo , File , Routine , Line ) !! Checks for a file error INTEGER ( I4B ), INTENT ( IN ) :: istat !! Result of iostat=istat for open,read,write,close CHARACTER ( len =* ), INTENT ( IN ) :: fname !! Name of the file INTEGER ( I4B ), INTENT ( IN ) :: flg !! IO_OPEN=Open, IO_READ=Read, IO_WRITE=Write, IO_CLOSE=Close INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: UnitNo !! file id to write the error to CHARACTER ( LEN = * ), INTENT ( IN ) :: File , Routine !! Filename and routine name INTEGER ( I4B ), INTENT ( IN ) :: Line ! Define internal variables CHARACTER ( len = :), allocatable :: Amsg INTEGER ( I4B ) :: iunit IF ( istat == 0 ) RETURN IF ( PRESENT ( UnitNo ) ) THEN iunit = UnitNo ELSE iunit = stdout END IF Amsg = '' SELECT CASE ( flg ) CASE ( IO_OPEN ) Amsg = 'Opening file: ' // trim ( fname ) CASE ( IO_READ ) Amsg = 'Reading from: ' // trim ( fname ) CASE ( IO_WRITE ) Amsg = 'Writing to file: ' // trim ( fname ) CASE ( IO_CLOSE ) Amsg = 'Closing file: ' // trim ( fname ) CASE DEFAULT Amsg = 'Error:Invalid error flag [1-4]' END SELECT call ErrorMSG ( Msg = aMsg , UnitNo = iunit , File = File , Line = Line , & & Routine = Routine ) END SUBROUTINE FileError !---------------------------------------------------------------------------- !                                                              AllocationErr !---------------------------------------------------------------------------- SUBROUTINE AllocationErr ( istat , aMsg , alloc , UnitNo , File , Routine , Line ) !! Checks for successful (de)allocation.  Stops the code. !! !! Use this after an allocate/deallocate statement !! allocate(x(nz,ny,nx), stat=istat); call mErr(istat,'x',1) !! deallocate(x, stat=istat); call mErr(istat,'x',2) !====================================================================! INTEGER ( I4B ), intent ( in ) :: istat !! results of stat=istat in (de)allocate character ( len =* ), intent ( in ) :: aMsg !! Message associated with the (de)allocate INTEGER ( I4B ), intent ( in ) :: alloc !! 1 = allocate, 2 = deallocate INTEGER ( I4B ), OPTIONAL , intent ( in ) :: UnitNo !! Optional file id to write the message to CHARACTER ( LEN = * ), INTENT ( IN ) :: File , Routine !! Filename and routine name INTEGER ( I4B ), INTENT ( IN ) :: Line ! Define internal variables CHARACTER ( LEN = : ), ALLOCATABLE :: tmp INTEGER ( I4B ) :: iunit IF ( istat == 0 ) RETURN tmp = '' SELECT CASE ( alloc ) CASE ( OPT_ALLOC ) tmp = 'Allocating Memory: ' // trim ( aMsg ) CASE ( OPT_DEALLOC ) tmp = 'Deallocating Memory: ' // trim ( aMsg ) END SELECT call ErrorMSG ( Msg = tmp , UnitNo = iunit , File = File , Line = Line , & & Routine = Routine ) END SUBROUTINE AllocationErr END MODULE ErrorHandling","tags":"","loc":"sourcefile/errorhandling.f90.html"},{"title":"AbstractVector_Method.f90 – Fortran Program","text":"Contents Modules AbstractVector_Method Source Code AbstractVector_Method.f90 Source Code MODULE AbstractVector_Method USE GlobalData USE BaseType , ONLY : AbstractVector_ PRIVATE INTERFACE Shape MODULE PROCEDURE get_shape END INTERFACE Shape PUBLIC :: Shape INTERFACE Size MODULE PROCEDURE get_Size END INTERFACE Size PUBLIC :: Size CONTAINS PURE FUNCTION get_shape ( Obj ) RESULT ( Ans ) TYPE ( AbstractVector_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ) :: Ans ( 1 ) Ans = 0_I4B END FUNCTION get_shape !<--------------------------------------------------------------------->| ! !<--------------------------------------------------------------------->| PURE FUNCTION get_size ( Obj , Dims ) RESULT ( Ans ) TYPE ( AbstractVector_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: Dims INTEGER ( I4B ) :: Ans Ans = 0 END FUNCTION get_size END MODULE AbstractVector_Method","tags":"","loc":"sourcefile/abstractvector_method.f90.html"},{"title":"Utility.f90 – Fortran Program","text":"Contents Modules Utility Source Code Utility.f90 Source Code MODULE Utility !! Utility module contains useful general purpose routines USE GlobalData USE IO USE ErrorHandling IMPLICIT NONE PRIVATE INTEGER ( I4B ), PARAMETER :: NPAR_ARTH = 16 , NPAR2_ARTH = 8 INTEGER ( I4B ), PARAMETER :: NPAR_GEOP = 4 , NPAR2_GEOP = 2 INTEGER ( I4B ), PARAMETER :: NPAR_CUMSUM = 16 INTEGER ( I4B ), PARAMETER :: NPAR_CUMPROD = 8 INTEGER ( I4B ), PARAMETER :: NPAR_POLY = 8 INTEGER ( I4B ), PARAMETER :: NPAR_POLYTERM = 8 !---------------------------------------------------------------------------- !                                                                 Reallocate !---------------------------------------------------------------------------- !> ! Generic subroutine to reallocate arrays INTERFACE Reallocate MODULE PROCEDURE Reallocate1 , & & Reallocate2 , & & Reallocate3 , & & Reallocate4 , & & Reallocate5 , & & Reallocate6 , & & Reallocate7 , & & Reallocate8 , & & Reallocate9 , & & Reallocate10 END INTERFACE Reallocate PUBLIC :: Reallocate !---------------------------------------------------------------------------- !                                                         EvaluatePolynomial !---------------------------------------------------------------------------- !> ! Generic FUNCTION to evaluate a polynomial INTERFACE EvaluatePolynomial MODULE PROCEDURE eval_poly END INTERFACE EvaluatePolynomial PUBLIC :: EvaluatePolynomial !---------------------------------------------------------------------------- !                                                              VectorProduct !---------------------------------------------------------------------------- !> ! Generic FUNCTION to evaluate vector product INTERFACE VectorProduct MODULE PROCEDURE vec_prod END INTERFACE VectorProduct PUBLIC :: VectorProduct !---------------------------------------------------------------------------- !                                                                 OUTERPROD !---------------------------------------------------------------------------- !> ! Generic FUNCTION to evaluate outerproduct. INTERFACE OUTERPROD MODULE PROCEDURE OUTERPROD1_1 , OUTERPROD2_1 , OUTERPROD3_1 , OUTERPROD2_11 , & & OUTERPROD1_1_sym END INTERFACE OUTERPROD PUBLIC :: OUTERPROD !---------------------------------------------------------------------------- !                                                             ExecuteCommand !---------------------------------------------------------------------------- INTERFACE ExecuteCommand MODULE PROCEDURE exe_cmd END INTERFACE ExecuteCommand PUBLIC :: ExecuteCommand !---------------------------------------------------------------------------- !                                                                 getUnitNo !---------------------------------------------------------------------------- PUBLIC :: getUnitNo , Factorial !---------------------------------------------------------------------------- !                                                                     Append !---------------------------------------------------------------------------- INTERFACE Append MODULE PROCEDURE Append_I1 , Append_I2 , Append_R1 , & Append_R2 END INTERFACE PUBLIC :: Append !---------------------------------------------------------------------------- !                                                                    Int2Str !---------------------------------------------------------------------------- INTERFACE Real2Str MODULE PROCEDURE SP2STR , DP2STR END INTERFACE PUBLIC :: Real2Str , Int2Str !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- INTERFACE outerdIFf MODULE PROCEDURE outerdIFf_r , outerdIFf_i , outerdIFf_d END INTERFACE PUBLIC :: outerdIFf INTERFACE arth MODULE PROCEDURE arth_r , arth_d , arth_i END INTERFACE PUBLIC :: ARTH INTERFACE assert_eq MODULE PROCEDURE assert_eq2 , assert_eq3 , assert_eq4 , assert_eqn END INTERFACE PUBLIC :: ASSERT_EQ !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- !> ! Generic subroutine for swapping INTERFACE SWAP MODULE PROCEDURE swap_i , swap_r , swap_rv , swap_c , & & swap_cv , swap_cm , & & masked_swap_rs , masked_swap_rv , masked_swap_rm END INTERFACE PUBLIC :: SWAP !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- !> Generic FUNCTION to get local of maximum value INTERFACE IMAXLOC MODULE PROCEDURE imaxloc_r , imaxloc_i END INTERFACE !> Generic FUNCTION for getting location of minmum value INTERFACE IMINLOC MODULE PROCEDURE iminloc_r END INTERFACE IMINLOC PUBLIC :: IMINLOC PUBLIC :: IMAXLOC !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- !> Generic FUNCTION to get determinent of `2x2` and `3x3` matrix INTERFACE Det MODULE PROCEDURE det_2D , det_3D END INTERFACE Det PUBLIC :: DET !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- !> Generic subroutine to get inverse of `2x2` and `3x3` matrix INTERFACE Inv MODULE PROCEDURE Inv_2D , Inv_3D END INTERFACE Inv PUBLIC :: INV INTERFACE matmul MODULE PROCEDURE matmul_r3_r1 , matmul_r4_r1 , matmul_r3_r2 , & & matmul_r1_r3 , matmul_r2_r3 END INTERFACE matmul PUBLIC :: matmul !---------------------------------------------------------------------------- !                                                                     Radian !---------------------------------------------------------------------------- INTERFACE radian MODULE PROCEDURE radian_dfp , radian_int END INTERFACE PUBLIC :: radian !---------------------------------------------------------------------------- !                                                                    Degrees !---------------------------------------------------------------------------- INTERFACE Degrees MODULE PROCEDURE degrees_dfp END INTERFACE Degrees PUBLIC :: Degrees !---------------------------------------------------------------------------- !                                                          LOC_NearestPoint !---------------------------------------------------------------------------- INTERFACE LOC_NearestPoint MODULE PROCEDURE Loc_Nearest_Point END INTERFACE LOC_NearestPoint PUBLIC :: LOC_NearestPoint INTERFACE SearchNearestCoord MODULE PROCEDURE Loc_Nearest_Point END INTERFACE SearchNearestCoord PUBLIC :: SearchNearestCoord !---------------------------------------------------------------------------- !                                                                 HeapSort !---------------------------------------------------------------------------- INTERFACE HeapSort MODULE PROCEDURE HEAPSORT_INT , HEAPSORT_REAL END INTERFACE HeapSort PUBLIC :: HeapSort !---------------------------------------------------------------------------- !                                                              Cross_Product !---------------------------------------------------------------------------- INTERFACE Cross_Product MODULE PROCEDURE CROSS_PRODUCT_R1_R1 END INTERFACE Cross_Product PUBLIC :: Cross_Product !---------------------------------------------------------------------------- !                                                                     Input !---------------------------------------------------------------------------- INTERFACE Input MODULE PROCEDURE input_Int , input_Real , input_IntVec , input_RealVec , input_IntArray , input_RealArray , input_String , input_logical END INTERFACE Input PUBLIC :: Input PUBLIC :: getExtension !---------------------------------------------------------------------------- !                                                                   CONTAINS !---------------------------------------------------------------------------- CONTAINS !---------------------------------------------------------------------------- !                                                               getExtension !---------------------------------------------------------------------------- FUNCTION getExtension ( char ) RESULT ( ext ) CHARACTER ( LEN =* ), INTENT ( IN ) :: char CHARACTER ( 7 ) :: ext ! Define internal variables integer ( int32 ) :: n , m ext = \"       \" n = 0 n = index ( char , \".\" , back = . true .) m = len ( char ) ext ( 1 : m - n + 1 ) = char ( n + 1 : m ) END FUNCTION !---------------------------------------------------------------------------- !                                                                     Radian !---------------------------------------------------------------------------- PURE FUNCTION radian_dfp ( deg ) RESULT ( Ans ) REAL ( DFP ), INTENT ( IN ) :: deg REAL ( DFP ) :: Ans Ans = deg / 18 0.0_DFP * 3.1415926535_DFP END FUNCTION radian_dfp PURE FUNCTION radian_int ( deg ) RESULT ( Ans ) INTEGER ( I4B ), INTENT ( IN ) :: deg REAL ( DFP ) :: Ans Ans = REAL ( deg , KIND = DFP ) / 18 0.0_DFP * 3.1415926535_DFP END FUNCTION radian_int !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This subroutine search the location of nearest point to x in the ! array of coordinates; Array FUNCTION Loc_Nearest_Point ( Array , x ) RESULT ( id ) REAL ( DFP ), INTENT ( IN ) :: Array ( :, : ) !! Nodal coordinates in XiJ format REAL ( DFP ), INTENT ( IN ) :: x ( : ) INTEGER ( I4B ) :: id ! Define internal variables REAL ( DFP ) :: xr ( 3 ) INTEGER ( I4B ) :: i , n , m , norm , tr_norm n = SIZE ( Array , 1 ) m = SIZE ( Array , 2 ) IF ( n . NE . SIZE ( x ) ) THEN CALL Display ( __ FILE__ , \"ERROR :: In File :: \" ) CALL Display ( __ LINE__ , \"         At line number :: \" ) CALL Display ( \"Loc_Nearest_Point()\" , \"In routine :: \" ) CALL Display ( \"SearchNearestCoord >> size(Array,1) should be =size(x)\" ) STOP ENDIF DO i = 1 , m xr ( 1 : n ) = Array ( 1 : n , i ) tr_norm = DOT_PRODUCT ( xr ( 1 : n ) - x ( 1 : n ), xr ( 1 : n ) - x ( 1 : n ) ) IF ( i . EQ . 1 ) THEN norm = tr_norm id = i ELSE IF ( norm . GT . tr_norm ) THEN norm = tr_norm id = i ELSE CYCLE END IF END IF END DO END FUNCTION Loc_Nearest_Point !---------------------------------------------------------------------------- !                                                                   HeapSort !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! Heap Sort algorithm for Integer PURE SUBROUTINE HEAPSORT_INT ( array ) INTEGER ( I4B ), INTENT ( INOUT ) :: array ( : ) INTEGER ( I4B ) :: n , i , k , j , l , t n = SIZE ( array ) IF ( n . EQ . 1 ) RETURN l = n / 2 + 1 k = n DO WHILE ( k . NE . 1 ) IF ( l . GT . 1 ) THEN l = l - 1 t = array ( L ) ELSE t = array ( k ) array ( k ) = array ( 1 ) k = k - 1 IF ( k . EQ . 1 ) THEN array ( 1 ) = t EXIT ENDIF ENDIF i = l j = l + l DO WHILE ( j . LE . k ) IF ( j . LT . k ) THEN IF ( array ( j ) . LT . array ( j + 1 ) ) j = j + 1 ENDIF IF ( t . LT . array ( j ) ) THEN array ( i ) = array ( j ) i = j j = j + j ELSE j = k + 1 ENDIF END DO array ( i ) = t ENDDO END SUBROUTINE HEAPSORT_INT !---------------------------------------------------------------------------- !                                                                   HeapSort !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! Heap Sort algorithm for Real PURE SUBROUTINE HEAPSORT_REAL ( array ) REAL ( DFP ), INTENT ( INOUT ) :: array ( : ) INTEGER ( I4B ) :: n , i , k , j , l REAL ( DFP ) :: t n = SIZE ( array ) IF ( n . EQ . 1 ) RETURN l = n / 2 + 1 k = n DO WHILE ( k . NE . 1 ) IF ( l . GT . 1 ) THEN l = l - 1 t = array ( L ) ELSE t = array ( k ) array ( k ) = array ( 1 ) k = k - 1 IF ( k . EQ . 1 ) THEN array ( 1 ) = t EXIT ENDIF ENDIF i = l j = l + l DO WHILE ( j . LE . k ) IF ( j . LT . k ) THEN IF ( array ( j ) . LT . array ( j + 1 ) ) j = j + 1 ENDIF IF ( t . LT . array ( j ) ) THEN array ( i ) = array ( j ) i = j j = j + j ELSE j = k + 1 ENDIF END DO array ( i ) = t ENDDO END SUBROUTINE HEAPSORT_REAL !---------------------------------------------------------------------------- !                                                             Cross_Product !---------------------------------------------------------------------------- PURE FUNCTION CROSS_PRODUCT_R1_R1 ( a , b ) RESULT ( Ans ) REAL ( DFP ), INTENT ( IN ) :: a ( 3 ), b ( 3 ) REAL ( DFP ) :: Ans ( 3 ) Ans ( 1 ) = a ( 2 ) * b ( 3 ) - a ( 3 ) * b ( 2 ) Ans ( 2 ) = a ( 3 ) * b ( 1 ) - a ( 1 ) * b ( 3 ) Ans ( 3 ) = a ( 1 ) * b ( 2 ) - a ( 2 ) * b ( 1 ) END FUNCTION CROSS_PRODUCT_R1_R1 !---------------------------------------------------------------------------- !                                                                    Degrees !---------------------------------------------------------------------------- PURE FUNCTION degrees_dfp ( rad ) RESULT ( Ans ) REAL ( DFP ), INTENT ( IN ) :: rad REAL ( DFP ) :: Ans Ans = rad / 3.1415926535_DFP * 18 0.0_DFP END FUNCTION degrees_dfp !---------------------------------------------------------------------------- !                                                                     Input !---------------------------------------------------------------------------- PURE FUNCTION input_Int ( default , option ) RESULT ( val ) INTEGER ( I4B ), INTENT ( IN ) :: default INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: option INTEGER ( I4B ) :: val IF ( PRESENT ( option ) ) THEN val = option ELSE val = default ENDIF END FUNCTION !---------------------------------------------------------------------------- !                                                                      Input !---------------------------------------------------------------------------- FUNCTION input_Real ( default , option ) RESULT ( val ) REAL ( DFP ), INTENT ( in ) :: default REAL ( DFP ), OPTIONAL , INTENT ( in ) :: option REAL ( DFP ) :: val IF ( PRESENT ( option ) ) THEN val = option ELSE val = default ENDIF END FUNCTION !---------------------------------------------------------------------------- !                                                                      Input !---------------------------------------------------------------------------- FUNCTION input_IntVec ( default , option ) RESULT ( val ) INTEGER ( I4B ), INTENT ( IN ) :: default (:) INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: option (:) INTEGER ( I4B ), ALLOCATABLE :: val (:) IF ( PRESENT ( option ) ) THEN val = option ELSE val = default ENDIF END FUNCTION !---------------------------------------------------------------------------- !                                                                      Input !---------------------------------------------------------------------------- FUNCTION input_Realvec ( default , option ) RESULT ( val ) REAL ( DFP ), INTENT ( IN ) :: default (:) REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: option (:) REAL ( DFP ), ALLOCATABLE :: val (:) IF ( PRESENT ( option ) ) THEN val = option ELSE val = default ENDIF END FUNCTION !---------------------------------------------------------------------------- !                                                                      Input !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This function input integer array PURE FUNCTION input_IntArray ( default , option ) RESULT ( val ) INTEGER ( I4B ), INTENT ( IN ) :: default (:,:) INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: option (:,:) INTEGER ( I4B ), ALLOCATABLE :: val (:,:) IF ( PRESENT ( option ) ) THEN val = option ELSE val = default ENDIF END FUNCTION input_IntArray !---------------------------------------------------------------------------- !                                                                      Input !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This function input real array PURE FUNCTION input_RealArray ( default , option ) RESULT ( val ) REAL ( DFP ), INTENT ( IN ) :: default (:,:) REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: option (:,:) REAL ( DFP ), ALLOCATABLE :: val (:,:) IF ( PRESENT ( option ) ) THEN val = option ELSE val = default ENDIF END FUNCTION input_RealArray !---------------------------------------------------------------------------- !                                                                      Input !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This function input string PURE FUNCTION input_String ( default , option ) RESULT ( val ) CHARACTER ( LEN =* ), INTENT ( IN ) :: default CHARACTER ( LEN =* ), OPTIONAL , INTENT ( IN ) :: option CHARACTER ( 200 ) :: val IF ( PRESENT ( option ) ) THEN val = TRIM ( option ) ELSE val = TRIM ( default ) ENDIF END FUNCTION input_String !---------------------------------------------------------------------------- !                                                                      Input !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This function input logical variables PURE FUNCTION input_logical ( default , option ) RESULT ( val ) LOGICAL ( LGT ), INTENT ( IN ) :: default LOGICAL ( LGT ), OPTIONAL , INTENT ( IN ) :: option LOGICAL ( LGT ) :: val IF ( PRESENT ( option ) ) THEN val = option ELSE val = default ENDIF END FUNCTION input_logical !---------------------------------------------------------------------------- !                                                                     MATMUL !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This fuction performs following task ! `Ans(:,:) = a1(:,:,a)*a2(a)` PURE FUNCTION matmul_r3_r1 ( a1 , a2 ) RESULT ( Ans ) REAL ( DFP ), INTENT ( IN ) :: a1 ( :, :, : ), a2 ( : ) REAL ( DFP ) :: Ans ( size ( a1 , 1 ), size ( a1 , 2 ) ) INTEGER ( I4B ) :: ii Ans = a2 ( 1 ) * a1 ( :, :, 1 ) DO ii = 2 , SIZE ( a2 ) Ans = Ans + a2 ( ii ) * a1 ( :, :, ii ) END DO END FUNCTION matmul_r3_r1 !---------------------------------------------------------------------------- !                                                                     MATMUL !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This fuction performs following task ! `Ans(i,j) = a1(a)*a2(a,i,j)` PURE FUNCTION matmul_r1_r3 ( a1 , a2 ) RESULT ( Ans ) REAL ( DFP ), INTENT ( IN ) :: a1 ( : ), a2 ( :, :, : ) REAL ( DFP ) :: Ans ( size ( a2 , 2 ), size ( a2 , 3 ) ) INTEGER ( I4B ) :: ii Ans = a1 ( 1 ) * a2 ( 1 ,:,:) DO ii = 2 , SIZE ( a1 ) Ans = Ans + a1 ( ii ) * a2 ( ii ,:,:) END DO END FUNCTION matmul_r1_r3 !---------------------------------------------------------------------------- !                                                                     MATMUL !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This fuction performs following task ! `Ans(i,j,ip) = a1(i,I)*a2(I,j,ip)` PURE FUNCTION matmul_r2_r3 ( a1 , a2 ) RESULT ( Ans ) REAL ( DFP ), INTENT ( IN ) :: a1 ( :, : ), a2 ( :, :, : ) REAL ( DFP ) :: Ans ( size ( a1 , 1 ), size ( a2 , 2 ), size ( a2 , 3 ) ) INTEGER ( I4B ) :: ii DO ii = 1 , SIZE ( a2 , 3 ) Ans ( :, :, ii ) = MATMUL ( a1 , a2 ( :, :, ii ) ) END DO END FUNCTION matmul_r2_r3 !---------------------------------------------------------------------------- !                                                                     MATMUL !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This fuction performs following task ! `Ans(:,:,:) = a1(:,:,:,a)*a2(a)` PURE FUNCTION matmul_r4_r1 ( a1 , a2 ) RESULT ( Ans ) REAL ( DFP ), INTENT ( IN ) :: a1 ( :, :, :, : ), a2 ( : ) REAL ( DFP ) :: Ans ( size ( a1 , 1 ), size ( a1 , 2 ), size ( a1 , 3 ) ) INTEGER ( I4B ) :: ii Ans = a2 ( 1 ) * a1 ( :, :, :, 1 ) DO ii = 2 , SIZE ( a2 ) Ans = Ans + a2 ( ii ) * a1 ( :, :, :, ii ) END DO END FUNCTION matmul_r4_r1 !---------------------------------------------------------------------------- !                                                                     MATMUL !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This fuction performs following task ! `Ans(i,j,ip) = a1(i,j,I)*a2(I,ip)` PURE FUNCTION matmul_r3_r2 ( a1 , a2 ) RESULT ( Ans ) REAL ( DFP ), INTENT ( IN ) :: a1 ( :, :, : ), a2 ( :, : ) REAL ( DFP ) :: Ans ( size ( a1 , 1 ), size ( a1 , 2 ), size ( a2 , 2 ) ) INTEGER ( I4B ) :: ip DO ip = 1 , SIZE ( a2 , 2 ) Ans ( :,:, ip ) = MATMUL ( a1 , a2 ( :, ip ) ) END DO END FUNCTION matmul_r3_r2 !----------------------------------------------------------------------------- !                                                                 Reallocate1 !----------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! Reallocate a 2D array PURE SUBROUTINE Reallocate1 ( Mat , row , col ) REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: Mat ( :, : ) INTEGER ( I4B ), INTENT ( IN ) :: row , col IF ( ALLOCATED ( Mat ) ) THEN IF ( ( SIZE ( Mat , 1 ) . NE . row ) . OR . ( SIZE ( Mat , 2 ) . NE . col ) ) THEN DEALLOCATE ( Mat ) ALLOCATE ( Mat ( row , col ) ) END IF ELSE ALLOCATE ( Mat ( row , col ) ) END IF Mat = 0.0_DFP END SUBROUTINE Reallocate1 !---------------------------------------------------------------------------- !                                                                 Reallocate2 !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This subroutine reallocates a vector PURE SUBROUTINE Reallocate2 ( Mat , row ) REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: Mat ( : ) INTEGER ( I4B ), INTENT ( IN ) :: row IF ( ALLOCATED ( Mat ) ) THEN IF ( SIZE ( Mat ) . NE . row ) THEN DEALLOCATE ( Mat ) ALLOCATE ( Mat ( row ) ) END IF ELSE ALLOCATE ( Mat ( row ) ) END IF Mat = 0.0_DFP END SUBROUTINE Reallocate2 !--------------------------------------------------------------------------- !                                                                 Reallocate !--------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This subroutine reallocates a 3D array PURE SUBROUTINE Reallocate3 ( Mat , i1 , i2 , i3 ) REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: Mat ( :, :, : ) INTEGER ( I4B ), INTENT ( IN ) :: i1 , i2 , i3 IF ( ALLOCATED ( Mat ) ) THEN IF ( ( SIZE ( Mat , 1 ) . NE . i1 ) & & . OR . ( SIZE ( Mat , 2 ) . NE . i2 ) & & . OR . ( SIZE ( Mat , 3 ) . NE . i3 ) ) THEN DEALLOCATE ( Mat ) ALLOCATE ( Mat ( i1 , i2 , i3 ) ) END IF ELSE ALLOCATE ( Mat ( i1 , i2 , i3 ) ) END IF Mat = 0.0_DFP END SUBROUTINE Reallocate3 !----------------------------------------------------------------------------- !                                                                 Reallocate4 !----------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This subroutine reallocates a 2D matrix PURE SUBROUTINE Reallocate4 ( Mat , row , col ) INTEGER ( I4B ), ALLOCATABLE , INTENT ( INOUT ) :: Mat ( :, : ) INTEGER ( I4B ), INTENT ( IN ) :: row , col IF ( ALLOCATED ( Mat ) ) THEN IF ( ( SIZE ( Mat , 1 ) . NE . row ) . OR . ( SIZE ( Mat , 2 ) . NE . col ) ) THEN DEALLOCATE ( Mat ) ALLOCATE ( Mat ( row , col ) ) END IF ELSE ALLOCATE ( Mat ( row , col ) ) END IF Mat = 0 END SUBROUTINE Reallocate4 !----------------------------------------------------------------------------- !                                                                 Reallocate5 !----------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This subroutine reallocates a vector PURE SUBROUTINE Reallocate5 ( Mat , row ) INTEGER ( I4B ), ALLOCATABLE , INTENT ( INOUT ) :: Mat ( : ) INTEGER ( I4B ), INTENT ( IN ) :: row IF ( ALLOCATED ( Mat ) ) THEN IF ( SIZE ( Mat ) . NE . row ) THEN DEALLOCATE ( Mat ) ALLOCATE ( Mat ( row ) ) END IF ELSE ALLOCATE ( Mat ( row ) ) END IF Mat = 0 END SUBROUTINE Reallocate5 !---------------------------------------------------------------------------- !                                                                 Reallocate6 !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This subroutine can reallocates upto six vectors PURE SUBROUTINE Reallocate6 ( Vec1 , n1 , Vec2 , n2 , Vec3 , n3 , Vec4 , n4 , & & Vec5 , n5 , Vec6 , n6 ) INTEGER ( I4B ), ALLOCATABLE , INTENT ( INOUT ) :: Vec1 ( : ), Vec2 ( : ) INTEGER ( I4B ), ALLOCATABLE , OPTIONAL , INTENT ( INOUT ) :: Vec3 ( : ), & & Vec4 ( : ), Vec5 ( : ), Vec6 ( : ) INTEGER ( I4B ), INTENT ( IN ) :: n1 , n2 INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: n3 , n4 , n5 , n6 IF ( ALLOCATED ( Vec1 ) ) THEN IF ( SIZE ( Vec1 ) . NE . n1 ) THEN DEALLOCATE ( Vec1 ) ALLOCATE ( Vec1 ( n1 ) ) END IF ELSE ALLOCATE ( Vec1 ( n1 ) ) END IF Vec1 = 0 IF ( ALLOCATED ( Vec2 ) ) THEN IF ( SIZE ( Vec2 ) . NE . n2 ) THEN DEALLOCATE ( Vec2 ) ALLOCATE ( Vec2 ( n2 ) ) END IF ELSE ALLOCATE ( Vec2 ( n2 ) ) END IF Vec2 = 0 IF ( PRESENT ( Vec3 ) ) THEN IF ( ALLOCATED ( Vec3 ) ) THEN IF ( SIZE ( Vec3 ) . NE . n3 ) THEN DEALLOCATE ( Vec3 ) ALLOCATE ( Vec3 ( n3 ) ) END IF ELSE ALLOCATE ( Vec3 ( n3 ) ) END IF Vec3 = 0 END IF IF ( PRESENT ( Vec4 ) ) THEN IF ( ALLOCATED ( Vec4 ) ) THEN IF ( SIZE ( Vec4 ) . NE . n4 ) THEN DEALLOCATE ( Vec4 ) ALLOCATE ( Vec4 ( n4 ) ) END IF ELSE ALLOCATE ( Vec4 ( n4 ) ) END IF Vec4 = 0 END IF IF ( PRESENT ( Vec5 ) ) THEN IF ( ALLOCATED ( Vec5 ) ) THEN IF ( SIZE ( Vec5 ) . NE . n5 ) THEN DEALLOCATE ( Vec5 ) ALLOCATE ( Vec5 ( n5 ) ) END IF ELSE ALLOCATE ( Vec5 ( n5 ) ) END IF Vec5 = 0 END IF IF ( PRESENT ( Vec6 ) ) THEN IF ( ALLOCATED ( Vec6 ) ) THEN IF ( SIZE ( Vec6 ) . NE . n6 ) THEN DEALLOCATE ( Vec6 ) ALLOCATE ( Vec6 ( n6 ) ) END IF ELSE ALLOCATE ( Vec6 ( n6 ) ) END IF Vec6 = 0 END IF END SUBROUTINE Reallocate6 !---------------------------------------------------------------------------- !                                                                 Reallocate7 !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This subroutine can reallocate upto six vectors PURE SUBROUTINE Reallocate7 ( Vec1 , n1 , Vec2 , n2 , Vec3 , n3 , Vec4 , n4 , & & Vec5 , n5 , Vec6 , n6 ) REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: Vec1 ( : ), Vec2 ( : ) REAL ( DFP ), ALLOCATABLE , OPTIONAL , INTENT ( INOUT ) :: Vec3 ( : ), & & Vec4 ( : ), Vec5 ( : ), Vec6 ( : ) INTEGER ( I4B ), INTENT ( IN ) :: n1 , n2 INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: n3 , n4 , n5 , n6 IF ( ALLOCATED ( Vec1 ) ) THEN IF ( SIZE ( Vec1 ) . NE . n1 ) THEN DEALLOCATE ( Vec1 ) ALLOCATE ( Vec1 ( n1 ) ) END IF ELSE ALLOCATE ( Vec1 ( n1 ) ) END IF Vec1 = 0.0 IF ( ALLOCATED ( Vec2 ) ) THEN IF ( SIZE ( Vec2 ) . NE . n2 ) THEN DEALLOCATE ( Vec2 ) ALLOCATE ( Vec2 ( n2 ) ) END IF ELSE ALLOCATE ( Vec2 ( n2 ) ) END IF Vec2 = 0.0 IF ( PRESENT ( Vec3 ) ) THEN IF ( ALLOCATED ( Vec3 ) ) THEN IF ( SIZE ( Vec3 ) . NE . n3 ) THEN DEALLOCATE ( Vec3 ) ALLOCATE ( Vec3 ( n3 ) ) END IF ELSE ALLOCATE ( Vec3 ( n3 ) ) END IF Vec3 = 0.0 END IF IF ( PRESENT ( Vec4 ) ) THEN IF ( ALLOCATED ( Vec4 ) ) THEN IF ( SIZE ( Vec4 ) . NE . n4 ) THEN DEALLOCATE ( Vec4 ) ALLOCATE ( Vec4 ( n4 ) ) END IF ELSE ALLOCATE ( Vec4 ( n4 ) ) END IF Vec4 = 0.0 END IF IF ( PRESENT ( Vec5 ) ) THEN IF ( ALLOCATED ( Vec5 ) ) THEN IF ( SIZE ( Vec5 ) . NE . n5 ) THEN DEALLOCATE ( Vec5 ) ALLOCATE ( Vec5 ( n5 ) ) END IF ELSE ALLOCATE ( Vec5 ( n5 ) ) END IF Vec5 = 0.0 END IF IF ( PRESENT ( Vec6 ) ) THEN IF ( ALLOCATED ( Vec6 ) ) THEN IF ( SIZE ( Vec6 ) . NE . n6 ) THEN DEALLOCATE ( Vec6 ) ALLOCATE ( Vec6 ( n6 ) ) END IF ELSE ALLOCATE ( Vec6 ( n6 ) ) END IF Vec6 = 0.0 END IF END SUBROUTINE Reallocate7 !---------------------------------------------------------------------------- !                                                                Reallocate !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This subroutine can reallocate three vectors; it is useful for ! sparse matrix related methods PURE SUBROUTINE Reallocate8 ( A , nA , IA , nIA , JA , nJA ) REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: A ( : ) INTEGER ( I4B ), ALLOCATABLE , INTENT ( INOUT ) :: IA ( : ), JA ( : ) INTEGER ( I4B ), INTENT ( IN ) :: nA , nIA , nJA IF ( ALLOCATED ( A ) ) THEN IF ( SIZE ( A ) . NE . nA ) THEN DEALLOCATE ( A ) ALLOCATE ( A ( nA ) ) END IF ELSE ALLOCATE ( A ( nA ) ) END IF A = 0.0 IF ( ALLOCATED ( IA ) ) THEN IF ( SIZE ( IA ) . NE . nIA ) THEN DEALLOCATE ( IA ) ALLOCATE ( IA ( nIA ) ) END IF ELSE ALLOCATE ( IA ( nIA ) ) END IF IA = 0 IF ( ALLOCATED ( JA ) ) THEN IF ( SIZE ( JA ) . NE . nJA ) THEN DEALLOCATE ( JA ) ALLOCATE ( JA ( nJA ) ) END IF ELSE ALLOCATE ( JA ( nJA ) ) END IF JA = 0 END SUBROUTINE Reallocate8 !---------------------------------------------------------------------------- !                                                                Reallocate !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This subroutine can reallocate two vectors PURE SUBROUTINE Reallocate9 ( A , nA , IA , nIA ) REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: A ( : ) INTEGER ( I4B ), ALLOCATABLE , INTENT ( INOUT ) :: IA ( : ) INTEGER ( I4B ), INTENT ( IN ) :: nA , nIA IF ( ALLOCATED ( A ) ) THEN IF ( SIZE ( A ) . NE . nA ) THEN DEALLOCATE ( A ) ALLOCATE ( A ( nA ) ) END IF ELSE ALLOCATE ( A ( nA ) ) END IF A = 0.0 IF ( ALLOCATED ( IA ) ) THEN IF ( SIZE ( IA ) . NE . nIA ) THEN DEALLOCATE ( IA ) ALLOCATE ( IA ( nIA ) ) END IF ELSE ALLOCATE ( IA ( nIA ) ) END IF IA = 0 END SUBROUTINE Reallocate9 !---------------------------------------------------------------------------- !                                                                 Reallocate !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This subroutine reallocates a 3D array PURE SUBROUTINE Reallocate10 ( Mat , i1 , i2 , i3 , i4 ) REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: Mat ( :, :, :, : ) INTEGER ( I4B ), INTENT ( IN ) :: i1 , i2 , i3 , i4 IF ( ALLOCATED ( Mat ) ) THEN IF ( ( SIZE ( Mat , 1 ) . NE . i1 ) & & . OR . ( SIZE ( Mat , 2 ) . NE . i2 ) & & . OR . ( SIZE ( Mat , 3 ) . NE . i3 ) & & . OR . ( SIZE ( Mat , 4 ) . NE . i4 ) & & ) THEN DEALLOCATE ( Mat ) ALLOCATE ( Mat ( i1 , i2 , i3 , i4 ) ) END IF ELSE ALLOCATE ( Mat ( i1 , i2 , i3 , i4 ) ) END IF Mat = 0.0_DFP END SUBROUTINE Reallocate10 !----------------------------------------------------------------------------- ! !----------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! this FUNCTION evaluate a polynomial ! - Power table contains the power of x, y, z ! - Its shape IF ( tTerms, 3 ) !\t- Coeff is vector its size is tTerms !\t- X( 3 ) contains x, y, z FUNCTION eval_poly ( PowerTable , Coeff , X , tTerms ) RESULT ( Ans ) INTEGER ( I4B ), INTENT ( IN ) :: tTerms REAL ( DFP ), DIMENSION ( tTerms , 3 ), INTENT ( IN ) :: PowerTable REAL ( DFP ), DIMENSION ( tTerms ), INTENT ( IN ) :: Coeff REAL ( DFP ), INTENT ( IN ) :: X ( 3 ) REAL ( DFP ) :: Ans ! Define internal variable INTEGER ( I4B ) :: i Ans = 0.0_DFP DO i = 1 , tTerms IF ( Coeff ( i ) . NE . 0.0_DFP ) THEN Ans = Ans + Coeff ( i ) * & & ( X ( 1 ) ** PowerTable ( i , 1 ) & & * X ( 2 ) ** PowerTable ( i , 2 ) & & * X ( 3 ) ** PowerTable ( i , 3 ) & & ) END IF END DO END FUNCTION eval_poly !------------------------------------------------------------------------------ ! !------------------------------------------------------------------------------ !> authors: Dr. Vikas Sharma ! ! This FUNCTION evaluate vectors product ! \\mathbf{ans} = \\mathbf{a} \\times \\mathbf{b} PURE FUNCTION vec_prod ( a , b ) RESULT ( c ) ! Define INTENT of dummy argument REAL ( DFP ), INTENT ( IN ) :: a ( 3 ), b ( 3 ) REAL ( DFP ) :: c ( 3 ) c ( 1 ) = a ( 2 ) * b ( 3 ) - a ( 3 ) * b ( 2 ) c ( 2 ) = a ( 3 ) * b ( 1 ) - a ( 1 ) * b ( 3 ) c ( 3 ) = a ( 1 ) * b ( 2 ) - a ( 2 ) * b ( 1 ) END FUNCTION vec_prod !-------------------------------------------------------------------- ! !-------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This FUNCTION returns outerproduct(matrix) of two vectors ! \\mathbf{ans} = \\mathbf{a} \\otimes \\mathbf{b} PURE FUNCTION OUTERPROD1_1 ( a , b ) RESULT ( Ans ) REAL ( DFP ), DIMENSION (:), INTENT ( IN ) :: a , b REAL ( DFP ), DIMENSION ( SIZE ( a ), SIZE ( b )) :: Ans Ans = 0.0_DFP Ans = SPREAD ( a , dim = 2 , ncopies = size ( b )) * & & SPREAD ( b , dim = 1 , ncopies = size ( a )) END FUNCTION OUTERPROD1_1 !-------------------------------------------------------------------- ! !-------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This FUNCTION returns outerproduct(matrix) of two vectors ! - \\mathbf{ans} = \\mathbf{a} \\otimes \\mathbf{b} ! - If `Sym` is .true. THEN symmetric part is returned PURE FUNCTION OUTERPROD1_1_sym ( a , b , Sym ) RESULT ( Ans ) ! Define INTENT of dummy variables REAL ( DFP ), INTENT ( IN ) :: a ( : ), b ( : ) REAL ( DFP ), DIMENSION ( SIZE ( a ), SIZE ( b )) :: Ans LOGICAL ( LGT ), INTENT ( IN ) :: Sym Ans = 0.0_DFP IF ( Sym ) THEN Ans = SPREAD ( 0.5_DFP * a , dim = 2 , ncopies = size ( b ) ) & & * SPREAD ( b , dim = 1 , ncopies = size ( a ) ) & & + SPREAD ( 0.5_DFP * b , dim = 2 , ncopies = size ( a ) ) & & * SPREAD ( a , dim = 1 , ncopies = size ( b ) ) ELSE Ans = SPREAD ( a , dim = 2 , ncopies = size ( b )) * & & SPREAD ( b , dim = 1 , ncopies = size ( a )) END IF END FUNCTION OUTERPROD1_1_sym !-------------------------------------------------------------------- ! !-------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This FUNCTION returns outerprod between a matrix and a vector ! `Ans(:,:,i) = a(:,:) * b(i)` PURE FUNCTION OUTERPROD2_1 ( a , b ) RESULT ( Ans ) REAL ( DFP ), INTENT ( IN ) :: a ( :, : ) REAL ( DFP ), INTENT ( IN ) :: b ( : ) REAL ( DFP ) :: Ans ( SIZE ( a , 1 ), SIZE ( a , 2 ), SIZE ( b ) ) ! Definen internal variables INTEGER ( I4B ) :: I Ans = 0.0_DFP FORALL ( I = 1 : SIZE ( b )) Ans ( :, :, I ) = a ( :, : ) * b ( I ) END FORALL END FUNCTION OUTERPROD2_1 !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This FUNCTION evaluate outerproduct between a 3D matrix and a vector ! - `Ans( :, :, :,  I ) = a( :, :, : ) * b( I )` PURE FUNCTION OUTERPROD3_1 ( a , b ) RESULT ( Ans ) REAL ( DFP ), INTENT ( IN ) :: a (:,:,:) REAL ( DFP ), INTENT ( IN ) :: b (:) REAL ( DFP ) :: Ans ( SIZE ( a , 1 ), SIZE ( a , 2 ), SIZE ( a , 3 ), SIZE ( b ) ) INTEGER ( I4B ) :: I Ans = 0.0_DFP FORALL ( I = 1 : SIZE ( b ) ) Ans ( :, :, :, I ) = a ( :, :, : ) * b ( I ) END FORALL END FUNCTION OUTERPROD3_1 !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This FUNCTION evaluates outer product between a matrix and two vector ! ! Ans = a \\otimes b \\otimes c PURE FUNCTION OUTERPROD2_11 ( a , b , c ) RESULT ( ANS ) REAL ( DFP ), INTENT ( IN ) :: a ( :, : ) REAL ( DFP ), INTENT ( IN ) :: b ( : ), c ( : ) REAL ( DFP ) :: ANS ( SIZE ( a , 1 ), SIZE ( a , 2 ), SIZE ( b ), SIZE ( c ) ) ! Definen internal variables REAL ( DFP ), DIMENSION ( SIZE ( a , 1 ), SIZE ( a , 2 ), SIZE ( b ) ) :: Dummy3 Dummy3 = OUTERPROD2_1 ( a , b ) ANS = OUTERPROD3_1 ( Dummy3 , c ) END FUNCTION OUTERPROD2_11 !------------------------------------------------------------------------------ !                                                                ExecuteCommand !------------------------------------------------------------------------------ !> authors: Dr. Vikas Sharma ! ! This subroutine run a system commoand on terminal SUBROUTINE exe_cmd ( CMD , Str ) CHARACTER ( LEN = * ), INTENT ( IN ) :: CMD , Str ! Define internal variables INTEGER ( I4B ) :: CMDSTAT , EXITSTAT LOGICAL ( LGT ) :: WAIT = . TRUE . CHARACTER ( LEN = 300 ) :: CMDMSG = \"\" CALL EXECUTE_COMMAND_LINE ( TRIM ( CMD ), CMDSTAT = CMDSTAT , & & EXITSTAT = EXITSTAT , WAIT = WAIT , CMDMSG = CMDMSG ) IF ( CMDSTAT . NE . 0 ) THEN IF ( CMDSTAT . EQ . - 1 ) THEN CALL ErrorMsg ( & & File = __ FILE__ , & & Routine = \"exe_cmd()\" , & & Line = __ LINE__ , & & MSG = \"following command failed \" // TRIM ( CMDMSG ) ) END IF CALL ErrorMsg ( & & File = __ FILE__ , & & Routine = \"exe_cmd()\" , & & Line = __ LINE__ , & & MSG = \"following command failed \" // TRIM ( CMDMSG ) ) STOP END IF END SUBROUTINE exe_cmd !------------------------------------------------------------------------------ ! !------------------------------------------------------------------------------ !> authors: Dr. Vikas Sharma ! ! This FUNCTION returns valid unit no for input output FUNCTION getUnitNo ( Str ) ! Define INTENT of dumy varibales INTEGER ( I4B ) :: getUnitNo CHARACTER ( LEN = * ), INTENT ( IN ) :: Str ! Define internal variables LOGICAL ( LGT ) :: isOpen , isExist INTEGER ( I4B ) :: Imin , Imax , I Imin = 10 Imax = 1000 DO I = Imin , Imax , 1 INQUIRE ( UNIT = I , OPENED = isOpen , EXIST = isExist ) IF ( isExist . AND . . NOT . isOpen ) EXIT END DO IF ( isOpen . OR . . NOT . isExist ) THEN CALL ErrorMsg ( & & File = __ FILE__ , & & Routine = \"getUnitNo()\" , & & Line = __ LINE__ , & & MSG = \" cannot find a valid unit number; Program Stopped\" ) STOP END IF getUnitNo = I END FUNCTION getUnitNo !---------------------------------------------------------------------------- !                                                                     Append !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! Append scalar INTEGER  to  INTEGER  vec tor PURE SUBROUTINE Append_I1 ( A , Entry ) INTEGER ( I4B ), ALLOCATABLE , INTENT ( INOUT ) :: A ( : ) INTEGER ( I4B ), INTENT ( IN ) :: Entry INTEGER ( I4B ), ALLOCATABLE :: Dummy ( : ) INTEGER ( I4B ) :: tSize IF ( . NOT . ALLOCATED ( A ) ) THEN A = [ Entry ] ELSE tSize = SIZE ( A ); ALLOCATE ( Dummy ( tSize + 1 ) ) Dummy ( 1 : tSize ) = A ; Dummy ( tSize + 1 ) = Entry CALL MOVE_ALLOC ( From = Dummy , To = A ) END IF END SUBROUTINE Append_I1 !---------------------------------------------------------------------------- !                                                                     Append !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! Append vector of INTEGER  to  INTEGER  vec tor !------------------------------------------------------------------------------ PURE SUBROUTINE Append_I2 ( A , Entry ) INTEGER ( I4B ), ALLOCATABLE , INTENT ( INOUT ) :: A ( : ) INTEGER ( I4B ), INTENT ( IN ) :: Entry ( : ) INTEGER ( I4B ), ALLOCATABLE :: Dummy ( : ) INTEGER ( I4B ) :: n , m IF ( . NOT . ALLOCATED ( A ) ) THEN A = Entry ELSE m = SIZE ( Entry ); n = SIZE ( A ) ALLOCATE ( Dummy ( n + m ) ); Dummy ( 1 : n ) = A ; Dummy ( n + 1 : ) = Entry CALL MOVE_ALLOC ( From = Dummy , To = A ) END IF END SUBROUTINE Append_I2 !---------------------------------------------------------------------------- !                                                                    Append !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! Append scalar REAL to the REAL-vector !------------------------------------------------------------------------------ PURE SUBROUTINE Append_R1 ( A , Entry ) REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: A ( : ) REAL ( DFP ), INTENT ( IN ) :: Entry REAL ( DFP ), ALLOCATABLE :: Dummy ( : ) INTEGER ( I4B ) :: n IF ( . NOT . ALLOCATED ( A ) ) THEN A = [ Entry ] ELSE n = SIZE ( A ); ALLOCATE ( Dummy ( n + 1 ) ) Dummy ( 1 : n ) = A ; Dummy ( 1 + n ) = Entry CALL MOVE_ALLOC ( From = Dummy , TO = A ) END IF END SUBROUTINE Append_R1 !---------------------------------------------------------------------------- !                                                                     Append !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! Append vector of REAL to REAL-vector PURE SUBROUTINE Append_R2 ( A , Entry ) REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: A ( : ) REAL ( DFP ), INTENT ( IN ) :: Entry ( : ) REAL ( DFP ), ALLOCATABLE :: Dummy ( : ) INTEGER ( I4B ) :: n , m IF ( . NOT . ALLOCATED ( A ) ) THEN A = Entry ELSE m = SIZE ( Entry ); n = SIZE ( A ); ALLOCATE ( Dummy ( n + m ) ) Dummy ( 1 : n ) = A ; Dummy ( 1 + n : ) = Entry CALL MOVE_ALLOC ( FROM = Dummy , TO = A ) END IF END SUBROUTINE Append_R2 !------------------------------------------------------------------------------ !                                                                  Rank1ToRank3 !------------------------------------------------------------------------------ !> authors: Dr. Vikas Sharma ! ! Returns a 3D arrays of pointers SUBROUTINE Rank1ToRank3 ( R1 , R3 , NSD , NNS , NNT ) REAL ( DFP ), DIMENSION ( : ), CONTIGUOUS , TARGET :: R1 REAL ( DFP ), DIMENSION ( :, :, : ), POINTER :: R3 INTEGER ( I4B ), INTENT ( IN ) :: NSD , NNS , NNT INTEGER ( I4B ) :: I , N , a , b , K ! Free the memory IF R3 is already allocated IF ( ASSOCIATED ( R3 ) ) DEALLOCATE ( R3 ) NULLIFY ( R3 ) N = SIZE ( R1 ) ! Flag-1 IF ( N . NE . ( NSD * NNS * NNT ) ) THEN CALL ErrorMsg ( & & File = __ FILE__ , & & Routine = \"Rank1ToRank3()\" , & & Line = __ LINE__ , & & MSG = \" Factor Problem\" ) RETURN END IF DO K = 1 , NNT DO I = 1 , NSD a = ( K - 1 ) * NSD * NNS + ( I - 1 ) * NNS + 1 b = a + NNS - 1 R3 ( I : I , 1 : NNS , K : K ) => R1 ( a : b ) END DO END DO END SUBROUTINE Rank1ToRank3 !---------------------------------------------------------------------------- !                                                                 Factorial !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This FUNCTION computes the factorial of an INTEGER RECURSIVE FUNCTION Factorial ( N ) RESULT ( Fact ) INTEGER ( I4B ), INTENT ( IN ) :: N INTEGER ( I4B ) :: Fact IF ( N . EQ . 0 ) THEN Fact = 1 ELSE Fact = N * Factorial ( N - 1 ) END IF END FUNCTION Factorial !------------------------------------------------------------------------------ !                                                                      Int2Str !------------------------------------------------------------------------------ !> authors: Dr. Vikas Sharma ! ! Convert INTEGER  to  string PURE FUNCTION Int2Str ( I ) INTEGER ( I4B ), INTENT ( IN ) :: I CHARACTER ( LEN = 15 ) :: Int2Str CHARACTER ( LEN = 15 ) :: Str WRITE ( Str , \"(I15)\" ) I Int2Str = TRIM ( ADJUSTL ( Str ) ) END FUNCTION Int2Str !---------------------------------------------------------------------------- !                                                                  Real2Str !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! Convert REAL to string FUNCTION SP2Str ( I ) REAL ( SP ), INTENT ( IN ) :: I CHARACTER ( LEN = 20 ) :: SP2Str CHARACTER ( LEN = 20 ) :: Str WRITE ( Str , \"(G17.7)\" ) I SP2Str = TRIM ( ADJUSTL ( Str ) ) END FUNCTION SP2Str !---------------------------------------------------------------------------- !                                                                  Real2Str !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! Convert REAL to string FUNCTION DP2Str ( I ) REAL ( DP ), INTENT ( IN ) :: I CHARACTER ( LEN = 20 ) :: DP2Str CHARACTER ( LEN = 20 ) :: Str WRITE ( Str , \"(G17.7)\" ) I DP2Str = TRIM ( ADJUSTL ( Str ) ) END FUNCTION DP2Str !------------------------------------------------------------------------------ !                                                                         arth !------------------------------------------------------------------------------ PURE FUNCTION arth_r ( first , increment , n ) REAL ( SP ), INTENT ( IN ) :: first , increment INTEGER ( I4B ), INTENT ( IN ) :: n REAL ( SP ), DIMENSION ( n ) :: arth_r INTEGER ( I4B ) :: k , k2 REAL ( SP ) :: temp IF ( n > 0 ) arth_r ( 1 ) = first IF ( n <= NPAR_ARTH ) THEN DO k = 2 , n arth_r ( k ) = arth_r ( k - 1 ) + increment END DO ELSE DO k = 2 , NPAR2_ARTH arth_r ( k ) = arth_r ( k - 1 ) + increment END DO temp = increment * NPAR2_ARTH k = NPAR2_ARTH DO IF ( k >= n ) exit k2 = k + k arth_r ( k + 1 : min ( k2 , n )) = temp + arth_r ( 1 : min ( k , n - k )) temp = temp + temp k = k2 END DO END IF END FUNCTION arth_r !BL PURE FUNCTION arth_d ( first , increment , n ) REAL ( DP ), INTENT ( IN ) :: first , increment INTEGER ( I4B ), INTENT ( IN ) :: n REAL ( DP ), DIMENSION ( n ) :: arth_d INTEGER ( I4B ) :: k , k2 REAL ( DP ) :: temp IF ( n > 0 ) arth_d ( 1 ) = first IF ( n <= NPAR_ARTH ) THEN DO k = 2 , n arth_d ( k ) = arth_d ( k - 1 ) + increment END DO ELSE DO k = 2 , NPAR2_ARTH arth_d ( k ) = arth_d ( k - 1 ) + increment END DO temp = increment * NPAR2_ARTH k = NPAR2_ARTH DO IF ( k >= n ) exit k2 = k + k arth_d ( k + 1 : min ( k2 , n )) = temp + arth_d ( 1 : min ( k , n - k )) temp = temp + temp k = k2 END DO END IF END FUNCTION arth_d ! PURE FUNCTION arth_i ( first , increment , n ) INTEGER ( I4B ), INTENT ( IN ) :: first , increment , n INTEGER ( I4B ), DIMENSION ( n ) :: arth_i INTEGER ( I4B ) :: k , k2 , temp IF ( n > 0 ) arth_i ( 1 ) = first IF ( n <= NPAR_ARTH ) THEN DO k = 2 , n arth_i ( k ) = arth_i ( k - 1 ) + increment END DO ELSE DO k = 2 , NPAR2_ARTH arth_i ( k ) = arth_i ( k - 1 ) + increment END DO temp = increment * NPAR2_ARTH k = NPAR2_ARTH DO IF ( k >= n ) exit k2 = k + k arth_i ( k + 1 : min ( k2 , n )) = temp + arth_i ( 1 : min ( k , n - k )) temp = temp + temp k = k2 END DO END IF END FUNCTION arth_i !------------------------------------------------------------------------------ !                                                                    OuterDIFf !------------------------------------------------------------------------------ !BL PURE FUNCTION outerdIFf_r ( a , b ) REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: a , b REAL ( SP ), DIMENSION ( size ( a ), size ( b )) :: outerdIFf_r outerdIFf_r = SPREAD ( a , dim = 2 , ncopies = size ( b )) - & SPREAD ( b , dim = 1 , ncopies = size ( a )) END FUNCTION outerdIFf_r ! PURE FUNCTION outerdIFf_d ( a , b ) REAL ( DP ), DIMENSION (:), INTENT ( IN ) :: a , b REAL ( DP ), DIMENSION ( size ( a ), size ( b )) :: outerdIFf_d outerdIFf_d = SPREAD ( a , dim = 2 , ncopies = size ( b )) - & SPREAD ( b , dim = 1 , ncopies = size ( a )) END FUNCTION outerdIFf_d !BL PURE FUNCTION outerdIFf_i ( a , b ) INTEGER ( I4B ), DIMENSION (:), INTENT ( IN ) :: a , b INTEGER ( I4B ), DIMENSION ( size ( a ), size ( b )) :: outerdIFf_i outerdIFf_i = SPREAD ( a , dim = 2 , ncopies = size ( b )) - & SPREAD ( b , dim = 1 , ncopies = size ( a )) END FUNCTION outerdIFf_i !------------------------------------------------------------------------------ !                                                                      nrerror !------------------------------------------------------------------------------ SUBROUTINE nrerror ( string ) CHARACTER ( LEN =* ), INTENT ( IN ) :: string write ( * , * ) 'nrerror: ' , string STOP 'program terminated by nrerror' END SUBROUTINE nrerror !------------------------------------------------------------------------------ !                                                                   assert_eq2 !------------------------------------------------------------------------------ FUNCTION assert_eq2 ( n1 , n2 , string ) CHARACTER ( LEN =* ), INTENT ( IN ) :: string INTEGER ( I4B ), INTENT ( IN ) :: n1 , n2 INTEGER ( I4B ) :: assert_eq2 IF ( n1 . EQ . n2 ) THEN assert_eq2 = n1 ELSE CALL ErrorMsg ( & & File = __ FILE__ , & & Routine = \"Assert_Eq()\" , & & Line = __ LINE__ , & & MSG = \" Sizes of Matrices are not the same; Program Stopped \" ) STOP END IF END FUNCTION assert_eq2 FUNCTION assert_eq3 ( n1 , n2 , n3 , string ) CHARACTER ( LEN =* ), INTENT ( IN ) :: string INTEGER ( I4B ), INTENT ( IN ) :: n1 , n2 , n3 INTEGER ( I4B ) :: assert_eq3 IF ( n1 == n2 . and . n2 == n3 ) THEN assert_eq3 = n1 ELSE CALL ErrorMsg ( & & File = __ FILE__ , & & Routine = \"Assert_Eq()\" , & & Line = __ LINE__ , & & MSG = \" Sizes of Matrices are not the same; Program Stopped \" ) STOP END IF END FUNCTION assert_eq3 FUNCTION assert_eq4 ( n1 , n2 , n3 , n4 , string ) CHARACTER ( LEN =* ), INTENT ( IN ) :: string INTEGER ( I4B ), INTENT ( IN ) :: n1 , n2 , n3 , n4 INTEGER ( I4B ) :: assert_eq4 IF ( n1 == n2 . and . n2 == n3 . and . n3 == n4 ) THEN assert_eq4 = n1 ELSE CALL ErrorMsg ( & & File = __ FILE__ , & & Routine = \"Assert_Eq()\" , & & Line = __ LINE__ , & & MSG = \" Sizes of Matrices are not the same; Program Stopped \" ) STOP END IF END FUNCTION assert_eq4 FUNCTION assert_eqn ( nn , string ) CHARACTER ( LEN =* ), INTENT ( IN ) :: string INTEGER ( I4B ), DIMENSION ( : ), INTENT ( IN ) :: nn INTEGER ( I4B ) :: assert_eqn IF ( all ( nn ( 2 :) == nn ( 1 ))) THEN assert_eqn = nn ( 1 ) ELSE CALL ErrorMsg ( & & File = __ FILE__ , & & Routine = \"Assert_Eq()\" , & & Line = __ LINE__ , & & MSG = \" Sizes of Matrices are not the same; Program Stopped \" ) STOP END IF END FUNCTION assert_eqn !---------------------------------------------------------------------------- !                                                                      SWAP !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! Subroutine for interchanging two INTEGER PURE SUBROUTINE swap_i ( a , b ) INTEGER ( I4B ), INTENT ( INOUT ) :: a , b INTEGER ( I4B ) :: dum dum = a a = b b = dum END SUBROUTINE swap_i !---------------------------------------------------------------------------- !                                                                      SWAP !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! Subroutine for interchanging two REAL numbers PURE SUBROUTINE swap_r ( a , b ) REAL ( DFP ), INTENT ( INOUT ) :: a , b REAL ( DFP ) :: dum dum = a a = b b = dum END SUBROUTINE swap_r !---------------------------------------------------------------------------- !                                                                       SWAP !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! Subroutine for interchanging two REAL valued vectors PURE SUBROUTINE swap_rv ( a , b ) REAL ( DFP ), DIMENSION (:), INTENT ( INOUT ) :: a , b REAL ( DFP ), DIMENSION ( SIZE ( a )) :: dum dum = a a = b b = dum END SUBROUTINE swap_rv !---------------------------------------------------------------------------- !                                                                       SWAP !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! Subroutine for interchanging two complex numbers PURE SUBROUTINE swap_c ( a , b ) COMPLEX ( DFPC ), INTENT ( INOUT ) :: a , b COMPLEX ( DFPC ) :: dum dum = a a = b b = dum END SUBROUTINE swap_c !---------------------------------------------------------------------------- !                                                                       SWAP !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! Subroutine for interchanging two complexed valued vectors PURE SUBROUTINE swap_cv ( a , b ) COMPLEX ( DFPC ), DIMENSION (:), INTENT ( INOUT ) :: a , b COMPLEX ( DFPC ), DIMENSION ( SIZE ( a )) :: dum dum = a a = b b = dum END SUBROUTINE swap_cv !---------------------------------------------------------------------------- !                                                                       SWAP !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! Subroutine for interchanging two complexed valued matrices PURE SUBROUTINE swap_cm ( a , b ) COMPLEX ( DFPC ), DIMENSION (:,:), INTENT ( INOUT ) :: a , b COMPLEX ( DFPC ), DIMENSION ( size ( a , 1 ), size ( a , 2 )) :: dum dum = a a = b b = dum END SUBROUTINE swap_cm !---------------------------------------------------------------------------- !                                                                      SWAP !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! Subroutine for interchanging two REAL valued number PURE SUBROUTINE masked_swap_rs ( a , b , mask ) REAL ( DFP ), INTENT ( INOUT ) :: a , b LOGICAL ( LGT ), INTENT ( IN ) :: mask REAL ( DFP ) :: swp IF ( mask ) THEN swp = a a = b b = swp END IF END SUBROUTINE masked_swap_rs !---------------------------------------------------------------------------- !                                                                       SWAP !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! !Subroutine for interchanging two REAL valued vectors PURE SUBROUTINE masked_swap_rv ( a , b , mask ) REAL ( DFP ), DIMENSION (:), INTENT ( INOUT ) :: a , b LOGICAL ( LGT ), DIMENSION (:), INTENT ( IN ) :: mask REAL ( DFP ), DIMENSION ( size ( a )) :: swp WHERE ( mask ) swp = a a = b b = swp END WHERE END SUBROUTINE masked_swap_rv !---------------------------------------------------------------------------- !                                                                      SWAP !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! Subroutine for interchanging two REAL valued matrices PURE SUBROUTINE masked_swap_rm ( a , b , mask ) REAL ( DFP ), DIMENSION (:,:), INTENT ( INOUT ) :: a , b LOGICAL ( LGT ), DIMENSION (:,:), INTENT ( IN ) :: mask REAL ( DFP ), DIMENSION ( size ( a , 1 ), size ( a , 2 )) :: swp where ( mask ) swp = a a = b b = swp END where END SUBROUTINE masked_swap_rm !---------------------------------------------------------------------------- !                                                                   IMAXLOC !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! Function for getting location of maximum value PURE FUNCTION imaxloc_r ( arr ) REAL ( DFP ), DIMENSION (:), INTENT ( IN ) :: arr INTEGER ( I4B ) :: imaxloc_r INTEGER ( I4B ), DIMENSION ( 1 ) :: imax imax = MAXLOC ( arr (:) ) imaxloc_r = imax ( 1 ) END FUNCTION imaxloc_r !---------------------------------------------------------------------------- !                                                                   IMAXLOC !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! Function for getting location of maximum value PURE FUNCTION imaxloc_i ( iarr ) INTEGER ( I4B ), DIMENSION (:), INTENT ( IN ) :: iarr INTEGER ( I4B ), DIMENSION ( 1 ) :: imax INTEGER ( I4B ) :: imaxloc_i imax = MAXLOC ( iarr ( : ) ) imaxloc_i = imax ( 1 ) END FUNCTION imaxloc_i !---------------------------------------------------------------------------- !                                                                    IMINLOC !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! Function for getting location of minimum value FUNCTION iminloc_r ( arr ) REAL ( DFP ), DIMENSION (:), INTENT ( IN ) :: arr INTEGER ( I4B ), DIMENSION ( 1 ) :: imin INTEGER ( I4B ) :: iminloc_r imin = MINLOC ( arr (:)) iminloc_r = imin ( 1 ) END FUNCTION iminloc_r !---------------------------------------------------------------------------- !                                                                        DET !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This FUNCTION returns determinent of 2 by 2 and 3 by 3 matrix PURE FUNCTION det_2D ( A ) RESULT ( Ans ) REAL ( DFP ), INTENT ( IN ) :: A ( :, : ) REAL ( DFP ) :: Ans SELECT CASE ( SIZE ( A , 1 ) ) CASE ( 1 ) Ans = A ( 1 , 1 ) CASE ( 2 ) Ans = A ( 1 , 1 ) * A ( 2 , 2 ) - A ( 1 , 2 ) * A ( 2 , 1 ) CASE ( 3 ) Ans = A ( 1 , 1 ) * ( A ( 2 , 2 ) * A ( 3 , 3 ) - A ( 2 , 3 ) * A ( 3 , 2 )) & & - A ( 1 , 2 ) * ( A ( 2 , 1 ) * A ( 3 , 3 ) - A ( 2 , 3 ) * A ( 3 , 1 )) & & + A ( 1 , 3 ) * ( A ( 2 , 1 ) * A ( 3 , 2 ) - A ( 3 , 1 ) * A ( 2 , 2 )) CASE ( 4 ) Ans = A ( 1 , 1 ) * ( A ( 2 , 2 ) * ( A ( 3 , 3 ) * A ( 4 , 4 ) - A ( 3 , 4 ) * A ( 4 , 3 ))& & + A ( 2 , 3 ) * ( A ( 3 , 4 ) * A ( 4 , 2 ) - A ( 3 , 2 ) * A ( 4 , 4 )) & & + A ( 2 , 4 ) * ( A ( 3 , 2 ) * A ( 4 , 3 ) & & - A ( 3 , 3 ) * A ( 4 , 2 ))) - A ( 1 , 2 ) * ( A ( 2 , 1 ) * ( A ( 3 , 3 ) * A ( 4 , 4 ) & & - A ( 3 , 4 ) * A ( 4 , 3 )) + A ( 2 , 3 ) * ( A ( 3 , 4 ) * A ( 4 , 1 ) - A ( 3 , 1 ) * A ( 4 , 4 )) & & + A ( 2 , 4 ) * ( A ( 3 , 1 ) * A ( 4 , 3 ) - A ( 3 , 3 ) * A ( 4 , 1 ))) & & + A ( 1 , 3 ) * ( A ( 2 , 1 ) * ( A ( 3 , 2 ) * A ( 4 , 4 ) - A ( 3 , 4 ) * A ( 4 , 2 )) & & + A ( 2 , 2 ) * ( A ( 3 , 4 ) * A ( 4 , 1 ) & & - A ( 3 , 1 ) * A ( 4 , 4 )) + A ( 2 , 4 ) * ( A ( 3 , 1 ) * A ( 4 , 2 ) - A ( 3 , 2 ) * A ( 4 , 1 ))) & & - A ( 1 , 4 ) * ( A ( 2 , 1 ) * ( A ( 3 , 2 ) * A ( 4 , 3 ) - A ( 3 , 3 ) * A ( 4 , 2 )) & & + A ( 2 , 2 ) * ( A ( 3 , 3 ) * A ( 4 , 1 ) - A ( 3 , 1 ) * A ( 4 , 3 )) & & + A ( 2 , 3 ) * ( A ( 3 , 1 ) * A ( 4 , 2 ) - A ( 3 , 2 ) * A ( 4 , 1 ))) END SELECT END FUNCTION det_2D !---------------------------------------------------------------------------- !                                                                        DET !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This FUNCTION returns the determinent of matrix PURE FUNCTION det_3D ( A ) RESULT ( Ans ) REAL ( DFP ), INTENT ( IN ) :: A ( :, :, : ) REAL ( DFP ), ALLOCATABLE :: Ans ( : ) INTEGER ( I4B ) :: i , n n = SIZE ( A , 3 ) ALLOCATE ( Ans ( n ) ) DO i = 1 , n Ans ( i ) = Det ( A ( :, :, i ) ) END DO END FUNCTION det_3D !---------------------------------------------------------------------------- !                                                                        Inv !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This subroutine returns inverse of 2 by 2 and 3 by 3 matrix PURE SUBROUTINE Inv_2D ( invA , A ) REAL ( DFP ), INTENT ( INOUT ) :: invA ( :, : ) REAL ( DFP ), INTENT ( IN ) :: A ( :, : ) !Define internal variables REAL ( DFP ) :: d , co ( 4 , 4 ) d = det ( A ) IF ( ABS ( d ) . LT . ZERO ) THEN invA = 0.0_DFP ELSE SELECT CASE ( SIZE ( A , 1 ) ) CASE ( 1 ) invA = 1.0 / d CASE ( 2 ) invA ( 1 , 1 ) = A ( 2 , 2 ) / d invA ( 1 , 2 ) = - A ( 1 , 2 ) / d invA ( 2 , 1 ) = - A ( 2 , 1 ) / d invA ( 2 , 2 ) = A ( 1 , 1 ) / d CASE ( 3 ) co ( 1 , 1 ) = ( A ( 2 , 2 ) * A ( 3 , 3 ) - A ( 2 , 3 ) * A ( 3 , 2 )) co ( 1 , 2 ) = - ( A ( 2 , 1 ) * A ( 3 , 3 ) - A ( 2 , 3 ) * A ( 3 , 1 )) co ( 1 , 3 ) = + ( A ( 2 , 1 ) * A ( 3 , 2 ) - A ( 2 , 2 ) * A ( 3 , 1 )) co ( 2 , 1 ) = - ( A ( 1 , 2 ) * A ( 3 , 3 ) - A ( 1 , 3 ) * A ( 3 , 2 )) co ( 2 , 2 ) = + ( A ( 1 , 1 ) * A ( 3 , 3 ) - A ( 1 , 3 ) * A ( 3 , 1 )) co ( 2 , 3 ) = - ( A ( 1 , 1 ) * A ( 3 , 2 ) - A ( 1 , 2 ) * A ( 3 , 1 )) co ( 3 , 1 ) = + ( A ( 1 , 2 ) * A ( 2 , 3 ) - A ( 1 , 3 ) * A ( 2 , 2 )) co ( 3 , 2 ) = - ( A ( 1 , 1 ) * A ( 2 , 3 ) - A ( 1 , 3 ) * A ( 2 , 1 )) co ( 3 , 3 ) = + ( A ( 1 , 1 ) * A ( 2 , 2 ) - A ( 1 , 2 ) * A ( 2 , 1 )) invA = TRANSPOSE ( co ( 1 : 3 , 1 : 3 ) ) / d CASE ( 4 ) co ( 1 , 1 ) = A ( 2 , 2 ) * ( A ( 3 , 3 ) * A ( 4 , 4 ) - A ( 3 , 4 ) * A ( 4 , 3 )) + & A ( 2 , 3 ) * ( A ( 3 , 4 ) * A ( 4 , 2 ) - A ( 3 , 2 ) * A ( 4 , 4 )) + & A ( 2 , 4 ) * ( A ( 3 , 2 ) * A ( 4 , 3 ) - A ( 3 , 3 ) * A ( 4 , 2 )) co ( 1 , 2 ) = A ( 2 , 1 ) * ( A ( 3 , 4 ) * A ( 4 , 3 ) - A ( 3 , 3 ) * A ( 4 , 4 )) + & A ( 2 , 3 ) * ( A ( 3 , 1 ) * A ( 4 , 4 ) - A ( 3 , 4 ) * A ( 4 , 1 )) + & A ( 2 , 4 ) * ( A ( 3 , 3 ) * A ( 4 , 1 ) - A ( 3 , 1 ) * A ( 4 , 3 )) co ( 1 , 3 ) = A ( 2 , 1 ) * ( A ( 3 , 2 ) * A ( 4 , 4 ) - A ( 3 , 4 ) * A ( 4 , 2 )) + & A ( 2 , 2 ) * ( A ( 3 , 4 ) * A ( 4 , 1 ) - A ( 3 , 1 ) * A ( 4 , 4 )) + & A ( 2 , 4 ) * ( A ( 3 , 1 ) * A ( 4 , 2 ) - A ( 3 , 2 ) * A ( 4 , 1 )) co ( 1 , 4 ) = A ( 2 , 1 ) * ( A ( 3 , 3 ) * A ( 4 , 2 ) - A ( 3 , 2 ) * A ( 4 , 3 )) + & A ( 2 , 2 ) * ( A ( 3 , 1 ) * A ( 4 , 3 ) - A ( 3 , 3 ) * A ( 4 , 1 )) + & A ( 2 , 3 ) * ( A ( 3 , 2 ) * A ( 4 , 1 ) - A ( 3 , 1 ) * A ( 4 , 2 )) co ( 2 , 1 ) = A ( 1 , 2 ) * ( A ( 3 , 4 ) * A ( 4 , 3 ) - A ( 3 , 3 ) * A ( 4 , 4 )) + & A ( 1 , 3 ) * ( A ( 3 , 2 ) * A ( 4 , 4 ) - A ( 3 , 4 ) * A ( 4 , 2 )) + & A ( 1 , 4 ) * ( A ( 3 , 3 ) * A ( 4 , 2 ) - A ( 3 , 2 ) * A ( 4 , 3 )) co ( 2 , 2 ) = A ( 1 , 1 ) * ( A ( 3 , 3 ) * A ( 4 , 4 ) - A ( 3 , 4 ) * A ( 4 , 3 )) + & A ( 1 , 3 ) * ( A ( 3 , 4 ) * A ( 4 , 1 ) - A ( 3 , 1 ) * A ( 4 , 4 )) + & A ( 1 , 4 ) * ( A ( 3 , 1 ) * A ( 4 , 3 ) - A ( 3 , 3 ) * A ( 4 , 1 )) co ( 2 , 3 ) = A ( 1 , 1 ) * ( A ( 3 , 4 ) * A ( 4 , 2 ) - A ( 3 , 2 ) * A ( 4 , 4 )) + & A ( 1 , 2 ) * ( A ( 3 , 1 ) * A ( 4 , 4 ) - A ( 3 , 4 ) * A ( 4 , 1 )) + & A ( 1 , 4 ) * ( A ( 3 , 2 ) * A ( 4 , 1 ) - A ( 3 , 1 ) * A ( 4 , 2 )) co ( 2 , 4 ) = A ( 1 , 1 ) * ( A ( 3 , 2 ) * A ( 4 , 3 ) - A ( 3 , 3 ) * A ( 4 , 2 )) + & A ( 1 , 2 ) * ( A ( 3 , 3 ) * A ( 4 , 1 ) - A ( 3 , 1 ) * A ( 4 , 3 )) + & A ( 1 , 3 ) * ( A ( 3 , 1 ) * A ( 4 , 2 ) - A ( 3 , 2 ) * A ( 4 , 1 )) co ( 3 , 1 ) = A ( 1 , 2 ) * ( A ( 2 , 3 ) * A ( 4 , 4 ) - A ( 2 , 4 ) * A ( 4 , 3 )) + & A ( 1 , 3 ) * ( A ( 2 , 4 ) * A ( 4 , 2 ) - A ( 2 , 2 ) * A ( 4 , 4 )) + & A ( 1 , 4 ) * ( A ( 2 , 2 ) * A ( 4 , 3 ) - A ( 2 , 3 ) * A ( 4 , 2 )) co ( 3 , 2 ) = A ( 1 , 1 ) * ( A ( 2 , 4 ) * A ( 4 , 3 ) - A ( 2 , 3 ) * A ( 4 , 4 )) + & A ( 1 , 3 ) * ( A ( 2 , 1 ) * A ( 4 , 4 ) - A ( 2 , 4 ) * A ( 4 , 1 )) + & A ( 1 , 4 ) * ( A ( 2 , 3 ) * A ( 4 , 1 ) - A ( 2 , 1 ) * A ( 4 , 3 )) co ( 3 , 3 ) = A ( 1 , 1 ) * ( A ( 2 , 2 ) * A ( 4 , 4 ) - A ( 2 , 4 ) * A ( 4 , 2 )) + & A ( 1 , 2 ) * ( A ( 2 , 4 ) * A ( 4 , 1 ) - A ( 2 , 1 ) * A ( 4 , 4 )) + & A ( 1 , 4 ) * ( A ( 2 , 1 ) * A ( 4 , 2 ) - A ( 2 , 2 ) * A ( 4 , 1 )) co ( 3 , 4 ) = A ( 1 , 1 ) * ( A ( 2 , 3 ) * A ( 4 , 2 ) - A ( 2 , 2 ) * A ( 4 , 3 )) + & A ( 1 , 2 ) * ( A ( 2 , 1 ) * A ( 4 , 3 ) - A ( 2 , 3 ) * A ( 4 , 1 )) + & A ( 1 , 3 ) * ( A ( 2 , 2 ) * A ( 4 , 1 ) - A ( 2 , 1 ) * A ( 4 , 2 )) co ( 4 , 1 ) = A ( 1 , 2 ) * ( A ( 2 , 4 ) * A ( 3 , 3 ) - A ( 2 , 3 ) * A ( 3 , 4 )) + & A ( 1 , 3 ) * ( A ( 2 , 2 ) * A ( 3 , 4 ) - A ( 2 , 4 ) * A ( 3 , 2 )) + & A ( 1 , 4 ) * ( A ( 2 , 3 ) * A ( 3 , 2 ) - A ( 2 , 2 ) * A ( 3 , 3 )) co ( 4 , 2 ) = A ( 1 , 1 ) * ( A ( 2 , 3 ) * A ( 3 , 4 ) - A ( 2 , 4 ) * A ( 3 , 3 )) + & A ( 1 , 3 ) * ( A ( 2 , 4 ) * A ( 3 , 1 ) - A ( 2 , 1 ) * A ( 3 , 4 )) + & A ( 1 , 4 ) * ( A ( 2 , 1 ) * A ( 3 , 3 ) - A ( 2 , 3 ) * A ( 3 , 1 )) co ( 4 , 3 ) = A ( 1 , 1 ) * ( A ( 2 , 4 ) * A ( 3 , 2 ) - A ( 2 , 2 ) * A ( 3 , 4 )) + & A ( 1 , 2 ) * ( A ( 2 , 1 ) * A ( 3 , 4 ) - A ( 2 , 4 ) * A ( 3 , 1 )) + & A ( 1 , 4 ) * ( A ( 2 , 2 ) * A ( 3 , 1 ) - A ( 2 , 1 ) * A ( 3 , 2 )) co ( 4 , 4 ) = A ( 1 , 1 ) * ( A ( 2 , 2 ) * A ( 3 , 3 ) - A ( 2 , 3 ) * A ( 3 , 2 )) + & A ( 1 , 2 ) * ( A ( 2 , 3 ) * A ( 3 , 1 ) - A ( 2 , 1 ) * A ( 3 , 3 )) + & A ( 1 , 3 ) * ( A ( 2 , 1 ) * A ( 3 , 2 ) - A ( 2 , 2 ) * A ( 3 , 1 )) invA = TRANSPOSE ( co ) / d END SELECT END IF END SUBROUTINE Inv_2D !---------------------------------------------------------------------------- !                                                                        Inv !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This subroutine returns inverse of 2 by 2 and 3 by 3 matrix PURE SUBROUTINE Inv_3D ( invA , A ) REAL ( DFP ), INTENT ( INOUT ) :: invA ( :, :, : ) REAL ( DFP ), INTENT ( IN ) :: A ( :, :, : ) ! define internal variables INTEGER ( I4B ) :: i , n n = SIZE ( A , 3 ) DO i = 1 , n CALL Inv ( invA = invA ( :, :, i ), A = A ( :, :, i ) ) END DO END SUBROUTINE Inv_3D !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- END MODULE Utility","tags":"","loc":"sourcefile/utility.f90.html"},{"title":"AbstractArray_Method.f90 – Fortran Program","text":"Contents Modules AbstractArray_Method Source Code AbstractArray_Method.f90 Source Code MODULE AbstractArray_Method USE GlobalData USE BaseType , ONLY : AbstractArray_ IMPLICIT NONE PRIVATE INTERFACE Size MODULE PROCEDURE get_size END INTERFACE Size PUBLIC :: Size INTERFACE Shape MODULE PROCEDURE get_shape END INTERFACE Shape PUBLIC :: Shape INTERFACE TotalDimension MODULE PROCEDURE get_tdimension END INTERFACE TotalDimension PUBLIC :: TotalDimension INTERFACE setTotalDimension MODULE PROCEDURE set_tdimension END INTERFACE setTotalDimension PUBLIC :: setTotalDimension CONTAINS !<--------------------------------------------------------------------->| ! !<--------------------------------------------------------------------->| PURE FUNCTION get_size ( Obj , Dims ) RESULT ( Ans ) TYPE ( AbstractArray_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: Dims INTEGER ( I4B ) :: Ans Ans = 0 END FUNCTION get_size !<--------------------------------------------------------------------->| ! !<--------------------------------------------------------------------->| PURE FUNCTION get_shape ( Obj ) RESULT ( Ans ) TYPE ( AbstractArray_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), ALLOCATABLE :: Ans ( : ) Ans = [ 0 ] END FUNCTION get_shape !<--------------------------------------------------------------------->| ! !<--------------------------------------------------------------------->| PURE FUNCTION get_tdimension ( Obj ) RESULT ( Ans ) CLASS ( AbstractArray_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ) :: Ans Ans = Obj % tDimension END FUNCTION get_tdimension !<--------------------------------------------------------------------->| ! !<--------------------------------------------------------------------->| PURE SUBROUTINE set_tdimension ( Obj , tDimension ) CLASS ( AbstractArray_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: tDimension Obj % tDimension = tDimension END SUBROUTINE set_tdimension END MODULE AbstractArray_Method","tags":"","loc":"sourcefile/abstractarray_method.f90.html"},{"title":"IO.f90 – Fortran Program","text":"Contents Modules IO Source Code IO.f90 Source Code MODULE IO USE GlobalData USE DISPMODULE USE H5Fortran USE BaseType , ONLY : FILE_ IMPLICIT NONE PRIVATE INTEGER ( I4B ), PARAMETER :: minRow = 4 , minCol = 4 PUBLIC :: Display , BlankLines , DashLine , DebugTag PUBLIC :: DotLine , EqualLine PUBLIC :: TIMESTAMP INTERFACE Display MODULE PROCEDURE & & Display_Str , & & Display_Str2 , & & Display_Real , & & Display_Int , & & Display_Logical , & & Display_Vector_Int , & & Display_Mat2_Real , & & Display_Mat2_Int , & & Display_Mat3_Real , & & Display_Mat4_Real END INTERFACE CONTAINS !---------------------------------------------------------------------------- !                                                                    Display !---------------------------------------------------------------------------- SUBROUTINE Display_Str ( msg , unitno ) CHARACTER ( LEN = * ), INTENT ( IN ) :: msg INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: unitno INTEGER ( I4B ) :: i if ( PRESENT ( unitno ) ) then i = unitno ELSE i = stdout END IF ! write( i, \"(A)\" ) TRIM( msg ) call disp ( title = '' , & & x = msg , & & FMT = 'a' , & & unit = i , & & style = 'left' ) END SUBROUTINE Display_Str !---------------------------------------------------------------------------- !                                                                    Display !---------------------------------------------------------------------------- SUBROUTINE Display_Str2 ( val , msg , unitno ) CHARACTER ( LEN = * ), INTENT ( IN ) :: val CHARACTER ( LEN = * ), INTENT ( IN ) :: msg INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: unitno INTEGER ( I4B ) :: i if ( PRESENT ( unitno ) ) then i = unitno ELSE i = stdout END IF call disp ( title = '' , & & x = trim ( msg ) // trim ( val ), & & FMT = 'a' , & & unit = i , & & style = 'left' ) END SUBROUTINE Display_Str2 !---------------------------------------------------------------------------- !                                                                    Display !---------------------------------------------------------------------------- SUBROUTINE Display_Real ( vec , msg , unitNo ) ! Define intent of dummy variables INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: unitNo REAL ( DFP ), INTENT ( IN ) :: vec CHARACTER ( LEN = * ), INTENT ( IN ) :: msg ! Define internal variables INTEGER ( I4B ) :: I ! I = stdout IF ( PRESENT ( unitNo ) ) I = unitNo call disp ( title = msg , x = vec , unit = I , style = 'left' ) END SUBROUTINE Display_Real !---------------------------------------------------------------------------- !                                                                    Display !---------------------------------------------------------------------------- SUBROUTINE Display_Int ( vec , msg , unitNo ) ! Define intent of dummy variables INTEGER ( I4B ), INTENT ( IN ) :: vec CHARACTER ( LEN = * ), INTENT ( IN ) :: msg INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: unitNo ! Define internal variables INTEGER ( I4B ) :: I I = stdout IF ( PRESENT ( unitNo ) ) I = unitNo call disp ( title = msg , x = vec , unit = I , style = 'left' ) END SUBROUTINE Display_Int !---------------------------------------------------------------------------- !                                                                    Display !---------------------------------------------------------------------------- SUBROUTINE Display_Logical ( vec , msg , unitNo ) ! Define intent of dummy variables INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: unitNo LOGICAL ( LGT ), INTENT ( IN ) :: vec CHARACTER ( LEN = * ), INTENT ( IN ) :: msg ! Define internal variables INTEGER ( I4B ) :: I ! I = stdout IF ( PRESENT ( unitNo ) ) I = unitNo call disp ( title = msg , x = vec , unit = I , style = 'left' ) END SUBROUTINE Display_Logical !---------------------------------------------------------------------------- !                                                                    Display !---------------------------------------------------------------------------- SUBROUTINE Display_Vector_Int ( vec , msg , unitNo , full ) ! Define intent of dummy variables INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: unitNo INTEGER ( I4B ), DIMENSION ( : ), INTENT ( IN ) :: vec CHARACTER ( LEN = * ), INTENT ( IN ) :: msg LOGICAL ( LGT ), INTENT ( IN ), OPTIONAL :: full ! Define internal variables INTEGER ( I4B ) :: I ! INTEGER( I4B ) :: I, j, n ! CHARACTER( LEN = 120 ) :: fmt I = stdout IF ( PRESENT ( unitNo ) ) I = unitNo IF ( LBOUND ( vec , 1 ) . EQ . 1 ) THEN call disp ( title = msg , & & x = vec , & & unit = I , & & style = 'underline & pad' , & & orient = 'row' ) ELSE call disp ( title = msg , & & x = vec , & & unit = I , & & style = 'underline & pad' , & & sep = ' ---> ' , & & lbound = LBOUND ( Vec ) ) END IF END SUBROUTINE Display_Vector_Int !---------------------------------------------------------------------------- !                                                                    Display !---------------------------------------------------------------------------- SUBROUTINE Display_Mat2_Real ( Mat , msg , unitNo , full ) !   Define intent of dummy variables INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: unitNo REAL ( DFP ), DIMENSION ( :, : ), INTENT ( IN ) :: Mat CHARACTER ( LEN = * ), INTENT ( IN ) :: msg LOGICAL ( LGT ), INTENT ( IN ), OPTIONAL :: full !   Define internal variables INTEGER ( I4B ) :: I , j , r ! I = stdout IF ( PRESENT ( unitNo ) ) I = unitNo call disp ( title = msg , & & x = mat , & & unit = I , & & style = 'underline & pad' , & & sep = ', ' , & & advance = 'double' ) ! IF( LEN_TRIM( msg ) .NE. 0 ) THEN !   WRITE( I, \"(A)\" ) TRIM( msg ) ! END IF ! ! ! r = SIZE( Mat, 1 ) ! IF( I .EQ. stdout ) THEN !   IF( PRESENT( full ) ) THEN !     DO j = 1, r !       CALL Display( Mat( j, : ), \"\", I, full ) !     END DO !   ELSE !     IF( r .LE. 10 ) THEN !       DO j = 1, r !         CALL Display( Mat( j, : ), \"\", I ) !       END DO !     ELSE !       DO j = 1, minRow !         CALL Display( Mat( j, : ), \"\", I ) !       END DO !       WRITE( I, \"(A)\") \".\" !       WRITE( I, \"(A)\") \".\" !       WRITE( I, \"(A)\") \".\" !       DO j = r, r-minRow, -1 !         CALL Display( Mat( j, : ), \"\", I ) !       END DO !     END IF !   END IF ! ELSE !   DO j = 1, r !     CALL Display( Mat( j, : ), \"\", I ) !   END DO ! END IF END SUBROUTINE Display_Mat2_Real !---------------------------------------------------------------------------- !                                                                    Display !---------------------------------------------------------------------------- SUBROUTINE Display_Mat2_Int ( Mat , msg , unitNo , full ) !   Define intent of dummy variables INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: unitNo INTEGER ( I4B ), INTENT ( IN ) :: Mat ( :, : ) CHARACTER ( LEN = * ), INTENT ( IN ) :: msg LOGICAL ( LGT ), INTENT ( IN ), OPTIONAL :: full !   Define internal variables INTEGER ( I4B ) :: I , j , r ! I = stdout IF ( PRESENT ( unitNo ) ) I = unitNo call disp ( title = msg , & & x = mat , & & unit = I , & & style = 'underline & pad' , & & sep = ', ' , & & advance = 'double' ) ! IF( LEN_TRIM( msg ) .NE. 0 ) THEN !   WRITE( I, \"(A)\" ) TRIM( msg ) ! END IF ! ! ! r = SIZE( Mat, 1 ) ! IF( I .EQ. stdout ) THEN !   IF( PRESENT( full ) ) THEN !     DO j = 1, r !       CALL Display( Mat( j, : ), \"\", I, full ) !     END DO !   ELSE !     IF( r .LE. 10 ) THEN !       DO j = 1, r !         CALL Display( Mat( j, : ), \"\", I ) !       END DO !     ELSE !       DO j = 1, minRow !         CALL Display( Mat( j, : ), \"\", I ) !       END DO !       WRITE( I, \"(A)\") \".\" !       WRITE( I, \"(A)\") \".\" !       WRITE( I, \"(A)\") \".\" !       DO j = r, r-minRow, -1 !         CALL Display( Mat( j, : ), \"\", I ) !       END DO !     END IF !   END IF ! ELSE !   DO j = 1, r !     CALL Display( Mat( j, : ), \"\", I ) !   END DO ! END IF END SUBROUTINE Display_Mat2_Int !---------------------------------------------------------------------------- !                                                                    Display !---------------------------------------------------------------------------- SUBROUTINE Display_Mat3_Real ( Mat , msg , unitNo ) !   Define intent of dummy variables INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: unitNo REAL ( DFP ), INTENT ( IN ) :: Mat ( :, :, : ) CHARACTER ( LEN = * ), INTENT ( IN ) :: msg !   Define internal variables INTEGER ( I4B ) :: I , J ! I = stdout IF ( PRESENT ( unitNo ) ) I = unitNo ! DO J = 1 , SIZE ( Mat , 3 ) CALL Display ( Mat ( :, :, J ), & & TRIM ( msg ) // \"( :, :, \" // TRIM ( Int2Str ( J ) ) // \" )\" , I ) END DO END SUBROUTINE Display_Mat3_Real !---------------------------------------------------------------------------- !                                                                    Display !---------------------------------------------------------------------------- SUBROUTINE Display_Mat4_Real ( Mat , msg , unitNo ) !   Define intent of dummy variables INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: unitNo REAL ( DFP ), INTENT ( IN ) :: Mat ( :, :, :, : ) CHARACTER ( LEN = * ), INTENT ( IN ) :: msg !   Define internal variables INTEGER ( I4B ) :: I , J , K ! I = stdout IF ( PRESENT ( unitNo ) ) I = unitNo ! DO K = 1 , SIZE ( Mat , 4 ) DO J = 1 , SIZE ( Mat , 3 ) CALL Display ( Mat ( :, :, J , K ), & & TRIM ( msg ) & & // \"( :, :, \" & & // TRIM ( Int2Str ( J ) ) & & // \", \" & & // TRIM ( Int2Str ( K ) ) & & // \" )\" & & , I ) END DO END DO END SUBROUTINE Display_Mat4_Real !------------------------------------------------------------------------------ !                                                                       Int2Str !------------------------------------------------------------------------------ ! FUNCTION Int2Str ( I ) ! Define intent of dummy arguments INTEGER ( I4B ), INTENT ( IN ) :: I CHARACTER ( LEN = 15 ) :: Int2Str ! Define internal variables CHARACTER ( LEN = 15 ) :: Str WRITE ( Str , \"(I15)\" ) I Int2Str = TRIM ( ADJUSTL ( Str ) ) END FUNCTION Int2Str !------------------------------------------------------------------------------ ! !------------------------------------------------------------------------------ SUBROUTINE DebugTag ( Tag , unitNo ) ! INTENT OF DUMMY VARIABLES INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: Tag , unitNo ! Define internal variables INTEGER ( I4B ) :: M = 1 IF ( PRESENT ( Tag ) ) M = Tag IF ( PRESENT ( unitNo ) ) THEN WRITE ( unitNo , \"(A,I4)\" ) \"**Debug**\" , M ELSE WRITE ( stdout , \"(A,I4)\" ) \"**Debug**\" , M END IF END SUBROUTINE DebugTag !------------------------------------------------------------------------------ ! !------------------------------------------------------------------------------ SUBROUTINE BlankLines ( unitNo , NOL ) ! INTENT OF DUMMY VARIABLES INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: NOL , unitNo ! Define internal variables INTEGER ( I4B ) :: M = 1 , I IF ( PRESENT ( NOL ) ) M = NOL IF ( PRESENT ( unitNo ) ) THEN DO I = 1 , M WRITE ( unitNo , \"(A)\" ) \"\" END DO ELSE DO I = 1 , M WRITE ( stdout , * ) \"\" END DO END IF END SUBROUTINE BlankLines !------------------------------------------------------------------------------ ! !------------------------------------------------------------------------------ SUBROUTINE DashLine ( unitNo ) ! INTENT OF DUMMY VARIABLES INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: unitNo IF ( PRESENT ( unitNo ) ) THEN WRITE ( unitNo , \"(A)\" ) \"-------------------------------------------------\" ELSE WRITE ( stdout , \"(A)\" ) \"-------------------------------------------------\" END IF END SUBROUTINE DashLine !------------------------------------------------------------------------------ ! !------------------------------------------------------------------------------ SUBROUTINE DotLine ( unitNo ) ! INTENT OF DUMMY VARIABLES INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: unitNo IF ( PRESENT ( unitNo ) ) THEN WRITE ( unitNo , \"(A)\" ) \".................................................\" ELSE WRITE ( stdout , \"(A)\" ) \".................................................\" END IF END SUBROUTINE DotLine !------------------------------------------------------------------------------ ! !------------------------------------------------------------------------------ SUBROUTINE EqualLine ( unitNo ) ! INTENT OF DUMMY VARIABLES INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: unitNo IF ( PRESENT ( unitNo ) ) THEN WRITE ( unitNo , \"(A)\" ) \"=================================================\" ELSE WRITE ( stdout , \"(A)\" ) \"=================================================\" END IF END SUBROUTINE EqualLine !------------------------------------------------------------------------------ ! !------------------------------------------------------------------------------ ! SUBROUTINE TIMESTAMP ( ) ! Define Intent of dummy Variable CHARACTER ( LEN = 8 ) :: ampm INTEGER ( I4B ) :: d INTEGER ( I4B ) :: h INTEGER ( I4B ) :: m INTEGER ( I4B ) :: mm CHARACTER ( LEN = 9 ), PARAMETER , DIMENSION ( 12 ) :: month = ( / & 'January  ' , 'February ' , 'March    ' , 'April    ' , & 'May      ' , 'June     ' , 'July     ' , 'August   ' , & 'September' , 'October  ' , 'November ' , 'December ' / ) INTEGER ( I4B ) :: n INTEGER ( I4B ) :: s INTEGER ( I4B ) :: values ( 8 ) INTEGER ( I4B ) :: y CALL date_and_time ( values = values ) y = values ( 1 ) m = values ( 2 ) d = values ( 3 ) h = values ( 5 ) n = values ( 6 ) s = values ( 7 ) mm = values ( 8 ) IF ( h < 12 ) THEN ampm = 'AM' ELSE IF ( h == 12 ) THEN IF ( n == 0 . and . s == 0 ) THEN ampm = 'Noon' ELSE ampm = 'PM' END IF ELSE h = h - 12 IF ( h < 12 ) THEN ampm = 'PM' ELSE IF ( h == 12 ) THEN IF ( n == 0 . and . s == 0 ) THEN ampm = 'Midnight' ELSE ampm = 'AM' END IF END IF END IF WRITE ( * , '(8x, i2,1x,a,1x,i4,2x,i2,a1,i2.2,a1,i2.2,a1,i3.3,1x,a)' ) & d , TRIM ( month ( m ) ), y , h , ':' , n , ':' , s , '.' , mm , TRIM ( ampm ) END SUBROUTINE TIMESTAMP !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- !> authors: Dr. Vikas Sharma ! ! This subroutine run a system commoand on terminal SUBROUTINE ExecuteCommand ( CMD , Str ) CHARACTER ( LEN = * ), INTENT ( IN ) :: CMD , Str ! Define internal variables INTEGER ( I4B ) :: CMDSTAT , EXITSTAT LOGICAL ( LGT ) :: WAIT = . TRUE . CHARACTER ( LEN = 300 ) :: CMDMSG = \"\" CALL EXECUTE_COMMAND_LINE ( TRIM ( CMD ), CMDSTAT = CMDSTAT , & & EXITSTAT = EXITSTAT , & WAIT = WAIT , CMDMSG = CMDMSG ) IF ( CMDSTAT . NE . 0 ) THEN IF ( CMDSTAT . EQ . - 1 ) THEN STOP END IF STOP END IF END SUBROUTINE ExecuteCommand END MODULE IO","tags":"","loc":"sourcefile/io.f90.html"},{"title":"QuadraturePoint_Method.f90 – Fortran Program","text":"Contents Modules QuadraturePoint_Method Source Code QuadraturePoint_Method.f90 Source Code MODULE QuadraturePoint_Method USE BaseType USE GlobalData IMPLICIT NONE PRIVATE !---------------------------------------------------------------------------- !                                                       Initiate@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE initiate_obj ( Obj , Points ) CLASS ( QuadraturePoint_ ), INTENT ( INOUT ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Points ( :, : ) END SUBROUTINE initiate_obj END INTERFACE INTERFACE MODULE PURE SUBROUTINE initiate_obj_txi ( Obj , tXi , tPoints ) CLASS ( QuadraturePoint_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: tXi , tPoints END SUBROUTINE initiate_obj_txi END INTERFACE INTERFACE Initiate MODULE PROCEDURE initiate_obj , initiate_obj_txi END INTERFACE PUBLIC :: Initiate !---------------------------------------------------------------------------- !                                                QuadraturePoint@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION Constructor_1 ( Points ) RESULT ( Obj ) CLASS ( QuadraturePoint_ ), POINTER :: Obj REAL ( DFP ), INTENT ( IN ) :: Points ( :, : ) END FUNCTION Constructor_1 MODULE PURE FUNCTION Constructor1 ( Points ) RESULT ( Obj ) TYPE ( QuadraturePoint_ ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Points ( :, : ) END FUNCTION Constructor1 END INTERFACE INTERFACE QuadraturePoint MODULE PROCEDURE Constructor1 END INTERFACE QuadraturePoint INTERFACE QuadraturePoint_Pointer MODULE PROCEDURE Constructor_1 END INTERFACE QuadraturePoint_Pointer PUBLIC :: QuadraturePoint , QuadraturePoint_Pointer !---------------------------------------------------------------------------- !                                                 DeallocateData@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE deallocate_data ( Obj ) CLASS ( QuadraturePoint_ ), INTENT ( INOUT ) :: Obj END SUBROUTINE deallocate_data END INTERFACE INTERFACE DeallocateData MODULE PROCEDURE deallocate_data END INTERFACE DeallocateData PUBLIC :: DeallocateData !---------------------------------------------------------------------------- !                                                           SIZE@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION size_obj ( Obj , dims ) RESULT ( Ans ) CLASS ( QuadraturePoint_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: dims INTEGER ( I4B ) :: Ans END FUNCTION size_obj END INTERFACE INTERFACE SIZE MODULE PROCEDURE size_obj END INTERFACE SIZE PUBLIC :: SIZE !---------------------------------------------------------------------------- !                                                        Display@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE display_obj ( Obj , msg , unitno ) CLASS ( QuadraturePoint_ ), INTENT ( IN ) :: Obj CHARACTER ( LEN = * ), INTENT ( IN ) :: msg INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: unitno END SUBROUTINE display_obj END INTERFACE INTERFACE Display MODULE PROCEDURE display_obj END INTERFACE Display PUBLIC :: Display !---------------------------------------------------------------------------- !                                             GetQuadraturePoint@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE getQP1 ( Obj , Point , Weight , Num ) CLASS ( QuadraturePoint_ ), INTENT ( IN ) :: Obj REAL ( DFP ), INTENT ( INOUT ) :: Point ( 3 ) REAL ( DFP ), INTENT ( INOUT ) :: Weight INTEGER ( I4B ), INTENT ( IN ) :: Num END SUBROUTINE getQP1 MODULE PURE SUBROUTINE getQP2 ( Obj , Point , Weight ) CLASS ( QuadraturePoint_ ), INTENT ( IN ) :: Obj REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: Point ( :, : ) REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: Weight ( : ) END SUBROUTINE getQP2 END INTERFACE INTERFACE GetQuadraturePoints MODULE PROCEDURE getQP1 , getQP2 END INTERFACE PUBLIC :: GetQuadraturePoints !---------------------------------------------------------------------------- !                                      GaussLegendreQuadrature@GaussLegendre !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION getGaussLegendreQP1 ( RefElem , Order ) RESULT ( Obj ) INTEGER ( I4B ), INTENT ( IN ) :: Order CLASS ( ReferenceElement_ ), INTENT ( IN ) :: RefElem TYPE ( QuadraturePoint_ ) :: Obj END FUNCTION getGaussLegendreQP1 MODULE PURE FUNCTION getGaussLegendreQP2 ( RefElem , NIPS ) RESULT ( Obj ) INTEGER ( I4B ), INTENT ( IN ) :: NIPS ( 1 ) CLASS ( ReferenceElement_ ), INTENT ( IN ) :: RefElem TYPE ( QuadraturePoint_ ) :: Obj END FUNCTION getGaussLegendreQP2 END INTERFACE INTERFACE GaussLegendreQuadrature MODULE PROCEDURE getGaussLegendreQP1 , getGaussLegendreQP2 END INTERFACE GaussLegendreQuadrature PUBLIC :: GaussLegendreQuadrature !---------------------------------------------------------------------------- !                                                GaussLegendre@GaussLegendre !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION getGaussLegendreQPLine1 ( RefElem , Order ) RESULT ( Obj ) INTEGER ( I4B ), INTENT ( IN ) :: Order TYPE ( ReferenceLine_ ), INTENT ( IN ) :: RefElem TYPE ( QuadraturePoint_ ) :: Obj END FUNCTION getGaussLegendreQPLine1 MODULE PURE FUNCTION getGaussLegendreQPLine2 ( RefElem , NIPS ) RESULT ( Obj ) INTEGER ( I4B ), INTENT ( IN ) :: NIPS ( 1 ) TYPE ( ReferenceLine_ ), INTENT ( IN ) :: RefElem TYPE ( QuadraturePoint_ ) :: Obj END FUNCTION getGaussLegendreQPLine2 END INTERFACE ! INTERFACE GaussLegendreQuadrature !   MODULE PROCEDURE getGaussLegendreQPLine1, getGaussLegendreQPLine2 ! END INTERFACE GaussLegendreQuadrature ! PUBLIC :: GaussLegendreQuadrature !---------------------------------------------------------------------------- !                                                GaussLegendre@GaussLegendre !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION getGaussLegendreQPTriangle1 ( RefElem , Order ) RESULT ( Obj ) INTEGER ( I4B ), INTENT ( IN ) :: Order TYPE ( ReferenceTriangle_ ), INTENT ( IN ) :: RefElem TYPE ( QuadraturePoint_ ) :: Obj END FUNCTION getGaussLegendreQPTriangle1 MODULE PURE FUNCTION getGaussLegendreQPTriangle2 ( RefElem , NIPS ) RESULT ( Obj ) INTEGER ( I4B ), INTENT ( IN ) :: NIPS ( 1 ) TYPE ( ReferenceTriangle_ ), INTENT ( IN ) :: RefElem TYPE ( QuadraturePoint_ ) :: Obj END FUNCTION getGaussLegendreQPTriangle2 END INTERFACE ! INTERFACE GaussLegendreQuadrature !   MODULE PROCEDURE getGaussLegendreQPTriangle1, getGaussLegendreQPTriangle2 ! END INTERFACE GaussLegendreQuadrature !---------------------------------------------------------------------------- !                                                GaussLegendre@GaussLegendre !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION getGaussLegendreQPQuadrangle1 ( RefElem , Order ) RESULT ( Obj ) INTEGER ( I4B ), INTENT ( IN ) :: Order TYPE ( ReferenceQuadrangle_ ), INTENT ( IN ) :: RefElem TYPE ( QuadraturePoint_ ) :: Obj END FUNCTION getGaussLegendreQPQuadrangle1 MODULE PURE FUNCTION getGaussLegendreQPQuadrangle2 ( RefElem , NIPS ) RESULT ( Obj ) INTEGER ( I4B ), INTENT ( IN ) :: NIPS ( 1 ) TYPE ( ReferenceQuadrangle_ ), INTENT ( IN ) :: RefElem TYPE ( QuadraturePoint_ ) :: Obj END FUNCTION getGaussLegendreQPQuadrangle2 END INTERFACE ! INTERFACE GaussLegendreQuadrature !   MODULE PROCEDURE getGaussLegendreQPQuadrangle1, getGaussLegendreQPQuadrangle2 ! END INTERFACE GaussLegendreQuadrature !---------------------------------------------------------------------------- !                                                GaussLegendre@GaussLegendre !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION getGaussLegendreQPTetrahedron1 ( RefElem , Order ) RESULT ( Obj ) INTEGER ( I4B ), INTENT ( IN ) :: Order TYPE ( ReferenceTetrahedron_ ), INTENT ( IN ) :: RefElem TYPE ( QuadraturePoint_ ) :: Obj END FUNCTION getGaussLegendreQPTetrahedron1 MODULE PURE FUNCTION getGaussLegendreQPTetrahedron2 ( RefElem , NIPS ) RESULT ( Obj ) INTEGER ( I4B ), INTENT ( IN ) :: NIPS ( 1 ) TYPE ( ReferenceTetrahedron_ ), INTENT ( IN ) :: RefElem TYPE ( QuadraturePoint_ ) :: Obj END FUNCTION getGaussLegendreQPTetrahedron2 END INTERFACE ! INTERFACE GaussLegendreQuadrature !   MODULE PROCEDURE getGaussLegendreQPTetrahedron1, getGaussLegendreQPTetrahedron2 ! END INTERFACE GaussLegendreQuadrature !---------------------------------------------------------------------------- !                                                GaussLegendre@GaussLegendre !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION getGaussLegendreQPPyramid1 ( RefElem , Order ) RESULT ( Obj ) INTEGER ( I4B ), INTENT ( IN ) :: Order TYPE ( ReferencePyramid_ ), INTENT ( IN ) :: RefElem TYPE ( QuadraturePoint_ ) :: Obj END FUNCTION getGaussLegendreQPPyramid1 MODULE PURE FUNCTION getGaussLegendreQPPyramid2 ( RefElem , NIPS ) RESULT ( Obj ) INTEGER ( I4B ), INTENT ( IN ) :: NIPS ( 1 ) TYPE ( ReferencePyramid_ ), INTENT ( IN ) :: RefElem TYPE ( QuadraturePoint_ ) :: Obj END FUNCTION getGaussLegendreQPPyramid2 END INTERFACE ! INTERFACE GaussLegendreQuadrature !   MODULE PROCEDURE getGaussLegendreQPPyramid1, getGaussLegendreQPPyramid2 ! END INTERFACE GaussLegendreQuadrature !---------------------------------------------------------------------------- !                                                GaussLegendre@GaussLegendre !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION getGaussLegendreQPPrism1 ( RefElem , Order ) RESULT ( Obj ) INTEGER ( I4B ), INTENT ( IN ) :: Order TYPE ( ReferencePrism_ ), INTENT ( IN ) :: RefElem TYPE ( QuadraturePoint_ ) :: Obj END FUNCTION getGaussLegendreQPPrism1 MODULE PURE FUNCTION getGaussLegendreQPPrism2 ( RefElem , NIPS ) RESULT ( Obj ) INTEGER ( I4B ), INTENT ( IN ) :: NIPS ( 1 ) TYPE ( ReferencePrism_ ), INTENT ( IN ) :: RefElem TYPE ( QuadraturePoint_ ) :: Obj END FUNCTION getGaussLegendreQPPrism2 END INTERFACE ! INTERFACE GaussLegendreQuadrature !   MODULE PROCEDURE getGaussLegendreQPPrism1, getGaussLegendreQPPrism2 ! END INTERFACE GaussLegendreQuadrature !---------------------------------------------------------------------------- !                                                GaussLegendre@GaussLegendre !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION getGaussLegendreQPHexahedron1 ( RefElem , Order ) & & RESULT ( Obj ) INTEGER ( I4B ), INTENT ( IN ) :: Order TYPE ( ReferenceHexahedron_ ), INTENT ( IN ) :: RefElem TYPE ( QuadraturePoint_ ) :: Obj END FUNCTION getGaussLegendreQPHexahedron1 MODULE PURE FUNCTION getGaussLegendreQPHexahedron2 ( RefElem , NIPS ) & & RESULT ( Obj ) INTEGER ( I4B ), INTENT ( IN ) :: NIPS ( 1 ) TYPE ( ReferenceHexahedron_ ), INTENT ( IN ) :: RefElem TYPE ( QuadraturePoint_ ) :: Obj END FUNCTION getGaussLegendreQPHexahedron2 END INTERFACE ! INTERFACE GaussLegendreQuadrature !   MODULE PROCEDURE getGaussLegendreQPHexahedron1, getGaussLegendreQPHexahedron2 ! END INTERFACE GaussLegendreQuadrature !---------------------------------------------------------------------------- !                                                                  Contains !---------------------------------------------------------------------------- #include \"./contains.part\" END MODULE QuadraturePoint_Method","tags":"","loc":"sourcefile/quadraturepoint_method.f90.html"},{"title":"DOF_Method.f90 – Fortran Program","text":"Contents Modules DOF_Method Source Code DOF_Method.f90 Source Code MODULE DOF_Method USE GlobalData USE BaseType IMPLICIT NONE PRIVATE !---------------------------------------------------------------------------- !                                                       Initiate@Constructor !---------------------------------------------------------------------------- INTERFACE !! Initiate [[DOF_]] object !> authors: Dr. Vikas Sharma ! ! This subroutine initiate [[DOF_]] object ! ! - If size of all dof are same then set tNodes = [tNodes] otherwise !   we need to provide length of all dofs ! - If a dof is scalar, such as pressure, temperature etc., then set ! its spaceCompo to -1. ! - For a time independent dof set `TimeCompo=1`. ! - The size of `Names`, `SpaceCompo`, `TimeCompo` should be same ! ! @note ! \t$\\matbf{v}$ is a physical variable, however, !   its component $v_1, v_2, v_3$ all are degrees of freedom. ! @endnote ! !### Usage ! ! ```fortran !\ttype( dof_ ) :: obj ! call initiate( obj, tNodes = [10], Names = ['x', 'y'], & !   & SpaceCompo = [3,3], TimeCompo = [1,1], StorageFMT = FMT_Nodes ) ! ``` MODULE PURE SUBROUTINE initiate_st_dof ( Obj , tNodes , Names , SpaceCompo , & & TimeCompo , StorageFMT ) CLASS ( DOF_ ), INTENT ( INOUT ) :: Obj !! degree of freedom object INTEGER ( I4B ), INTENT ( IN ) :: tNodes ( : ) !! number of nodes for each physical variable INTEGER ( I4B ), INTENT ( IN ) :: SpaceCompo ( : ) !! Space component of each physical variable INTEGER ( I4B ), INTENT ( IN ) :: TimeCompo ( : ) !! Time component of each physical variable INTEGER ( I4B ), INTENT ( IN ) :: StorageFMT !! Storage format `FMT_DOF`, `FMT_Nodes` CHARACTER ( LEN = 1 ), INTENT ( IN ) :: Names ( : ) !! Names of each physical variable END SUBROUTINE initiate_st_dof END INTERFACE INTERFACE !! Initiate a fortran vector using [[dof_]] object !> authors: Dr. Vikas Sharma ! ! This subroutine initiate a fortran vector using information stored inside ! [[dof_]] object MODULE PURE SUBROUTINE initiate_val ( Val , Obj ) REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: Val ( : ) CLASS ( DOF_ ), INTENT ( IN ) :: Obj END SUBROUTINE initiate_val END INTERFACE INTERFACE !! Initiate [[RealVector_]] using [[dof_]] object !> authors: Dr. Vikas Sharma ! ! This subroutine initiate [[RealVector_]] using information stored inside ! [[dof_]] object MODULE PURE SUBROUTINE initiate_realvector_scalar ( Val , Obj ) CLASS ( RealVector_ ), INTENT ( INOUT ) :: Val CLASS ( DOF_ ), INTENT ( IN ) :: Obj END SUBROUTINE initiate_realvector_scalar END INTERFACE INTERFACE !! Initiate a vector of [[realvector_]] from [[dof_]] object !> authors: Dr. Vikas Sharma ! ! This subroutine initiate a vector of [[realvector_]] object ! Each entry Val( idof ) denotes degree of freedom `idof` MODULE PURE SUBROUTINE initiate_realvector_vector ( Val , Obj ) TYPE ( RealVector_ ), ALLOCATABLE , INTENT ( INOUT ) :: Val ( : ) CLASS ( DOF_ ), INTENT ( IN ) :: Obj END SUBROUTINE initiate_realvector_vector END INTERFACE INTERFACE !! Initiate two fortran vectors using [[dof_]] object !> authors: Dr. Vikas Sharma ! ! This subroutine initiate two fortran vectors using  the information ! stored inside the [[dof_]] object MODULE PURE SUBROUTINE initiate_2val ( Val1 , Val2 , Obj ) REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: Val1 ( : ), Val2 ( : ) CLASS ( DOF_ ), INTENT ( IN ) :: Obj END SUBROUTINE initiate_2val END INTERFACE !> Generic interface to initiate Fortran vectors or [[realvectors_]] from ! [[dof_]] object INTERFACE Initiate MODULE PROCEDURE initiate_st_dof , initiate_val , & & initiate_realvector_scalar , & & initiate_realvector_vector , & & initiate_2val END INTERFACE Initiate PUBLIC :: Initiate !---------------------------------------------------------------------------- !                                                            DOF@Constructor !---------------------------------------------------------------------------- INTERFACE !! Constructor for [[dof_]] object !> authors: Dr. Vikas Sharma ! ! This function return instance of [[dof_]] ! for more see [[dof_:initiate]] MODULE PURE FUNCTION Constructor1 ( tNodes , Names , SpaceCompo , TimeCompo , & & StorageFMT ) RESULT ( Obj ) TYPE ( DOF_ ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: tNodes ( : ), SpaceCompo ( : ), & & TimeCompo ( : ), StorageFMT CHARACTER ( LEN = 1 ), INTENT ( IN ) :: Names ( : ) END FUNCTION Constructor1 END INTERFACE !> Generic function to construct [[dof_]] object INTERFACE DOF MODULE PROCEDURE Constructor1 END INTERFACE DOF PUBLIC :: DOF !---------------------------------------------------------------------------- !                                                     DOF_Pointer@Constructor !---------------------------------------------------------------------------- !> Generic interface to get pointer to instance of [[dof_]] object INTERFACE DOF_Pointer MODULE PROCEDURE Constructor_1 END INTERFACE DOF_Pointer PUBLIC :: DOF_Pointer !---------------------------------------------------------------------------- !                                                 DeallocateData@Constructor !---------------------------------------------------------------------------- INTERFACE !! Deallocate data in [[dof_]] !> authors: Dr. Vikas Sharma ! ! This subroutine deallocates the data in [[dof_]] object MODULE PURE SUBROUTINE deallocate_data ( Obj ) CLASS ( DOF_ ), INTENT ( INOUT ) :: Obj END SUBROUTINE deallocate_data END INTERFACE !> Generic interface to deallocate data in [[dof_]] INTERFACE DeallocateData MODULE PROCEDURE deallocate_data END INTERFACE DeallocateData PUBLIC :: DeallocateData !---------------------------------------------------------------------------- !                                                        Display@Constructor !---------------------------------------------------------------------------- INTERFACE !! Display content of [[dof_]] !> authors: Dr. Vikas Sharma ! ! This subroutine display the content of [[dof_]] object MODULE SUBROUTINE display_obj ( Obj , msg , UnitNo ) CLASS ( DOF_ ), INTENT ( IN ) :: Obj CHARACTER ( LEN = * ), INTENT ( IN ) :: msg INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: UnitNo END SUBROUTINE display_obj END INTERFACE INTERFACE !! Display content of fortran vec with [[DOF_]] object info MODULE SUBROUTINE dof_display_vec ( Vec , Obj , msg , unitno ) REAL ( DFP ), INTENT ( IN ) :: Vec ( : ) CLASS ( DOF_ ), INTENT ( IN ) :: Obj CHARACTER ( LEN = * ), INTENT ( IN ) :: msg INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: unitno END SUBROUTINE dof_display_vec END INTERFACE !> Generic subroutine to displacy content of [[dof_]] INTERFACE Display MODULE PROCEDURE display_obj , dof_display_vec END INTERFACE Display PUBLIC :: Display !---------------------------------------------------------------------------- !                                                            tNodes@getMethod !---------------------------------------------------------------------------- INTERFACE !! This function returns the total number of nodes !> authors: Dr. Vikas Sharma ! !  This function returns the total length of the vector which stores the ! dof stored inside `obj`. MODULE PURE FUNCTION get_tNodes ( Obj ) RESULT ( Ans ) CLASS ( DOF_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ) :: Ans END FUNCTION get_tNodes END INTERFACE INTERFACE OPERATOR ( . tNodes . ) MODULE PROCEDURE get_tNodes END INTERFACE PUBLIC :: OPERATOR ( . tNodes . ) INTERFACE SIZE MODULE PROCEDURE get_tNodes END INTERFACE SIZE PUBLIC :: SIZE !---------------------------------------------------------------------------- !                                                           tNodes@getMethod !---------------------------------------------------------------------------- INTERFACE !! This function returns the total number of nodes !> authors: Dr. Vikas Sharma ! ! This subroutine returns the size of a given degree of freedom MODULE PURE FUNCTION get_tNodes_idof ( Obj , idof ) RESULT ( Ans ) CLASS ( DOF_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: idof INTEGER ( I4B ) :: Ans END FUNCTION get_tNodes_idof END INTERFACE INTERFACE OPERATOR ( . tNodes . ) MODULE PROCEDURE get_tNodes_idof END INTERFACE INTERFACE SIZE MODULE PROCEDURE get_tNodes_idof END INTERFACE SIZE !---------------------------------------------------------------------------- !                                                             tDOF@getMethod !---------------------------------------------------------------------------- INTERFACE !! This function returns the total number of degree of freedom !> authors: Dr. Vikas Sharma ! ! This function returns the total dof MODULE PURE FUNCTION get_tDOF ( Obj ) RESULT ( Ans ) CLASS ( DOF_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ) :: Ans END FUNCTION get_tDOF END INTERFACE INTERFACE OPERATOR ( . tDOF . ) MODULE PROCEDURE get_tDOF END INTERFACE PUBLIC :: OPERATOR ( . tDOF . ) INTERFACE !! This subroutine returns the total number of degrees of freedom !> authors: Dr. Vikas Sharma ! ! This function returns the total number of dof in given physical name MODULE PURE FUNCTION get_tDOF_iname ( Obj , Name ) RESULT ( Ans ) CLASS ( DOF_ ), INTENT ( IN ) :: Obj CHARACTER ( LEN = 1 ), INTENT ( IN ) :: Name INTEGER ( I4B ) :: Ans END FUNCTION get_tDOF_iname END INTERFACE INTERFACE OPERATOR ( . tDOF . ) MODULE PROCEDURE get_tDOF_iname END INTERFACE OPERATOR ( . tDOF . ) !---------------------------------------------------------------------------- !                                                            tNames@getMethod !---------------------------------------------------------------------------- INTERFACE !! This subroutine returns the total number of names !> authors: Dr. Vikas Sharma ! ! This subroutine returns the total number of names or total number of ! physical quantities MODULE PURE FUNCTION get_tNames ( Obj ) RESULT ( Ans ) CLASS ( DOF_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ) :: Ans END FUNCTION get_tNames END INTERFACE INTERFACE OPERATOR ( . tNames . ) MODULE PROCEDURE get_tNames END INTERFACE PUBLIC :: OPERATOR ( . tNames . ) !---------------------------------------------------------------------------- !                                                           Names@getMethod !---------------------------------------------------------------------------- INTERFACE !! This function returns the name of all physical variables stored in obj MODULE PURE FUNCTION dof_all_names ( Obj ) RESULT ( Ans ) CLASS ( DOF_ ), INTENT ( IN ) :: Obj CHARACTER ( LEN = 1 ), ALLOCATABLE :: Ans ( : ) END FUNCTION dof_all_names END INTERFACE INTERFACE !! This function returns the name of a physical variable MODULE PURE FUNCTION dof_single_name ( Obj , ii ) RESULT ( Ans ) CLASS ( DOF_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: ii CHARACTER ( LEN = 1 ), ALLOCATABLE :: Ans END FUNCTION dof_single_name END INTERFACE INTERFACE OPERATOR ( . Names . ) MODULE PROCEDURE dof_all_names , dof_single_name END INTERFACE OPERATOR ( . Names . ) PUBLIC :: OPERATOR ( . Names . ) !---------------------------------------------------------------------------- !                                                         IndexOF@getMethod !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION get_index_of_name ( Obj , Name ) RESULT ( Ans ) CLASS ( DOF_ ), INTENT ( IN ) :: Obj CHARACTER ( LEN = 1 ), INTENT ( IN ) :: Name INTEGER ( I4B ) :: Ans END FUNCTION get_index_of_name END INTERFACE INTERFACE IndexOf MODULE PROCEDURE get_index_of_name END INTERFACE IndexOf PUBLIC :: IndexOf !---------------------------------------------------------------------------- !                                                tSpaceComponents@getMethod !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION get_tspace_compo ( Obj ) RESULT ( Ans ) CLASS ( DOF_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ) :: Ans END FUNCTION get_tspace_compo END INTERFACE INTERFACE OPERATOR ( . tSpaceComponents . ) MODULE PROCEDURE get_tspace_compo END INTERFACE PUBLIC :: OPERATOR ( . tSpaceComponents . ) !---------------------------------------------------------------------------- !                                                tTimeComponents@getMethod !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION get_tTime_compo ( Obj ) RESULT ( Ans ) CLASS ( DOF_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ) :: Ans END FUNCTION get_tTime_compo END INTERFACE INTERFACE OPERATOR ( . tTimeComponents . ) MODULE PROCEDURE get_tTime_compo END INTERFACE PUBLIC :: OPERATOR ( . tTimeComponents . ) !---------------------------------------------------------------------------- !                                                   getArrayValues@getMethod !---------------------------------------------------------------------------- INTERFACE !! Returns the values of degrees of freedom in a single vector !> authors: Dr. Vikas Sharma ! ! This subroutine extracts the values of from `val` corresponding to ! degrees of freedom specified by `DOFNo(:)` and return it in `V` ! ! - `StorageFMT` can be 'Nodes_FMT' or `DOF_FMT` MODULE PURE SUBROUTINE get_arrayvalues_single_vec ( v , Val , Obj , DOFNo , & & StorageFMT , Nptrs ) REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: v ( : ) REAL ( DFP ), INTENT ( IN ) :: Val ( : ) CLASS ( DOF_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: DOFNo ( : ), StorageFMT INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: Nptrs ( : ) END SUBROUTINE get_arrayvalues_single_vec END INTERFACE INTERFACE getArrayValues MODULE PROCEDURE get_arrayvalues_single_vec END INTERFACE PUBLIC :: getArrayValues !---------------------------------------------------------------------------- !                                                   getArrayValues@getMethod !---------------------------------------------------------------------------- INTERFACE !! Returns the values of degrees of freedom in a 2D array !> authors: Dr. Vikas Sharma ! ! This subroutine extracts the values of from `val` corresponding to ! degrees of freedom specified by `DOFNo(:)` and return it in `V(:,:)` ! Values in `Val(:,:)` are stored in xiJ format. ! ! - Force3D will return a vector in 3D. if there are only two components ! then it will set the third component to 0 ! MODULE PURE SUBROUTINE get_arrayvalues_array ( v , Val , Obj , DOFNo , force3D ) REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: v ( :, : ) REAL ( DFP ), INTENT ( IN ) :: Val ( : ) CLASS ( DOF_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: DOFNo ( : ) LOGICAL ( LGT ), OPTIONAL , INTENT ( IN ) :: force3D END SUBROUTINE get_arrayvalues_array END INTERFACE INTERFACE getArrayValues MODULE PROCEDURE get_arrayvalues_array END INTERFACE !---------------------------------------------------------------------------- !                                                      ArrayValues@getMethod !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION arrayvalues_single_vec ( Val , Obj , DOFNo , & & StorageFMT , Nptrs , Force3D ) RESULT ( Ans ) REAL ( DFP ), INTENT ( IN ) :: Val ( : ) CLASS ( DOF_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: DOFNo ( : ), StorageFMT INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: Nptrs ( : ) LOGICAL ( LGT ), OPTIONAL , INTENT ( IN ) :: force3D REAL ( DFP ), ALLOCATABLE :: Ans ( : ) END FUNCTION arrayvalues_single_vec END INTERFACE INTERFACE ArrayValues MODULE PROCEDURE arrayvalues_single_vec END INTERFACE PUBLIC :: ArrayValues !---------------------------------------------------------------------------- !                                                        setValue@setMethod !---------------------------------------------------------------------------- INTERFACE !! Set values in a vector of real numbers !> authors: Dr. Vikas Sharma ! ! This subroutine is designed to set the values in a vector of real number ! ! - [[DOF_]] object `obj` contains the storage pattern of degrees of freedom ! inside `Vec`. This storage pattern can be `FMT_Nodes` or `FMT_DOF` ! - `Val` denotes the nodal values of all dof defined inside `Obj`. Once ! storage pattern in `Val` can be `FMT_DOF` or `FMT_Nodes`. ! - To tackle this `Conversion`  can be set to `DOFToNodes`, `NodesToDOF` ! or `NONE`. ! - This subroutine effectivily performes `Vec( Nptrs ) = Val` ! - If `SIZE(val)==1` then all values are set to `val(1)` ! - If `SIZE(val) .EQ. SIZE(Nptrs)` then for each dof its value set to !  `val` ! - If `SIZE(val)=tDOF*Size(Nptrs)` then each dof will be set to ! corresponding val MODULE PURE SUBROUTINE dof_setValue_1 ( Vec , Obj , Nptrs , Val , Conversion ) REAL ( DFP ), INTENT ( INOUT ) :: Vec ( : ) CLASS ( DOF_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Nptrs ( : ), Conversion ( 1 ) REAL ( DFP ), INTENT ( IN ) :: Val ( : ) END SUBROUTINE dof_setValue_1 END INTERFACE INTERFACE !! Set values in a vector of real numbers !> authors: Dr. Vikas Sharma ! ! This subroutine is designed to set the values in a vector of real number ! - [[DOF_]] object `obj` contains the storage pattern of degrees of freedom ! inside `Vec`. This storage pattern can be `FMT_Nodes` or `FMT_DOF` ! - `Val` denotes the nodal values of dof `dofno`. ! ! This subroutine effectivily performes `Vec( Nptrs ) = Val` MODULE PURE SUBROUTINE dof_setValue_2 ( Vec , Obj , Nptrs , Val , dofno ) REAL ( DFP ), INTENT ( INOUT ) :: Vec ( : ) CLASS ( DOF_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Nptrs ( : ) REAL ( DFP ), INTENT ( IN ) :: Val ( : ) INTEGER ( I4B ), INTENT ( IN ) :: dofno END SUBROUTINE dof_setValue_2 END INTERFACE !> Generic subroutine to set values in fortran vectors using [[dof_]] object INTERFACE setValue MODULE PROCEDURE dof_setValue_1 , dof_setValue_2 END INTERFACE setValue PUBLIC :: setValue !---------------------------------------------------------------------------- !                                                 addContribution@setMethod !---------------------------------------------------------------------------- INTERFACE !! Set values in a vector of real numbers !> authors: Dr. Vikas Sharma ! ! This subroutine is designed to add values in a vector of real number ! - [[DOF_]] object `obj` contains the storage pattern of degrees of freedom ! inside `Vec`. This storage pattern can be `FMT_Nodes` or `FMT_DOF` ! - `Val` denotes the nodal values of all dof defined inside `Obj`. Once ! storage pattern in `Val` can be `FMT_DOF` or `FMT_Nodes`. ! - To tackle this `Conversion`  can be set to `DOFToNodes`, `NodesToDOF` ! or `NONE`. ! ! This subroutine effectivily performes ! `Vec( Nptrs ) = Vec(Nptrs) + scale * Val` MODULE PURE SUBROUTINE dof_addValue_1 ( Vec , Obj , Nptrs , Val , scale , & & Conversion ) REAL ( DFP ), INTENT ( INOUT ) :: Vec ( : ) CLASS ( DOF_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Nptrs ( : ), Conversion ( 1 ) REAL ( DFP ), INTENT ( IN ) :: Val ( : ), scale END SUBROUTINE dof_addValue_1 END INTERFACE INTERFACE !! Set values in a vector of real numbers !> authors: Dr. Vikas Sharma ! ! This subroutine is designed to add values in a vector of real number ! - [[DOF_]] object `obj` contains the storage pattern of degrees of freedom ! inside `Vec`. This storage pattern can be `FMT_Nodes` or `FMT_DOF` ! - `Val` denotes the nodal values of dof `dofno`. ! ! This subroutine effectivily performes ! `Vec( Nptrs ) = Vec(Nptrs) + scale * Val` MODULE PURE SUBROUTINE dof_addValue_2 ( Vec , Obj , Nptrs , Val , scale , dofno ) REAL ( DFP ), INTENT ( INOUT ) :: Vec ( : ) CLASS ( DOF_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Nptrs ( : ) REAL ( DFP ), INTENT ( IN ) :: Val ( : ), scale INTEGER ( I4B ), INTENT ( IN ) :: dofno END SUBROUTINE dof_addValue_2 END INTERFACE !> Generic subroutine to add values in vectors using [[dof_]] object INTERFACE addContribution MODULE PROCEDURE dof_addValue_1 , dof_addValue_2 END INTERFACE addContribution PUBLIC :: addContribution !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- CONTAINS !---------------------------------------------------------------------------- !                                                                DOF_Pointer !---------------------------------------------------------------------------- !! Constructor for pointer to [[dof_]] object !> authors: Dr. Vikas Sharma ! ! This function returns the pointer to instance of [[dof_]] object ! for more see [[dof_:initiate]] FUNCTION Constructor_1 ( tNodes , Names , SpaceCompo , TimeCompo , & & StorageFMT ) RESULT ( Obj ) CLASS ( DOF_ ), POINTER :: Obj INTEGER ( I4B ), INTENT ( IN ) :: tNodes ( : ), SpaceCompo ( : ), & & TimeCompo ( : ), StorageFMT CHARACTER ( LEN = 1 ), INTENT ( IN ) :: Names ( : ) ALLOCATE ( Obj ) CALL Initiate ( Obj = Obj , Names = Names , tNodes = tNodes , & & SpaceCompo = SpaceCompo , TimeCompo = TimeCompo , StorageFMT = StorageFMT ) END FUNCTION Constructor_1 END MODULE DOF_Method","tags":"","loc":"sourcefile/dof_method.f90.html"},{"title":"File_Method.f90 – Fortran Program","text":"Contents Modules File_Method Source Code File_Method.f90 Source Code MODULE File_Method !! This module contains routine related to file handling !! Routines for File_ userdata typehas been defined !! Submodules !! - Constructor !! - WriteMethods !! - ReadLine USE GlobalData USE BaseType PRIVATE !---------------------------------------------------------------------------- !                                                        Initiate@Constructor !---------------------------------------------------------------------------- INTERFACE !! This routine intiate the [[file_]] object !> authors: Dr. Vikas Sharma ! \tThis routine initiate the [[file_]] obj ! MODULE SUBROUTINE init_file ( Obj , Path , FileName , Extension , Status , & & Action , Access , isBinary , Comment , Separator ) CLASS ( File_ ), INTENT ( INOUT ) :: Obj !! File object CHARACTER ( LEN = * ), INTENT ( IN ) :: Path , FileName , Extension , Status , & & Action CHARACTER ( LEN = * ), INTENT ( IN ), OPTIONAL :: Access LOGICAL ( LGT ), OPTIONAL , INTENT ( IN ) :: isBinary !! Flag for binary file CHARACTER ( LEN = 1 ), OPTIONAL , INTENT ( IN ) :: Comment CHARACTER ( LEN = 1 ), OPTIONAL , INTENT ( IN ) :: Separator END SUBROUTINE init_file END INTERFACE INTERFACE Initiate MODULE PROCEDURE init_file END INTERFACE Initiate PUBLIC :: Initiate !---------------------------------------------------------------------------- !                                                          File@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE FUNCTION Constructor1 ( ) RESULT ( Ans ) TYPE ( File_ ) :: Ans END FUNCTION Constructor1 END INTERFACE INTERFACE File MODULE PROCEDURE Constructor1 END INTERFACE PUBLIC :: File !---------------------------------------------------------------------------- !                                                       File_Pointer@Contains !---------------------------------------------------------------------------- INTERFACE File_Pointer MODULE PROCEDURE Constructor_1 END INTERFACE PUBLIC :: File_Pointer !---------------------------------------------------------------------------- !                                                        OpenFile@Constuctor !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE open_file ( Obj ) CLASS ( File_ ), INTENT ( INOUT ) :: Obj END SUBROUTINE open_file END INTERFACE INTERFACE OpenFile MODULE PROCEDURE open_file END INTERFACE OpenFile PUBLIC :: OpenFile !---------------------------------------------------------------------------- !                                               OpenFileToWrite@Constructor !---------------------------------------------------------------------------- INTERFACE !! This routine open a file to write !> authors: Dr. Vikas Sharma ! ! This routine opens a file to write MODULE SUBROUTINE open_file_write_a ( Obj , Path , FileName , Extension ) CLASS ( File_ ), INTENT ( INOUT ) :: Obj CHARACTER ( LEN = * ), INTENT ( IN ) :: Path , FileName , Extension END SUBROUTINE open_file_write_a END INTERFACE INTERFACE !! This routine open a file to write !> authors: Dr. Vikas Sharma ! ! This routine opens a file to write MODULE SUBROUTINE open_file_write_b ( Obj , PFE ) CLASS ( File_ ), INTENT ( INOUT ) :: Obj TYPE ( String ), INTENT ( IN ) :: PFE ( : ) END SUBROUTINE open_file_write_b END INTERFACE INTERFACE !! This routine open a file to write !> authors: Dr. Vikas Sharma ! ! This routine opens a file to write MODULE SUBROUTINE open_file_write_c ( Obj , Path , FileName , Extension ) CLASS ( File_ ), INTENT ( INOUT ) :: Obj TYPE ( String ), INTENT ( IN ) :: Path , FileName , Extension END SUBROUTINE open_file_write_c END INTERFACE INTERFACE OpenFileToWrite MODULE PROCEDURE open_file_write_a , open_file_write_b , open_file_write_c END INTERFACE OpenFileToWrite PUBLIC :: OpenFileToWrite !---------------------------------------------------------------------------- !                                        OpenBinaryFileToWrite@Constructor !---------------------------------------------------------------------------- INTERFACE !! This routine open a binary file to write !> authors: Dr. Vikas Sharma ! ! This routine opens a binary file to write MODULE SUBROUTINE open_bfile_write_a ( Obj , Path , FileName , Extension ) CLASS ( File_ ), INTENT ( INOUT ) :: Obj CHARACTER ( LEN = * ), INTENT ( IN ) :: Path , FileName , Extension END SUBROUTINE open_bfile_write_a END INTERFACE INTERFACE OpenBinaryFileToWrite MODULE PROCEDURE open_bfile_write_a END INTERFACE OpenBinaryFileToWrite PUBLIC :: OpenBinaryFileToWrite !---------------------------------------------------------------------------- !                                                OpenFileToRead@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE open_file_Read_a ( Obj , Path , FileName , Extension ) CLASS ( File_ ), INTENT ( INOUT ) :: Obj CHARACTER ( LEN = * ), INTENT ( IN ) :: Path , FileName , Extension END SUBROUTINE open_file_Read_a END INTERFACE INTERFACE MODULE SUBROUTINE open_file_Read_b ( Obj , PFE ) CLASS ( File_ ), INTENT ( INOUT ) :: Obj TYPE ( String ), INTENT ( IN ) :: PFE ( : ) END SUBROUTINE open_file_Read_b END INTERFACE INTERFACE MODULE SUBROUTINE open_file_Read_c ( Obj , Path , FileName , Extension ) CLASS ( File_ ), INTENT ( INOUT ) :: Obj TYPE ( String ), INTENT ( IN ) :: Path , FileName , Extension END SUBROUTINE open_file_Read_c END INTERFACE INTERFACE OpenFileToRead MODULE PROCEDURE open_file_Read_a , open_file_Read_b , open_file_Read_c END INTERFACE OpenFileToRead PUBLIC :: OpenFileToRead !---------------------------------------------------------------------------- !                                              OpenFileToAppend@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE open_file_Append_a ( Obj , Path , FileName , Extension ) CLASS ( File_ ), INTENT ( INOUT ) :: Obj CHARACTER ( LEN = * ), INTENT ( IN ) :: Path , FileName , Extension END SUBROUTINE open_file_Append_a END INTERFACE INTERFACE MODULE SUBROUTINE open_file_Append_b ( Obj , PFE ) CLASS ( File_ ), INTENT ( INOUT ) :: Obj TYPE ( String ), INTENT ( IN ) :: PFE ( : ) END SUBROUTINE open_file_Append_b END INTERFACE INTERFACE MODULE SUBROUTINE open_file_Append_c ( Obj , Path , FileName , Extension ) CLASS ( File_ ), INTENT ( INOUT ) :: Obj TYPE ( String ), INTENT ( IN ) :: Path , FileName , Extension END SUBROUTINE open_file_Append_c END INTERFACE INTERFACE OpenFileToAppend MODULE PROCEDURE open_file_Append_a , open_file_Append_b , open_file_Append_c END INTERFACE OpenFileToAppend PUBLIC :: OpenFileToAppend !---------------------------------------------------------------------------- !                                                      CloseFile@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE close_file ( Obj ) CLASS ( File_ ), INTENT ( INOUT ) :: Obj END SUBROUTINE close_file END INTERFACE INTERFACE CloseFile MODULE PROCEDURE close_file END INTERFACE CloseFile PUBLIC :: CloseFile !---------------------------------------------------------------------------- !                                                     DeleteFile@Constructor !---------------------------------------------------------------------------- INTERFACE !! This subroutine deletes the file on the hard-disk !> authors: Dr. Vikas Sharma ! ! This routine deletes the file on the hard disk MODULE SUBROUTINE DeleteFile ( Obj ) CLASS ( File_ ), INTENT ( IN ) :: Obj END SUBROUTINE DeleteFile END INTERFACE PUBLIC :: DeleteFile !---------------------------------------------------------------------------- !                                                     ReopenFile@Constructor !---------------------------------------------------------------------------- INTERFACE !! This subroutine opens a file to !> authors: Dr. Vikas Sharma ! ! This subroutine reopens the file MODULE SUBROUTINE reopen_file ( Obj ) CLASS ( File_ ), INTENT ( INOUT ) :: Obj END SUBROUTINE reopen_file END INTERFACE INTERFACE ReopenFile MODULE PROCEDURE reopen_file END INTERFACE ReopenFile PUBLIC :: ReopenFile !---------------------------------------------------------------------------- !                                                       FileSize@Inquiry !---------------------------------------------------------------------------- INTERFACE !! this function returns the file size in bytes !> authors: Dr. Vikas Sharma ! ! This subroutine returns the file size in bytes MODULE FUNCTION file_size ( Obj ) RESULT ( Ans ) CLASS ( File_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ) :: Ans END FUNCTION file_size END INTERFACE INTERFACE SIZE MODULE PROCEDURE file_size END INTERFACE SIZE PUBLIC :: SIZE !---------------------------------------------------------------------------- !                                                              Exist@Inquiry !---------------------------------------------------------------------------- INTERFACE !! This subroutine checks whether filename exists or not !> authors: Dr. Vikas Sharma ! ! This function checks whether the filename exists or not MODULE FUNCTION fileExists ( Obj ) RESULT ( Ans ) CLASS ( File_ ), INTENT ( IN ) :: Obj LOGICAL ( LGT ) :: Ans END FUNCTION fileExists END INTERFACE INTERFACE Exists MODULE PROCEDURE fileExists END INTERFACE Exists PUBLIC :: Exists !---------------------------------------------------------------------------- !                                                       hasExtension@Inquiry !---------------------------------------------------------------------------- INTERFACE MODULE FUNCTION hasExtension ( Obj , Extension ) RESULT ( Ans ) CLASS ( File_ ), INTENT ( IN ) :: Obj CHARACTER ( LEN = 3 ), INTENT ( IN ) :: Extension LOGICAL ( LGT ) :: Ans END FUNCTION END INTERFACE PUBLIC :: hasExtension !---------------------------------------------------------------------------- !                                                            isOpen@Inquiry !---------------------------------------------------------------------------- INTERFACE MODULE FUNCTION checkIsOpen ( Obj ) RESULT ( Ans ) CLASS ( File_ ), INTENT ( IN ) :: Obj LOGICAL ( LGT ) :: Ans END FUNCTION checkIsOpen END INTERFACE INTERFACE isOpen MODULE PROCEDURE checkIsOpen END INTERFACE isOpen PUBLIC :: isOpen ! !---------------------------------------------------------------------------- ! !                                                       Write@WriteMethods ! !---------------------------------------------------------------------------- ! INTERFACE ! !! This routine writes data into a file ! !> authors: Dr. Vikas Sharma ! ! This routine writes data into a file ! ! If transpose is true then data is printed as row ! ! If transpose is false then data is printed as column ! MODULE SUBROUTINE write_data_ascii_r1( Obj, Val, transpose ) !   CLASS(File_), INTENT( INOUT) :: Obj !     !! File object !   CLASS(*), INTENT( IN ) :: Val(:) !     !! One D array !   LOGICAL( LGT ), INTENT( IN ) :: transpose !     !! Transpose flag ! END SUBROUTINE write_data_ascii_r1 ! END INTERFACE !---------------------------------------------------------------------------- !                                                       Write@WriteMethods !---------------------------------------------------------------------------- INTERFACE !! This routine writes data into a file !> authors: Dr. Vikas Sharma ! This routine writes data into a file ! If row is present then data is printed as row ! If col is present then data is printed as column ! If both row or col are absent then data is printed as row MODULE SUBROUTINE write_data_ascii_r1 ( Obj , Val , row , col ) CLASS ( File_ ), INTENT ( INOUT ) :: Obj !! File object CLASS ( * ), INTENT ( IN ) :: Val (:) !! One D array LOGICAL ( LGT ), INTENT ( IN ), OPTIONAL :: row !! If present then vector will be printed as rowwise LOGICAL ( LGT ), INTENT ( IN ), OPTIONAL :: col !! If present then vector will be printed as column wise END SUBROUTINE write_data_ascii_r1 END INTERFACE !---------------------------------------------------------------------------- !                                                       Write@WriteMethods !---------------------------------------------------------------------------- INTERFACE !! This routine writes data into a file !> authors: Dr. Vikas Sharma ! This routine writes data into a file ! If transpose is true then data is printed after taking transpose MODULE SUBROUTINE write_data_ascii_r2 ( Obj , Val , transpose ) CLASS ( File_ ), INTENT ( INOUT ) :: Obj CLASS ( * ), INTENT ( IN ) :: Val (:, :) LOGICAL ( LGT ), INTENT ( IN ) :: transpose END SUBROUTINE write_data_ascii_r2 END INTERFACE !---------------------------------------------------------------------------- !                                                       Write@WriteMethods !---------------------------------------------------------------------------- INTERFACE !! This routine writes data into a file !> authors: Dr. Vikas Sharma ! This routine writes data into a file ! If transpose is present then data is printed after taking transpose MODULE SUBROUTINE write_data_ascii_scalar ( Obj , Val ) CLASS ( File_ ), INTENT ( INOUT ) :: Obj CLASS ( * ), INTENT ( IN ) :: Val END SUBROUTINE write_data_ascii_scalar END INTERFACE INTERFACE Write MODULE PROCEDURE write_data_ascii_r1 , write_data_ascii_r2 , & & write_data_ascii_scalar END INTERFACE Write PUBLIC :: Write !---------------------------------------------------------------------------- !                                                        WriteLine@WriteData !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE writeLine_a ( a , fileName , unitNo ) REAL ( DFP ), INTENT ( IN ) :: a CHARACTER ( LEN = * ), INTENT ( IN ) :: fileName INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: unitno END SUBROUTINE writeLine_a END INTERFACE !---------------------------------------------------------------------------- !                                                        WriteLine@WriteData !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE writeLine_ab ( a , b , fileName , unitNo ) REAL ( DFP ), INTENT ( IN ) :: a , b CHARACTER ( LEN = * ), INTENT ( IN ) :: fileName INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: unitno END SUBROUTINE writeLine_ab END INTERFACE !---------------------------------------------------------------------------- !                                                        WriteLine@WriteData !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE writeLine_abc ( a , b , c , fileName , unitNo ) REAL ( DFP ), INTENT ( IN ) :: a , b , c CHARACTER ( LEN = * ), INTENT ( IN ) :: fileName INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: unitno END SUBROUTINE writeLine_abc END INTERFACE !---------------------------------------------------------------------------- !                                                        WriteLine@WriteData !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE writeLine_abcd ( a , b , c , d , fileName , unitNo ) REAL ( DFP ), INTENT ( IN ) :: a , b , c , d CHARACTER ( LEN = * ), INTENT ( IN ) :: fileName INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: unitno END SUBROUTINE writeLine_abcd END INTERFACE !---------------------------------------------------------------------------- !                                                        WriteLine@WriteData !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE writeLine_abcde ( a , b , c , d , e , fileName , unitNo ) REAL ( DFP ), INTENT ( IN ) :: a , b , c , d , e CHARACTER ( LEN = * ), INTENT ( IN ) :: fileName INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: unitno END SUBROUTINE writeLine_abcde END INTERFACE !---------------------------------------------------------------------------- !                                                        WriteLine@WriteData !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE writeLine_av ( a , fileName , unitNo ) REAL ( DFP ), INTENT ( IN ) :: a ( : ) CHARACTER ( LEN = * ), INTENT ( IN ) :: fileName INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: unitno END SUBROUTINE writeLine_av END INTERFACE !---------------------------------------------------------------------------- !                                                        WriteLine@WriteData !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE writeLine_avbv ( a , b , fileName , unitNo ) REAL ( DFP ), INTENT ( IN ) :: a ( : ), b ( : ) CHARACTER ( LEN = * ), INTENT ( IN ) :: fileName INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: unitno END SUBROUTINE writeLine_avbv END INTERFACE !---------------------------------------------------------------------------- !                                                        WriteLine@WriteData !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE writeLine_avbvcv ( a , b , c , fileName , unitNo ) REAL ( DFP ), INTENT ( IN ) :: a ( : ), b ( : ), c ( : ) CHARACTER ( LEN = * ), INTENT ( IN ) :: fileName INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: unitno END SUBROUTINE writeLine_avbvcv END INTERFACE INTERFACE WriteLine MODULE PROCEDURE writeLine_a , writeLine_ab , writeLine_abc , writeLine_abcd ,& & writeLine_abcde , writeLine_av , writeLine_avbv , writeLine_avbvcv END INTERFACE WriteLine PUBLIC :: WriteLine !---------------------------------------------------------------------------- !                                                       Readline@ReadMethods !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE readline_a ( a , buffer , fileName , unitNo ) REAL ( DFP ), INTENT ( OUT ) :: a !! Number CHARACTER ( LEN =* ), INTENT ( IN ), OPTIONAL :: fileName !! File name INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: UnitNo !! File id number to read from CHARACTER ( LEN =* ), INTENT ( IN ), OPTIONAL :: buffer !! Character string to read from instead of the line in the file END SUBROUTINE readline_a END INTERFACE !---------------------------------------------------------------------------- !                                                       Readline@ReadMethods !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE readline_ab ( a , b , buffer , fileName , unitNo ) REAL ( DFP ), INTENT ( OUT ) :: a , b !! Number CHARACTER ( LEN =* ), INTENT ( IN ), OPTIONAL :: fileName !! File name INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: UnitNo !! File id number to read from CHARACTER ( LEN =* ), INTENT ( IN ), OPTIONAL :: buffer !! Character string to read from instead of the line in the file END SUBROUTINE readline_ab END INTERFACE !---------------------------------------------------------------------------- !                                                       Readline@ReadMethods !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE readline_abc ( a , b , c , buffer , fileName , unitNo ) REAL ( DFP ), INTENT ( OUT ) :: a , b , c !! Number CHARACTER ( LEN =* ), INTENT ( IN ), OPTIONAL :: fileName !! File name INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: UnitNo !! File id number to read from character ( len =* ), intent ( in ), optional :: buffer !! Character string to read from instead of the line in the file END SUBROUTINE readline_abc END INTERFACE !---------------------------------------------------------------------------- !                                                       Readline@ReadMethods !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE readline_abcd ( a , b , c , d , buffer , fileName , unitNo ) real ( DFP ), intent ( out ) :: a , b , c , d !! Number character ( len =* ), intent ( in ) :: fileName !! File name integer ( I4B ), intent ( in ) :: UnitNo !! File id number to read from character ( len =* ), intent ( in ), optional :: buffer !! Character string to read from instead of the line in the file END SUBROUTINE readline_abcd END INTERFACE INTERFACE !---------------------------------------------------------------------------- !                                                       Readline@ReadMethods !---------------------------------------------------------------------------- MODULE SUBROUTINE readline_abcde ( a , b , c , d , e , buffer , fileName , unitNo ) REAL ( DFP ), INTENT ( OUT ) :: a , b , c , d , e !! Number CHARACTER ( LEN =* ), INTENT ( IN ), OPTIONAL :: fileName !! File name INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: UnitNo !! File id number to read from character ( len =* ), intent ( in ), optional :: buffer !! Character string to read from instead of the line in the file END SUBROUTINE readline_abcde END INTERFACE INTERFACE ReadLine MODULE PROCEDURE readline_a , readline_ab , readline_abc , readline_abcd , & & readline_abcde END INTERFACE ReadLine PUBLIC :: ReadLine !---------------------------------------------------------------------------- !                                                       Readline@ReadMethods !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE readline_av ( a , buffer , fileName , unitNo ) REAL ( DFP ), INTENT ( OUT ) :: a ( : ) !! Number CHARACTER ( LEN =* ), INTENT ( IN ), OPTIONAL :: fileName !! File name INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: UnitNo !! File id number to read from CHARACTER ( LEN =* ), INTENT ( IN ), OPTIONAL :: buffer !! Character string to read from instead of the line in the file END SUBROUTINE readline_av END INTERFACE !---------------------------------------------------------------------------- !                                                       Readline@ReadMethods !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE readline_avbv ( a , b , buffer , fileName , unitNo ) REAL ( DFP ), INTENT ( OUT ) :: a ( : ), b ( : ) !! Number CHARACTER ( LEN =* ), INTENT ( IN ), OPTIONAL :: fileName !! File name INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: UnitNo !! File id number to read from CHARACTER ( LEN =* ), INTENT ( IN ), OPTIONAL :: buffer !! Character string to read from instead of the line in the file END SUBROUTINE readline_avbv END INTERFACE !---------------------------------------------------------------------------- !                                                       Readline@ReadMethods !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE readline_avbvcv ( a , b , c , buffer , fileName , unitNo ) REAL ( DFP ), INTENT ( OUT ) :: a ( : ), b ( : ), c ( : ) !! Number CHARACTER ( LEN =* ), INTENT ( IN ), OPTIONAL :: fileName !! File name INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: UnitNo !! File id number to read from CHARACTER ( LEN =* ), INTENT ( IN ), OPTIONAL :: buffer !! Character string to read from instead of the line in the file END SUBROUTINE readline_avbvcv END INTERFACE INTERFACE ReadLine MODULE PROCEDURE readline_av , readline_avbv , readline_avbvcv END INTERFACE ReadLine !---------------------------------------------------------------------------- !                                                       Readline@ReadMethods !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE readline_abv ( a , b , buffer , fileName , unitNo ) REAL ( DFP ), INTENT ( OUT ) :: a , b ( : ) !! Number CHARACTER ( LEN =* ), INTENT ( IN ), OPTIONAL :: fileName !! File name INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: UnitNo !! File id number to read from CHARACTER ( LEN =* ), INTENT ( IN ), OPTIONAL :: buffer !! Character string to read from instead of the line in the file END SUBROUTINE readline_abv END INTERFACE !---------------------------------------------------------------------------- !                                                       Readline@ReadMethods !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE readline_abvcv ( a , b , c , buffer , fileName , unitNo ) REAL ( DFP ), INTENT ( OUT ) :: a , b ( : ), c ( : ) !! Number CHARACTER ( LEN =* ), INTENT ( IN ), OPTIONAL :: fileName !! File name INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: UnitNo !! File id number to read from CHARACTER ( LEN =* ), INTENT ( IN ), OPTIONAL :: buffer !! Character string to read from instead of the line in the file END SUBROUTINE readline_abvcv END INTERFACE !---------------------------------------------------------------------------- !                                                       Readline@ReadMethods !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE readline_abcv ( a , b , c , buffer , fileName , unitNo ) REAL ( DFP ), INTENT ( OUT ) :: a , b , c ( : ) !! Number CHARACTER ( LEN =* ), INTENT ( IN ), OPTIONAL :: fileName !! File name INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: UnitNo !! File id number to read from CHARACTER ( LEN =* ), INTENT ( IN ), OPTIONAL :: buffer !! Character string to read from instead of the line in the file END SUBROUTINE readline_abcv END INTERFACE !---------------------------------------------------------------------------- !                                                       Readline@ReadMethods !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE readline_abcvdv ( a , b , c , d , buffer , fileName , unitNo ) REAL ( DFP ), INTENT ( OUT ) :: a , b , c ( : ), d ( : ) !! Number CHARACTER ( LEN =* ), INTENT ( IN ), OPTIONAL :: fileName !! File name INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: UnitNo !! File id number to read from CHARACTER ( LEN =* ), INTENT ( IN ), OPTIONAL :: buffer !! Character string to read from instead of the line in the file END SUBROUTINE readline_abcvdv END INTERFACE !---------------------------------------------------------------------------- !                                                       Readline@ReadMethods !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE readline_abcdv ( a , b , c , d , buffer , fileName , unitNo ) REAL ( DFP ), INTENT ( OUT ) :: a , b , c , d ( : ) !! Number CHARACTER ( LEN =* ), INTENT ( IN ), OPTIONAL :: fileName !! File name INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: UnitNo !! File id number to read from CHARACTER ( LEN =* ), INTENT ( IN ), OPTIONAL :: buffer !! Character string to read from instead of the line in the file END SUBROUTINE readline_abcdv END INTERFACE !---------------------------------------------------------------------------- !                                                       Readline@ReadMethods !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE readline_abcdvev ( a , b , c , d , e , buffer , fileName , unitNo ) REAL ( DFP ), INTENT ( OUT ) :: a , b , c , d ( : ), e ( : ) !! Number CHARACTER ( LEN =* ), INTENT ( IN ), OPTIONAL :: fileName !! File name INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: UnitNo !! File id number to read from CHARACTER ( LEN =* ), INTENT ( IN ), OPTIONAL :: buffer !! Character string to read from instead of the line in the file END SUBROUTINE readline_abcdvev END INTERFACE !---------------------------------------------------------------------------- !                                                       Readline@ReadMethods !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE readline_abcdev ( a , b , c , d , e , buffer , fileName , unitNo ) REAL ( DFP ), INTENT ( OUT ) :: a , b , c , d , e ( : ) !! Number CHARACTER ( LEN =* ), INTENT ( IN ), OPTIONAL :: fileName !! File name INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: UnitNo !! File id number to read from CHARACTER ( LEN =* ), INTENT ( IN ), OPTIONAL :: buffer !! Character string to read from instead of the line in the file END SUBROUTINE readline_abcdev END INTERFACE INTERFACE ReadLine MODULE PROCEDURE readline_abv , readline_abvcv , readline_abcv , & & readline_abcvdv , readline_abcdv , readline_abcdvev , readline_abcdev END INTERFACE ReadLine !---------------------------------------------------------------------------- !                                                                    Contains !---------------------------------------------------------------------------- CONTAINS FUNCTION Constructor_1 ( ) RESULT ( Obj ) ! Define intent of dummy variables CLASS ( File_ ), POINTER :: Obj ALLOCATE ( Obj ) Obj % isOpen = . FALSE . END FUNCTION Constructor_1 END MODULE File_Method","tags":"","loc":"sourcefile/file_method.f90.html"},{"title":"FEMatrix_Module.f90 – Fortran Program","text":"Contents Modules FEMatrix_Module Source Code FEMatrix_Module.f90 Source Code MODULE FEMatrix_Module !! This module contains interfaces of finite element matrices USE BaseType USE GlobalData IMPLICIT NONE PRIVATE !---------------------------------------------------------------------------- !                                                       MassMatrix@MassMatrix !---------------------------------------------------------------------------- INTERFACE !! This subroutine makes mass matrix in space domain !> authors: Dr. Vikas Sharma ! ! This subroutine makes space matrix in space domain, Here Rho $\\rho$ is a ! finite element variable ! ! \\int_{\\Omega } N&#94;{I}\\rho N&#94;{J}d\\Omega MODULE PURE FUNCTION Space_MassMatrix ( Test , Trial , Rho , nCopy ) RESULT ( Ans ) CLASS ( ElemshapeData_ ), INTENT ( IN ) :: Test !! Shapedata for test function CLASS ( ElemshapeData_ ), INTENT ( IN ) :: Trial !! Shapedata for trial function CLASS ( FEVariable_ ), INTENT ( IN ), OPTIONAL :: Rho !! Finite element variable (density) INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: nCopy !! number of diagonal copies REAL ( DFP ), ALLOCATABLE :: Ans ( :, : ) END FUNCTION Space_MassMatrix END INTERFACE !---------------------------------------------------------------------------- !                                                                 MassMatrix !---------------------------------------------------------------------------- INTERFACE !! This subroutine makes mass matrix in space time domain !> authors: Dr. Vikas Sharma ! ! This subroutine makes space matrix in space domain, Here Rho $\\rho$ is a ! finite element variable. Following expression can be evaluated ! ! \\int_{\\Omega } N&#94;{I}T_{a}\\rho N&#94;{J}T_{b}d\\Omega ! \\iint \\frac{\\partial N&#94;{I}T_{a}}{\\partial t} \\rho N&#94;{J}T_{b}d\\Omega dt ! \\iint \\frac{\\partial N&#94;{I}T_{a}}{\\partial t} \\rho \\frac{\\partial ! N&#94;{J}T_{b}}{\\partial t} d\\Omega dt ! \\iint N&#94;{I}T_{a}\\rho \\frac{\\partial N&#94;{J}T_{b}}{\\partial t} d\\Omega dt MODULE PURE FUNCTION st_massMatrix_a ( Test , Trial , Rho , Term1 , Term2 , nCopy )& & RESULT ( Ans ) CLASS ( STElemshapeData_ ), INTENT ( IN ) :: Test (:) CLASS ( STElemshapeData_ ), INTENT ( IN ) :: Trial (:) TYPE ( FEVariable_ ), OPTIONAL , INTENT ( IN ) :: Rho INTEGER ( I4B ), INTENT ( IN ) :: Term1 !! If 0 then time derivative in first term true, otherwise false INTEGER ( I4B ), INTENT ( IN ) :: Term2 !! If 0 then time derivative in second term true, otherwise false INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: nCopy REAL ( DFP ), ALLOCATABLE :: Ans ( :, : ) END FUNCTION st_massMatrix_a END INTERFACE !---------------------------------------------------------------------------- !                                                                 MassMatrix !---------------------------------------------------------------------------- !> Generic function to obtain mass matrix INTERFACE MassMatrix MODULE PROCEDURE Space_MassMatrix , st_massMatrix_a END INTERFACE MassMatrix PUBLIC :: MassMatrix !---------------------------------------------------------------------------- !                                            DiffusionMatrix@DiffusionMatrix !---------------------------------------------------------------------------- INTERFACE !! This subroutine returns the diffusion matrix in space domain !> authors: Dr. Vikas Sharma ! ! This function returns the diffusion matrix in space domain ! ! \\int&#94;{}_{\\Omega } \\frac{\\partial N&#94;{I}}{\\partial x_{i}} \\frac{\\partial N&#94; ! {J}}{\\partial x_{i}} d\\Omega MODULE PURE FUNCTION Space_DiffusionMatrix ( Test , Trial , nCopy ) RESULT ( Ans ) CLASS ( ElemshapeData_ ), INTENT ( IN ) :: Test , Trial INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: nCopy REAL ( DFP ), ALLOCATABLE :: Ans ( :, : ) END FUNCTION Space_DiffusionMatrix END INTERFACE !---------------------------------------------------------------------------- !                                            DiffusionMatrix@DiffusionMatrix !---------------------------------------------------------------------------- INTERFACE !! This subroutine returns the diffusion matrix in space domain !> authors: Dr. Vikas Sharma ! ! This function returns the diffusion matrix in space domain ! ! \\int&#94;{}_{\\Omega } \\frac{\\partial N&#94;{I}}{\\partial x_{i}} k_{ij} !\\frac{\\partial N&#94;{J}}{\\partial x_{j}} d\\Omega MODULE PURE FUNCTION Space_DiffusionMatrix_K ( Test , Trial , K , nCopy ) & & RESULT ( Ans ) CLASS ( ElemshapeData_ ), INTENT ( IN ) :: Test , Trial CLASS ( FEVariable_ ), INTENT ( IN ) :: K INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: nCopy REAL ( DFP ), ALLOCATABLE :: Ans ( :, : ) END FUNCTION Space_DiffusionMatrix_K END INTERFACE !---------------------------------------------------------------------------- !                                            DiffusionMatrix@DiffusionMatrix !---------------------------------------------------------------------------- INTERFACE !! This subroutine returns the diffusion matrix in space domain !> authors: Dr. Vikas Sharma ! ! This function returns the diffusion matrix in space domain ! ! \\int&#94;{}_{\\Omega } \\frac{\\partial N&#94;{I}}{\\partial x_{i}} c_i !\\frac{\\partial N&#94;{J}}{\\partial x_{j}} c_j d\\Omega MODULE PURE FUNCTION Space_DiffusionMatrix_C ( Test , Trial , C1 , C2 , nCopy ) & & RESULT ( Ans ) CLASS ( ElemshapeData_ ), INTENT ( IN ) :: Test , Trial CLASS ( FEVariable_ ), INTENT ( IN ) :: C1 , C2 INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: nCopy REAL ( DFP ), ALLOCATABLE :: Ans ( :, : ) END FUNCTION Space_DiffusionMatrix_C END INTERFACE !---------------------------------------------------------------------------- !                                                           DiffusionMatrix !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION st_diffusionMatrix ( Test , Trial , nCopy ) RESULT ( Ans ) CLASS ( STElemshapeData_ ), INTENT ( IN ) :: Test ( : ) CLASS ( STElemshapeData_ ), INTENT ( IN ) :: Trial ( : ) INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: nCopy REAL ( DFP ), ALLOCATABLE :: Ans ( :, : ) END FUNCTION st_diffusionMatrix END INTERFACE !---------------------------------------------------------------------------- !                                                           DiffusionMatrix !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION st_diffusionMatrix_K ( Test , Trial , K , nCopy ) & & RESULT ( Ans ) CLASS ( STElemshapeData_ ), INTENT ( IN ) :: Test (:) CLASS ( STElemshapeData_ ), INTENT ( IN ) :: Trial (:) CLASS ( FEVariable_ ), INTENT ( IN ) :: K INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: nCopy REAL ( DFP ), ALLOCATABLE :: Ans ( :, : ) END FUNCTION st_diffusionMatrix_K END INTERFACE !---------------------------------------------------------------------------- !                                                           DiffusionMatrix !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION st_diffusionMatrix_C ( Test , Trial , C1 , C2 , nCopy ) & & RESULT ( Ans ) CLASS ( STElemshapeData_ ), INTENT ( IN ) :: Test ( : ) CLASS ( STElemshapeData_ ), INTENT ( IN ) :: Trial ( : ) CLASS ( FEVariable_ ), INTENT ( IN ) :: C1 CLASS ( FEVariable_ ), INTENT ( IN ) :: C2 INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: nCopy REAL ( DFP ), ALLOCATABLE :: Ans ( :, : ) END FUNCTION st_diffusionMatrix_C END INTERFACE INTERFACE DiffusionMatrix MODULE PROCEDURE Space_DiffusionMatrix , Space_DiffusionMatrix_K ,& & Space_DiffusionMatrix_C , & & st_DiffusionMatrix , st_DiffusionMatrix_K ,& & st_DiffusionMatrix_C END INTERFACE DiffusionMatrix PUBLIC :: DiffusionMatrix !---------------------------------------------------------------------------- !                                            StiffnessMatrix@StiffnessMatrix !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION Space_StiffnessMatrix_Cijkl ( Test , Trial , Cijkl ) & & RESULT ( Ans ) CLASS ( ElemshapeData_ ), INTENT ( IN ) :: Test , Trial CLASS ( FEVariable_ ), INTENT ( IN ) :: Cijkl REAL ( DFP ), ALLOCATABLE :: Ans ( :, : ) END FUNCTION Space_StiffnessMatrix_Cijkl END INTERFACE INTERFACE StiffnessMatrix MODULE PROCEDURE Space_StiffnessMatrix_Cijkl END INTERFACE StiffnessMatrix PUBLIC :: StiffnessMatrix !---------------------------------------------------------------------------- !                                            StiffnessMatrix@StiffnessMatrix !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION Space_StiffnessMatrix_Lambda ( Test , Trial , Lambda , Mu ) & & RESULT ( Ans ) CLASS ( ElemshapeData_ ), INTENT ( IN ) :: Test , Trial CLASS ( FEVariable_ ), INTENT ( IN ) :: Lambda , Mu REAL ( DFP ), ALLOCATABLE :: Ans ( :, : ) END FUNCTION Space_StiffnessMatrix_Lambda END INTERFACE INTERFACE StiffnessMatrix MODULE PROCEDURE Space_StiffnessMatrix_Lambda END INTERFACE StiffnessMatrix !---------------------------------------------------------------------------- !                                            StiffnessMatrix@StiffnessMatrix !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION Space_StiffnessMatrix_LamMu ( Test , Trial , Lambda , & & Mu ) RESULT ( Ans ) CLASS ( ElemshapeData_ ), INTENT ( IN ) :: Test , Trial REAL ( DFP ), INTENT ( IN ) :: Lambda , Mu REAL ( DFP ), ALLOCATABLE :: Ans ( :, : ) END FUNCTION Space_StiffnessMatrix_LamMu END INTERFACE INTERFACE StiffnessMatrix MODULE PROCEDURE Space_StiffnessMatrix_LamMu END INTERFACE StiffnessMatrix !---------------------------------------------------------------------------- !                                                NitscheMatrix@NitscheMatrix !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION space_nitsche_mat_1 ( Test , Trial , Lambda , Mu , Evec ) & & RESULT ( Ans ) CLASS ( ElemshapeData_ ), INTENT ( IN ) :: Test , Trial CLASS ( FEVariable_ ), INTENT ( IN ) :: Lambda , Mu , Evec REAL ( DFP ), ALLOCATABLE :: Ans ( :, : ) END FUNCTION space_nitsche_mat_1 END INTERFACE INTERFACE MODULE PURE FUNCTION space_nitsche_mat_3 ( Test , Trial , Lambda , Mu , Evec ) & & RESULT ( Ans ) CLASS ( ElemshapeData_ ), INTENT ( IN ) :: Test , Trial CLASS ( FEVariable_ ), INTENT ( IN ) :: Evec REAL ( DFP ), INTENT ( IN ) :: Lambda , Mu REAL ( DFP ), ALLOCATABLE :: Ans ( :, : ) END FUNCTION space_nitsche_mat_3 END INTERFACE INTERFACE MODULE PURE FUNCTION space_nitsche_mat_5 ( Test , Trial , Lambda , Mu , isNoSlip )& & RESULT ( Ans ) CLASS ( ElemshapeData_ ), INTENT ( IN ) :: Test , Trial REAL ( DFP ), INTENT ( IN ) :: Lambda , Mu LOGICAL ( LGT ), INTENT ( IN ) :: isNoSlip REAL ( DFP ), ALLOCATABLE :: Ans ( :, : ) END FUNCTION space_nitsche_mat_5 END INTERFACE INTERFACE MODULE PURE FUNCTION space_nitsche_mat_7 ( Test , Trial , Lambda , Mu , isNoSlip )& & RESULT ( Ans ) CLASS ( ElemshapeData_ ), INTENT ( IN ) :: Test , Trial CLASS ( FEVariable_ ), INTENT ( IN ) :: Lambda , Mu LOGICAL ( LGT ), INTENT ( IN ) :: isNoSlip REAL ( DFP ), ALLOCATABLE :: Ans ( :, : ) END FUNCTION space_nitsche_mat_7 END INTERFACE INTERFACE MODULE PURE FUNCTION space_nitsche_mat_2 ( Test , Trial , Alpha , Evec ) & & RESULT ( Ans ) CLASS ( ElemshapeData_ ), INTENT ( IN ) :: Test , Trial CLASS ( FEVariable_ ), INTENT ( IN ) :: Alpha , Evec REAL ( DFP ), ALLOCATABLE :: Ans ( :, : ) END FUNCTION space_nitsche_mat_2 END INTERFACE INTERFACE MODULE PURE FUNCTION space_nitsche_mat_4 ( Test , Trial , Alpha , Evec ) & & RESULT ( Ans ) CLASS ( ElemshapeData_ ), INTENT ( IN ) :: Test , Trial CLASS ( FEVariable_ ), INTENT ( IN ) :: Evec REAL ( DFP ), INTENT ( IN ) :: Alpha REAL ( DFP ), ALLOCATABLE :: Ans ( :, : ) END FUNCTION space_nitsche_mat_4 END INTERFACE INTERFACE NitscheMatrix MODULE PROCEDURE space_nitsche_mat_1 , space_nitsche_mat_2 , & & space_nitsche_mat_3 , space_nitsche_mat_4 , space_nitsche_mat_5 , & & space_nitsche_mat_7 END INTERFACE NitscheMatrix PUBLIC :: NitscheMatrix !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- END MODULE FEMatrix_Module","tags":"","loc":"sourcefile/fematrix_module.f90.html"},{"title":"IndexValue_Method.f90 – Fortran Program","text":"Contents Modules IndexValue_Method Source Code IndexValue_Method.f90 Source Code MODULE IndexValue_Method USE GlobalData USE BaseType IMPLICIT NONE PRIVATE !---------------------------------------------------------------------------- !                                                                 Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION Constructor1 ( Indx , Val ) RESULT ( Obj ) INTEGER ( I4B ), INTENT ( IN ) :: Indx REAL ( DFP ), INTENT ( IN ) :: Val TYPE ( IndexValue_ ) :: Obj END FUNCTION Constructor1 MODULE PURE FUNCTION Constructor2 ( Indx , Val ) RESULT ( Obj ) INTEGER ( I4B ), INTENT ( IN ) :: Indx ( : ) REAL ( DFP ), INTENT ( IN ) :: Val ( : ) TYPE ( IndexValue_ ), ALLOCATABLE :: Obj ( : ) END FUNCTION Constructor2 MODULE PURE FUNCTION Constructor3 ( Indx , Val ) RESULT ( Obj ) INTEGER ( I4B ), INTENT ( IN ) :: Indx ( : ) REAL ( DFP ), INTENT ( IN ) :: Val TYPE ( IndexValue_ ), ALLOCATABLE :: Obj ( : ) END FUNCTION Constructor3 END INTERFACE INTERFACE IndexValue MODULE PROCEDURE Constructor1 , Constructor2 , Constructor3 END INTERFACE IndexValue PUBLIC :: IndexValue !---------------------------------------------------------------------------- !                                                                 Contains !---------------------------------------------------------------------------- END MODULE IndexValue_Method","tags":"","loc":"sourcefile/indexvalue_method.f90.html"},{"title":"IterationData_Method.f90 – Fortran Program","text":"Contents Modules IterationData_Method Source Code IterationData_Method.f90 Source Code MODULE IterationData_Method USE GlobalData USE BaseType IMPLICIT NONE PRIVATE !---------------------------------------------------------------------------- !                                                                  Initiate !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE initiate_obj ( Obj , MaxIter , IterationNumber , & & Tolerance , ErrorAtStart , ErrorAtEnd , TimeAtStart , TimeAtEnd , & & ConvergenceType , ConvergenceIn , NormType , Converged ) TYPE ( IterationData_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: MaxIter , IterationNumber , & & ConvergenceType , NormType , ConvergenceIn REAL ( DFP ), INTENT ( IN ), OPTIONAL :: Tolerance , ErrorAtEnd , & & ErrorAtStart , TimeAtStart , TimeAtEnd LOGICAL ( LGT ), OPTIONAL , INTENT ( IN ) :: Converged END SUBROUTINE initiate_obj END INTERFACE INTERFACE Initiate MODULE PROCEDURE initiate_obj END INTERFACE Initiate PUBLIC :: Initiate !---------------------------------------------------------------------------- !                                                               isConverged !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION is_converged ( Obj ) RESULT ( Ans ) TYPE ( IterationData_ ), INTENT ( IN ) :: Obj LOGICAL ( LGT ) :: Ans END FUNCTION is_converged END INTERFACE INTERFACE isConverged MODULE PROCEDURE is_converged END INTERFACE isConverged PUBLIC :: isConverged !---------------------------------------------------------------------------- !                                                                    Display !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE Display_obj ( Obj , msg , UnitNo ) TYPE ( IterationData_ ), INTENT ( IN ) :: Obj CHARACTER ( LEN = * ), INTENT ( IN ) :: msg INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: UnitNo END SUBROUTINE Display_obj END INTERFACE INTERFACE Display MODULE PROCEDURE Display_obj END INTERFACE Display PUBLIC :: Display !---------------------------------------------------------------------------- !                                                                 Contains !---------------------------------------------------------------------------- #include \"./contains.part\" END MODULE IterationData_Method","tags":"","loc":"sourcefile/iterationdata_method.f90.html"},{"title":"KeyValue_Method.f90 – Fortran Program","text":"Contents Modules KeyValue_Method Source Code KeyValue_Method.f90 Source Code MODULE KeyValue_Method !! This module contains interfaces of methods related to [[keyvalue_]] !> authors: Dr. Vikas Sharma ! ! !### Usage ! ! ```fortran ! program main ! use easifem ! implicit none ! type( keyvalue_ ) :: obj ! real( dfp ) :: vec( 3 ), mat( 3, 3 ) ! call random_number( vec ) ! call random_number( mat ) ! obj = keyvalue( 'real-rank-0', 1.0_dfp ) ! obj = 1.0_dfp ! call display( obj, 'obj' ) ! obj = keyvalue( 'real-rank-1', vec ) ! obj = [1.0_dfp, 1.0_dfp, 1.0_dfp] ! call display( obj, 'obj' ) ! obj = keyvalue( 'real-rank-2', mat ) ! call display( obj, 'obj' ) ! end program main ! ``` USE BaseType USE GlobalData USE StringiFor IMPLICIT NONE PRIVATE INTEGER , PARAMETER :: REAL_RANK_0 = 0 INTEGER , PARAMETER :: REAL_RANK_1 = 1 INTEGER , PARAMETER :: REAL_RANK_2 = 2 INTEGER , PARAMETER :: INT_RANK_0 = 3 INTEGER , PARAMETER :: INT_RANK_1 = 4 INTEGER , PARAMETER :: INT_RANK_2 = 5 #include \"./constructor.inc\" #include \"./setmethod.inc\" #include \"./getmethod.inc\" #include \"./contains.part\" END MODULE KeyValue_Method","tags":"","loc":"sourcefile/keyvalue_method.f90.html"},{"title":"SparseMatrix_Method.f90 – Fortran Program","text":"Contents Modules SparseMatrix_Method Source Code SparseMatrix_Method.f90 Source Code MODULE SparseMatrix_Method USE GlobalData USE BaseType IMPLICIT NONE PRIVATE #include \"./SparseMatrix_Interface.inc\" !---------------------------------------------------------------------------- !                                                       Initiate@Constructor !---------------------------------------------------------------------------- INTERFACE !! This subroutine construct the `SparseMatrix_` object !> authors: Dr. Vikas Sharma ! ! This subroutine construct the `sparsematrix_` object ! MODULE PURE SUBROUTINE initiate_obj1 ( Obj , tDOF , tNodes , MatrixProp , & & StorageFMT ) TYPE ( SparseMatrix_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: tDOF !! Total number of degrees of freedom INTEGER ( I4B ), INTENT ( IN ) :: tNodes ( : ) !! Total nunber of spatial nodes (size of vec) of each dof CHARACTER ( LEN = * ), OPTIONAL , INTENT ( IN ) :: MatrixProp !! Matrix is `SYM`, `UNSYM` INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: StorageFMT END SUBROUTINE initiate_obj1 END INTERFACE INTERFACE !! This subroutine converts a dense matrix into sparse matrix !> authors: Dr. Vikas Sharma ! ! This subroutine converts a dense matrix into a sparse matrix MODULE PURE SUBROUTINE initiate_obj2 ( Obj , Val , MatrixProp ) TYPE ( SparseMatrix_ ), INTENT ( INOUT ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Val ( :, : ) CHARACTER ( LEN = * ), OPTIONAL , INTENT ( IN ) :: MatrixProp END SUBROUTINE initiate_obj2 END INTERFACE ! todo INTERFACE !! This matrix converts a dense matrix into a sparse matrix !> authors: Dr. Vikas Sharma ! ! This matrix converts a dense matrix into a sparse matrix MODULE PURE SUBROUTINE initiate_obj3 ( Obj , Val , MatrixProp ) TYPE ( SparseMatrix_ ), INTENT ( INOUT ) :: Obj TYPE ( RealMatrix_ ), INTENT ( IN ) :: Val CHARACTER ( LEN = * ), OPTIONAL , INTENT ( IN ) :: MatrixProp END SUBROUTINE initiate_obj3 END INTERFACE INTERFACE !! This subroutine construct `sparsematrix_` object from IA, JA, A !> authors: Dr. Vikas Sharma ! ! This subroutine constructs `sparsematrix_` object from IA, JA, and A MODULE PURE SUBROUTINE initiate_obj4 ( Obj , A , IA , JA , MatrixProp ) TYPE ( SparseMatrix_ ), INTENT ( INOUT ) :: Obj REAL ( DFP ), INTENT ( IN ) :: A ( : ) INTEGER ( I4B ), INTENT ( IN ) :: IA ( : ), JA ( : ) CHARACTER ( LEN = * ), OPTIONAL , INTENT ( IN ) :: MatrixProp END SUBROUTINE initiate_obj4 END INTERFACE INTERFACE MODULE PURE SUBROUTINE initiate_obj5 ( Obj , IA , JA , MatrixProp ) TYPE ( SparseMatrix_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: IA ( : ), JA ( : ) CHARACTER ( LEN = * ), OPTIONAL , INTENT ( IN ) :: MatrixProp END SUBROUTINE initiate_obj5 END INTERFACE INTERFACE Initiate MODULE PROCEDURE initiate_obj1 , initiate_obj2 , initiate_obj3 , & & initiate_obj4 , initiate_obj5 END INTERFACE Initiate PUBLIC :: Initiate !---------------------------------------------------------------------------- !                                                          Shape@Constructor !---------------------------------------------------------------------------- INTERFACE !! This function returns the shape of sparse matrix !> authors: Dr. Vikas Sharma ! ! This function returns the shape of sparse matrix MODULE PURE FUNCTION get_shape ( Obj ) RESULT ( Ans ) TYPE ( SparseMatrix_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ) :: Ans ( 2 ) END FUNCTION get_shape END INTERFACE INTERFACE Shape MODULE PROCEDURE get_shape END INTERFACE Shape PUBLIC :: Shape !---------------------------------------------------------------------------- !                                                           Size@Constructor !---------------------------------------------------------------------------- INTERFACE !! This function returns the size of sparse matrix !> authors: Dr. Vikas Sharma ! ! This function returns the size of sparse matrix ! If Dims equal to 1 then total number of rows are returned ! If Dims is equal to 2 then total number of columns are return ! If Dims is absent then nrow*ncol are returned MODULE PURE FUNCTION get_size ( Obj , Dims ) RESULT ( Ans ) TYPE ( SparseMatrix_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: Dims INTEGER ( I4B ) :: Ans END FUNCTION get_size END INTERFACE INTERFACE Size MODULE PROCEDURE get_size END INTERFACE Size PUBLIC :: Size !---------------------------------------------------------------------------- !                                                         getNNZ@Constructor !---------------------------------------------------------------------------- INTERFACE !! Return the total number of non zero entry in the matrix !> authors: Dr. Vikas Sharma ! ! This function return the total number of non-zero entry in the sparse matrix MODULE PURE FUNCTION get_nnz ( Obj ) RESULT ( Ans ) TYPE ( SparseMatrix_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ) :: Ans END FUNCTION get_nnz END INTERFACE INTERFACE getNNZ MODULE PROCEDURE get_nnz END INTERFACE getNNZ PUBLIC :: getNNZ !---------------------------------------------------------------------------- !                                                   AllocateData@Constructor !---------------------------------------------------------------------------- INTERFACE !! This subroutine creates memeory space for the sparse matrix object !> authors: Dr. Vikas Sharma ! ! This subroutine creates memory space for the sparse matrix ! ! Dims(1) denotes total number of rows ! Dims(2) denotes total number of columns ! tDOF is set to 1 ! tNodes is set to Dims(1) ! nnz is set to to 0 MODULE PURE SUBROUTINE Allocate_data ( Obj , Dims , MatrixProp ) TYPE ( SparseMatrix_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Dims ( 2 ) CHARACTER ( LEN = * ), OPTIONAL , INTENT ( IN ) :: MatrixProp END SUBROUTINE Allocate_data END INTERFACE INTERFACE AllocateData MODULE PROCEDURE Allocate_Data END INTERFACE AllocateData PUBLIC :: AllocateData !---------------------------------------------------------------------------- !                                                 DeallocateData@Constructor !---------------------------------------------------------------------------- INTERFACE !! This subroutine deallocates the data !> authors: Dr. Vikas Sharma ! ! This subroutine deallocates the data stored MODULE PURE SUBROUTINE Deallocate_Data ( Obj ) TYPE ( SparseMatrix_ ), INTENT ( INOUT ) :: Obj END SUBROUTINE Deallocate_Data END INTERFACE INTERFACE DeallocateData MODULE PROCEDURE Deallocate_Data END INTERFACE DeallocateData PUBLIC :: DeallocateData !---------------------------------------------------------------------------- !                                                                 Display@IO !---------------------------------------------------------------------------- INTERFACE !! This subroutine display the content of sparse matrix !> authors: Dr. Vikas Sharma ! ! This subroutine display the content of sparse matrix ! - In this subroutine `dump` routine from sparsekit lib is called MODULE SUBROUTINE Display_obj ( Obj , Msg , UnitNo ) TYPE ( SparseMatrix_ ), INTENT ( IN ) :: Obj CHARACTER ( LEN = * ), INTENT ( IN ) :: Msg INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: UnitNo END SUBROUTINE Display_obj END INTERFACE INTERFACE !! This subroutine displays the content of sparse matrix !> authors: Dr. Vikas Sharma ! ! This subroutine displays the content of sparse matrix ! - options( 1 ) = i1 ! - options( 2 ) = i2 ! - options( 3 ) = 1 if values need to be printed else dont print values ! - options( 4 ) = unitno MODULE SUBROUTINE Display_CSR_2 ( Obj , msg , options ) TYPE ( SparseMatrix_ ), INTENT ( IN ) :: Obj CHARACTER ( LEN = * ), INTENT ( IN ) :: msg INTEGER ( I4B ), INTENT ( IN ) :: options ( : ) END SUBROUTINE Display_CSR_2 END INTERFACE INTERFACE Display MODULE PROCEDURE Display_obj , Display_CSR_2 END INTERFACE Display PUBLIC :: Display !---------------------------------------------------------------------------- !                                                                     Spy@IO !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE obj_spy ( Obj , PFE , ScriptLang , Values ) TYPE ( SparseMatrix_ ), INTENT ( IN ) :: Obj TYPE ( String ), INTENT ( IN ) :: PFE ( 3 ) CHARACTER ( LEN = * ), INTENT ( IN ) :: ScriptLang LOGICAL ( LGT ), INTENT ( IN ) :: Values END SUBROUTINE obj_spy END INTERFACE INTERFACE Spy MODULE PROCEDURE obj_spy END INTERFACE Spy PUBLIC :: Spy !---------------------------------------------------------------------------- !                                                      setSparsity@setMethod !---------------------------------------------------------------------------- INTERFACE !! This subroutine set the sparsity pattern of a given row !> authors: Dr. Vikas Sharma ! ! This subroutine set the sparsity pattern of a given row !  - If `obj%tdof` is equal to 1, then `Col` is sorted in increasing order, ! and appended to `Obj%Row(Row)` ! - If `obj%tdof` is not equal  to 1, then based on the storage format and ! `Col` connectivity information is generated. MODULE PURE SUBROUTINE setSparsity_1 ( Obj , Row , Col ) TYPE ( SparseMatrix_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Row , Col ( : ) END SUBROUTINE setSparsity_1 END INTERFACE INTERFACE !! This subroutine set the sparsity pattern of a given row !> authors: Dr. Vikas Sharma ! ! This subroutine sets the sparsity pattern of a given row ! This subroutine calls `setSparsity_1` MODULE PURE SUBROUTINE setSparsity_2 ( Obj , Row , Col ) TYPE ( SparseMatrix_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Row ( : ) TYPE ( IntVector_ ), INTENT ( IN ) :: Col ( : ) END SUBROUTINE setSparsity_2 END INTERFACE INTERFACE !! This subroutine set sparsity pattern of `sparsematrix_` !> authors: Dr. Vikas Sharma ! ! This subroutine set sparsity pattern of `sparsematrix_` ! This will finally set the data into ! - `Obj % A(:)` ! - `Obj % IA(:)`, ! - `Obj % JA(:)` ! in CSR format. This routine also set data inside `Obj % ColSize(:)` and ! `Obj % RowSize(:) `, and `Obj % DiagIndx(:)` MODULE PURE SUBROUTINE setSparsity_3 ( Obj ) TYPE ( SparseMatrix_ ), INTENT ( INOUT ) :: Obj END SUBROUTINE setSparsity_3 END INTERFACE INTERFACE setSparsity MODULE PROCEDURE setSparsity_1 , setSparsity_2 , setSparsity_3 END INTERFACE setSparsity PUBLIC :: setSparsity !---------------------------------------------------------------------------- !                                                         setValue@setMethod !---------------------------------------------------------------------------- INTERFACE !! This subroutine set the value in `sparsematrix_` !> authors: Dr. Vikas Sharma ! ! This subroutine sets the value in `sparsematrix_` ! - Shape( Val ) = [SIZE(Nptrs)*tdof, SIZE(Nptrs)*tdof] ! - Usually `Val` denotes the element matrix ! - Symbolic we are performing following task `Obj(Nptrs, Nptrs)=Val` MODULE PURE SUBROUTINE setValueInternally ( Obj , Nptrs , Val ) TYPE ( SparseMatrix_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Nptrs ( : ) REAL ( DFP ), INTENT ( IN ) :: Val ( :, : ) END SUBROUTINE setValueInternally END INTERFACE INTERFACE !! This subroutine set the value in sparse matrix !> authors: Dr. Vikas Sharma ! ! This subroutine sets the values in sparse matrix ! - Usually `Val(:,:)` represents the elemental finite element matrix ! - `StorageFMT` denotes the storage format of Val; `Nodes_FMT` or `DOF_FMT` ! - Usually finite element matrix is stored with `DOF_FMT` ! ! ### Usage ! ```fortran ! program main !   use easifem !   implicit none !   type( sparsematrix_ ) :: obj !   real( dfp ), allocatable :: val( :, : ) !   call initiate( obj = obj, tdof = 2, tnodes = [8], storageFMT=DOF_FMT ) !   call setsparsity( obj = obj, row = 1, col = [1,2,7] ) !   call setsparsity( obj = obj, row = 2, col = [2,1,3,6,7,8] ) !   call setsparsity( obj = obj, row = 3, col = [3, 2, 4, 8] ) !   call setsparsity( obj = obj, row = 4, col = [4,3,5,8] ) !   call setsparsity( obj = obj, row = 5, col = [5,4,6,8] ) !   call setsparsity( obj = obj, row = 6, col = [6,2,5,7,8] ) !   call setsparsity( obj = obj, row = 7, col = [7,1,2,6] ) !   call setsparsity( obj = obj, row = 8, col = [8,2,3,4,5,6] ) !   call setsparsity( obj = obj ) !   allocate( val( 6, 6 ) ) !   call RANDOM_NUMBER( val ) !   call display( val, \"val\") !   call setValue( obj=obj, nptrs=[1,2,7], val=val, storageFMT=DOF_FMT ) !   call display( obj, \"obj\" ) ! end program main ! ``` MODULE PURE SUBROUTINE setValue_1 ( Obj , Nptrs , Val , StorageFMT ) TYPE ( SparseMatrix_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Nptrs ( : ) INTEGER ( I4B ), INTENT ( IN ) :: StorageFMT REAL ( DFP ), INTENT ( IN ) :: Val ( :, : ) END SUBROUTINE setValue_1 END INTERFACE INTERFACE !! This subroutine set all values of [[sparsematrix_]] to given scalar value !> authors: Dr. Vikas Sharma ! ! This subroutine set all values of [[sparsematrix_]] to a given scalar value MODULE PURE SUBROUTINE setValue_2 ( Obj , Val ) TYPE ( SparseMatrix_ ), INTENT ( INOUT ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Val END SUBROUTINE setValue_2 END INTERFACE INTERFACE setValue MODULE PROCEDURE setValue_1 , setValue_2 END INTERFACE setValue PUBLIC :: setValue !---------------------------------------------------------------------------- !                                                  addContribution@setMethod !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE addContributionInternally ( Obj , Nptrs , Val , Scale ) TYPE ( SparseMatrix_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Nptrs ( : ) REAL ( DFP ), INTENT ( IN ) :: Val ( :, : ), Scale END SUBROUTINE addContributionInternally END INTERFACE INTERFACE MODULE PURE SUBROUTINE addContribution_1 ( Obj , Nptrs , Val , Scale , StorageFMT ) TYPE ( SparseMatrix_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Nptrs ( : ), StorageFMT REAL ( DFP ), INTENT ( IN ) :: Val ( :, : ), Scale END SUBROUTINE addContribution_1 END INTERFACE INTERFACE addContribution MODULE PROCEDURE addContribution_1 END INTERFACE addContribution PUBLIC :: addContribution !---------------------------------------------------------------------------- !                                                              Convert@Unary !---------------------------------------------------------------------------- INTERFACE !! This subroutine converts sparsematrix to dense storage !> authors: Dr. Vikas Sharma ! ! This subroutine converts sparsematrix to dense storage format ! `A(:), IA(:), JA(:)` denotes CSR format. ! MODULE PURE SUBROUTINE aij_convert_dns ( A , IA , JA , mat ) REAL ( DFP ), INTENT ( IN ) :: A ( : ) INTEGER ( I4B ), INTENT ( IN ) :: IA ( : ), JA ( : ) REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: mat ( :, : ) END SUBROUTINE aij_convert_dns END INTERFACE INTERFACE MODULE PURE SUBROUTINE obj_convert_dns ( From , To ) TYPE ( SparseMatrix_ ), INTENT ( IN ) :: From REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: To ( :, : ) END SUBROUTINE obj_convert_dns END INTERFACE INTERFACE Convert MODULE PROCEDURE aij_convert_dns , obj_convert_dns END INTERFACE Convert PUBLIC :: Convert !---------------------------------------------------------------------------- !                                                                 SORT@Unary !---------------------------------------------------------------------------- !<--- From sparsekit lib of SAAD !<--- If Sortvalues = .true. Obj % A will also be sorted in increasing order INTERFACE MODULE SUBROUTINE csort_CSR ( Obj , Values ) TYPE ( SparseMatrix_ ), INTENT ( INOUT ) :: Obj LOGICAL ( LGT ), INTENT ( IN ), OPTIONAL :: Values END SUBROUTINE csort_CSR END INTERFACE INTERFACE ColSORT MODULE PROCEDURE csort_CSR END INTERFACE ColSORT PUBLIC :: ColSORT !---------------------------------------------------------------------------- !                                                      RemoveDuplicates@Unary !---------------------------------------------------------------------------- !<--- From sparsekit lib of SAAD !<--- If values = .true. then remove the corresponding values too INTERFACE MODULE SUBROUTINE remove_duplicates_csr ( Obj , Values ) TYPE ( SparseMatrix_ ), INTENT ( INOUT ) :: Obj LOGICAL ( LGT ), INTENT ( IN ), OPTIONAL :: Values END SUBROUTINE remove_duplicates_csr END INTERFACE INTERFACE RemoveDuplicates MODULE PROCEDURE remove_duplicates_csr END INTERFACE RemoveDuplicates PUBLIC :: RemoveDuplicates !---------------------------------------------------------------------------- !                                                                Clean@Unary !---------------------------------------------------------------------------- !<--- From sparsekit lib of SAAD !<--- extraoption 0 do nothing !<---    1 eliminate duplicates and zeros !<---    2 eliminate duplicates and perform partial ordering !<---    3 eliminate duplicates and sort entries in increasing order of !<---    col indices !<--- Values  .true. work on Obj % A too, otherwise dont touch Obj % A !<--- INDU contains pointers to upper triangle INTERFACE MODULE SUBROUTINE clean_CSR ( Obj , Values , ExtraOption , INDU ) TYPE ( SparseMatrix_ ), INTENT ( INOUT ) :: Obj LOGICAL ( LGT ), INTENT ( IN ) :: Values INTEGER ( I4B ), INTENT ( IN ) :: ExtraOption INTEGER ( I4B ), ALLOCATABLE , INTENT ( INOUT ) :: INDU ( : ) END SUBROUTINE clean_CSR END INTERFACE INTERFACE Clean MODULE PROCEDURE clean_CSR END INTERFACE Clean PUBLIC :: Clean !---------------------------------------------------------------------------- !                                                                 Copy@Unary !---------------------------------------------------------------------------- !<--- From sparsekit lib of SAAD !<--- If Values .true. then copy Values also INTERFACE MODULE SUBROUTINE copy_CSR_CSR ( From , To , Values ) TYPE ( SparseMatrix_ ), INTENT ( IN ) :: From TYPE ( SparseMatrix_ ), INTENT ( INOUT ) :: To LOGICAL ( LGT ), OPTIONAL , INTENT ( IN ) :: Values END SUBROUTINE copy_CSR_CSR END INTERFACE INTERFACE Copy MODULE PROCEDURE copy_CSR_CSR END INTERFACE Copy PUBLIC :: Copy !---------------------------------------------------------------------------- !                                                          ArrayValues@Unary !---------------------------------------------------------------------------- !<--- From sparsekit lib of SAAD INTERFACE MODULE FUNCTION get_scalar_value ( Obj , i , j , Sorted ) RESULT ( Ans ) TYPE ( SparseMatrix_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: i , j LOGICAL ( LGT ), OPTIONAL , INTENT ( IN ) :: Sorted REAL ( DFP ) :: Ans END FUNCTION get_scalar_value END INTERFACE INTERFACE ArrayValues MODULE PROCEDURE get_scalar_value END INTERFACE ArrayValues PUBLIC :: ArrayValues !---------------------------------------------------------------------------- !                                                              Matvec@MatVec !---------------------------------------------------------------------------- !<--- From sparsekit lib of SAAD !<--- call to AMUX and ATMUXR ! y = Ax INTERFACE MODULE SUBROUTINE matvec_CSR_amux ( Obj , x , y , matvectype ) TYPE ( SparseMatrix_ ), INTENT ( IN ) :: Obj REAL ( DFP ), INTENT ( IN ) :: x ( : ) REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: y ( : ) CHARACTER ( LEN = * ), INTENT ( IN ) :: matvectype END SUBROUTINE matvec_CSR_amux END INTERFACE INTERFACE MatVec MODULE PROCEDURE matvec_CSR_amux END INTERFACE MatVec PUBLIC :: MatVec !---------------------------------------------------------------------------- !                                                              Matmul@MatVec !---------------------------------------------------------------------------- !<--- From sparsekit lib of SAAD !<--- call to AMUX and ATMUXR ! y = Ax INTERFACE MODULE FUNCTION matmul_CSR ( Obj , x , matvectype ) RESULT ( Ans ) TYPE ( SparseMatrix_ ), INTENT ( IN ) :: Obj REAL ( DFP ), INTENT ( IN ) :: x ( : ) CHARACTER ( LEN = * ), INTENT ( IN ) :: matvectype REAL ( DFP ) :: Ans ( SIZE ( x ) ) END FUNCTION matmul_CSR END INTERFACE INTERFACE Matmul MODULE PROCEDURE matmul_CSR END INTERFACE Matmul PUBLIC :: Matmul !---------------------------------------------------------------------------- !                                                    Sparsekit_LSolve@MatVec !---------------------------------------------------------------------------- !<--- From sparsekit lib of SAAD !<--- Here L is lower triangular matrix with unit diag in CSR format !<--- Solve Lx = y by forward elimination technique will be used INTERFACE MODULE SUBROUTINE lsol_csr ( Obj , x , y ) TYPE ( SparseMatrix_ ), INTENT ( IN ) :: Obj REAL ( DFP ), INTENT ( IN ) :: y ( : ) REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: x ( : ) END SUBROUTINE lsol_csr END INTERFACE INTERFACE Sparsekit_LSolve MODULE PROCEDURE lsol_csr END INTERFACE Sparsekit_LSolve PUBLIC :: Sparsekit_LSolve !---------------------------------------------------------------------------- !                                                    Sparsekit_USolve@MatVec !---------------------------------------------------------------------------- !<--- From sparsekit lib of SAAD !<--- Here U is upper triangular matrix with unit diag in CSR format !<--- Solve Ux = y by backward elimination technique will be used INTERFACE MODULE SUBROUTINE usol_csr ( Obj , x , y ) TYPE ( SparseMatrix_ ), INTENT ( IN ) :: Obj REAL ( DFP ), INTENT ( IN ) :: y ( : ) REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: x ( : ) END SUBROUTINE usol_csr END INTERFACE INTERFACE Sparsekit_USolve MODULE PROCEDURE usol_csr END INTERFACE Sparsekit_USolve PUBLIC :: Sparsekit_USolve !---------------------------------------------------------------------------- !                                                                   ILUT@ILUT !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE ilut_csr ( Obj , alu , jlu , ju , ierr , droptol , lfil ) TYPE ( SparseMatrix_ ), INTENT ( IN ) :: Obj REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: alu ( : ) INTEGER ( I4B ), ALLOCATABLE , INTENT ( INOUT ) :: jlu ( : ), ju ( : ) INTEGER ( I4B ), INTENT ( INOUT ) :: ierr REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: droptol INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: lfil END SUBROUTINE ilut_csr END INTERFACE INTERFACE SparseKit_ILUT MODULE PROCEDURE ilut_csr END INTERFACE SparseKit_ILUT PUBLIC :: Sparsekit_ILUT !---------------------------------------------------------------------------- !                                                                  ILUTP@ILUT !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE ilutp_csr ( Obj , alu , jlu , ju , iperm , ierr , droptol , & & permtol , lfil , mbloc ) TYPE ( SparseMatrix_ ), INTENT ( INOUT ) :: Obj REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: alu ( : ) INTEGER ( I4B ), ALLOCATABLE , INTENT ( INOUT ) :: jlu ( : ), ju ( : ), iperm ( : ) INTEGER ( I4B ), INTENT ( INOUT ) :: ierr REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: droptol , permtol INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: lfil , mbloc END SUBROUTINE ilutp_csr END INTERFACE INTERFACE SparseKit_ilutp MODULE PROCEDURE ilutp_csr END INTERFACE SparseKit_ilutp PUBLIC :: Sparsekit_ilutp !---------------------------------------------------------------------------- !                                                                   ILUD@ILUT !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE ilud_csr ( Obj , alu , jlu , ju , ierr , alpha , droptol ) TYPE ( SparseMatrix_ ), INTENT ( IN ) :: Obj REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: alu ( : ) INTEGER ( I4B ), ALLOCATABLE , INTENT ( INOUT ) :: jlu ( : ), ju ( : ) INTEGER ( I4B ), INTENT ( INOUT ) :: ierr REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: droptol , alpha END SUBROUTINE ilud_csr END INTERFACE INTERFACE SparseKit_ilud MODULE PROCEDURE ilud_csr END INTERFACE SparseKit_ilud PUBLIC :: Sparsekit_ilud !---------------------------------------------------------------------------- !                                                                 ILUdP@ILUT !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE iludp_csr ( Obj , alu , jlu , ju , iperm , ierr , droptol , & & permtol , alpha , mbloc ) TYPE ( SparseMatrix_ ), INTENT ( INOUT ) :: Obj REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: alu ( : ) INTEGER ( I4B ), ALLOCATABLE , INTENT ( INOUT ) :: jlu ( : ), ju ( : ), iperm ( : ) INTEGER ( I4B ), INTENT ( INOUT ) :: ierr REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: droptol , permtol , alpha INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: mbloc END SUBROUTINE iludp_csr END INTERFACE INTERFACE SparseKit_iludp MODULE PROCEDURE iludp_csr END INTERFACE SparseKit_iludp PUBLIC :: Sparsekit_iludp !---------------------------------------------------------------------------- !                                                      Sparsekit_LUSOLVE@ILUT !---------------------------------------------------------------------------- ! LUx = y INTERFACE MODULE SUBROUTINE lusol_alu ( x , y , alu , jlu , ju ) REAL ( DFP ), INTENT ( IN ) :: y ( : ), alu ( : ) REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: x ( : ) INTEGER ( I4B ), INTENT ( IN ) :: jlu ( : ), ju ( : ) END SUBROUTINE lusol_alu END INTERFACE INTERFACE Sparsekit_LUSOLVE MODULE PROCEDURE lusol_alu END INTERFACE Sparsekit_LUSOLVE PUBLIC :: Sparsekit_LUSOLVE !---------------------------------------------------------------------------- !                                                     Sparsekit_LUTSOLVE@ILUT !---------------------------------------------------------------------------- !(LU)&#94;T x = y INTERFACE MODULE SUBROUTINE lutsol_alu ( x , y , alu , jlu , ju ) REAL ( DFP ), INTENT ( IN ) :: y ( : ), alu ( : ) REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: x ( : ) INTEGER ( I4B ), INTENT ( IN ) :: jlu ( : ), ju ( : ) END SUBROUTINE lutsol_alu END INTERFACE INTERFACE Sparsekit_LUTSOLVE MODULE PROCEDURE lutsol_alu END INTERFACE Sparsekit_LUTSOLVE PUBLIC :: Sparsekit_LUTSOLVE !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- CONTAINS #include \"contains.part\" END MODULE SparseMatrix_Method","tags":"","loc":"sourcefile/sparsematrix_method.f90.html"},{"title":"BoundingBox_Method.f90 – Fortran Program","text":"Contents Modules BoundingBox_Method Source Code BoundingBox_Method.f90 Source Code MODULE BoundingBox_Method USE GlobalData USE IO USE BaseType IMPLICIT NONE PRIVATE !---------------------------------------------------------------------------- !                                                        Initiate@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE initiate_1 ( Obj , nsd , lim ) CLASS ( BoundingBox_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: NSD REAL ( DFP ), INTENT ( IN ) :: lim ( 6 ) END SUBROUTINE initiate_1 END INTERFACE INTERFACE MODULE PURE SUBROUTINE initiate_2 ( Obj , AnotherObj ) CLASS ( BoundingBox_ ), INTENT ( INOUT ) :: Obj CLASS ( BoundingBox_ ), INTENT ( IN ) :: AnotherObj END SUBROUTINE initiate_2 END INTERFACE INTERFACE Initiate MODULE PROCEDURE initiate_1 , initiate_2 END INTERFACE Initiate PUBLIC :: Initiate !---------------------------------------------------------------------------- !                                                     BoundingBox@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION Constructor1 ( nsd , lim ) RESULT ( Ans ) TYPE ( BoundingBox_ ) :: Ans INTEGER ( I4B ), INTENT ( IN ) :: nsd REAL ( DFP ), INTENT ( IN ) :: lim ( 6 ) END FUNCTION Constructor1 END INTERFACE !---------------------------------------------------------------------------- !                                                                BoundingBox !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION Constructor2 ( AnotherObj ) RESULT ( Ans ) TYPE ( BoundingBox_ ) :: Ans CLASS ( BoundingBox_ ), INTENT ( IN ) :: AnotherObj END FUNCTION Constructor2 END INTERFACE !---------------------------------------------------------------------------- !                                                                BoundingBox !---------------------------------------------------------------------------- INTERFACE !! Return the bouding box for a given set of coordinates !> authors: Dr. Vikas Sharma ! ! Return the bouding box for a given set of coordinates ! !### Usage ! ! ```fortran !\tbbox = BoundingBox( XiJ ) ! ``` MODULE PURE FUNCTION Constructor3 ( xij ) RESULT ( Ans ) REAL ( DFP ), INTENT ( IN ) :: xij ( :, : ) !! Nodal coordinates xij( 1:nsd, 1:tnodes ) TYPE ( BoundingBox_ ) :: Ans END FUNCTION Constructor3 END INTERFACE !---------------------------------------------------------------------------- !                                                                 BoundingBox !---------------------------------------------------------------------------- INTERFACE BoundingBox MODULE PROCEDURE Constructor1 , Constructor2 , Constructor3 END INTERFACE BoundingBox PUBLIC :: BoundingBox !---------------------------------------------------------------------------- !                                             BoundingBox_Pointer@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE FUNCTION Constructor_1 ( nsd , lim ) RESULT ( Ans ) CLASS ( BoundingBox_ ), POINTER :: Ans INTEGER ( I4B ), INTENT ( IN ) :: nsd REAL ( DFP ), INTENT ( IN ) :: lim ( 6 ) END FUNCTION Constructor_1 END INTERFACE INTERFACE MODULE FUNCTION Constructor_2 ( AnotherObj ) RESULT ( Ans ) CLASS ( BoundingBox_ ), POINTER :: Ans CLASS ( BoundingBox_ ), INTENT ( IN ) :: AnotherObj END FUNCTION Constructor_2 END INTERFACE INTERFACE BoundingBox_Pointer MODULE PROCEDURE Constructor_1 , Constructor_2 END INTERFACE BoundingBox_Pointer PUBLIC :: BoundingBox_Pointer !---------------------------------------------------------------------------- !                                                        Display@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE display_obj ( Obj , msg , unitno ) CLASS ( BoundingBox_ ), INTENT ( IN ) :: Obj CHARACTER ( LEN = * ), INTENT ( IN ) :: msg INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: unitNo END SUBROUTINE display_obj END INTERFACE INTERFACE Display MODULE PROCEDURE display_obj END INTERFACE Display PUBLIC :: Display !---------------------------------------------------------------------------- !                                                                        set !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE setXmin ( Obj , Val ) CLASS ( BoundingBox_ ), INTENT ( INOUT ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Val END SUBROUTINE setXmin END INTERFACE INTERFACE MODULE PURE SUBROUTINE setXmax ( Obj , Val ) CLASS ( BoundingBox_ ), INTENT ( INOUT ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Val END SUBROUTINE setXmax END INTERFACE INTERFACE MODULE PURE SUBROUTINE setYmin ( Obj , Val ) CLASS ( BoundingBox_ ), INTENT ( INOUT ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Val END SUBROUTINE setYmin END INTERFACE INTERFACE MODULE PURE SUBROUTINE setYmax ( Obj , Val ) CLASS ( BoundingBox_ ), INTENT ( INOUT ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Val END SUBROUTINE setYmax END INTERFACE INTERFACE MODULE PURE SUBROUTINE setZmin ( Obj , Val ) CLASS ( BoundingBox_ ), INTENT ( INOUT ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Val END SUBROUTINE setZmin END INTERFACE INTERFACE MODULE PURE SUBROUTINE setZmax ( Obj , Val ) CLASS ( BoundingBox_ ), INTENT ( INOUT ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Val END SUBROUTINE setZmax END INTERFACE !---------------------------------------------------------------------------- !                                                                       get !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION getXmin ( Obj ) RESULT ( Ans ) CLASS ( BoundingBox_ ), INTENT ( IN ) :: Obj REAL ( DFP ) :: Ans END FUNCTION getXmin END INTERFACE INTERFACE Operator ( . Xmin . ) MODULE PROCEDURE getXmin END INTERFACE Operator ( . Xmin . ) PUBLIC :: Operator ( . Xmin . ) INTERFACE MODULE PURE FUNCTION getXmax ( Obj ) RESULT ( Ans ) CLASS ( BoundingBox_ ), INTENT ( IN ) :: Obj REAL ( DFP ) :: Ans END FUNCTION getXmax END INTERFACE INTERFACE Operator ( . Xmax . ) MODULE PROCEDURE getXmax END INTERFACE Operator ( . Xmax . ) PUBLIC :: Operator ( . Xmax . ) INTERFACE MODULE PURE FUNCTION getYmin ( Obj ) RESULT ( Ans ) CLASS ( BoundingBox_ ), INTENT ( IN ) :: Obj REAL ( DFP ) :: Ans END FUNCTION getYmin END INTERFACE INTERFACE Operator ( . Ymin . ) MODULE PROCEDURE getYmin END INTERFACE Operator ( . Ymin . ) PUBLIC :: Operator ( . Ymin . ) INTERFACE MODULE PURE FUNCTION getYmax ( Obj ) RESULT ( Ans ) CLASS ( BoundingBox_ ), INTENT ( IN ) :: Obj REAL ( DFP ) :: Ans END FUNCTION getYmax END INTERFACE INTERFACE Operator ( . Ymax . ) MODULE PROCEDURE getYmax END INTERFACE Operator ( . Ymax . ) PUBLIC :: Operator ( . Ymax . ) INTERFACE MODULE PURE FUNCTION getZmin ( Obj ) RESULT ( Ans ) CLASS ( BoundingBox_ ), INTENT ( IN ) :: Obj REAL ( DFP ) :: Ans END FUNCTION getZmin END INTERFACE INTERFACE Operator ( . Zmin . ) MODULE PROCEDURE getZmin END INTERFACE Operator ( . Zmin . ) PUBLIC :: Operator ( . Zmin . ) INTERFACE MODULE PURE FUNCTION getZmax ( Obj ) RESULT ( Ans ) CLASS ( BoundingBox_ ), INTENT ( IN ) :: Obj REAL ( DFP ) :: Ans END FUNCTION getZmax END INTERFACE INTERFACE Operator ( . Zmax . ) MODULE PROCEDURE getZmax END INTERFACE Operator ( . Zmax . ) PUBLIC :: Operator ( . Zmax . ) !---------------------------------------------------------------------------- !                                                          is_intersect_in_X !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION is_intersect_in_X ( Obj , Obj2 ) RESULT ( Ans ) CLASS ( BoundingBox_ ), INTENT ( IN ) :: Obj , Obj2 LOGICAL ( LGT ) :: Ans END FUNCTION is_intersect_in_X END INTERFACE INTERFACE isIntersectInX MODULE PROCEDURE is_intersect_in_X END INTERFACE isIntersectInX PUBLIC :: isIntersectInX !---------------------------------------------------------------------------- !                                                           is_intersect_in_Y !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION is_intersect_in_Y ( Obj , Obj2 ) RESULT ( Ans ) CLASS ( BoundingBox_ ), INTENT ( IN ) :: Obj , Obj2 LOGICAL ( LGT ) :: Ans END FUNCTION is_intersect_in_Y END INTERFACE INTERFACE isIntersectInY MODULE PROCEDURE is_intersect_in_Y END INTERFACE isIntersectInY PUBLIC :: isIntersectInY !---------------------------------------------------------------------------- !                                                          is_intersect_in_Z !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION is_intersect_in_Z ( Obj , Obj2 ) RESULT ( Ans ) CLASS ( BoundingBox_ ), INTENT ( IN ) :: Obj , Obj2 LOGICAL ( LGT ) :: Ans END FUNCTION is_intersect_in_Z END INTERFACE INTERFACE isIntersectInZ MODULE PROCEDURE is_intersect_in_Z END INTERFACE isIntersectInZ PUBLIC :: isIntersectInZ !---------------------------------------------------------------------------- !                                                                isIntersect !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION is_intersect ( Obj , Obj2 ) RESULT ( Ans ) CLASS ( BoundingBox_ ), INTENT ( IN ) :: Obj , Obj2 LOGICAL ( LGT ) :: Ans END FUNCTION is_intersect END INTERFACE INTERFACE Operator ( . isIntersect . ) MODULE PROCEDURE is_intersect END INTERFACE Operator ( . isIntersect . ) PUBLIC :: Operator ( . isIntersect . ) INTERFACE isIntersect MODULE PROCEDURE is_intersect END INTERFACE isIntersect PUBLIC :: isIntersect !---------------------------------------------------------------------------- !                                                            getIntersection !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION get_intersection ( Obj , Obj2 ) RESULT ( Ans ) CLASS ( BoundingBox_ ), INTENT ( IN ) :: Obj , Obj2 TYPE ( BoundingBox_ ) :: Ans END FUNCTION get_intersection END INTERFACE INTERFACE OPERATOR ( . Intersection . ) MODULE PROCEDURE get_intersection END INTERFACE OPERATOR ( . Intersection . ) PUBLIC :: OPERATOR ( . Intersection . ) INTERFACE Intersection MODULE PROCEDURE get_intersection END INTERFACE Intersection PUBLIC :: Intersection !---------------------------------------------------------------------------- !                                                                 getUnion !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION get_Union ( Obj , Obj2 ) RESULT ( Ans ) CLASS ( BoundingBox_ ), INTENT ( IN ) :: Obj , Obj2 TYPE ( BoundingBox_ ) :: Ans END FUNCTION get_Union END INTERFACE INTERFACE OPERATOR (. UNION .) MODULE PROCEDURE get_Union END INTERFACE OPERATOR (. UNION .) PUBLIC :: OPERATOR (. UNION .) INTERFACE Union MODULE PROCEDURE get_Union END INTERFACE Union PUBLIC :: Union !---------------------------------------------------------------------------- !                                                                 getCenter !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION get_Center ( Obj ) RESULT ( Ans ) CLASS ( BoundingBox_ ), INTENT ( IN ) :: Obj REAL ( DFP ) :: Ans ( 3 ) END FUNCTION get_Center END INTERFACE INTERFACE Center MODULE PROCEDURE get_Center END INTERFACE Center PUBLIC :: Center INTERFACE OPERATOR (. Center .) MODULE PROCEDURE get_Center END INTERFACE OPERATOR (. Center .) PUBLIC :: OPERATOR (. Center .) !---------------------------------------------------------------------------- !                                                                  isInside !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION is_Inside ( Obj , Val ) RESULT ( Ans ) CLASS ( BoundingBox_ ), INTENT ( IN ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Val ( : ) LOGICAL ( LGT ) :: Ans END FUNCTION is_Inside END INTERFACE INTERFACE OPERATOR ( . isInside . ) MODULE PROCEDURE is_Inside END INTERFACE OPERATOR ( . isInside . ) PUBLIC :: OPERATOR ( . isInside . ) INTERFACE isInside MODULE PROCEDURE is_Inside END INTERFACE isInside PUBLIC :: isInside !---------------------------------------------------------------------------- !                                                                  getNptrs !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION get_nptrs ( Obj , xij ) RESULT ( Ans ) CLASS ( BoundingBox_ ), INTENT ( IN ) :: Obj REAL ( DFP ), INTENT ( IN ) :: xij ( :, : ) INTEGER ( I4B ), ALLOCATABLE :: Ans ( : ) END FUNCTION get_nptrs END INTERFACE INTERFACE OPERATOR ( . Nptrs . ) MODULE PROCEDURE get_nptrs END INTERFACE PUBLIC :: OPERATOR ( . Nptrs . ) !---------------------------------------------------------------------------- !                                                                    Contains !---------------------------------------------------------------------------- END MODULE BoundingBox_Method","tags":"","loc":"sourcefile/boundingbox_method.f90.html"},{"title":"ReferenceElement_Method.f90 – Fortran Program","text":"Contents Modules ReferenceElement_Method Source Code ReferenceElement_Method.f90 Source Code MODULE ReferenceElement_Method USE BaseType USE GlobalData IMPLICIT NONE PRIVATE !---------------------------------------------------------------------------- !                                              ReferenceTopology@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION reference_topology ( Nptrs , Name ) RESULT ( Obj ) TYPE ( ReferenceTopology_ ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Nptrs ( : ), Name END FUNCTION reference_topology END INTERFACE INTERFACE ReferenceTopology MODULE PROCEDURE reference_topology END INTERFACE ReferenceTopology PUBLIC :: ReferenceTopology !---------------------------------------------------------------------------- !                                                 DeallocateData@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE deallocatedata_ref_topology ( Obj ) CLASS ( ReferenceTopology_ ), INTENT ( INOUT ) :: Obj END SUBROUTINE deallocatedata_ref_topology END INTERFACE INTERFACE DeallocateData MODULE PROCEDURE deallocatedata_ref_topology END INTERFACE PUBLIC :: DeallocateData !---------------------------------------------------------------------------- !                                                           NNE@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION tNodes_RefTopo ( Obj ) RESULT ( Ans ) CLASS ( ReferenceTopology_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ) :: Ans END FUNCTION tNodes_RefTopo MODULE PURE FUNCTION tNodes_RefElem ( Obj ) RESULT ( Ans ) CLASS ( ReferenceElement_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ) :: Ans END FUNCTION tNodes_RefElem END INTERFACE INTERFACE OPERATOR ( . NNE . ) MODULE PROCEDURE tNodes_RefTopo , tNodes_RefElem END INTERFACE PUBLIC :: OPERATOR ( . NNE . ) !---------------------------------------------------------------------------- !                                                 DeallocateData@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE deallocatedata_ref_elem ( Obj ) CLASS ( ReferenceElement_ ), INTENT ( INOUT ) :: Obj END SUBROUTINE deallocatedata_ref_elem END INTERFACE INTERFACE DeallocateData MODULE PROCEDURE deallocatedata_ref_elem END INTERFACE !---------------------------------------------------------------------------- !                                                       Display@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE display_ref_elem ( Obj , msg , unitno ) CLASS ( ReferenceElement_ ), INTENT ( IN ) :: Obj CHARACTER ( LEN = * ), INTENT ( IN ) :: msg INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: unitno END SUBROUTINE display_ref_elem MODULE SUBROUTINE display_ref_topo ( Obj , msg , unitno ) CLASS ( ReferenceTopology_ ), INTENT ( IN ) :: Obj CHARACTER ( LEN = * ), INTENT ( IN ) :: msg INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: unitno END SUBROUTINE display_ref_topo END INTERFACE INTERFACE Display MODULE PROCEDURE display_ref_elem , display_ref_topo END INTERFACE Display PUBLIC :: Display !---------------------------------------------------------------------------- !                                                       Initiate@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE init_refelem ( Obj , AnotherObj ) CLASS ( ReferenceElement_ ), INTENT ( INOUT ) :: Obj CLASS ( ReferenceElement_ ), INTENT ( IN ) :: AnotherObj END SUBROUTINE init_refelem END INTERFACE INTERFACE Initiate MODULE PROCEDURE init_refelem END INTERFACE Initiate PUBLIC :: Initiate INTERFACE ASSIGNMENT ( = ) MODULE PROCEDURE init_refelem END INTERFACE PUBLIC :: ASSIGNMENT ( = ) !---------------------------------------------------------------------------- !                                                       Initiate@Constructor !---------------------------------------------------------------------------- INTERFACE !  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ! 1. Subroutine for constructing linear reference line object !  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . MODULE PURE SUBROUTINE initiate_ref_Line ( Obj , NSD , XiJ ) CLASS ( ReferenceLine_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: NSD REAL ( DFP ), INTENT ( IN ), OPTIONAL :: XiJ ( :, : ) END SUBROUTINE initiate_ref_Line END INTERFACE INTERFACE Initiate MODULE PROCEDURE initiate_ref_Line END INTERFACE Initiate !---------------------------------------------------------------------------- !                                                 ReferenceLine@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION reference_line ( NSD , XiJ ) RESULT ( Obj ) INTEGER ( I4B ), INTENT ( IN ) :: NSD REAL ( DFP ), INTENT ( IN ), OPTIONAL :: XiJ (:,:) TYPE ( ReferenceLine_ ) :: Obj END FUNCTION reference_line END INTERFACE INTERFACE ReferenceLine MODULE PROCEDURE reference_line END INTERFACE ReferenceLine INTERFACE ReferenceLine_Pointer MODULE PROCEDURE reference_line_Pointer END INTERFACE ReferenceLine_Pointer PUBLIC :: ReferenceLine , ReferenceLine_Pointer !---------------------------------------------------------------------------- !                                                       Initiate@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE initiate_ref_Triangle ( Obj , NSD , XiJ ) CLASS ( ReferenceTriangle_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: NSD REAL ( DFP ), INTENT ( IN ), OPTIONAL :: XiJ ( :, : ) END SUBROUTINE initiate_ref_Triangle END INTERFACE INTERFACE Initiate MODULE PROCEDURE initiate_ref_Triangle END INTERFACE Initiate !---------------------------------------------------------------------------- !                                             ReferenceTriangle@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION reference_Triangle ( NSD , XiJ ) RESULT ( Obj ) INTEGER ( I4B ), INTENT ( IN ) :: NSD REAL ( DFP ), INTENT ( IN ), OPTIONAL :: XiJ (:,:) TYPE ( ReferenceTriangle_ ) :: Obj END FUNCTION reference_Triangle END INTERFACE INTERFACE ReferenceTriangle MODULE PROCEDURE reference_Triangle END INTERFACE ReferenceTriangle INTERFACE ReferenceTriangle_Pointer MODULE PROCEDURE reference_Triangle_Pointer END INTERFACE ReferenceTriangle_Pointer PUBLIC :: ReferenceTriangle , ReferenceTriangle_Pointer !---------------------------------------------------------------------------- !                                                       Initiate@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE initiate_ref_Quadrangle ( Obj , NSD , XiJ ) CLASS ( ReferenceQuadrangle_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: NSD REAL ( DFP ), INTENT ( IN ), OPTIONAL :: XiJ ( :, : ) END SUBROUTINE initiate_ref_Quadrangle END INTERFACE INTERFACE Initiate MODULE PROCEDURE initiate_ref_Quadrangle END INTERFACE Initiate !---------------------------------------------------------------------------- !                                            ReferenceQuadrangle@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION reference_Quadrangle ( NSD , XiJ ) RESULT ( Obj ) INTEGER ( I4B ), INTENT ( IN ) :: NSD REAL ( DFP ), INTENT ( IN ), OPTIONAL :: XiJ (:,:) TYPE ( ReferenceQuadrangle_ ) :: Obj END FUNCTION reference_Quadrangle END INTERFACE INTERFACE ReferenceQuadrangle MODULE PROCEDURE reference_Quadrangle END INTERFACE ReferenceQuadrangle INTERFACE ReferenceQuadrangle_Pointer MODULE PROCEDURE reference_Quadrangle_Pointer END INTERFACE ReferenceQuadrangle_Pointer PUBLIC :: ReferenceQuadrangle , ReferenceQuadrangle_Pointer !---------------------------------------------------------------------------- !                                                       Initiate@Constructor !---------------------------------------------------------------------------- INTERFACE !  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ! 1. Subroutine for constructing the object !  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . MODULE PURE SUBROUTINE initiate_ref_Tetrahedron ( Obj , NSD , XiJ ) CLASS ( ReferenceTetrahedron_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: NSD REAL ( DFP ), INTENT ( IN ), OPTIONAL :: XiJ ( :, : ) END SUBROUTINE initiate_ref_Tetrahedron END INTERFACE INTERFACE Initiate MODULE PROCEDURE initiate_ref_Tetrahedron END INTERFACE Initiate !---------------------------------------------------------------------------- !                                            ReferenceTetrahedron@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION reference_Tetrahedron ( NSD , XiJ ) RESULT ( Obj ) INTEGER ( I4B ), INTENT ( IN ) :: NSD REAL ( DFP ), INTENT ( IN ), OPTIONAL :: XiJ (:,:) TYPE ( ReferenceTetrahedron_ ) :: Obj END FUNCTION reference_Tetrahedron END INTERFACE INTERFACE ReferenceTetrahedron MODULE PROCEDURE reference_Tetrahedron END INTERFACE ReferenceTetrahedron INTERFACE ReferenceTetrahedron_Pointer MODULE PROCEDURE reference_Tetrahedron_Pointer END INTERFACE ReferenceTetrahedron_Pointer PUBLIC :: ReferenceTetrahedron , ReferenceTetrahedron_Pointer !---------------------------------------------------------------------------- !                                                       Initiate@Constructor !---------------------------------------------------------------------------- INTERFACE !  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ! 1. Subroutine for constructing the object !  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . MODULE PURE SUBROUTINE initiate_ref_Hexahedron ( Obj , NSD , XiJ ) CLASS ( ReferenceHexahedron_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: NSD REAL ( DFP ), INTENT ( IN ), OPTIONAL :: XiJ ( :, : ) END SUBROUTINE initiate_ref_Hexahedron END INTERFACE INTERFACE Initiate MODULE PROCEDURE initiate_ref_Hexahedron END INTERFACE Initiate !---------------------------------------------------------------------------- !                                            ReferenceHexahedron@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION reference_Hexahedron ( NSD , XiJ ) RESULT ( Obj ) INTEGER ( I4B ), INTENT ( IN ) :: NSD REAL ( DFP ), INTENT ( IN ), OPTIONAL :: XiJ (:,:) TYPE ( ReferenceHexahedron_ ) :: Obj END FUNCTION reference_Hexahedron END INTERFACE INTERFACE ReferenceHexahedron MODULE PROCEDURE reference_Hexahedron END INTERFACE ReferenceHexahedron INTERFACE ReferenceHexahedron_Pointer MODULE PROCEDURE reference_Hexahedron_Pointer END INTERFACE ReferenceHexahedron_Pointer PUBLIC :: ReferenceHexahedron , ReferenceHexahedron_Pointer !---------------------------------------------------------------------------- !                                                       Initiate@Constructor !---------------------------------------------------------------------------- INTERFACE !  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ! 1. Subroutine for constructing the object !  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . MODULE PURE SUBROUTINE initiate_ref_Pyramid ( Obj , NSD , XiJ ) CLASS ( ReferencePyramid_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: NSD REAL ( DFP ), INTENT ( IN ), OPTIONAL :: XiJ ( :, : ) END SUBROUTINE initiate_ref_Pyramid END INTERFACE INTERFACE Initiate MODULE PROCEDURE initiate_ref_Pyramid END INTERFACE Initiate !---------------------------------------------------------------------------- !                                            ReferencePyramid@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION reference_Pyramid ( NSD , XiJ ) RESULT ( Obj ) INTEGER ( I4B ), INTENT ( IN ) :: NSD REAL ( DFP ), INTENT ( IN ), OPTIONAL :: XiJ (:,:) TYPE ( ReferencePyramid_ ) :: Obj END FUNCTION reference_Pyramid END INTERFACE INTERFACE ReferencePyramid MODULE PROCEDURE reference_Pyramid END INTERFACE ReferencePyramid INTERFACE ReferencePyramid_Pointer MODULE PROCEDURE reference_Pyramid_Pointer END INTERFACE ReferencePyramid_Pointer PUBLIC :: ReferencePyramid , ReferencePyramid_Pointer !---------------------------------------------------------------------------- !                                                       Initiate@Constructor !---------------------------------------------------------------------------- INTERFACE !  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . ! 1. Subroutine for constructing the object !  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . MODULE PURE SUBROUTINE initiate_ref_Prism ( Obj , NSD , XiJ ) CLASS ( ReferencePrism_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: NSD REAL ( DFP ), INTENT ( IN ), OPTIONAL :: XiJ ( :, : ) END SUBROUTINE initiate_ref_Prism END INTERFACE INTERFACE Initiate MODULE PROCEDURE initiate_ref_Prism END INTERFACE Initiate !---------------------------------------------------------------------------- !                                                ReferencePrism@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION reference_Prism ( NSD , XiJ ) RESULT ( Obj ) INTEGER ( I4B ), INTENT ( IN ) :: NSD REAL ( DFP ), INTENT ( IN ), OPTIONAL :: XiJ (:,:) TYPE ( ReferencePrism_ ) :: Obj END FUNCTION reference_Prism END INTERFACE INTERFACE ReferencePrism MODULE PROCEDURE reference_Prism END INTERFACE ReferencePrism INTERFACE ReferencePrism_Pointer MODULE PROCEDURE reference_Prism_Pointer END INTERFACE ReferencePrism_Pointer PUBLIC :: ReferencePrism , ReferencePrism_Pointer !---------------------------------------------------------------------------- !                                                    LagrangePoints@Lagrange !---------------------------------------------------------------------------- INTERFACE !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . !   1. Returns equidistant points on [-1,1] for lagrange interpolation !\t\t2, Nodecoord is a 2D array with 3 rows !\t\t3. first row is xi, second row is eta, third row is zeta !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . MODULE PURE FUNCTION EquidistanceLIP_Line ( RefElem , Order ) & & RESULT ( NodeCoord ) CLASS ( ReferenceLine_ ), INTENT ( IN ) :: RefElem INTEGER ( I4B ), INTENT ( IN ) :: Order REAL ( DFP ), ALLOCATABLE :: NodeCoord ( :, : ) END FUNCTION EquidistanceLIP_Line END INTERFACE INTERFACE LagrangePoints MODULE PROCEDURE EquidistanceLIP_Line END INTERFACE LagrangePoints PUBLIC :: LagrangePoints !---------------------------------------------------------------------------- !                                                  LagrangeElement@Lagrange !---------------------------------------------------------------------------- INTERFACE !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . ! Returns lagrange line element of different order !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . MODULE PURE FUNCTION LagrangeElement_Line ( RefElem , Order ) RESULT ( Obj ) CLASS ( ReferenceLine_ ), INTENT ( IN ) :: RefElem INTEGER ( I4B ), INTENT ( IN ) :: Order TYPE ( ReferenceLine_ ) :: Obj END FUNCTION LagrangeElement_Line END INTERFACE INTERFACE LagrangeElement MODULE PROCEDURE LagrangeElement_Line END INTERFACE LagrangeElement PUBLIC :: LagrangeElement !---------------------------------------------------------------------------- !                                                   LagrangePoints@Lagrange !---------------------------------------------------------------------------- INTERFACE !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . !   1. Returns equidistant points on triangle for lagrange interpolation !\t\t2, Nodecoord is a 2D array with 3 rows !\t\t3. first row is xi, second row is eta, third row is zeta !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . MODULE PURE FUNCTION EquidistanceLIP_Triangle ( RefElem , Order ) & & RESULT ( NodeCoord ) CLASS ( ReferenceTriangle_ ), INTENT ( IN ) :: RefElem INTEGER ( I4B ), INTENT ( IN ) :: Order REAL ( DFP ), ALLOCATABLE :: NodeCoord ( :, : ) END FUNCTION EquidistanceLIP_Triangle END INTERFACE INTERFACE LagrangePoints MODULE PROCEDURE EquidistanceLIP_Triangle END INTERFACE !---------------------------------------------------------------------------- !                                                   LagrangeElement@Lagrange !---------------------------------------------------------------------------- INTERFACE !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . ! Returns lagrange Triangle element of different order !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . MODULE PURE FUNCTION LagrangeElement_Triangle ( RefElem , Order ) RESULT ( Obj ) CLASS ( ReferenceTriangle_ ), INTENT ( IN ) :: RefElem INTEGER ( I4B ), INTENT ( IN ) :: Order TYPE ( ReferenceTriangle_ ) :: Obj END FUNCTION LagrangeElement_Triangle END INTERFACE INTERFACE LagrangeElement MODULE PROCEDURE LagrangeElement_Triangle END INTERFACE LagrangeElement !---------------------------------------------------------------------------- !                                                    LagrangePoints@Lagrange !---------------------------------------------------------------------------- INTERFACE !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . !   1. Returns equidistant points on [-1,1] for lagrange interpolation !\t\t2, Nodecoord is a 2D array with 3 rows !\t\t3. first row is xi, second row is eta, third row is zeta !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . MODULE PURE FUNCTION EquidistanceLIP_Quadrangle ( RefElem , Order ) & & RESULT ( NodeCoord ) CLASS ( ReferenceQuadrangle_ ), INTENT ( IN ) :: RefElem INTEGER ( I4B ), INTENT ( IN ) :: Order REAL ( DFP ), ALLOCATABLE :: NodeCoord ( :, : ) END FUNCTION EquidistanceLIP_Quadrangle END INTERFACE INTERFACE LagrangePoints MODULE PROCEDURE EquidistanceLIP_Quadrangle END INTERFACE !---------------------------------------------------------------------------- !                                                   LagrangeElement@Lagrange !---------------------------------------------------------------------------- INTERFACE !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . ! Returns lagrange Quadrangle element of different order !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . MODULE PURE FUNCTION LagrangeElement_Quadrangle ( RefElem , Order ) & & RESULT ( Obj ) CLASS ( ReferenceQuadrangle_ ), INTENT ( IN ) :: RefElem INTEGER ( I4B ), INTENT ( IN ) :: Order TYPE ( ReferenceQuadrangle_ ) :: Obj END FUNCTION LagrangeElement_Quadrangle END INTERFACE INTERFACE LagrangeElement MODULE PROCEDURE LagrangeElement_Quadrangle END INTERFACE LagrangeElement !---------------------------------------------------------------------------- !                                                   LagrangePoints@Lagrange !---------------------------------------------------------------------------- INTERFACE !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . !   1. Returns equidistant points on [-1,1] for lagrange interpolation !\t\t2, Nodecoord is a 2D array with 3 rows !\t\t3. first row is xi, second row is eta, third row is zeta !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . MODULE PURE FUNCTION EquidistanceLIP_Tetrahedron ( RefElem , Order ) & & RESULT ( NodeCoord ) CLASS ( ReferenceTetrahedron_ ), INTENT ( IN ) :: RefElem INTEGER ( I4B ), INTENT ( IN ) :: Order REAL ( DFP ), ALLOCATABLE :: NodeCoord ( :, : ) END FUNCTION EquidistanceLIP_Tetrahedron END INTERFACE INTERFACE LagrangePoints MODULE PROCEDURE EquidistanceLIP_Tetrahedron END INTERFACE !---------------------------------------------------------------------------- !                                                   LagrangeElement@Lagrange !---------------------------------------------------------------------------- INTERFACE !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . ! Returns lagrange Tetrahedron element of different order !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . MODULE PURE FUNCTION LagrangeElement_Tetrahedron ( RefElem , Order ) & & RESULT ( Obj ) CLASS ( ReferenceTetrahedron_ ), INTENT ( IN ) :: RefElem INTEGER ( I4B ), INTENT ( IN ) :: Order TYPE ( ReferenceTetrahedron_ ) :: Obj END FUNCTION LagrangeElement_Tetrahedron END INTERFACE INTERFACE LagrangeElement MODULE PROCEDURE LagrangeElement_Tetrahedron END INTERFACE LagrangeElement !---------------------------------------------------------------------------- !                                                   LagrangePoints@Lagrange !---------------------------------------------------------------------------- INTERFACE !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . !   1. Returns equidistant points on [-1,1] for lagrange interpolation !\t\t2, Nodecoord is a 2D array with 3 rows !\t\t3. first row is xi, second row is eta, third row is zeta !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . MODULE PURE FUNCTION EquidistanceLIP_Prism ( RefElem , Order ) & & RESULT ( NodeCoord ) CLASS ( ReferencePrism_ ), INTENT ( IN ) :: RefElem INTEGER ( I4B ), INTENT ( IN ) :: Order REAL ( DFP ), ALLOCATABLE :: NodeCoord ( :, : ) END FUNCTION EquidistanceLIP_Prism END INTERFACE INTERFACE LagrangePoints MODULE PROCEDURE EquidistanceLIP_Prism END INTERFACE !---------------------------------------------------------------------------- !                                                   LagrangeElement@Lagrange !---------------------------------------------------------------------------- INTERFACE !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . ! Returns lagrange Prism element of different order !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . MODULE PURE FUNCTION LagrangeElement_Prism ( RefElem , Order ) RESULT ( Obj ) CLASS ( ReferencePrism_ ), INTENT ( IN ) :: RefElem INTEGER ( I4B ), INTENT ( IN ) :: Order TYPE ( ReferencePrism_ ) :: Obj END FUNCTION LagrangeElement_Prism END INTERFACE INTERFACE LagrangeElement MODULE PROCEDURE LagrangeElement_Prism END INTERFACE LagrangeElement !---------------------------------------------------------------------------- !                                                   LagrangePoints@Lagrange !---------------------------------------------------------------------------- INTERFACE !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . !   1. Returns equidistant points on [-1,1] for lagrange interpolation !   2, Nodecoord is a 2D array with 3 rows !   3. first row is xi, second row is eta, third row is zeta !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . MODULE PURE FUNCTION EquidistanceLIP_Pyramid ( RefElem , Order ) & & RESULT ( NodeCoord ) CLASS ( ReferencePyramid_ ), INTENT ( IN ) :: RefElem INTEGER ( I4B ), INTENT ( IN ) :: Order REAL ( DFP ), ALLOCATABLE :: NodeCoord ( :, : ) END FUNCTION EquidistanceLIP_Pyramid END INTERFACE INTERFACE LagrangePoints MODULE PROCEDURE EquidistanceLIP_Pyramid END INTERFACE !---------------------------------------------------------------------------- !                                                  LagrangeElement@Lagrange !---------------------------------------------------------------------------- INTERFACE !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . ! Returns lagrange Pyramid element of different order !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . MODULE PURE FUNCTION LagrangeElement_Pyramid ( RefElem , Order ) RESULT ( Obj ) CLASS ( ReferencePyramid_ ), INTENT ( IN ) :: RefElem INTEGER ( I4B ), INTENT ( IN ) :: Order TYPE ( ReferencePyramid_ ) :: Obj END FUNCTION LagrangeElement_Pyramid END INTERFACE INTERFACE LagrangeElement MODULE PROCEDURE LagrangeElement_Pyramid END INTERFACE LagrangeElement !---------------------------------------------------------------------------- !                                                   LagrangePoints@Lagrange !---------------------------------------------------------------------------- INTERFACE !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . !   1. Returns equidistant points on [-1,1] for lagrange interpolation !\t\t2, Nodecoord is a 2D array with 3 rows !\t\t3. first row is xi, second row is eta, third row is zeta !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . MODULE PURE FUNCTION EquidistanceLIP_Hexahedron ( RefElem , Order ) & & RESULT ( NodeCoord ) CLASS ( ReferenceHexahedron_ ), INTENT ( IN ) :: RefElem INTEGER ( I4B ), INTENT ( IN ) :: Order REAL ( DFP ), ALLOCATABLE :: NodeCoord ( :, : ) END FUNCTION EquidistanceLIP_Hexahedron END INTERFACE INTERFACE LagrangePoints MODULE PROCEDURE EquidistanceLIP_Hexahedron END INTERFACE !---------------------------------------------------------------------------- !                                                   LagrangeElement@Lagrange !---------------------------------------------------------------------------- INTERFACE !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . ! Returns lagrange Hexahedron element of different order !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . MODULE PURE FUNCTION LagrangeElement_Hexahedron ( RefElem , Order ) RESULT ( Obj ) CLASS ( ReferenceHexahedron_ ), INTENT ( IN ) :: RefElem INTEGER ( I4B ), INTENT ( IN ) :: Order TYPE ( ReferenceHexahedron_ ) :: Obj END FUNCTION LagrangeElement_Hexahedron END INTERFACE INTERFACE LagrangeElement MODULE PROCEDURE LagrangeElement_Hexahedron END INTERFACE LagrangeElement !---------------------------------------------------------------------------- !                                                       ElementType@Geometry !---------------------------------------------------------------------------- INTERFACE !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . !  1. Returns element name in integer from element name !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . MODULE PURE FUNCTION Element_Type ( ElemName ) RESULT ( Ans ) CHARACTER ( LEN = * ), INTENT ( IN ) :: ElemName INTEGER ( I4B ) :: Ans END FUNCTION Element_Type END INTERFACE INTERFACE ElementType MODULE PROCEDURE Element_Type END INTERFACE ElementType PUBLIC :: ElementType !---------------------------------------------------------------------------- !                                                       ElementName@Geometry !---------------------------------------------------------------------------- INTERFACE !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . !  1. Returns element name in character from element number/type !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . MODULE PURE FUNCTION Element_Name ( ElemType ) RESULT ( Ans ) INTEGER ( I4B ), INTENT ( IN ) :: ElemType CHARACTER ( LEN = 50 ) :: Ans END FUNCTION Element_Name END INTERFACE INTERFACE ElementName MODULE PROCEDURE Element_Name END INTERFACE ElementName PUBLIC :: ElementName !---------------------------------------------------------------------------- !                                              TotalNodesInElement@Geometry !---------------------------------------------------------------------------- INTERFACE !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . !  1. Returns total numbers of nodes present in a given element !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . MODULE PURE FUNCTION Total_Nodes_In_Element ( ElemType ) RESULT ( Ans ) INTEGER ( I4B ) :: Ans INTEGER ( I4B ), INTENT ( IN ) :: ElemType END FUNCTION Total_Nodes_In_Element END INTERFACE INTERFACE TotalNodesInElement MODULE PROCEDURE Total_Nodes_In_Element END INTERFACE TotalNodesInElement PUBLIC :: TotalNodesInElement !---------------------------------------------------------------------------- !                                                     ElementOrder@Geometry !---------------------------------------------------------------------------- INTERFACE !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . !  1. Returns the order of an element !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . MODULE PURE FUNCTION Element_Order ( ElemType ) RESULT ( Ans ) INTEGER ( I4B ) :: Ans INTEGER ( I4B ), INTENT ( IN ) :: ElemType END FUNCTION Element_Order END INTERFACE !---------------------------------------------------------------------------- !                                                     ElementOrder@Geometry !---------------------------------------------------------------------------- INTERFACE !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . !  1. Returns the order of an element !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . MODULE PURE FUNCTION Element_Order_RefElem ( RefElem ) RESULT ( Ans ) INTEGER ( I4B ) :: Ans CLASS ( ReferenceElement_ ), INTENT ( IN ) :: RefElem END FUNCTION Element_Order_RefElem END INTERFACE INTERFACE ElementOrder MODULE PROCEDURE Element_Order_RefElem , Element_Order END INTERFACE ElementOrder PUBLIC :: ElementOrder !---------------------------------------------------------------------------- !                                                      XiDimension@Geometry !---------------------------------------------------------------------------- INTERFACE !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . !  1. Returns the xidimension of an element !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . MODULE PURE FUNCTION Elem_XiDimension ( ElemType ) RESULT ( Ans ) INTEGER ( I4B ) :: Ans INTEGER ( I4B ), INTENT ( IN ) :: ElemType END FUNCTION Elem_XiDimension END INTERFACE INTERFACE XiDimension MODULE PROCEDURE Elem_XiDimension END INTERFACE XiDimension PUBLIC :: XiDimension !---------------------------------------------------------------------------- !                                                          isVolume@Geometry !---------------------------------------------------------------------------- INTERFACE !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . !  1. Returns true if element is a volume element !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . MODULE PURE FUNCTION isVolume ( ElemType ) RESULT ( Ans ) LOGICAL ( LGT ) :: Ans INTEGER ( I4B ), INTENT ( IN ) :: ElemType END FUNCTION isVolume END INTERFACE PUBLIC :: isVolume !---------------------------------------------------------------------------- !                                                        isSurface@Geometry !---------------------------------------------------------------------------- INTERFACE !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . !  1. Returns true if element is a Surface element !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . MODULE PURE FUNCTION isSurface ( ElemType ) RESULT ( Ans ) LOGICAL ( LGT ) :: Ans INTEGER ( I4B ), INTENT ( IN ) :: ElemType END FUNCTION isSurface END INTERFACE PUBLIC :: isSurface !---------------------------------------------------------------------------- !                                                           isLine@Geometry !---------------------------------------------------------------------------- INTERFACE !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . !  1. Returns true if element is a Line element !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . MODULE PURE FUNCTION isLine ( ElemType ) RESULT ( Ans ) LOGICAL ( LGT ) :: Ans INTEGER ( I4B ), INTENT ( IN ) :: ElemType END FUNCTION isLine END INTERFACE PUBLIC :: isLine !---------------------------------------------------------------------------- !                                                          isPoint@Geometry !---------------------------------------------------------------------------- INTERFACE !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . !  1. Returns true if element is a Point element !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . MODULE PURE FUNCTION isPoint ( ElemType ) RESULT ( Ans ) LOGICAL ( LGT ) :: Ans INTEGER ( I4B ), INTENT ( IN ) :: ElemType END FUNCTION isPoint END INTERFACE PUBLIC :: isPoint !---------------------------------------------------------------------------- !                                                        isTriangle@Geometry !---------------------------------------------------------------------------- INTERFACE !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . !  1. Returns true if element is a Triangle element !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . MODULE PURE FUNCTION isTriangle ( ElemType ) RESULT ( Ans ) LOGICAL ( LGT ) :: Ans INTEGER ( I4B ), INTENT ( IN ) :: ElemType END FUNCTION isTriangle END INTERFACE PUBLIC :: isTriangle !---------------------------------------------------------------------------- !                                                      isQuadrangle@Geometry !---------------------------------------------------------------------------- INTERFACE !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . !  1. Returns true if element is a Quadrangle element !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . MODULE PURE FUNCTION isQuadrangle ( ElemType ) RESULT ( Ans ) LOGICAL ( LGT ) :: Ans INTEGER ( I4B ), INTENT ( IN ) :: ElemType END FUNCTION isQuadrangle END INTERFACE PUBLIC :: isQuadrangle !---------------------------------------------------------------------------- !                                                    isTetrahedron@Geometry !---------------------------------------------------------------------------- INTERFACE !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . !  1. Returns true if element is a Tetrahedron element !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . MODULE PURE FUNCTION isTetrahedron ( ElemType ) RESULT ( Ans ) LOGICAL ( LGT ) :: Ans INTEGER ( I4B ), INTENT ( IN ) :: ElemType END FUNCTION isTetrahedron END INTERFACE PUBLIC :: isTetrahedron !---------------------------------------------------------------------------- !                                                     isHexahedron@Geometry !---------------------------------------------------------------------------- INTERFACE !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . !  1. Returns true if element is a Hexahedron element !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . MODULE PURE FUNCTION isHexahedron ( ElemType ) RESULT ( Ans ) LOGICAL ( LGT ) :: Ans INTEGER ( I4B ), INTENT ( IN ) :: ElemType END FUNCTION isHexahedron END INTERFACE PUBLIC :: isHexahedron !---------------------------------------------------------------------------- !                                                            isPrism@Geometry !---------------------------------------------------------------------------- INTERFACE !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . !  1. Returns true if element is a Prism element !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . MODULE PURE FUNCTION isPrism ( ElemType ) RESULT ( Ans ) LOGICAL ( LGT ) :: Ans INTEGER ( I4B ), INTENT ( IN ) :: ElemType END FUNCTION isPrism END INTERFACE PUBLIC :: isPrism !---------------------------------------------------------------------------- !                                                         isPyramid@Geometry !---------------------------------------------------------------------------- INTERFACE !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . !  1. Returns true if element is a Pyramid element !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . MODULE PURE FUNCTION isPyramid ( ElemType ) RESULT ( Ans ) LOGICAL ( LGT ) :: Ans INTEGER ( I4B ), INTENT ( IN ) :: ElemType END FUNCTION isPyramid END INTERFACE PUBLIC :: isPyramid !---------------------------------------------------------------------------- !                                               isSerendipityElement@Geometry !---------------------------------------------------------------------------- INTERFACE !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . !  1. Returns true if element is a SerendipityElement element !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . MODULE PURE FUNCTION isSerendipityElement ( ElemType ) RESULT ( Ans ) LOGICAL ( LGT ) :: Ans INTEGER ( I4B ), INTENT ( IN ) :: ElemType END FUNCTION isSerendipityElement END INTERFACE PUBLIC :: isSerendipityElement !---------------------------------------------------------------------------- !                                                   ElementTopology@Geometry !---------------------------------------------------------------------------- INTERFACE !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . !   1.  This will return the element topology !     Line !     Triangle !     Quadrangle !     Tetrahedron !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . MODULE PURE FUNCTION Elem_Topology ( ElemType ) RESULT ( Ans ) INTEGER ( I4B ) :: Ans INTEGER ( I4B ), INTENT ( IN ) :: ElemType END FUNCTION Elem_Topology END INTERFACE INTERFACE ElementTopology MODULE PROCEDURE Elem_Topology END INTERFACE ElementTopology PUBLIC :: ElementTopology !---------------------------------------------------------------------------- !                                                       FacetMatrix@Geometry !---------------------------------------------------------------------------- INTERFACE !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . ! Returns the facet matrix ! Number of rows are equal to the number of facet in an element ! Number of columns = MAX( NNS ) ! First column => ElementTopology ! Second Column => XiDimension ! Third column => NNS ! 4 to NNS + 3 => Local Nptrs !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . MODULE PURE FUNCTION Facet_Matrix_RefElem ( RefElem ) RESULT ( FM ) INTEGER ( I4B ), ALLOCATABLE :: FM ( :, : ) CLASS ( ReferenceElement_ ), INTENT ( IN ) :: RefElem END FUNCTION Facet_Matrix_RefElem END INTERFACE INTERFACE FacetMatrix MODULE PROCEDURE Facet_Matrix_RefElem END INTERFACE FacetMatrix PUBLIC :: FacetMatrix !---------------------------------------------------------------------------- !                                                    LocalNodeCoord@Geometry !---------------------------------------------------------------------------- INTERFACE !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . ! This routine will be removed in near future ! This routine is not included in generic LocalNodeCoord routine !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . MODULE PURE SUBROUTINE Local_NodeCoord ( NodeCoord , ElemType ) ! Define intent of dummy variables REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: NodeCoord ( :, : ) INTEGER ( I4B ), INTENT ( IN ) :: ElemType END SUBROUTINE Local_NodeCoord END INTERFACE !---------------------------------------------------------------------------- !                                                    LocalNodeCoord@Geometry !---------------------------------------------------------------------------- INTERFACE !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . ! Returns the local NodeCoord of an element !.  .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .   . MODULE PURE FUNCTION Local_NodeCoord_RefElem ( RefElem ) RESULT ( NodeCoord ) CLASS ( ReferenceElement_ ), INTENT ( IN ) :: RefElem REAL ( DFP ), ALLOCATABLE :: NodeCoord ( :, : ) END FUNCTION Local_NodeCoord_RefElem END INTERFACE INTERFACE LocalNodeCoord MODULE PROCEDURE Local_NodeCoord_RefElem END INTERFACE LocalNodeCoord PUBLIC :: LocalNodeCoord !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- #include \"./line.inc\" #include \"./triangle.inc\" #include \"./quadrangle.inc\" #include \"./tetrahedron.inc\" #include \"./hexahedron.inc\" #include \"./prism.inc\" #include \"./pyramid.inc\" !---------------------------------------------------------------------------- !                                                 MeasureOfSimplex@Geometry !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION Measure_Simplex ( RefElem , XiJ ) RESULT ( Ans ) CLASS ( ReferenceElement_ ), INTENT ( IN ) :: RefElem REAL ( DFP ), INTENT ( IN ) :: XiJ ( :, : ) REAL ( DFP ) :: Ans END FUNCTION Measure_Simplex END INTERFACE INTERFACE MeasureSimplex MODULE PROCEDURE Measure_Simplex END INTERFACE MeasureSimplex PUBLIC :: MeasureSimplex !---------------------------------------------------------------------------- !                                                    ElementQuality@Geometry !---------------------------------------------------------------------------- INTERFACE MODULE FUNCTION Element_Quality ( refelem , xij , measure ) RESULT ( Ans ) CLASS ( ReferenceElement_ ), INTENT ( IN ) :: refelem REAL ( DFP ) , INTENT ( IN ) :: xij (:,:) INTEGER ( I4B ), INTENT ( IN ) :: measure REAL ( DFP ) :: Ans END FUNCTION Element_Quality END INTERFACE INTERFACE ElementQuality MODULE PROCEDURE Element_Quality END INTERFACE ElementQuality PUBLIC :: ElementQuality !---------------------------------------------------------------------------- !                                                     ContainsPoint@geometry !---------------------------------------------------------------------------- INTERFACE MODULE FUNCTION contains_point ( refelem , xij , x ) RESULT ( Ans ) CLASS ( ReferenceElement_ ), INTENT ( IN ) :: refelem REAL ( DFP ), INTENT ( IN ) :: xij ( :, : ) REAL ( DFP ), INTENT ( IN ) :: x (:) LOGICAL ( LGT ) :: Ans END FUNCTION contains_point END INTERFACE INTERFACE ContainsPoint MODULE PROCEDURE contains_point END INTERFACE ContainsPoint PUBLIC :: ContainsPoint !---------------------------------------------------------------------------- !                                                          getVTKelementType !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE get_vtk_elemType ( ElemType , vtk_type , nptrs ) INTEGER ( I4B ), INTENT ( IN ) :: ElemType INTEGER ( Int8 ), INTENT ( OUT ) :: vtk_type INTEGER ( I4B ), ALLOCATABLE , INTENT ( INOUT ) :: nptrs ( : ) END SUBROUTINE get_vtk_elemType END INTERFACE INTERFACE getVTKelementType MODULE PROCEDURE get_vtk_elemType END INTERFACE getVTKelementType PUBLIC :: getVTKelementType !---------------------------------------------------------------------------- !                                                                 Contains !---------------------------------------------------------------------------- ! there are some routines which should be described inside the module ! rather than submodules. those routines should be described inside ! the contains.part ! These routines mainly returns pointers. CONTAINS !---------------------------------------------------------------------------- !                                                      ReferenceLine_Pointer !---------------------------------------------------------------------------- PURE FUNCTION reference_Line_Pointer ( NSD , XiJ ) RESULT ( Obj ) INTEGER ( I4B ), INTENT ( IN ) :: NSD REAL ( DFP ), INTENT ( IN ), OPTIONAL :: XiJ (:,:) CLASS ( ReferenceLine_ ), POINTER :: Obj ALLOCATE ( Obj ) IF ( PRESENT ( XiJ ) ) THEN CALL Initiate ( Obj , NSD , XiJ ) ELSE CALL Initiate ( Obj , NSD ) END IF END FUNCTION reference_Line_Pointer !---------------------------------------------------------------------------- !                                                      ReferenceTriangle_Pointer !---------------------------------------------------------------------------- PURE FUNCTION reference_Triangle_Pointer ( NSD , XiJ ) RESULT ( Obj ) INTEGER ( I4B ), INTENT ( IN ) :: NSD REAL ( DFP ), INTENT ( IN ), OPTIONAL :: XiJ (:,:) CLASS ( ReferenceTriangle_ ), POINTER :: Obj ALLOCATE ( Obj ) IF ( PRESENT ( XiJ ) ) THEN CALL Initiate ( Obj , NSD , XiJ ) ELSE CALL Initiate ( Obj , NSD ) END IF END FUNCTION reference_Triangle_Pointer !---------------------------------------------------------------------------- !                                                      ReferenceQuadrangle_Pointer !---------------------------------------------------------------------------- PURE FUNCTION reference_Quadrangle_Pointer ( NSD , XiJ ) RESULT ( Obj ) INTEGER ( I4B ), INTENT ( IN ) :: NSD REAL ( DFP ), INTENT ( IN ), OPTIONAL :: XiJ (:,:) CLASS ( ReferenceQuadrangle_ ), POINTER :: Obj ALLOCATE ( Obj ) IF ( PRESENT ( XiJ ) ) THEN CALL Initiate ( Obj , NSD , XiJ ) ELSE CALL Initiate ( Obj , NSD ) END IF END FUNCTION reference_Quadrangle_Pointer !---------------------------------------------------------------------------- !                                               ReferenceTetrahedron_Pointer !---------------------------------------------------------------------------- PURE FUNCTION reference_Tetrahedron_Pointer ( NSD , XiJ ) RESULT ( Obj ) INTEGER ( I4B ), INTENT ( IN ) :: NSD REAL ( DFP ), INTENT ( IN ), OPTIONAL :: XiJ (:,:) CLASS ( ReferenceTetrahedron_ ), POINTER :: Obj ALLOCATE ( Obj ) IF ( PRESENT ( XiJ ) ) THEN CALL Initiate ( Obj , NSD , XiJ ) ELSE CALL Initiate ( Obj , NSD ) END IF END FUNCTION reference_Tetrahedron_Pointer !---------------------------------------------------------------------------- !                                               ReferenceHexahedron_Pointer !---------------------------------------------------------------------------- PURE FUNCTION reference_Hexahedron_Pointer ( NSD , XiJ ) RESULT ( Obj ) INTEGER ( I4B ), INTENT ( IN ) :: NSD REAL ( DFP ), INTENT ( IN ), OPTIONAL :: XiJ (:,:) CLASS ( ReferenceHexahedron_ ), POINTER :: Obj ALLOCATE ( Obj ) IF ( PRESENT ( XiJ ) ) THEN CALL Initiate ( Obj , NSD , XiJ ) ELSE CALL Initiate ( Obj , NSD ) END IF END FUNCTION reference_Hexahedron_Pointer !---------------------------------------------------------------------------- !                                               ReferencePyramid_Pointer !---------------------------------------------------------------------------- PURE FUNCTION reference_Pyramid_Pointer ( NSD , XiJ ) RESULT ( Obj ) INTEGER ( I4B ), INTENT ( IN ) :: NSD REAL ( DFP ), INTENT ( IN ), OPTIONAL :: XiJ (:,:) CLASS ( ReferencePyramid_ ), POINTER :: Obj ALLOCATE ( Obj ) IF ( PRESENT ( XiJ ) ) THEN CALL Initiate ( Obj , NSD , XiJ ) ELSE CALL Initiate ( Obj , NSD ) END IF END FUNCTION reference_Pyramid_Pointer !---------------------------------------------------------------------------- !                                               ReferencePrism_Pointer !---------------------------------------------------------------------------- PURE FUNCTION reference_Prism_Pointer ( NSD , XiJ ) RESULT ( Obj ) INTEGER ( I4B ), INTENT ( IN ) :: NSD REAL ( DFP ), INTENT ( IN ), OPTIONAL :: XiJ (:,:) CLASS ( ReferencePrism_ ), POINTER :: Obj ALLOCATE ( Obj ) IF ( PRESENT ( XiJ ) ) THEN CALL Initiate ( Obj , NSD , XiJ ) ELSE CALL Initiate ( Obj , NSD ) END IF END FUNCTION reference_Prism_Pointer !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- END MODULE ReferenceElement_Method","tags":"","loc":"sourcefile/referenceelement_method.f90.html"},{"title":"Rank2Tensor_Method.f90 – Fortran Program","text":"Contents Modules Rank2Tensor_Method Source Code Rank2Tensor_Method.f90 Source Code MODULE Rank2Tensor_Method USE GlobalData USE IO USE BaseType IMPLICIT NONE PRIVATE !---------------------------------------------------------------------------- !                                                         initiate@constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE init_by_mat ( Obj , Mat ) CLASS ( Rank2Tensor_ ), INTENT ( INOUT ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Mat ( 3 , 3 ) END SUBROUTINE init_by_mat MODULE PURE SUBROUTINE init_by_vec ( Obj , Vec , VoigtType ) CLASS ( Rank2Tensor_ ), INTENT ( INOUT ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Vec ( : ) INTEGER ( I4B ), INTENT ( IN ) :: VoigtType END SUBROUTINE init_by_vec END INTERFACE INTERFACE Initiate MODULE PROCEDURE init_by_mat , init_by_vec END INTERFACE Initiate PUBLIC :: Initiate !---------------------------------------------------------------------------- !                                                          convert@constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE mat_to_rank2 ( From , To ) CLASS ( Rank2Tensor_ ), INTENT ( INOUT ) :: To REAL ( DFP ), INTENT ( IN ) :: From ( 3 , 3 ) END SUBROUTINE mat_to_rank2 MODULE PURE SUBROUTINE rank2_to_mat ( From , To ) CLASS ( Rank2Tensor_ ), INTENT ( IN ) :: From REAL ( DFP ), INTENT ( INOUT ) :: To ( 3 , 3 ) END SUBROUTINE rank2_to_mat MODULE PURE SUBROUTINE rank2_equal_mat ( Obj , Mat ) CLASS ( Rank2Tensor_ ), INTENT ( INOUT ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Mat ( 3 , 3 ) END SUBROUTINE rank2_equal_mat MODULE PURE SUBROUTINE mat_equal_rank2 ( Mat , Obj ) REAL ( DFP ), INTENT ( INOUT ) :: Mat ( 3 , 3 ) CLASS ( Rank2Tensor_ ), INTENT ( IN ) :: Obj END SUBROUTINE mat_equal_rank2 END INTERFACE INTERFACE ASSIGNMENT ( = ) MODULE PROCEDURE rank2_equal_mat , mat_equal_rank2 END INTERFACE INTERFACE Convert MODULE PROCEDURE mat_to_rank2 , rank2_to_mat END INTERFACE Convert PUBLIC :: Convert , ASSIGNMENT ( = ) !---------------------------------------------------------------------------- !                                                    Rank2Tensor@constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION r2t_by_mat ( Mat ) RESULT ( Obj ) REAL ( DFP ), INTENT ( IN ) :: Mat ( 3 , 3 ) TYPE ( Rank2Tensor_ ) :: Obj END FUNCTION r2t_by_mat MODULE PURE FUNCTION r2t_by_voigtvec ( VoigtVec , VoigtType ) RESULT ( Obj ) REAL ( DFP ), INTENT ( IN ) :: VoigtVec ( : ) INTEGER ( I4B ), INTENT ( IN ) :: VoigtType TYPE ( Rank2Tensor_ ) :: Obj END FUNCTION r2t_by_voigtvec END INTERFACE INTERFACE Rank2Tensor MODULE PROCEDURE r2t_by_mat , r2t_by_voigtvec END INTERFACE Rank2Tensor PUBLIC :: Rank2Tensor !---------------------------------------------------------------------------- !                                            Rank2Tensor_Pointer@constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION r2tp_by_mat ( Mat ) RESULT ( Obj ) REAL ( DFP ), INTENT ( IN ) :: Mat ( 3 , 3 ) CLASS ( Rank2Tensor_ ), POINTER :: Obj END FUNCTION r2tp_by_mat MODULE PURE FUNCTION r2tp_by_voigtvec ( VoigtVec , VoigtType ) RESULT ( Obj ) REAL ( DFP ), INTENT ( IN ) :: VoigtVec ( : ) INTEGER ( I4B ), INTENT ( IN ) :: VoigtType CLASS ( Rank2Tensor_ ), POINTER :: Obj END FUNCTION r2tp_by_voigtvec END INTERFACE INTERFACE Rank2Tensor_Pointer MODULE PROCEDURE r2tp_by_mat , r2tp_by_voigtvec END INTERFACE Rank2Tensor_Pointer PUBLIC :: Rank2Tensor_Pointer !---------------------------------------------------------------------------- !                                                 IdentityTensor@constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE identity_rank2 ( Obj ) CLASS ( Rank2Tensor_ ), INTENT ( INOUT ) :: Obj END SUBROUTINE identity_rank2 END INTERFACE INTERFACE IdentityTensor MODULE PROCEDURE identity_rank2 END INTERFACE IdentityTensor PUBLIC :: IdentityTensor !---------------------------------------------------------------------------- !                                                     OnesTensor@constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE Ones_rank2 ( Obj ) CLASS ( Rank2Tensor_ ), INTENT ( INOUT ) :: Obj END SUBROUTINE Ones_rank2 END INTERFACE INTERFACE Ones MODULE PROCEDURE Ones_rank2 END INTERFACE Ones PUBLIC :: Ones !---------------------------------------------------------------------------- !                                                   ZerosTensor@constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE Zeros_rank2 ( Obj ) CLASS ( Rank2Tensor_ ), INTENT ( INOUT ) :: Obj END SUBROUTINE Zeros_rank2 END INTERFACE INTERFACE Zeros MODULE PROCEDURE Zeros_rank2 END INTERFACE Zeros PUBLIC :: Zeros !---------------------------------------------------------------------------- !                                                IsotropicTensor@constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE isotropic_rank2 ( Obj , Lambda ) CLASS ( Rank2Tensor_ ), INTENT ( INOUT ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Lambda END SUBROUTINE isotropic_rank2 END INTERFACE INTERFACE IsotropicTensor MODULE PROCEDURE isotropic_rank2 END INTERFACE IsotropicTensor PUBLIC :: IsotropicTensor !---------------------------------------------------------------------------- !                                                       Display@constructor !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE display_obj ( Obj , Msg , UnitNo ) CLASS ( Rank2Tensor_ ), INTENT ( IN ) :: Obj CHARACTER ( LEN = * ), INTENT ( IN ) :: Msg INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: UnitNo END SUBROUTINE display_obj END INTERFACE INTERFACE Display MODULE PROCEDURE display_obj END INTERFACE Display PUBLIC :: Display !---------------------------------------------------------------------------- !                                                           Trace@Operation !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION trace_obj ( Obj , Power ) RESULT ( Ans ) CLASS ( Rank2Tensor_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Power REAL ( DFP ) :: Ans END FUNCTION trace_obj END INTERFACE INTERFACE Trace MODULE PROCEDURE trace_obj END INTERFACE Trace PUBLIC :: Trace !---------------------------------------------------------------------------- !                                                                J2@Operation !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION j2_obj ( Obj , isDeviatoric ) RESULT ( Ans ) CLASS ( Rank2Tensor_ ), INTENT ( IN ) :: Obj LOGICAL ( LGT ), INTENT ( IN ) :: isDeviatoric REAL ( DFP ) :: Ans END FUNCTION j2_obj END INTERFACE INTERFACE J2 MODULE PROCEDURE j2_obj END INTERFACE J2 PUBLIC :: J2 !---------------------------------------------------------------------------- !                                                                J3@Operation !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION j3_obj ( Obj , isDeviatoric ) RESULT ( Ans ) CLASS ( Rank2Tensor_ ), INTENT ( IN ) :: Obj LOGICAL ( LGT ), INTENT ( IN ) :: isDeviatoric REAL ( DFP ) :: Ans END FUNCTION j3_obj END INTERFACE INTERFACE J3 MODULE PROCEDURE j3_obj END INTERFACE J3 PUBLIC :: J3 !---------------------------------------------------------------------------- !                                                               Det@Operation !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION det_obj ( Obj ) RESULT ( Ans ) CLASS ( Rank2Tensor_ ), INTENT ( IN ) :: Obj REAL ( DFP ) :: Ans END FUNCTION det_obj END INTERFACE INTERFACE Det MODULE PROCEDURE Det_obj END INTERFACE Det PUBLIC :: Det !---------------------------------------------------------------------------- !                                                         LodeAngle@Operation !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION theta_obj ( Obj , LodeType , isDeviatoric ) RESULT ( Ans ) CLASS ( Rank2Tensor_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: LodeType LOGICAL ( LGT ), INTENT ( IN ) :: isDeviatoric REAL ( DFP ) :: Ans END FUNCTION theta_obj MODULE PURE FUNCTION theta_obj_j2j3 ( Obj , LodeType , J2J3 ) RESULT ( Ans ) CLASS ( Rank2Tensor_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: LodeType REAL ( DFP ), INTENT ( IN ), OPTIONAL :: J2J3 ( 2 ) REAL ( DFP ) :: Ans END FUNCTION theta_obj_j2j3 END INTERFACE INTERFACE LodeAngle MODULE PROCEDURE theta_obj , theta_obj_j2j3 END INTERFACE LodeAngle PUBLIC :: LodeAngle !---------------------------------------------------------------------------- !                                                               Sym@Operation !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION sym_r2t ( Obj ) RESULT ( Ans ) CLASS ( Rank2Tensor_ ), INTENT ( IN ) :: Obj TYPE ( Rank2Tensor_ ) :: Ans END FUNCTION sym_r2t END INTERFACE INTERFACE Sym MODULE PROCEDURE sym_r2t END INTERFACE Sym PUBLIC :: Sym !---------------------------------------------------------------------------- !                                                            SkewSym@Operation !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION Skewsym_r2t ( Obj ) RESULT ( Ans ) CLASS ( Rank2Tensor_ ), INTENT ( IN ) :: Obj TYPE ( Rank2Tensor_ ) :: Ans END FUNCTION Skewsym_r2t END INTERFACE INTERFACE SkewSym MODULE PROCEDURE Skewsym_r2t END INTERFACE SkewSym PUBLIC :: SkewSym !---------------------------------------------------------------------------- !                                                    IsotropicPart@Operation !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION iso_part_obj ( Obj ) RESULT ( Ans ) CLASS ( Rank2Tensor_ ), INTENT ( IN ) :: Obj TYPE ( Rank2Tensor_ ) :: Ans END FUNCTION iso_part_obj END INTERFACE INTERFACE Isotropic MODULE PROCEDURE iso_part_obj END INTERFACE Isotropic PUBLIC :: Isotropic !---------------------------------------------------------------------------- !                                                    DeviatoricPart@Operation !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION dev_part_obj ( Obj ) RESULT ( Ans ) CLASS ( Rank2Tensor_ ), INTENT ( IN ) :: Obj TYPE ( Rank2Tensor_ ) :: Ans END FUNCTION dev_part_obj END INTERFACE INTERFACE Deviatoric MODULE PROCEDURE dev_part_obj END INTERFACE Deviatoric PUBLIC :: Deviatoric !---------------------------------------------------------------------------- !                                                      Contraction@Operation !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION r2_contract_r2 ( Obj1 , Obj2 ) RESULT ( Ans ) CLASS ( Rank2Tensor_ ), INTENT ( IN ) :: Obj1 , Obj2 REAL ( DFP ) :: Ans END FUNCTION r2_contract_r2 MODULE PURE FUNCTION r2_contract_voigt_r2 ( Obj1 , Obj2 ) RESULT ( Ans ) CLASS ( Rank2Tensor_ ), INTENT ( IN ) :: Obj1 CLASS ( VoigtRank2Tensor_ ), INTENT ( IN ) :: Obj2 REAL ( DFP ) :: Ans END FUNCTION r2_contract_voigt_r2 MODULE PURE FUNCTION voigt_r2_contract_r2 ( Obj1 , Obj2 ) RESULT ( Ans ) CLASS ( VoigtRank2Tensor_ ), INTENT ( IN ) :: Obj1 CLASS ( Rank2Tensor_ ), INTENT ( IN ) :: Obj2 REAL ( DFP ) :: Ans END FUNCTION voigt_r2_contract_r2 MODULE PURE FUNCTION voigt_r2_contract_voigt_r2 ( Obj1 , Obj2 ) RESULT ( Ans ) CLASS ( VoigtRank2Tensor_ ), INTENT ( IN ) :: Obj1 CLASS ( VoigtRank2Tensor_ ), INTENT ( IN ) :: Obj2 REAL ( DFP ) :: Ans END FUNCTION voigt_r2_contract_voigt_r2 END INTERFACE INTERFACE Contraction MODULE PROCEDURE r2_contract_r2 , r2_contract_voigt_r2 , voigt_r2_contract_r2 , & & voigt_r2_contract_voigt_r2 END INTERFACE Contraction PUBLIC :: Contraction !---------------------------------------------------------------------------- !                                                             AXPY@Operation !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE axpy_a1_a2 ( a1 , Obj1 , a2 , Obj2 ) CLASS ( Rank2Tensor_ ), INTENT ( INOUT ) :: Obj1 CLASS ( Rank2Tensor_ ), INTENT ( IN ) :: Obj2 REAL ( DFP ), INTENT ( IN ) :: a1 , a2 END SUBROUTINE axpy_a1_a2 END INTERFACE INTERFACE AXPY MODULE PROCEDURE axpy_a1_a2 END INTERFACE AXPY PUBLIC :: AXPY !---------------------------------------------------------------------------- !                                                      Invariants@Operation !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION invariants_rank2 ( Obj , isDeviatoric ) RESULT ( Ans ) CLASS ( Rank2Tensor_ ), INTENT ( IN ) :: Obj LOGICAL ( LGT ), INTENT ( IN ) :: isDeviatoric REAL ( DFP ) :: Ans ( 3 ) END FUNCTION invariants_rank2 END INTERFACE INTERFACE Invariants MODULE PROCEDURE invariants_rank2 END INTERFACE Invariants PUBLIC :: Invariants !---------------------------------------------------------------------------- !                                                          Eigen@Operation !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE sym_spectral_r2t ( Obj , Q , W ) CLASS ( Rank2Tensor_ ), INTENT ( IN ) :: Obj REAL ( DFP ), INTENT ( INOUT ) :: Q ( 3 , 3 ), W ( 3 ) END SUBROUTINE sym_spectral_r2t MODULE SUBROUTINE spectral_r2t ( Obj , Q , W ) CLASS ( Rank2Tensor_ ), INTENT ( IN ) :: Obj COMPLEX ( DFP ), INTENT ( INOUT ) :: Q ( 3 , 3 ), W ( 3 ) END SUBROUTINE spectral_r2t END INTERFACE INTERFACE SymEigen MODULE PROCEDURE sym_spectral_r2t END INTERFACE SymEigen INTERFACE Eigen MODULE PROCEDURE spectral_r2t END INTERFACE Eigen PUBLIC :: SymEigen , Eigen !---------------------------------------------------------------------------- !                                                     PolarDecomp@Operation !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE right_pd_r2t ( Obj , R , U ) CLASS ( Rank2Tensor_ ), INTENT ( IN ) :: Obj CLASS ( Rank2Tensor_ ), INTENT ( INOUT ) :: R , U END SUBROUTINE right_pd_r2t MODULE SUBROUTINE left_pd_r2t ( Obj , V , R ) CLASS ( Rank2Tensor_ ), INTENT ( IN ) :: Obj CLASS ( Rank2Tensor_ ), INTENT ( INOUT ) :: R , V END SUBROUTINE left_pd_r2t END INTERFACE INTERFACE RightPolarDecomp MODULE PROCEDURE right_pd_r2t END INTERFACE RightPolarDecomp INTERFACE LeftPolarDecomp MODULE PROCEDURE right_pd_r2t END INTERFACE LeftPolarDecomp PUBLIC :: RightPolarDecomp , LeftPolarDecomp !---------------------------------------------------------------------------- !                                                                +@Operation !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION obj_add_obj ( Obj1 , Obj2 ) RESULT ( Ans ) CLASS ( Rank2Tensor_ ), INTENT ( IN ) :: Obj1 CLASS ( Rank2Tensor_ ), INTENT ( IN ) :: Obj2 TYPE ( Rank2Tensor_ ) :: Ans END FUNCTION obj_add_obj MODULE PURE FUNCTION obj_add_mat ( Obj1 , Obj2 ) RESULT ( Ans ) CLASS ( Rank2Tensor_ ), INTENT ( IN ) :: Obj1 REAL ( DFP ), INTENT ( IN ) :: Obj2 ( 3 , 3 ) TYPE ( Rank2Tensor_ ) :: Ans END FUNCTION obj_add_mat MODULE PURE FUNCTION mat_add_obj ( Obj1 , Obj2 ) RESULT ( Ans ) REAL ( DFP ), INTENT ( IN ) :: Obj1 ( 3 , 3 ) CLASS ( Rank2Tensor_ ), INTENT ( IN ) :: Obj2 TYPE ( Rank2Tensor_ ) :: Ans END FUNCTION mat_add_obj MODULE PURE FUNCTION obj_add_scalar ( Obj1 , Obj2 ) RESULT ( Ans ) CLASS ( Rank2Tensor_ ), INTENT ( IN ) :: Obj1 REAL ( DFP ), INTENT ( IN ) :: Obj2 TYPE ( Rank2Tensor_ ) :: Ans END FUNCTION obj_add_scalar MODULE PURE FUNCTION scalar_add_obj ( Obj1 , Obj2 ) RESULT ( Ans ) REAL ( DFP ), INTENT ( IN ) :: Obj1 CLASS ( Rank2Tensor_ ), INTENT ( IN ) :: Obj2 TYPE ( Rank2Tensor_ ) :: Ans END FUNCTION scalar_add_obj END INTERFACE INTERFACE OPERATOR ( + ) MODULE PROCEDURE obj_add_obj , obj_add_mat , mat_add_obj , obj_add_scalar , & & scalar_add_obj END INTERFACE PUBLIC :: OPERATOR ( + ) !---------------------------------------------------------------------------- !                                                                -@Operation !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION obj_minus_obj ( Obj1 , Obj2 ) RESULT ( Ans ) CLASS ( Rank2Tensor_ ), INTENT ( IN ) :: Obj1 CLASS ( Rank2Tensor_ ), INTENT ( IN ) :: Obj2 TYPE ( Rank2Tensor_ ) :: Ans END FUNCTION obj_minus_obj MODULE PURE FUNCTION obj_minus_mat ( Obj1 , Obj2 ) RESULT ( Ans ) CLASS ( Rank2Tensor_ ), INTENT ( IN ) :: Obj1 REAL ( DFP ), INTENT ( IN ) :: Obj2 ( 3 , 3 ) TYPE ( Rank2Tensor_ ) :: Ans END FUNCTION obj_minus_mat MODULE PURE FUNCTION mat_minus_obj ( Obj1 , Obj2 ) RESULT ( Ans ) REAL ( DFP ), INTENT ( IN ) :: Obj1 ( 3 , 3 ) CLASS ( Rank2Tensor_ ), INTENT ( IN ) :: Obj2 TYPE ( Rank2Tensor_ ) :: Ans END FUNCTION mat_minus_obj MODULE PURE FUNCTION obj_minus_scalar ( Obj1 , Obj2 ) RESULT ( Ans ) CLASS ( Rank2Tensor_ ), INTENT ( IN ) :: Obj1 REAL ( DFP ), INTENT ( IN ) :: Obj2 TYPE ( Rank2Tensor_ ) :: Ans END FUNCTION obj_minus_scalar MODULE PURE FUNCTION scalar_minus_obj ( Obj1 , Obj2 ) RESULT ( Ans ) REAL ( DFP ), INTENT ( IN ) :: Obj1 CLASS ( Rank2Tensor_ ), INTENT ( IN ) :: Obj2 TYPE ( Rank2Tensor_ ) :: Ans END FUNCTION scalar_minus_obj END INTERFACE INTERFACE OPERATOR ( - ) MODULE PROCEDURE obj_minus_obj , obj_minus_mat , mat_minus_obj , & & obj_minus_scalar , scalar_minus_obj END INTERFACE PUBLIC :: OPERATOR ( - ) !---------------------------------------------------------------------------- !                                                             Exp@Operation !---------------------------------------------------------------------------- ! INTERFACE ! MODULE FUNCTION exp_r2t( Obj ) RESULT( Ans ) ! \tCLASS( Rank2Tensor_ ), INTENT( IN ) ::Obj ! \tTYPE( Rank2Tensor_ ) :: Ans ! END FUNCTION exp_r2t ! END INTERFACE ! INTERFACE EXP ! \tMODULE PROCEDURE exp_r2t ! END INTERFACE ! PUBLIC :: EXP !---------------------------------------------------------------------------- !                                                                    Contains !---------------------------------------------------------------------------- END MODULE Rank2Tensor_Method","tags":"","loc":"sourcefile/rank2tensor_method.f90.html"},{"title":"matrix_exponential.f90 – Fortran Program","text":"Contents Subroutines c8mat_expm1 r8mat_expm1 r8mat_expm2 r8mat_expm3 Source Code matrix_exponential.f90 Source Code subroutine c8mat_expm1 ( n , a , e ) !*****************************************************************************80 ! !! C8MAT_EXPM1 is essentially MATLAB's built-in matrix exponential algorithm. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    01 March 2013 ! !  Author: ! !    FORTRAN90 version by John Burkardt ! !  Reference: ! !    Cleve Moler, Charles VanLoan, !    Nineteen Dubious Ways to Compute the Exponential of a Matrix, !    Twenty-Five Years Later, !    SIAM Review, !    Volume 45, Number 1, March 2003, pages 3-49. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the dimension of the matrix. ! !    Input, complex ( kind = 8 ) A(N,N), the matrix. ! !    Output, complex ( kind = 8 ) E(N,N), the estimate for exp(A). ! implicit none integer ( kind = 4 ) n complex ( kind = 8 ) a ( n , n ) complex ( kind = 8 ) a2 ( n , n ) real ( kind = 8 ) a_norm real ( kind = 8 ) c real ( kind = 8 ) c8mat_norm_li complex ( kind = 8 ) d ( n , n ) complex ( kind = 8 ) e ( n , n ) integer ( kind = 4 ) ee integer ( kind = 4 ) k logical p integer ( kind = 4 ) , parameter :: q = 6 real ( kind = 8 ) r8_log_2 integer ( kind = 4 ) s complex ( kind = 8 ) x ( n , n ) ! !  Make a copy of the matrix. ! a2 ( 1 : n , 1 : n ) = a ( 1 : n , 1 : n ) ! !  Compute the L-infinity norm. ! a_norm = c8mat_norm_li ( n , n , a2 ) ! !  Determine a scaling factor for the matrix. ! ee = int ( r8_log_2 ( a_norm ) ) + 1 s = max ( 0 , ee + 1 ) a2 ( 1 : n , 1 : n ) = a2 ( 1 : n , 1 : n ) / 2.0D+00 ** s x ( 1 : n , 1 : n ) = a2 ( 1 : n , 1 : n ) c = 0.5D+00 call c8mat_identity ( n , e ) e ( 1 : n , 1 : n ) = e ( 1 : n , 1 : n ) + c * a2 ( 1 : n , 1 : n ) call c8mat_identity ( n , d ) d ( 1 : n , 1 : n ) = d ( 1 : n , 1 : n ) - c * a2 ( 1 : n , 1 : n ) p = . true . do k = 2 , q c = c * real ( q - k + 1 , kind = 8 ) & / real ( k * ( 2 * q - k + 1 ), kind = 8 ) x ( 1 : n , 1 : n ) = matmul ( a2 ( 1 : n , 1 : n ), x ( 1 : n , 1 : n ) ) e ( 1 : n , 1 : n ) = e ( 1 : n , 1 : n ) + c * x ( 1 : n , 1 : n ) if ( p ) then d ( 1 : n , 1 : n ) = d ( 1 : n , 1 : n ) + c * x ( 1 : n , 1 : n ) else d ( 1 : n , 1 : n ) = d ( 1 : n , 1 : n ) - c * x ( 1 : n , 1 : n ) end if p = . not . p end do ! !  E -> inverse(D) * E ! call c8mat_minvm ( n , n , d , e , e ) ! !  E -> E&#94;(2*S) ! do k = 1 , s e ( 1 : n , 1 : n ) = matmul ( e ( 1 : n , 1 : n ), e ( 1 : n , 1 : n ) ) end do return end subroutine r8mat_expm1 ( n , a , e ) !*****************************************************************************80 ! !! R8MAT_EXPM1 is essentially MATLAB's built-in matrix exponential algorithm. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    26 November 2011 ! !  Author: ! !    Cleve Moler, Charles Van Loan ! !  Reference: ! !    Cleve Moler, Charles VanLoan, !    Nineteen Dubious Ways to Compute the Exponential of a Matrix, !    Twenty-Five Years Later, !    SIAM Review, !    Volume 45, Number 1, March 2003, pages 3-49. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the dimension of the matrix. ! !    Input, real ( kind = 8 ) A(N,N), the matrix. ! !    Output, real ( kind = 8 ) E(N,N), the estimate for exp(A). ! implicit none integer ( kind = 4 ) n real ( kind = 8 ) a ( n , n ) real ( kind = 8 ) a2 ( n , n ) real ( kind = 8 ) a_norm real ( kind = 8 ) c real ( kind = 8 ) d ( n , n ) real ( kind = 8 ) e ( n , n ) integer ( kind = 4 ) ee integer ( kind = 4 ) k logical p integer ( kind = 4 ) , parameter :: q = 6 real ( kind = 8 ) r8_log_2 real ( kind = 8 ) r8mat_norm_li integer ( kind = 4 ) s real ( kind = 8 ) x ( n , n ) a2 ( 1 : n , 1 : n ) = a ( 1 : n , 1 : n ) a_norm = r8mat_norm_li ( n , n , a2 ) ee = int ( r8_log_2 ( a_norm ) ) + 1 s = max ( 0 , ee + 1 ) a2 ( 1 : n , 1 : n ) = a2 ( 1 : n , 1 : n ) / 2.0D+00 ** s x ( 1 : n , 1 : n ) = a2 ( 1 : n , 1 : n ) c = 0.5D+00 call r8mat_identity ( n , e ) e ( 1 : n , 1 : n ) = e ( 1 : n , 1 : n ) + c * a2 ( 1 : n , 1 : n ) call r8mat_identity ( n , d ) d ( 1 : n , 1 : n ) = d ( 1 : n , 1 : n ) - c * a2 ( 1 : n , 1 : n ) p = . true . do k = 2 , q c = c * real ( q - k + 1 , kind = 8 ) & / real ( k * ( 2 * q - k + 1 ), kind = 8 ) x ( 1 : n , 1 : n ) = matmul ( a2 ( 1 : n , 1 : n ), x ( 1 : n , 1 : n ) ) e ( 1 : n , 1 : n ) = e ( 1 : n , 1 : n ) + c * x ( 1 : n , 1 : n ) if ( p ) then d ( 1 : n , 1 : n ) = d ( 1 : n , 1 : n ) + c * x ( 1 : n , 1 : n ) else d ( 1 : n , 1 : n ) = d ( 1 : n , 1 : n ) - c * x ( 1 : n , 1 : n ) end if p = . not . p end do ! !  E -> inverse(D) * E ! call r8mat_minvm ( n , n , d , e , e ) ! !  E -> E&#94;(2*S) ! do k = 1 , s e ( 1 : n , 1 : n ) = matmul ( e ( 1 : n , 1 : n ), e ( 1 : n , 1 : n ) ) end do return end subroutine r8mat_expm2 ( n , a , e ) !*****************************************************************************80 ! !! R8MAT_EXPM2 uses the Taylor series for the matrix exponential. ! !  Discussion: ! !    Formally, ! !      exp ( A ) = I + A + 1/2 A&#94;2 + 1/3! A&#94;3 + ... ! !    This function sums the series until a tolerance is satisfied. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    26 November 2011 ! !  Author: ! !    Cleve Moler, Charles Van Loan ! !  Reference: ! !    Cleve Moler, Charles VanLoan, !    Nineteen Dubious Ways to Compute the Exponential of a Matrix, !    Twenty-Five Years Later, !    SIAM Review, !    Volume 45, Number 1, March 2003, pages 3-49. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the dimension of the matrix. ! !    Input, real ( kind = 8 ) A(N,N), the matrix. ! !    Output, real ( kind = 8 ) E(N,N), the estimate for exp(A). ! implicit none integer ( kind = 4 ) n real ( kind = 8 ) a ( n , n ) real ( kind = 8 ) e ( n , n ) real ( kind = 8 ) f ( n , n ) real ( kind = 8 ) g ( n , n ) integer ( kind = 4 ) k logical r8mat_insignificant e ( 1 : n , 1 : n ) = 0.0D+00 call r8mat_identity ( n , f ) k = 1 do if ( r8mat_insignificant ( n , n , e , f ) ) then exit end if e ( 1 : n , 1 : n ) = e ( 1 : n , 1 : n ) + f ( 1 : n , 1 : n ) f ( 1 : n , 1 : n ) = matmul ( a ( 1 : n , 1 : n ), f ( 1 : n , 1 : n ) ) / real ( k , kind = 8 ) k = k + 1 end do return end subroutine r8mat_expm3 ( n , a , e ) !*****************************************************************************80 ! !! R8MAT_EXPM3 approximates the matrix exponential using an eigenvalue approach. ! !  Discussion: ! !    exp(A) = V * D * V ! !    where V is the matrix of eigenvectors of A, and D is the diagonal matrix !    whose i-th diagonal entry is exp(lambda(i)), for lambda(i) an eigenvalue !    of A. ! !    This function is accurate for matrices which are symmetric, orthogonal, !    or normal. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    26 November 2011 ! !  Author: ! !    Cleve Moler, Charles Van Loan ! !  Reference: ! !    Cleve Moler, Charles VanLoan, !    Nineteen Dubious Ways to Compute the Exponential of a Matrix, !    Twenty-Five Years Later, !    SIAM Review, !    Volume 45, Number 1, March 2003, pages 3-49. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the dimension of the matrix. ! !    Input, real ( kind = 8 ) A(N,N), the matrix. ! !    Output, real ( kind = 8 ) E(N,N), the estimate for exp(A). ! ! [ V, D ] = eig ( A ); ! E = V * diag ( exp ( diag ( D ) ) ) / V; return end","tags":"","loc":"sourcefile/matrix_exponential.f90.html"},{"title":"dsytrd3.f – Fortran Program","text":"Contents Subroutines DSYTRD3 Source Code dsytrd3.f Source Code * ---------------------------------------------------------------------------- * Numerical diagonalization of 3x3 matrcies * Copyright (C) 2006  Joachim Kopp * ---------------------------------------------------------------------------- * This library is free software; you can redistribute it and/or * modify it under the terms of the GNU Lesser General Public * License as published by the Free Software Foundation; either * version 2.1 of the License, or (at your option) any later version. * * This library is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this library; if not, write to the Free Software * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA * ---------------------------------------------------------------------------- * ---------------------------------------------------------------------------- SUBROUTINE DSYTRD3 ( A , Q , D , E ) * ---------------------------------------------------------------------------- * Reduces a symmetric 3x3 matrix to real tridiagonal form by applying * (unitary) Householder transformations: *            [ D[1]  E[1]       ] *    A = Q . [ E[1]  D[2]  E[2] ] . Q&#94;T *            [       E[2]  D[3] ] * The function accesses only the diagonal and upper triangular parts of * A. The access is read-only. * --------------------------------------------------------------------------- *     .. Arguments .. DOUBLE PRECISION A ( 3 , 3 ) DOUBLE PRECISION Q ( 3 , 3 ) DOUBLE PRECISION D ( 3 ) DOUBLE PRECISION E ( 2 ) *     .. Parameters .. INTEGER N PARAMETER ( N = 3 ) *     .. Local Variables .. DOUBLE PRECISION U ( N ), P ( N ) DOUBLE PRECISION OMEGA , F DOUBLE PRECISION K , H , G INTEGER I , J *     Initialize Q to the identitity matrix *     --- This loop can be omitted if only the eigenvalues are desired --- DO 10 I = 1 , N Q ( I , I ) = 1.0D0 DO 11 , J = 1 , I - 1 Q ( I , J ) = 0.0D0 Q ( J , I ) = 0.0D0 11 CONTINUE 10 CONTINUE *     Bring first row and column to the desired form H = A ( 1 , 2 ) ** 2 + A ( 1 , 3 ) ** 2 IF ( A ( 1 , 2 ) . GT . 0.0D0 ) THEN G = - SQRT ( H ) ELSE G = SQRT ( H ) END IF E ( 1 ) = G F = G * A ( 1 , 2 ) U ( 2 ) = A ( 1 , 2 ) - G U ( 3 ) = A ( 1 , 3 ) OMEGA = H - F IF ( OMEGA > 0.0D0 ) THEN OMEGA = 1.0D0 / OMEGA K = 0.0D0 DO 20 I = 2 , N F = A ( 2 , I ) * U ( 2 ) + A ( I , 3 ) * U ( 3 ) P ( I ) = OMEGA * F K = K + U ( I ) * F 20 CONTINUE K = 0.5D0 * K * OMEGA ** 2 DO 30 I = 2 , N P ( I ) = P ( I ) - K * U ( I ) 30 CONTINUE D ( 1 ) = A ( 1 , 1 ) D ( 2 ) = A ( 2 , 2 ) - 2.0D0 * P ( 2 ) * U ( 2 ) D ( 3 ) = A ( 3 , 3 ) - 2.0D0 * P ( 3 ) * U ( 3 ) *       Store inverse Householder transformation in Q *       --- This loop can be omitted if only the eigenvalues are desired --- DO 40 , J = 2 , N F = OMEGA * U ( J ) DO 41 I = 2 , N Q ( I , J ) = Q ( I , J ) - F * U ( I ) 41 CONTINUE 40 CONTINUE *       Calculated updated A(2, 3) and store it in E(2) E ( 2 ) = A ( 2 , 3 ) - P ( 2 ) * U ( 3 ) - U ( 2 ) * P ( 3 ) ELSE DO 50 I = 1 , N D ( I ) = A ( I , I ) 50 CONTINUE E ( 2 ) = A ( 2 , 3 ) END IF END SUBROUTINE * End of subroutine DSYTRD3","tags":"","loc":"sourcefile/dsytrd3.f.html"},{"title":"dsyevq3.f – Fortran Program","text":"Contents Subroutines DSYEVQ3 Source Code dsyevq3.f Source Code * ---------------------------------------------------------------------------- * Numerical diagonalization of 3x3 matrcies * Copyright (C) 2006  Joachim Kopp * ---------------------------------------------------------------------------- * This library is free software; you can redistribute it and/or * modify it under the terms of the GNU Lesser General Public * License as published by the Free Software Foundation; either * version 2.1 of the License, or (at your option) any later version. * * This library is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this library; if not, write to the Free Software * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA * ---------------------------------------------------------------------------- * ---------------------------------------------------------------------------- SUBROUTINE DSYEVQ3 ( A , Q , W ) * ---------------------------------------------------------------------------- * Calculates the eigenvalues and normalized eigenvectors of a symmetric 3x3 * matrix A using the QL algorithm with implicit shifts, preceded by a * Householder reduction to real tridiagonal form. * The function accesses only the diagonal and upper triangular parts of * A. The access is read-only. * ---------------------------------------------------------------------------- * Parameters: *   A: The symmetric input matrix *   Q: Storage buffer for eigenvectors *   W: Storage buffer for eigenvalues * ---------------------------------------------------------------------------- * Dependencies: *   DSYTRD3() * ---------------------------------------------------------------------------- *     .. Arguments .. DOUBLE PRECISION A ( 3 , 3 ) DOUBLE PRECISION Q ( 3 , 3 ) DOUBLE PRECISION W ( 3 ) *     .. Parameters .. INTEGER N PARAMETER ( N = 3 ) *     .. Local Variables .. DOUBLE PRECISION E ( 3 ) DOUBLE PRECISION G , R , P , F , B , S , C , T INTEGER NITER INTEGER L , M , I , J , K *     .. External Functions .. EXTERNAL DSYTRD3 *     Transform A to real tridiagonal form by the Householder method CALL DSYTRD3 ( A , Q , W , E ) *     Calculate eigensystem of the remaining real symmetric tridiagonal *     matrix with the QL method * *     Loop over all off-diagonal elements DO 10 L = 1 , N - 1 NITER = 0 *       Iteration loop DO 11 I = 1 , 50 *         Check for convergence and exit iteration loop if off-diagonal *         element E(L) is zero DO 20 M = L , N - 1 G = ABS ( W ( M )) + ABS ( W ( M + 1 )) IF ( ABS ( E ( M )) + G . EQ . G ) THEN GO TO 30 END IF 20 CONTINUE 30 IF ( M . EQ . L ) THEN GO TO 10 END IF NITER = NITER + 1 IF ( NITER >= 30 ) THEN PRINT * , 'DSYEVQ3: No convergence.' RETURN END IF *         Calculate G = D(M) - K G = ( W ( L + 1 ) - W ( L )) / ( 2.0D0 * E ( L )) R = SQRT ( 1.0D0 + G ** 2 ) IF ( G . GE . 0.0D0 ) THEN G = W ( M ) - W ( L ) + E ( L ) / ( G + R ) ELSE G = W ( M ) - W ( L ) + E ( L ) / ( G - R ) END IF S = 1.0D0 C = 1.0D0 P = 0.0D0 DO 40 J = M - 1 , L , - 1 F = S * E ( J ) B = C * E ( J ) IF ( ABS ( F ) . GT . ABS ( G )) THEN C = G / F R = SQRT ( 1.0D0 + C ** 2 ) E ( J + 1 ) = F * R S = 1.0D0 / R C = C * S ELSE S = F / G R = SQRT ( 1.0D0 + S ** 2 ) E ( J + 1 ) = G * R C = 1.0D0 / R S = S * C END IF G = W ( J + 1 ) - P R = ( W ( J ) - G ) * S + 2.0D0 * C * B P = S * R W ( J + 1 ) = G + P G = C * R - B *           Form eigenvectors *           --- This loop can be omitted if only the eigenvalues are desired --- DO 50 K = 1 , N T = Q ( K , J + 1 ) Q ( K , J + 1 ) = S * Q ( K , J ) + C * T Q ( K , J ) = C * Q ( K , J ) - S * T 50 CONTINUE 40 CONTINUE W ( L ) = W ( L ) - P E ( L ) = G E ( M ) = 0.0D0 11 CONTINUE 10 CONTINUE END SUBROUTINE * End of subroutine DSYEVQ3","tags":"","loc":"sourcefile/dsyevq3.f.html"},{"title":"dsyevh3.f – Fortran Program","text":"Contents Subroutines DSYEVH3 Source Code dsyevh3.f Source Code * ---------------------------------------------------------------------------- * Numerical diagonalization of 3x3 matrcies * Copyright (C) 2006  Joachim Kopp * ---------------------------------------------------------------------------- * This library is free software; you can redistribute it and/or * modify it under the terms of the GNU Lesser General Public * License as published by the Free Software Foundation; either * version 2.1 of the License, or (at your option) any later version. * * This library is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this library; if not, write to the Free Software * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA * ---------------------------------------------------------------------------- * ---------------------------------------------------------------------------- SUBROUTINE DSYEVH3 ( A , Q , W ) * ---------------------------------------------------------------------------- * Calculates the eigenvalues and normalized eigenvectors of a symmetric 3x3 * matrix A using Cardano's method for the eigenvalues and an analytical * method based on vector cross products for the eigenvectors. However, * if conditions are such that a large error in the results is to be * expected, the routine falls back to using the slower, but more * accurate QL algorithm. Only the diagonal and upper triangular parts of A need * to contain meaningful values. Access to A is read-only. * ---------------------------------------------------------------------------- * Parameters: *   A: The symmetric input matrix *   Q: Storage buffer for eigenvectors *   W: Storage buffer for eigenvalues * ---------------------------------------------------------------------------- * Dependencies: *   DSYEVC3(), DSYTRD3(), DSYEVQ3() * ---------------------------------------------------------------------------- * Version history: *   v1.2 (12 Mar 2012): Removed unused label to avoid gfortran warning, *     removed unnecessary use of DREAL which led to gfortran error *   v1.1: Simplified fallback condition --> speed-up *   v1.0: First released version * ---------------------------------------------------------------------------- *     .. Arguments .. DOUBLE PRECISION A ( 3 , 3 ) DOUBLE PRECISION Q ( 3 , 3 ) DOUBLE PRECISION W ( 3 ) *     .. Parameters .. DOUBLE PRECISION EPS PARAMETER ( EPS = 2.2204460492503131D-16 ) *     .. Local Variables .. DOUBLE PRECISION NORM DOUBLE PRECISION ERROR DOUBLE PRECISION T , U INTEGER J *     .. External Functions .. EXTERNAL DSYEVC3 , DSYEVQ3 *     Calculate eigenvalues CALL DSYEVC3 ( A , W ) *     --- The rest of this subroutine can be omitted if only the eigenvalues are desired --- *     Prepare calculation of eigenvectors *      N1      = A(1, 1)**2 + A(1, 2)**2 + A(1, 3)**2 *      N2      = A(1, 2)**2 + A(2, 2)**2 + A(2, 3)**2 T = MAX ( ABS ( W ( 1 )), ABS ( W ( 2 )), ABS ( W ( 3 ))) U = MAX ( T , T ** 2 ) ERROR = 25 6.0D0 * EPS * U ** 2 *      ERROR   = 256.0D0 * EPS * (N1 + U) * (N2 + U) Q ( 1 , 2 ) = A ( 1 , 2 ) * A ( 2 , 3 ) - A ( 1 , 3 ) * A ( 2 , 2 ) Q ( 2 , 2 ) = A ( 1 , 3 ) * A ( 1 , 2 ) - A ( 2 , 3 ) * A ( 1 , 1 ) Q ( 3 , 2 ) = A ( 1 , 2 ) ** 2 *     Calculate first eigenvector by the formula *       v[0] = (A - lambda[0]).e1 x (A - lambda[0]).e2 Q ( 1 , 1 ) = Q ( 1 , 2 ) + A ( 1 , 3 ) * W ( 1 ) Q ( 2 , 1 ) = Q ( 2 , 2 ) + A ( 2 , 3 ) * W ( 1 ) Q ( 3 , 1 ) = ( A ( 1 , 1 ) - W ( 1 )) * ( A ( 2 , 2 ) - W ( 1 )) - Q ( 3 , 2 ) NORM = Q ( 1 , 1 ) ** 2 + Q ( 2 , 1 ) ** 2 + Q ( 3 , 1 ) ** 2 *     If vectors are nearly linearly dependent, or if there might have *     been large cancellations in the calculation of A(I,I) - W(1), fall *     back to QL algorithm *     Note that this simultaneously ensures that multiple eigenvalues do *     not cause problems: If W(1) = W(2), then A - W(1) * I has rank 1, *     i.e. all columns of A - W(1) * I are linearly dependent. IF ( NORM . LE . ERROR ) THEN CALL DSYEVQ3 ( A , Q , W ) RETURN *     This is the standard branch ELSE NORM = SQRT ( 1.0D0 / NORM ) DO 20 , J = 1 , 3 Q ( J , 1 ) = Q ( J , 1 ) * NORM 20 CONTINUE END IF *     Calculate second eigenvector by the formula *       v[1] = (A - lambda[1]).e1 x (A - lambda[1]).e2 Q ( 1 , 2 ) = Q ( 1 , 2 ) + A ( 1 , 3 ) * W ( 2 ) Q ( 2 , 2 ) = Q ( 2 , 2 ) + A ( 2 , 3 ) * W ( 2 ) Q ( 3 , 2 ) = ( A ( 1 , 1 ) - W ( 2 )) * ( A ( 2 , 2 ) - W ( 2 )) - Q ( 3 , 2 ) NORM = Q ( 1 , 2 ) ** 2 + Q ( 2 , 2 ) ** 2 + Q ( 3 , 2 ) ** 2 IF ( NORM . LE . ERROR ) THEN CALL DSYEVQ3 ( A , Q , W ) RETURN ELSE NORM = SQRT ( 1.0D0 / NORM ) DO 40 , J = 1 , 3 Q ( J , 2 ) = Q ( J , 2 ) * NORM 40 CONTINUE END IF *     Calculate third eigenvector according to *       v[2] = v[0] x v[1] Q ( 1 , 3 ) = Q ( 2 , 1 ) * Q ( 3 , 2 ) - Q ( 3 , 1 ) * Q ( 2 , 2 ) Q ( 2 , 3 ) = Q ( 3 , 1 ) * Q ( 1 , 2 ) - Q ( 1 , 1 ) * Q ( 3 , 2 ) Q ( 3 , 3 ) = Q ( 1 , 1 ) * Q ( 2 , 2 ) - Q ( 2 , 1 ) * Q ( 1 , 2 ) END SUBROUTINE * End of subroutine DSYEVH3","tags":"","loc":"sourcefile/dsyevh3.f.html"},{"title":"dsyevc3.f – Fortran Program","text":"Contents Subroutines DSYEVC3 Source Code dsyevc3.f Source Code * ---------------------------------------------------------------------------- * Numerical diagonalization of 3x3 matrcies * Copyright (C) 2006  Joachim Kopp * ---------------------------------------------------------------------------- * This library is free software; you can redistribute it and/or * modify it under the terms of the GNU Lesser General Public * License as published by the Free Software Foundation; either * version 2.1 of the License, or (at your option) any later version. * * This library is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU * Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public * License along with this library; if not, write to the Free Software * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA * ---------------------------------------------------------------------------- * ---------------------------------------------------------------------------- SUBROUTINE DSYEVC3 ( A , W ) * ---------------------------------------------------------------------------- * Calculates the eigenvalues of a symmetric 3x3 matrix A using Cardano's * analytical algorithm. * Only the diagonal and upper triangular parts of A are accessed. The access * is read-only. * ---------------------------------------------------------------------------- * Parameters: *   A: The symmetric input matrix *   W: Storage buffer for eigenvalues * ---------------------------------------------------------------------------- *     .. Arguments .. DOUBLE PRECISION A ( 3 , 3 ) DOUBLE PRECISION W ( 3 ) *     .. Parameters .. DOUBLE PRECISION SQRT3 PARAMETER ( SQRT3 = 1.73205080756887729352744634151D0 ) *     .. Local Variables .. DOUBLE PRECISION M , C1 , C0 DOUBLE PRECISION DE , DD , EE , FF DOUBLE PRECISION P , SQRTP , Q , C , S , PHI *     Determine coefficients of characteristic poynomial. We write *           | A   D   F  | *      A =  | D*  B   E  | *           | F*  E*  C  | DE = A ( 1 , 2 ) * A ( 2 , 3 ) DD = A ( 1 , 2 ) ** 2 EE = A ( 2 , 3 ) ** 2 FF = A ( 1 , 3 ) ** 2 M = A ( 1 , 1 ) + A ( 2 , 2 ) + A ( 3 , 3 ) C1 = ( A ( 1 , 1 ) * A ( 2 , 2 ) + A ( 1 , 1 ) * A ( 3 , 3 ) + A ( 2 , 2 ) * A ( 3 , 3 ) ) $ - ( DD + EE + FF ) C0 = A ( 3 , 3 ) * DD + A ( 1 , 1 ) * EE + A ( 2 , 2 ) * FF - A ( 1 , 1 ) * A ( 2 , 2 ) * A ( 3 , 3 ) $ - 2.0D0 * A ( 1 , 3 ) * DE P = M ** 2 - 3.0D0 * C1 Q = M * ( P - ( 3.0D0 / 2.0D0 ) * C1 ) - ( 2 7.0D0 / 2.0D0 ) * C0 SQRTP = SQRT ( ABS ( P )) PHI = 2 7.0D0 * ( 0.25D0 * C1 ** 2 * ( P - C1 ) $ + C0 * ( Q + ( 2 7.0D0 / 4.0D0 ) * C0 ) ) PHI = ( 1.0D0 / 3.0D0 ) * ATAN2 ( SQRT ( ABS ( PHI )), Q ) C = SQRTP * COS ( PHI ) S = ( 1.0D0 / SQRT3 ) * SQRTP * SIN ( PHI ) W ( 2 ) = ( 1.0D0 / 3.0D0 ) * ( M - C ) W ( 3 ) = W ( 2 ) + S W ( 1 ) = W ( 2 ) + C W ( 2 ) = W ( 2 ) - S END SUBROUTINE * End of subroutine DSYEVC3","tags":"","loc":"sourcefile/dsyevc3.f.html"},{"title":"VoigtRank2Tensor_Method.f90 – Fortran Program","text":"Contents Modules VoigtRank2Tensor_Method Source Code VoigtRank2Tensor_Method.f90 Source Code MODULE VoigtRank2Tensor_Method USE GlobalData USE IO USE BaseType IMPLICIT NONE PRIVATE !---------------------------------------------------------------------------- !                                                       Initiate@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE init_from_vec ( Obj , Vec , VoigtType ) CLASS ( VoigtRank2Tensor_ ), INTENT ( INOUT ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Vec ( : ) INTEGER ( I4B ), INTENT ( IN ) :: VoigtType END SUBROUTINE init_from_vec MODULE PURE SUBROUTINE init_from_mat ( Obj , T , VoigtType ) CLASS ( VoigtRank2Tensor_ ), INTENT ( INOUT ) :: Obj REAL ( DFP ), INTENT ( IN ) :: T ( 3 , 3 ) INTEGER ( I4B ), INTENT ( IN ) :: VoigtType END SUBROUTINE init_from_mat MODULE PURE SUBROUTINE init_from_r2tensor ( Obj , T , VoigtType ) CLASS ( VoigtRank2Tensor_ ), INTENT ( INOUT ) :: Obj CLASS ( Rank2Tensor_ ), INTENT ( IN ) :: T INTEGER ( I4B ), INTENT ( IN ) :: VoigtType END SUBROUTINE init_from_r2tensor END INTERFACE INTERFACE Initiate MODULE PROCEDURE init_from_vec , init_from_r2tensor , init_from_mat END INTERFACE Initiate PUBLIC :: Initiate !---------------------------------------------------------------------------- !                                               VoigtRank2Tensor@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION constructor1 ( Vec , VoigtType ) RESULT ( Obj ) REAL ( DFP ), INTENT ( IN ) :: Vec ( : ) INTEGER ( I4B ), INTENT ( IN ) :: VoigtType TYPE ( VoigtRank2Tensor_ ) :: Obj END FUNCTION constructor1 END INTERFACE INTERFACE VoigtRank2Tensor MODULE PROCEDURE constructor1 END INTERFACE VoigtRank2Tensor PUBLIC :: VoigtRank2Tensor !---------------------------------------------------------------------------- !                                       VoigtRank2Tensor_Pointer@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION constructor_1 ( Vec , VoigtType ) RESULT ( Obj ) REAL ( DFP ), INTENT ( IN ) :: Vec ( : ) INTEGER ( I4B ), INTENT ( IN ) :: VoigtType CLASS ( VoigtRank2Tensor_ ), POINTER :: Obj END FUNCTION constructor_1 END INTERFACE INTERFACE VoigtRank2Tensor_Pointer MODULE PROCEDURE constructor_1 END INTERFACE VoigtRank2Tensor_Pointer PUBLIC :: VoigtRank2Tensor_Pointer !---------------------------------------------------------------------------- !                                                        Display@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE display_obj ( Obj , Msg , UnitNo ) CLASS ( VoigtRank2Tensor_ ), INTENT ( IN ) :: Obj CHARACTER ( LEN = * ), INTENT ( IN ) :: Msg INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: UnitNo END SUBROUTINE display_obj END INTERFACE INTERFACE Display MODULE PROCEDURE display_obj END INTERFACE Display PUBLIC :: Display !---------------------------------------------------------------------------- !                                                           Convert@GetMethod !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE voigt_to_mat ( From , To ) CLASS ( VoigtRank2Tensor_ ), INTENT ( IN ) :: From REAL ( DFP ), INTENT ( INOUT ) :: To ( 3 , 3 ) END SUBROUTINE voigt_to_mat MODULE PURE SUBROUTINE voigt_to_vec ( From , To ) CLASS ( VoigtRank2Tensor_ ), INTENT ( IN ) :: From REAL ( DFP ), INTENT ( INOUT ) :: To ( : ) END SUBROUTINE voigt_to_vec MODULE PURE SUBROUTINE voigt_to_tensor ( From , To ) CLASS ( VoigtRank2Tensor_ ), INTENT ( IN ) :: From CLASS ( Rank2Tensor_ ), INTENT ( INOUT ) :: To END SUBROUTINE voigt_to_tensor MODULE PURE SUBROUTINE tensor_to_voigt ( From , To , VoigtType ) CLASS ( Rank2Tensor_ ), INTENT ( IN ) :: From CLASS ( VoigtRank2Tensor_ ), INTENT ( INOUT ) :: To INTEGER ( I4B ), INTENT ( IN ) :: VoigtType END SUBROUTINE tensor_to_voigt END INTERFACE INTERFACE Convert MODULE PROCEDURE voigt_to_mat , voigt_to_vec , voigt_to_tensor , & & tensor_to_voigt END INTERFACE Convert PUBLIC :: Convert !---------------------------------------------------------------------------- !                                                                 Contains !---------------------------------------------------------------------------- END MODULE VoigtRank2Tensor_Method","tags":"","loc":"sourcefile/voigtrank2tensor_method.f90.html"},{"title":"Random_Method.f90 – Fortran Program","text":"Contents Modules Random_Method Source Code Random_Method.f90 Source Code MODULE Random_Method !! Module to handle random numbers in easifem USE GlobalData USE BaseType IMPLICIT NONE PRIVATE !---------------------------------------------------------------------------- !                                                      Initiate@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE initRandom ( Obj ) CLASS ( Random_ ), INTENT ( INOUT ) :: Obj END SUBROUTINE initRandom END INTERFACE INTERFACE Initiate MODULE PROCEDURE initRandom END INTERFACE Initiate PUBLIC :: Initiate !---------------------------------------------------------------------------- !                                                                 getRandom !---------------------------------------------------------------------------- INTERFACE MODULE FUNCTION getRandom ( Obj , distribution ) RESULT ( Ans ) CLASS ( Random_ ), INTENT ( IN ) :: Obj CHARACTER ( LEN = * ), OPTIONAL , INTENT ( IN ) :: distribution REAL ( DFP ) :: Ans END FUNCTION getRandom END INTERFACE INTERFACE RandomValue MODULE PROCEDURE getRandom END INTERFACE RandomValue PUBLIC :: RandomValue !---------------------------------------------------------------------------- !                                                                 SaveRandom !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE SaveRandom ( Obj ) CLASS ( Random_ ), INTENT ( INOUT ) :: Obj END SUBROUTINE SaveRandom END INTERFACE PUBLIC :: SaveRandom !---------------------------------------------------------------------------- !                                                             UniformRandom !---------------------------------------------------------------------------- INTERFACE MODULE FUNCTION uniformRandom ( Obj , From , To ) RESULT ( Ans ) CLASS ( Random_ ), INTENT ( IN ) :: Obj REAL ( DFP ), INTENT ( IN ) :: From , To REAL ( DFP ) :: Ans END FUNCTION uniformRandom END INTERFACE PUBLIC :: uniformRandom INTERFACE RandomValue MODULE PROCEDURE uniformRandom END INTERFACE RandomValue !---------------------------------------------------------------------------- !                                                             RandomInteger !---------------------------------------------------------------------------- INTERFACE MODULE FUNCTION getRandomInteger ( Obj , From , To ) RESULT ( Ans ) CLASS ( Random_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: From , To INTEGER ( I4B ) :: Ans END FUNCTION getRandomInteger END INTERFACE INTERFACE RandomValue MODULE PROCEDURE getRandomInteger END INTERFACE RandomValue !---------------------------------------------------------------------------- !                                                                RandomValue !---------------------------------------------------------------------------- INTERFACE MODULE FUNCTION select_random_int_from_vec ( Obj , Val ) RESULT ( Ans ) CLASS ( Random_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Val ( : ) INTEGER ( I4B ) :: Ans END FUNCTION select_random_int_from_vec END INTERFACE INTERFACE MODULE FUNCTION select_random_int_from_array ( Obj , Val ) RESULT ( Ans ) CLASS ( Random_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Val ( :, : ) INTEGER ( I4B ) :: Ans END FUNCTION select_random_int_from_array END INTERFACE INTERFACE MODULE FUNCTION select_random_real_from_vec ( Obj , Val ) RESULT ( Ans ) CLASS ( Random_ ), INTENT ( IN ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Val ( : ) REAL ( DFP ) :: Ans END FUNCTION select_random_real_from_vec END INTERFACE INTERFACE MODULE FUNCTION select_random_real_from_array ( Obj , Val ) RESULT ( Ans ) CLASS ( Random_ ), INTENT ( IN ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Val ( :, : ) REAL ( DFP ) :: Ans END FUNCTION select_random_real_from_array END INTERFACE INTERFACE RandomValue MODULE PROCEDURE select_random_int_from_vec , select_random_int_from_array ,& & select_random_real_from_vec , select_random_real_from_array END INTERFACE RandomValue !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- END MODULE Random_Method","tags":"","loc":"sourcefile/random_method.f90.html"},{"title":"IntVector_Method.f90 – Fortran Program","text":"Contents Modules IntVector_Method Source Code IntVector_Method.f90 Source Code MODULE IntVector_Method USE GlobalData USE IO USE BaseType , ONLY : IntVector_ IMPLICIT NONE PRIVATE !---------------------------------------------------------------------------- !                                                          Shape@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION get_shape ( Obj ) RESULT ( Ans ) CLASS ( IntVector_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ) :: Ans ( 1 ) END FUNCTION get_shape END INTERFACE INTERFACE Shape MODULE PROCEDURE get_shape END INTERFACE Shape PUBLIC :: Shape !---------------------------------------------------------------------------- !                                                            SIZE@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION get_size ( Obj , Dims ) RESULT ( Ans ) TYPE ( IntVector_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: Dims INTEGER ( I4B ) :: Ans END FUNCTION get_size END INTERFACE INTERFACE SIZE MODULE PROCEDURE get_size END INTERFACE SIZE PUBLIC :: SIZE !---------------------------------------------------------------------------- !                                                    AllocateData@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE Allocate_Data ( Obj , Dims ) CLASS ( IntVector_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Dims END SUBROUTINE Allocate_Data END INTERFACE INTERFACE AllocateData MODULE PROCEDURE Allocate_Data END INTERFACE AllocateData PUBLIC :: AllocateData !---------------------------------------------------------------------------- !                                                  DeAllocateData@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE Deallocate_Data ( Obj ) CLASS ( IntVector_ ), INTENT ( INOUT ) :: Obj END SUBROUTINE Deallocate_Data END INTERFACE INTERFACE DeallocateData MODULE PROCEDURE Deallocate_Data END INTERFACE DeallocateData PUBLIC :: DeallocateData !---------------------------------------------------------------------------- !                                                         Display@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE IntVectorDisplay ( Obj , msg , UnitNo ) CLASS ( IntVector_ ), INTENT ( IN ) :: Obj ( : ) CHARACTER ( LEN = * ), INTENT ( IN ) :: msg INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: UnitNo END SUBROUTINE IntVectorDisplay MODULE SUBROUTINE IntscalarDisplay ( Obj , msg , UnitNo ) CLASS ( IntVector_ ), INTENT ( IN ) :: Obj CHARACTER ( LEN = * ), INTENT ( IN ) :: msg INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: UnitNo END SUBROUTINE IntscalarDisplay MODULE SUBROUTINE IntIntrinsicDisplay ( Val , msg , UnitNo ) INTEGER ( I4B ), INTENT ( IN ) :: Val ( : ) CHARACTER ( LEN = * ), INTENT ( IN ) :: msg INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: UnitNo END SUBROUTINE IntIntrinsicDisplay END INTERFACE INTERFACE Display MODULE PROCEDURE IntVectorDisplay , & & IntscalarDisplay END INTERFACE Display PUBLIC :: Display !---------------------------------------------------------------------------- !                                                        Initiate@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE initiate_obj ( Obj , tSize ) CLASS ( IntVector_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: tSize END SUBROUTINE initiate_obj MODULE PURE SUBROUTINE initiate_obj_vector ( Obj , tSize ) TYPE ( IntVector_ ), ALLOCATABLE , INTENT ( INOUT ) :: Obj ( : ) INTEGER ( I4B ), INTENT ( IN ) :: tSize ( : ) END SUBROUTINE initiate_obj_vector MODULE PURE SUBROUTINE initiate_obj_ab ( Obj , a , b ) CLASS ( IntVector_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: a , b END SUBROUTINE initiate_obj_ab END INTERFACE INTERFACE Initiate MODULE PROCEDURE initiate_obj , initiate_obj_vector , initiate_obj_ab END INTERFACE Initiate PUBLIC :: Initiate !---------------------------------------------------------------------------- !                                                          Vector@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION Constructor1 ( tSize ) RESULT ( Obj ) TYPE ( IntVector_ ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: tSize END FUNCTION Constructor1 END INTERFACE INTERFACE IntVector MODULE PROCEDURE Constructor1 END INTERFACE IntVector PUBLIC :: IntVector !---------------------------------------------------------------------------- !                                                 Vector_Pointer@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION Constructor_1 ( tSize ) RESULT ( Obj ) CLASS ( IntVector_ ), POINTER :: Obj INTEGER ( I4B ), INTENT ( IN ) :: tSize END FUNCTION Constructor_1 END INTERFACE INTERFACE IntVector_Pointer MODULE PROCEDURE Constructor_1 END INTERFACE IntVector_Pointer PUBLIC :: IntVector_Pointer !---------------------------------------------------------------------------- !                                                   Vector_Pointer@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION Constructor_Int ( Val ) RESULT ( Obj ) CLASS ( IntVector_ ), POINTER :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Val ( : ) END FUNCTION Constructor_Int MODULE PURE FUNCTION ConstructorInt ( Val ) RESULT ( Obj ) TYPE ( IntVector_ ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Val ( : ) END FUNCTION ConstructorInt END INTERFACE INTERFACE IntVector MODULE PROCEDURE ConstructorInt END INTERFACE IntVector INTERFACE IntVector_Pointer MODULE PROCEDURE Constructor_Int END INTERFACE IntVector_Pointer INTERFACE MODULE PURE FUNCTION Constructor_Real ( Val ) RESULT ( Obj ) CLASS ( IntVector_ ), POINTER :: Obj REAL ( DFP ), INTENT ( IN ) :: Val ( : ) END FUNCTION Constructor_Real MODULE PURE FUNCTION ConstructorReal ( Val ) RESULT ( Obj ) TYPE ( IntVector_ ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Val ( : ) END FUNCTION ConstructorReal END INTERFACE INTERFACE IntVector MODULE PROCEDURE ConstructorReal END INTERFACE IntVector INTERFACE IntVector_Pointer MODULE PROCEDURE Constructor_Real END INTERFACE IntVector_Pointer !---------------------------------------------------------------------------- !                                                       ArrayValues@GetMethod !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION f_getValues_self ( Obj , DataType ) RESULT ( Val ) CLASS ( IntVector_ ), INTENT ( IN ) :: Obj TYPE ( IntVector_ ), INTENT ( IN ) :: DataType TYPE ( IntVector_ ) :: Val END FUNCTION f_getValues_self MODULE PURE FUNCTION f_getSectionValues_self ( Obj , Indx , DataType ) & & RESULT ( Val ) CLASS ( IntVector_ ), INTENT ( IN ) :: Obj TYPE ( IntVector_ ), INTENT ( IN ) :: DataType INTEGER ( I4B ), INTENT ( IN ) :: Indx ( : ) TYPE ( IntVector_ ) :: Val END FUNCTION f_getSectionValues_self MODULE PURE FUNCTION f_getValuesFromTriplet_self ( Obj , iStart , iEnd , & & Stride , DataType ) RESULT ( Val ) CLASS ( IntVector_ ), INTENT ( IN ) :: Obj TYPE ( IntVector_ ), INTENT ( IN ) :: DataType INTEGER ( I4B ), INTENT ( IN ) :: iStart , iEnd , Stride TYPE ( IntVector_ ) :: Val END FUNCTION f_getValuesFromTriplet_self MODULE PURE FUNCTION f_getARRAYValues_self ( Obj , DataType ) RESULT ( Val ) CLASS ( IntVector_ ), INTENT ( IN ) :: Obj ( : ) TYPE ( IntVector_ ), INTENT ( IN ) :: DataType TYPE ( IntVector_ ) :: Val END FUNCTION f_getARRAYValues_self MODULE PURE FUNCTION f_getARRAYSectionValues_self ( Obj , Indx , DataType ) & & RESULT ( Val ) CLASS ( IntVector_ ), INTENT ( IN ) :: Obj ( : ) TYPE ( IntVector_ ), INTENT ( IN ) :: DataType INTEGER ( I4B ), INTENT ( IN ) :: Indx ( : ) TYPE ( IntVector_ ) :: Val END FUNCTION f_getARRAYSectionValues_self MODULE PURE FUNCTION f_getARRAYValuesFromTriplet_self ( Obj , iStart , iEnd , & & Stride , DataType ) RESULT ( Val ) CLASS ( IntVector_ ), INTENT ( IN ) :: Obj ( : ) INTEGER ( I4B ), INTENT ( IN ) :: iStart , iEnd , Stride TYPE ( IntVector_ ), INTENT ( IN ) :: DataType TYPE ( IntVector_ ) :: Val END FUNCTION f_getARRAYValuesFromTriplet_self END INTERFACE INTERFACE ArrayValues MODULE PROCEDURE f_getValues_self , & & f_getSectionValues_self , & & f_getValuesFromTriplet_self , & & f_getARRAYValues_self , & & f_getARRAYSectionValues_self , & & f_getARRAYValuesFromTriplet_self END INTERFACE PUBLIC :: ArrayValues INTERFACE getValues MODULE PROCEDURE f_getValues_self , & & f_getSectionValues_self , & & f_getValuesFromTriplet_self , & & f_getARRAYValues_self , & & f_getARRAYSectionValues_self , & & f_getARRAYValuesFromTriplet_self END INTERFACE getValues PUBLIC :: getValues !---------------------------------------------------------------------------- !                                                       ArrayValues@GetMethod !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION f_getValues_Int ( Obj , DataType ) RESULT ( Val ) CLASS ( IntVector_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: DataType INTEGER ( I4B ), ALLOCATABLE :: Val ( : ) END FUNCTION f_getValues_Int MODULE PURE FUNCTION f_getSectionValues_Int ( Obj , Indx , DataType ) & & RESULT ( Val ) CLASS ( IntVector_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Indx ( : ) INTEGER ( I4B ), INTENT ( IN ) :: DataType INTEGER ( I4B ), ALLOCATABLE :: Val ( : ) END FUNCTION f_getSectionValues_Int MODULE PURE FUNCTION f_getValuesFromTriplet_Int ( Obj , iStart , iEnd , Stride ,& & DataType ) RESULT ( Val ) CLASS ( IntVector_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: iStart , iEnd , Stride INTEGER ( I4B ), INTENT ( IN ) :: DataType INTEGER ( I4B ), ALLOCATABLE :: Val ( : ) END FUNCTION f_getValuesFromTriplet_Int MODULE PURE FUNCTION f_getARRAYValues_Int ( Obj , DataType ) RESULT ( Val ) CLASS ( IntVector_ ), INTENT ( IN ) :: Obj ( : ) INTEGER ( I4B ), INTENT ( IN ) :: DataType INTEGER ( I4B ), ALLOCATABLE :: Val ( : ) END FUNCTION f_getARRAYValues_Int MODULE PURE FUNCTION f_getARRAYSectionValues_Int ( Obj , Indx , DataType ) & & RESULT ( Val ) CLASS ( IntVector_ ), INTENT ( IN ) :: Obj ( : ) INTEGER ( I4B ), INTENT ( IN ) :: DataType INTEGER ( I4B ), INTENT ( IN ) :: Indx ( : ) INTEGER ( I4B ), ALLOCATABLE :: Val ( : ) END FUNCTION f_getARRAYSectionValues_Int MODULE PURE FUNCTION f_getARRAYValuesFromTriplet_Int ( Obj , iStart , iEnd , & & Stride , & & DataType ) RESULT ( Val ) CLASS ( IntVector_ ), INTENT ( IN ) :: Obj ( : ) INTEGER ( I4B ), INTENT ( IN ) :: iStart , iEnd , Stride INTEGER ( I4B ), INTENT ( IN ) :: DataType INTEGER ( I4B ), ALLOCATABLE :: Val ( : ) END FUNCTION f_getARRAYValuesFromTriplet_Int END INTERFACE INTERFACE ArrayValues MODULE PROCEDURE f_getValues_Int , & & f_getSectionValues_Int , & & f_getValuesFromTriplet_Int , & & f_getARRAYValues_Int , & & f_getARRAYSectionValues_Int , & & f_getARRAYValuesFromTriplet_Int END INTERFACE ArrayValues INTERFACE getValues MODULE PROCEDURE f_getValues_Int , & & f_getSectionValues_Int , & & f_getValuesFromTriplet_Int , & & f_getARRAYValues_Int , & & f_getARRAYSectionValues_Int , & & f_getARRAYValuesFromTriplet_Int END INTERFACE getValues !---------------------------------------------------------------------------- !                                                               ArrayPointers !---------------------------------------------------------------------------- INTERFACE MODULE FUNCTION f_getPointer_self ( Obj , DataType ) RESULT ( Val ) CLASS ( IntVector_ ), INTENT ( IN ), TARGET :: Obj TYPE ( IntVector_ ), INTENT ( IN ) :: DataType TYPE ( IntVector_ ), POINTER :: Val END FUNCTION f_getPointer_self MODULE FUNCTION f_getPointer_Int ( Obj , DataType ) RESULT ( Val ) CLASS ( IntVector_ ), INTENT ( IN ), TARGET :: Obj INTEGER ( I4B ), INTENT ( IN ) :: DataType INTEGER ( I4B ), POINTER :: Val ( : ) END FUNCTION f_getPointer_Int END INTERFACE INTERFACE ArrayPointer MODULE PROCEDURE f_getPointer_self , f_getPointer_Int END INTERFACE PUBLIC :: ArrayPointer !---------------------------------------------------------------------------- !                                                                 Convert !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE obj_convert_int ( From , To ) CLASS ( IntVector_ ), INTENT ( IN ) :: From INTEGER ( I4B ), ALLOCATABLE , INTENT ( INOUT ) :: To ( : ) END SUBROUTINE obj_convert_int END INTERFACE INTERFACE Convert MODULE PROCEDURE obj_convert_int END INTERFACE Convert PUBLIC :: Convert !---------------------------------------------------------------------------- !                                                           IndexOf@getMethod !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION IndexOf_1 ( Obj , Value ) RESULT ( Ans ) CLASS ( IntVector_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Value INTEGER ( I4B ) :: Ans END FUNCTION IndexOf_1 MODULE PURE FUNCTION IndexOf_2 ( Obj , Value ) RESULT ( Ans ) CLASS ( IntVector_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Value ( : ) INTEGER ( I4B ), ALLOCATABLE :: Ans ( : ) END FUNCTION IndexOf_2 MODULE PURE FUNCTION IndexOf_3 ( Obj , Value ) RESULT ( Ans ) INTEGER ( I4B ), INTENT ( IN ) :: Obj ( : ) INTEGER ( I4B ), INTENT ( IN ) :: Value INTEGER ( I4B ) :: Ans END FUNCTION IndexOf_3 MODULE PURE FUNCTION IndexOf_4 ( Obj , Value ) RESULT ( Ans ) INTEGER ( I4B ), INTENT ( IN ) :: Obj ( : ) INTEGER ( I4B ), INTENT ( IN ) :: Value ( : ) INTEGER ( I4B ), ALLOCATABLE :: Ans ( : ) END FUNCTION IndexOf_4 END INTERFACE INTERFACE IndexOF MODULE PROCEDURE IndexOf_1 , IndexOf_2 , IndexOf_3 , IndexOf_4 END INTERFACE PUBLIC :: IndexOf INTERFACE LOC MODULE PROCEDURE IndexOf_1 , IndexOf_2 , IndexOf_3 , IndexOf_4 END INTERFACE LOC PUBLIC :: LOC !---------------------------------------------------------------------------- !                                                        isPresent@getMethod !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION isPresent_1 ( Obj , Value ) RESULT ( Ans ) CLASS ( IntVector_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Value LOGICAL ( LGT ) :: Ans END FUNCTION isPresent_1 MODULE PURE FUNCTION isPresent_2 ( Obj , Value ) RESULT ( Ans ) CLASS ( IntVector_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Value ( : ) LOGICAL ( LGT ), ALLOCATABLE :: Ans ( : ) END FUNCTION isPresent_2 END INTERFACE INTERFACE isPresent MODULE PROCEDURE isPresent_1 , isPresent_2 END INTERFACE isPresent PUBLIC :: isPresent ! INTERFACE OPERATOR( .EQ. ) !   MODULE PROCEDURE isPresent_1, isPresent_2 ! END INTERFACE ! PUBLIC :: OPERATOR( .EQ. ) !---------------------------------------------------------------------------- !                                                                      Append !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE Append_1 ( Obj , Value ) CLASS ( IntVector_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Value END SUBROUTINE Append_1 MODULE PURE SUBROUTINE Append_2 ( Obj , Value ) CLASS ( IntVector_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Value ( : ) END SUBROUTINE Append_2 MODULE PURE SUBROUTINE Append_3 ( Obj , AnotherObj ) CLASS ( IntVector_ ), INTENT ( INOUT ) :: Obj CLASS ( IntVector_ ), INTENT ( IN ) :: AnotherObj END SUBROUTINE Append_3 END INTERFACE INTERFACE Append MODULE PROCEDURE Append_1 , Append_2 , Append_3 END INTERFACE Append PUBLIC :: Append !---------------------------------------------------------------------------- !                                                         setValue@SetMethod !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE setValue_1 ( Obj , Indx , Value ) CLASS ( IntVector_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Indx ( : ) INTEGER ( I4B ), INTENT ( IN ) :: Value ( : ) END SUBROUTINE setValue_1 END INTERFACE INTERFACE SetValue MODULE PROCEDURE setValue_1 END INTERFACE PUBLIC :: SetValue !---------------------------------------------------------------------------- !                                                 RemoveDuplicate@setMethod !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE remove_duplicates ( Obj ) CLASS ( IntVector_ ), INTENT ( INOUT ) :: Obj END SUBROUTINE remove_duplicates END INTERFACE INTERFACE MODULE PURE SUBROUTINE remove_dupl_intvec ( Obj ) INTEGER ( I4B ), ALLOCATABLE , INTENT ( INOUT ) :: Obj ( : ) END SUBROUTINE remove_dupl_intvec END INTERFACE INTERFACE RemoveDuplicates MODULE PROCEDURE remove_duplicates , remove_dupl_intvec END INTERFACE RemoveDuplicates PUBLIC :: RemoveDuplicates !---------------------------------------------------------------------------- !                                                           Repeat@setMethod !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION repeat_int ( Val , rtimes ) RESULT ( Ans ) INTEGER ( I4B ), INTENT ( IN ) :: Val ( : ) INTEGER ( I4B ), INTENT ( IN ) :: rtimes INTEGER ( I4B ) :: Ans ( SIZE ( Val ) * rtimes ) END FUNCTION repeat_int END INTERFACE INTERFACE MODULE PURE FUNCTION repeat_obj ( Obj , rtimes ) RESULT ( Ans ) TYPE ( IntVector_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: rtimes INTEGER ( I4B ) :: Ans ( SIZE ( Obj % Val ) * rtimes ) END FUNCTION repeat_obj END INTERFACE INTERFACE Repeat MODULE PROCEDURE repeat_int , repeat_obj END INTERFACE Repeat PUBLIC :: Repeat !---------------------------------------------------------------------------- !                                                                 Contains !---------------------------------------------------------------------------- #include \"./contains.part\" END MODULE IntVector_Method","tags":"","loc":"sourcefile/intvector_method.f90.html"},{"title":"RealVector_Method.f90 – Fortran Program","text":"Contents Modules RealVector_Method Source Code RealVector_Method.f90 Source Code MODULE RealVector_Method USE GlobalData USE IO USE BaseType , ONLY : RealVector_ , File_ IMPLICIT NONE PRIVATE !---------------------------------------------------------------------------- !                                                          Shape@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION get_shape ( Obj ) RESULT ( Ans ) CLASS ( RealVector_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ) :: Ans ( 1 ) END FUNCTION get_shape END INTERFACE INTERFACE Shape MODULE PROCEDURE get_shape END INTERFACE Shape PUBLIC :: Shape !---------------------------------------------------------------------------- !                                                           SIZE@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION get_size ( Obj , Dims ) RESULT ( Ans ) TYPE ( RealVector_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: Dims INTEGER ( I4B ) :: Ans END FUNCTION get_size END INTERFACE INTERFACE SIZE MODULE PROCEDURE get_size END INTERFACE SIZE PUBLIC :: SIZE !---------------------------------------------------------------------------- !                                                   AllocateData@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE Allocate_Data ( Obj , Dims ) CLASS ( RealVector_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Dims END SUBROUTINE Allocate_Data END INTERFACE INTERFACE AllocateData MODULE PROCEDURE Allocate_Data END INTERFACE AllocateData PUBLIC :: AllocateData !---------------------------------------------------------------------------- !                                                 DeAllocateData@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE Deallocate_Data ( Obj ) CLASS ( RealVector_ ), INTENT ( INOUT ) :: Obj END SUBROUTINE Deallocate_Data END INTERFACE INTERFACE DeallocateData MODULE PROCEDURE Deallocate_Data END INTERFACE DeallocateData PUBLIC :: DeallocateData !---------------------------------------------------------------------------- !                                                       Initiate@Constructor !---------------------------------------------------------------------------- INTERFACE !! This subroutine allocate the memory for [[RealVector_]] !> authors: Dr. Vikas Sharma ! ! This subroutine allocates the memeory for [[RealVector_]] ! ! ```fortran ! CALL Initiate(Obj, 5) !``` MODULE PURE SUBROUTINE initiate_obj ( Obj , tSize ) CLASS ( RealVector_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: tSize END SUBROUTINE initiate_obj END INTERFACE !---------------------------------------------------------------------------- !                                                       Initiate@Constructor !---------------------------------------------------------------------------- INTERFACE !! This subroutine allocate the memory for a vector of type [[RealVector_]] !> authors: Dr. Vikas Sharma ! ! This subroutine allocate the memory for a vector of type [[RealVector_]] ! The size of `Obj` would be same as the size of `tSize` MODULE PURE SUBROUTINE initiate_obj_vector ( Obj , tSize ) TYPE ( RealVector_ ), ALLOCATABLE , INTENT ( INOUT ) :: Obj ( : ) INTEGER ( I4B ), INTENT ( IN ) :: tSize ( : ) END SUBROUTINE initiate_obj_vector END INTERFACE !---------------------------------------------------------------------------- !                                                       Initiate@Constructor !---------------------------------------------------------------------------- INTERFACE !! This subroutine allocate the memory for an instance of [[RealVector_]] !> authors: Dr. Vikas Sharma ! ! This subroutine allocate the memory for an instance of [[RealVector_]]. ! User can specify the lowerbounds and upper bounds MODULE PURE SUBROUTINE initiate_obj_ab ( Obj , a , b ) CLASS ( RealVector_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: a , b END SUBROUTINE initiate_obj_ab END INTERFACE INTERFACE Initiate MODULE PROCEDURE initiate_obj , initiate_obj_vector , initiate_obj_ab END INTERFACE Initiate PUBLIC :: Initiate !---------------------------------------------------------------------------- !                                                  Random_number@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE RANDOM_NUMBER_Obj ( Obj , tsize ) CLASS ( RealVector_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: tsize END SUBROUTINE RANDOM_NUMBER_Obj END INTERFACE !---------------------------------------------------------------------------- !                                                  Random_number@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE Random_number_obj_vec ( Obj , tsize ) TYPE ( RealVector_ ), ALLOCATABLE , INTENT ( INOUT ) :: Obj (:) INTEGER ( I4B ), INTENT ( IN ) :: tsize ( : ) END SUBROUTINE Random_number_obj_vec END INTERFACE INTERFACE RANDOM_NUMBER MODULE PROCEDURE RANDOM_NUMBER_Obj , Random_number_obj_vec END INTERFACE RANDOM_NUMBER PUBLIC :: RANDOM_NUMBER !---------------------------------------------------------------------------- !                                                         Vector@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION Constructor1 ( tSize ) RESULT ( Obj ) TYPE ( RealVector_ ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: tSize END FUNCTION Constructor1 END INTERFACE INTERFACE RealVector MODULE PROCEDURE Constructor1 END INTERFACE RealVector PUBLIC :: RealVector !---------------------------------------------------------------------------- !                                                 Vector_Pointer@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION Constructor_1 ( tSize ) RESULT ( Obj ) CLASS ( RealVector_ ), POINTER :: Obj INTEGER ( I4B ), INTENT ( IN ) :: tSize END FUNCTION Constructor_1 END INTERFACE INTERFACE RealVector_Pointer MODULE PROCEDURE Constructor_1 END INTERFACE RealVector_Pointer PUBLIC :: RealVector_Pointer !---------------------------------------------------------------------------- !                                                 Vector_Pointer@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION Constructor_Int8 ( Val ) RESULT ( Obj ) CLASS ( RealVector_ ), POINTER :: Obj INTEGER ( Int8 ), INTENT ( IN ) :: Val ( : ) END FUNCTION Constructor_Int8 MODULE PURE FUNCTION ConstructorInt8 ( Val ) RESULT ( Obj ) TYPE ( RealVector_ ) :: Obj INTEGER ( Int8 ), INTENT ( IN ) :: Val ( : ) END FUNCTION ConstructorInt8 END INTERFACE INTERFACE RealVector MODULE PROCEDURE ConstructorInt8 END INTERFACE RealVector INTERFACE RealVector_Pointer MODULE PROCEDURE Constructor_Int8 END INTERFACE RealVector_Pointer INTERFACE MODULE PURE FUNCTION Constructor_Int16 ( Val ) RESULT ( Obj ) CLASS ( RealVector_ ), POINTER :: Obj INTEGER ( Int16 ), INTENT ( IN ) :: Val ( : ) END FUNCTION Constructor_Int16 MODULE PURE FUNCTION ConstructorInt16 ( Val ) RESULT ( Obj ) TYPE ( RealVector_ ) :: Obj INTEGER ( Int16 ), INTENT ( IN ) :: Val ( : ) END FUNCTION ConstructorInt16 END INTERFACE INTERFACE RealVector MODULE PROCEDURE ConstructorInt16 END INTERFACE RealVector INTERFACE RealVector_Pointer MODULE PROCEDURE Constructor_Int16 END INTERFACE RealVector_Pointer INTERFACE MODULE PURE FUNCTION Constructor_Int32 ( Val ) RESULT ( Obj ) CLASS ( RealVector_ ), POINTER :: Obj INTEGER ( Int32 ), INTENT ( IN ) :: Val ( : ) END FUNCTION Constructor_Int32 MODULE PURE FUNCTION ConstructorInt32 ( Val ) RESULT ( Obj ) TYPE ( RealVector_ ) :: Obj INTEGER ( Int32 ), INTENT ( IN ) :: Val ( : ) END FUNCTION ConstructorInt32 END INTERFACE INTERFACE RealVector MODULE PROCEDURE ConstructorInt32 END INTERFACE RealVector INTERFACE RealVector_Pointer MODULE PROCEDURE Constructor_Int32 END INTERFACE RealVector_Pointer INTERFACE MODULE PURE FUNCTION Constructor_Int64 ( Val ) RESULT ( Obj ) CLASS ( RealVector_ ), POINTER :: Obj INTEGER ( Int64 ), INTENT ( IN ) :: Val ( : ) END FUNCTION Constructor_Int64 MODULE PURE FUNCTION ConstructorInt64 ( Val ) RESULT ( Obj ) TYPE ( RealVector_ ) :: Obj INTEGER ( Int64 ), INTENT ( IN ) :: Val ( : ) END FUNCTION ConstructorInt64 END INTERFACE INTERFACE RealVector MODULE PROCEDURE ConstructorInt64 END INTERFACE RealVector INTERFACE RealVector_Pointer MODULE PROCEDURE Constructor_Int64 END INTERFACE RealVector_Pointer INTERFACE MODULE PURE FUNCTION Constructor_Real32 ( Val ) RESULT ( Obj ) CLASS ( RealVector_ ), POINTER :: Obj REAL ( Real32 ), INTENT ( IN ) :: Val ( : ) END FUNCTION Constructor_Real32 MODULE PURE FUNCTION ConstructorReal32 ( Val ) RESULT ( Obj ) TYPE ( RealVector_ ) :: Obj REAL ( Real32 ), INTENT ( IN ) :: Val ( : ) END FUNCTION ConstructorReal32 END INTERFACE INTERFACE RealVector MODULE PROCEDURE ConstructorReal32 END INTERFACE RealVector INTERFACE RealVector_Pointer MODULE PROCEDURE Constructor_Real32 END INTERFACE RealVector_Pointer INTERFACE MODULE PURE FUNCTION Constructor_Real64 ( Val ) RESULT ( Obj ) CLASS ( RealVector_ ), POINTER :: Obj REAL ( Real64 ), INTENT ( IN ) :: Val ( : ) END FUNCTION Constructor_Real64 MODULE PURE FUNCTION ConstructorReal64 ( Val ) RESULT ( Obj ) TYPE ( RealVector_ ) :: Obj REAL ( Real64 ), INTENT ( IN ) :: Val ( : ) END FUNCTION ConstructorReal64 END INTERFACE INTERFACE RealVector MODULE PROCEDURE ConstructorReal64 END INTERFACE RealVector INTERFACE RealVector_Pointer MODULE PROCEDURE Constructor_Real64 END INTERFACE RealVector_Pointer !---------------------------------------------------------------------------- !                                                     ArrayValues@GetMethod !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION f_getValues_self ( Obj , DataType ) RESULT ( Val ) CLASS ( RealVector_ ), INTENT ( IN ) :: Obj TYPE ( RealVector_ ), INTENT ( IN ) :: DataType TYPE ( RealVector_ ) :: Val END FUNCTION f_getValues_self MODULE PURE FUNCTION f_getSectionValues_self ( Obj , Indx , DataType ) RESULT ( Val ) CLASS ( RealVector_ ), INTENT ( IN ) :: Obj TYPE ( RealVector_ ), INTENT ( IN ) :: DataType INTEGER ( I4B ), INTENT ( IN ) :: Indx ( : ) TYPE ( RealVector_ ) :: Val END FUNCTION f_getSectionValues_self MODULE PURE FUNCTION f_getValuesFromTriplet_self ( Obj , iStart , iEnd , Stride , & & DataType ) RESULT ( Val ) CLASS ( RealVector_ ), INTENT ( IN ) :: Obj TYPE ( RealVector_ ), INTENT ( IN ) :: DataType INTEGER ( I4B ), INTENT ( IN ) :: iStart , iEnd , Stride TYPE ( RealVector_ ) :: Val END FUNCTION f_getValuesFromTriplet_self MODULE PURE FUNCTION f_getARRAYValues_self ( Obj , DataType ) RESULT ( Val ) CLASS ( RealVector_ ), INTENT ( IN ) :: Obj ( : ) TYPE ( RealVector_ ), INTENT ( IN ) :: DataType TYPE ( RealVector_ ) :: Val END FUNCTION f_getARRAYValues_self MODULE PURE FUNCTION f_getARRAYSectionValues_self ( Obj , Indx , DataType ) RESULT ( Val ) CLASS ( RealVector_ ), INTENT ( IN ) :: Obj ( : ) TYPE ( RealVector_ ), INTENT ( IN ) :: DataType INTEGER ( I4B ), INTENT ( IN ) :: Indx ( : ) TYPE ( RealVector_ ) :: Val END FUNCTION f_getARRAYSectionValues_self MODULE PURE FUNCTION f_getARRAYValuesFromTriplet_self ( Obj , iStart , iEnd , Stride , & & DataType ) RESULT ( Val ) CLASS ( RealVector_ ), INTENT ( IN ) :: Obj ( : ) INTEGER ( I4B ), INTENT ( IN ) :: iStart , iEnd , Stride TYPE ( RealVector_ ), INTENT ( IN ) :: DataType TYPE ( RealVector_ ) :: Val END FUNCTION f_getARRAYValuesFromTriplet_self END INTERFACE INTERFACE ArrayValues MODULE PROCEDURE f_getValues_self , & & f_getSectionValues_self , & & f_getValuesFromTriplet_self , & & f_getARRAYValues_self , & & f_getARRAYSectionValues_self , & & f_getARRAYValuesFromTriplet_self END INTERFACE PUBLIC :: ArrayValues !---------------------------------------------------------------------------- !                                                     ArrayValues@GetMethod !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION f_getValues_Int ( Obj , DataType ) RESULT ( Val ) CLASS ( RealVector_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: DataType INTEGER ( I4B ), ALLOCATABLE :: Val ( : ) END FUNCTION f_getValues_Int MODULE PURE FUNCTION f_getSectionValues_Int ( Obj , Indx , DataType ) RESULT ( Val ) CLASS ( RealVector_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Indx ( : ) INTEGER ( I4B ), INTENT ( IN ) :: DataType INTEGER ( I4B ), ALLOCATABLE :: Val ( : ) END FUNCTION f_getSectionValues_Int MODULE PURE FUNCTION f_getValuesFromTriplet_Int ( Obj , iStart , iEnd , Stride , & & DataType ) RESULT ( Val ) CLASS ( RealVector_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: iStart , iEnd , Stride INTEGER ( I4B ), INTENT ( IN ) :: DataType INTEGER ( I4B ), ALLOCATABLE :: Val ( : ) END FUNCTION f_getValuesFromTriplet_Int MODULE PURE FUNCTION f_getARRAYValues_Int ( Obj , DataType ) RESULT ( Val ) CLASS ( RealVector_ ), INTENT ( IN ) :: Obj ( : ) INTEGER ( I4B ), INTENT ( IN ) :: DataType INTEGER ( I4B ), ALLOCATABLE :: Val ( : ) END FUNCTION f_getARRAYValues_Int MODULE PURE FUNCTION f_getARRAYSectionValues_Int ( Obj , Indx , DataType ) RESULT ( Val ) CLASS ( RealVector_ ), INTENT ( IN ) :: Obj ( : ) INTEGER ( I4B ), INTENT ( IN ) :: DataType INTEGER ( I4B ), INTENT ( IN ) :: Indx ( : ) INTEGER ( I4B ), ALLOCATABLE :: Val ( : ) END FUNCTION f_getARRAYSectionValues_Int MODULE PURE FUNCTION f_getARRAYValuesFromTriplet_Int ( Obj , iStart , iEnd , & & Stride , DataType ) RESULT ( Val ) CLASS ( RealVector_ ), INTENT ( IN ) :: Obj ( : ) INTEGER ( I4B ), INTENT ( IN ) :: iStart , iEnd , Stride INTEGER ( I4B ), INTENT ( IN ) :: DataType INTEGER ( I4B ), ALLOCATABLE :: Val ( : ) END FUNCTION f_getARRAYValuesFromTriplet_Int END INTERFACE INTERFACE ArrayValues MODULE PROCEDURE f_getValues_Int , & & f_getSectionValues_Int , & & f_getValuesFromTriplet_Int , & & f_getARRAYValues_Int , & & f_getARRAYValuesFromTriplet_Int END INTERFACE ArrayValues INTERFACE MODULE PURE FUNCTION f_getValues_Real ( Obj , DataType ) RESULT ( Val ) CLASS ( RealVector_ ), INTENT ( IN ) :: Obj REAL ( DFP ), INTENT ( IN ) :: DataType REAL ( DFP ), ALLOCATABLE :: Val ( : ) END FUNCTION f_getValues_Real MODULE PURE FUNCTION f_getSectionValues_Real ( Obj , Indx , DataType ) RESULT ( Val ) CLASS ( RealVector_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Indx ( : ) REAL ( DFP ), INTENT ( IN ) :: DataType REAL ( DFP ), ALLOCATABLE :: Val ( : ) END FUNCTION f_getSectionValues_Real MODULE PURE FUNCTION f_getValuesFromTriplet_Real ( Obj , iStart , iEnd , Stride , & & DataType ) RESULT ( Val ) CLASS ( RealVector_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: iStart , iEnd , Stride REAL ( DFP ), INTENT ( IN ) :: DataType REAL ( DFP ), ALLOCATABLE :: Val ( : ) END FUNCTION f_getValuesFromTriplet_Real MODULE PURE FUNCTION f_getARRAYValues_Real ( Obj , DataType ) RESULT ( Val ) CLASS ( RealVector_ ), INTENT ( IN ) :: Obj ( : ) REAL ( DFP ), INTENT ( IN ) :: DataType REAL ( DFP ), ALLOCATABLE :: Val ( : ) END FUNCTION f_getARRAYValues_Real MODULE PURE FUNCTION f_getARRAYSectionValues_Real ( Obj , Indx , DataType ) RESULT ( Val ) CLASS ( RealVector_ ), INTENT ( IN ) :: Obj ( : ) REAL ( DFP ), INTENT ( IN ) :: DataType INTEGER ( I4B ), INTENT ( IN ) :: Indx ( : ) REAL ( DFP ), ALLOCATABLE :: Val ( : ) END FUNCTION f_getARRAYSectionValues_Real MODULE PURE FUNCTION f_getARRAYValuesFromTriplet_Real ( Obj , iStart , iEnd , Stride , & & DataType ) RESULT ( Val ) CLASS ( RealVector_ ), INTENT ( IN ) :: Obj ( : ) INTEGER ( I4B ), INTENT ( IN ) :: iStart , iEnd , Stride REAL ( DFP ), INTENT ( IN ) :: DataType REAL ( DFP ), ALLOCATABLE :: Val ( : ) END FUNCTION f_getARRAYValuesFromTriplet_Real END INTERFACE INTERFACE ArrayValues MODULE PROCEDURE f_getValues_Real , & & f_getSectionValues_Real , & & f_getValuesFromTriplet_Real , & & f_getARRAYValues_Real , & & f_getARRAYSectionValues_Real , & & f_getARRAYValuesFromTriplet_Real END INTERFACE ArrayValues !---------------------------------------------------------------------------- !                                                    ArrayPointers@getMethod !---------------------------------------------------------------------------- INTERFACE MODULE FUNCTION f_getPointer_self ( Obj , DataType ) RESULT ( Val ) CLASS ( RealVector_ ), INTENT ( IN ), TARGET :: Obj TYPE ( RealVector_ ), INTENT ( IN ) :: DataType TYPE ( RealVector_ ), POINTER :: Val END FUNCTION f_getPointer_self MODULE FUNCTION f_getPointer_Real64 ( Obj , DataType ) RESULT ( Val ) CLASS ( RealVector_ ), INTENT ( IN ), TARGET :: Obj REAL ( Real64 ), INTENT ( IN ) :: DataType REAL ( Real64 ), POINTER :: Val ( : ) END FUNCTION f_getPointer_Real64 END INTERFACE INTERFACE ArrayPointer MODULE PROCEDURE f_getPointer_self , f_getPointer_Real64 END INTERFACE PUBLIC :: ArrayPointer !---------------------------------------------------------------------------- !                                                           IndexOf@getMethod !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION IndexOf_1 ( Obj , Value ) RESULT ( Ans ) CLASS ( RealVector_ ), INTENT ( IN ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Value INTEGER ( I4B ) :: Ans END FUNCTION IndexOf_1 MODULE PURE FUNCTION IndexOf_2 ( Obj , Value ) RESULT ( Ans ) CLASS ( RealVector_ ), INTENT ( IN ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Value ( : ) INTEGER ( I4B ), ALLOCATABLE :: Ans ( : ) END FUNCTION IndexOf_2 END INTERFACE INTERFACE IndexOF MODULE PROCEDURE IndexOf_1 , IndexOf_2 END INTERFACE PUBLIC :: IndexOf INTERFACE LOC MODULE PROCEDURE IndexOf_1 , IndexOf_2 END INTERFACE LOC PUBLIC :: LOC !---------------------------------------------------------------------------- !                                                         isPresentgetMethod !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION isPresent_1 ( Obj , Value ) RESULT ( Ans ) CLASS ( RealVector_ ), INTENT ( IN ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Value LOGICAL ( LGT ) :: Ans END FUNCTION isPresent_1 MODULE PURE FUNCTION isPresent_2 ( Obj , Value ) RESULT ( Ans ) CLASS ( RealVector_ ), INTENT ( IN ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Value ( : ) LOGICAL ( LGT ), ALLOCATABLE :: Ans ( : ) END FUNCTION isPresent_2 END INTERFACE INTERFACE isPresent MODULE PROCEDURE isPresent_1 , isPresent_2 END INTERFACE isPresent PUBLIC :: isPresent INTERFACE OPERATOR ( . EQ . ) MODULE PROCEDURE isPresent_1 , isPresent_2 END INTERFACE PUBLIC :: OPERATOR ( . EQ . ) !---------------------------------------------------------------------------- !                                                          Append@getMethod !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE Append_1 ( Obj , Value ) CLASS ( RealVector_ ), INTENT ( INOUT ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Value END SUBROUTINE Append_1 MODULE PURE SUBROUTINE Append_2 ( Obj , Value ) CLASS ( RealVector_ ), INTENT ( INOUT ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Value ( : ) END SUBROUTINE Append_2 MODULE PURE SUBROUTINE Append_3 ( Obj , AnotherObj ) CLASS ( RealVector_ ), INTENT ( INOUT ) :: Obj CLASS ( RealVector_ ), INTENT ( IN ) :: AnotherObj END SUBROUTINE Append_3 END INTERFACE INTERFACE Append MODULE PROCEDURE Append_1 , Append_2 , Append_3 END INTERFACE Append PUBLIC :: Append !<---------------------------------------------------------------------------- !                                                                   NRM2@BLAS1 !<---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION NRM2scalar ( Obj ) RESULT ( Ans ) CLASS ( RealVector_ ), INTENT ( IN ) :: Obj REAL ( DFP ) :: Ans END FUNCTION NRM2scalar MODULE PURE FUNCTION NRM2vector ( Obj ) RESULT ( Ans ) CLASS ( RealVector_ ), INTENT ( IN ) :: Obj ( : ) REAL ( DFP ) :: Ans END FUNCTION NRM2vector END INTERFACE INTERFACE NORM2 MODULE PROCEDURE NRM2scalar , NRM2vector END INTERFACE NORM2 PUBLIC :: NORM2 ! <--------------------------------------------------------------------------- !                                                               NORM2SQR@BLAS1 ! <--------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION NRM2SQRscalar ( Obj ) RESULT ( Ans ) CLASS ( RealVector_ ), INTENT ( IN ) :: Obj REAL ( DFP ) :: Ans END FUNCTION NRM2SQRscalar MODULE PURE FUNCTION NRM2SQRvector ( Obj ) RESULT ( Ans ) CLASS ( RealVector_ ), INTENT ( IN ) :: Obj ( : ) REAL ( DFP ) :: Ans END FUNCTION NRM2SQRvector MODULE PURE FUNCTION NRM2SQRintrinsic ( Val ) RESULT ( Ans ) REAL ( DFP ), INTENT ( IN ) :: Val ( : ) REAL ( DFP ) :: Ans END FUNCTION NRM2SQRintrinsic END INTERFACE INTERFACE NORM2SQR MODULE PROCEDURE NRM2SQRscalar , NRM2SQRvector , NRM2SQRintrinsic END INTERFACE NORM2SQR PUBLIC :: NORM2SQR !<---------------------------------------------------------------------------- !                                                                   DOT@BLAS1 !<---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION intrinsicDOTintrinsic ( Val1 , Val2 ) RESULT ( Ans ) REAL ( DFP ), INTENT ( IN ) :: Val1 ( : ), Val2 ( : ) REAL ( DFP ) :: Ans END FUNCTION intrinsicDOTintrinsic MODULE PURE FUNCTION scalarDOTscalar ( Obj1 , Obj2 ) RESULT ( Ans ) CLASS ( RealVector_ ), INTENT ( IN ) :: Obj1 , Obj2 REAL ( DFP ) :: Ans END FUNCTION scalarDOTscalar MODULE PURE FUNCTION vectorDOTvector ( Obj1 , Obj2 ) RESULT ( Ans ) CLASS ( RealVector_ ), INTENT ( IN ) :: Obj1 ( : ), Obj2 ( : ) REAL ( DFP ) :: Ans END FUNCTION vectorDOTvector MODULE PURE FUNCTION vectorDOTscalar ( Obj1 , Obj2 ) RESULT ( Ans ) CLASS ( RealVector_ ), INTENT ( IN ) :: Obj1 ( : ), Obj2 REAL ( DFP ) :: Ans END FUNCTION vectorDOTscalar MODULE PURE FUNCTION scalarDOTvector ( Obj1 , Obj2 ) RESULT ( Ans ) CLASS ( RealVector_ ), INTENT ( IN ) :: Obj1 , Obj2 ( : ) REAL ( DFP ) :: Ans END FUNCTION scalarDOTvector MODULE PURE FUNCTION intrinsicDOTscalar ( Val , Obj ) RESULT ( Ans ) REAL ( DFP ), INTENT ( IN ) :: Val ( : ) CLASS ( RealVector_ ), INTENT ( IN ) :: Obj REAL ( DFP ) :: Ans END FUNCTION intrinsicDOTscalar MODULE PURE FUNCTION scalarDOTintrinsic ( Obj , Val ) RESULT ( Ans ) REAL ( DFP ), INTENT ( IN ) :: Val ( : ) CLASS ( RealVector_ ), INTENT ( IN ) :: Obj REAL ( DFP ) :: Ans END FUNCTION scalarDOTintrinsic END INTERFACE INTERFACE DOT MODULE PROCEDURE scalarDOTscalar , vectorDOTvector , vectorDOTscalar , & & scalarDOTvector , intrinsicDOTintrinsic , & & scalarDOTintrinsic END INTERFACE DOT PUBLIC :: DOT !---------------------------------------------------------------------------- !                                                                 ASUM@BLAS1 !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION ASUMIntrinsic ( Val ) RESULT ( Ans ) REAL ( DFP ), INTENT ( IN ) :: Val ( : ) REAL ( DFP ) :: Ans END FUNCTION ASUMIntrinsic MODULE PURE FUNCTION ASUMScalar ( Obj ) RESULT ( Ans ) CLASS ( RealVector_ ), INTENT ( IN ) :: Obj REAL ( DFP ) :: Ans END FUNCTION ASUMScalar MODULE PURE FUNCTION ASUMvector ( Obj ) RESULT ( Ans ) CLASS ( RealVector_ ), INTENT ( IN ) :: Obj ( : ) REAL ( DFP ) :: Ans END FUNCTION ASUMvector END INTERFACE INTERFACE ASUM MODULE PROCEDURE ASUMScalar , ASUMvector , ASUMIntrinsic END INTERFACE ASUM PUBLIC :: ASUM !---------------------------------------------------------------------------- !                                                                 COPY@BLAS1 !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE intrinsicCOPYintrinsic ( Val1 , Val2 ) REAL ( DFP ), INTENT ( IN ) :: Val2 ( : ) REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: Val1 ( : ) END SUBROUTINE intrinsicCOPYintrinsic MODULE PURE SUBROUTINE scalarCOPYscalar ( Obj1 , Obj2 ) TYPE ( RealVector_ ), INTENT ( INOUT ) :: Obj1 CLASS ( RealVector_ ), INTENT ( IN ) :: Obj2 END SUBROUTINE scalarCOPYscalar MODULE PURE SUBROUTINE vectorCOPYvector ( Obj1 , Obj2 ) TYPE ( RealVector_ ), INTENT ( INOUT ), ALLOCATABLE :: Obj1 ( : ) CLASS ( RealVector_ ), INTENT ( IN ) :: Obj2 ( : ) END SUBROUTINE vectorCOPYvector MODULE PURE SUBROUTINE scalarCOPYvector ( Obj1 , Obj2 ) TYPE ( RealVector_ ), INTENT ( INOUT ) :: Obj1 CLASS ( RealVector_ ), INTENT ( IN ) :: Obj2 ( : ) END SUBROUTINE scalarCOPYvector MODULE PURE SUBROUTINE scalarCOPYintrinsic ( Obj , Val ) CLASS ( RealVector_ ), INTENT ( INOUT ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Val ( : ) END SUBROUTINE scalarCOPYintrinsic MODULE PURE SUBROUTINE intrinsicCOPYscalar ( Val , Obj ) CLASS ( RealVector_ ), INTENT ( IN ) :: Obj REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: Val ( : ) END SUBROUTINE intrinsicCOPYscalar END INTERFACE INTERFACE COPY MODULE PROCEDURE intrinsicCOPYintrinsic , scalarCOPYscalar , & & vectorCOPYvector , scalarCOPYvector , scalarCOPYintrinsic END INTERFACE COPY PUBLIC :: COPY !---------------------------------------------------------------------------- !                                                          SHALLOWCOPY@BLAS1 !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE intrinsicSHALLOWCOPYintrinsic ( Val1 , Val2 ) REAL ( DFP ), INTENT ( IN ) :: Val2 ( : ) REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: Val1 ( : ) END SUBROUTINE intrinsicSHALLOWCOPYintrinsic MODULE PURE SUBROUTINE scalarSHALLOWCOPYscalar ( Obj1 , Obj2 ) TYPE ( RealVector_ ), INTENT ( INOUT ) :: Obj1 CLASS ( RealVector_ ), INTENT ( IN ) :: Obj2 END SUBROUTINE scalarSHALLOWCOPYscalar MODULE PURE SUBROUTINE vectorSHALLOWCOPYvector ( Obj1 , Obj2 ) TYPE ( RealVector_ ), INTENT ( INOUT ), ALLOCATABLE :: Obj1 ( : ) CLASS ( RealVector_ ), INTENT ( IN ) :: Obj2 ( : ) END SUBROUTINE vectorSHALLOWCOPYvector MODULE PURE SUBROUTINE scalarSHALLOWCOPYvector ( Obj1 , Obj2 ) TYPE ( RealVector_ ), INTENT ( INOUT ) :: Obj1 CLASS ( RealVector_ ), INTENT ( IN ) :: Obj2 ( : ) END SUBROUTINE scalarSHALLOWCOPYvector MODULE PURE SUBROUTINE scalarSHALLOWCOPYintrinsic ( Obj , Val ) CLASS ( RealVector_ ), INTENT ( INOUT ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Val ( : ) END SUBROUTINE scalarSHALLOWCOPYintrinsic MODULE PURE SUBROUTINE intrinsicSHALLOWCOPYscalar ( Val , Obj ) CLASS ( RealVector_ ), INTENT ( IN ) :: Obj REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: Val ( : ) END SUBROUTINE intrinsicSHALLOWCOPYscalar END INTERFACE INTERFACE SHALLOWCOPY MODULE PROCEDURE intrinsicSHALLOWCOPYintrinsic , scalarSHALLOWCOPYscalar , & & vectorSHALLOWCOPYvector , scalarSHALLOWCOPYvector , & & scalarSHALLOWCOPYintrinsic END INTERFACE SHALLOWCOPY PUBLIC :: SHALLOWCOPY !---------------------------------------------------------------------------- !                                                                 SWAP@BLAS1 !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE intrinsicSWAPintrinsic ( Val1 , Val2 ) REAL ( DFP ), INTENT ( INOUT ) :: Val1 ( : ), Val2 ( : ) END SUBROUTINE intrinsicSWAPintrinsic MODULE PURE SUBROUTINE scalarSWAPscalar ( Obj1 , Obj2 ) CLASS ( RealVector_ ), INTENT ( INOUT ) :: Obj1 , Obj2 END SUBROUTINE scalarSWAPscalar MODULE PURE SUBROUTINE vectorSWAPvector ( Obj1 , Obj2 ) CLASS ( RealVector_ ), INTENT ( INOUT ) :: Obj1 ( : ), Obj2 ( : ) END SUBROUTINE vectorSWAPvector MODULE PURE SUBROUTINE scalarSWAPintrinsic ( Obj , Val ) CLASS ( RealVector_ ), INTENT ( INOUT ) :: Obj REAL ( DFP ), INTENT ( INOUT ) :: Val ( : ) END SUBROUTINE scalarSWAPintrinsic MODULE PURE SUBROUTINE intrinsicSWAPscalar ( Val , Obj ) CLASS ( RealVector_ ), INTENT ( INOUT ) :: Obj REAL ( DFP ), INTENT ( INOUT ) :: Val ( : ) END SUBROUTINE intrinsicSWAPscalar END INTERFACE INTERFACE SWAP MODULE PROCEDURE scalarSWAPscalar , & & vectorSWAPvector , scalarSWAPintrinsic END INTERFACE SWAP PUBLIC :: SWAP !---------------------------------------------------------------------------- !                                                                SCALE@BLAS1 !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE SCALintrinsic ( alpha , Val ) REAL ( DFP ), INTENT ( INOUT ) :: Val ( : ) REAL ( DFP ), INTENT ( IN ) :: alpha END SUBROUTINE SCALintrinsic MODULE PURE SUBROUTINE SCALscalar ( alpha , Obj ) CLASS ( RealVector_ ), INTENT ( INOUT ) :: Obj REAL ( DFP ), INTENT ( IN ) :: alpha END SUBROUTINE SCALscalar MODULE PURE SUBROUTINE SCALvector ( alpha , Obj ) CLASS ( RealVector_ ), INTENT ( INOUT ) :: Obj ( : ) REAL ( DFP ), INTENT ( IN ) :: alpha END SUBROUTINE SCALvector END INTERFACE INTERFACE SCALE MODULE PROCEDURE SCALintrinsic , SCALscalar , SCALvector END INTERFACE SCALE PUBLIC :: SCALE !---------------------------------------------------------------------------- !                                                                  AXPY@BLAS1 !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE scalarAXPYscalar ( Obj1 , alpha , Obj2 ) CLASS ( RealVector_ ), INTENT ( INOUT ) :: Obj1 REAL ( DFP ), INTENT ( IN ) :: alpha CLASS ( RealVector_ ), INTENT ( IN ) :: Obj2 END SUBROUTINE scalarAXPYscalar MODULE PURE SUBROUTINE vectorAXPYvector ( Obj1 , alpha , Obj2 ) CLASS ( RealVector_ ), INTENT ( INOUT ) :: Obj1 ( : ) REAL ( DFP ), INTENT ( IN ) :: alpha CLASS ( RealVector_ ), INTENT ( IN ) :: Obj2 ( : ) END SUBROUTINE vectorAXPYvector MODULE PURE SUBROUTINE scalarAXPYintrinsic ( Obj , alpha , Val ) CLASS ( RealVector_ ), INTENT ( INOUT ) :: Obj REAL ( DFP ), INTENT ( IN ) :: alpha REAL ( DFP ), INTENT ( IN ) :: Val ( : ) END SUBROUTINE scalarAXPYintrinsic MODULE PURE SUBROUTINE intrinsicAXPYintrinsic ( Val1 , alpha , Val2 ) REAL ( DFP ), INTENT ( INOUT ) :: Val1 ( : ) REAL ( DFP ), INTENT ( IN ) :: alpha REAL ( DFP ), INTENT ( IN ) :: Val2 ( : ) END SUBROUTINE intrinsicAXPYintrinsic END INTERFACE INTERFACE AXPY MODULE PROCEDURE scalarAXPYscalar , vectorAXPYvector , & & scalarAXPYintrinsic , intrinsicAXPYintrinsic END INTERFACE AXPY PUBLIC :: AXPY !---------------------------------------------------------------------------- !                                                         setValue@SetMethod !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE setValue_1 ( Obj , Indx , Value ) CLASS ( RealVector_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Indx ( : ) REAL ( DFP ), INTENT ( IN ) :: Value ( : ) END SUBROUTINE setValue_1 END INTERFACE INTERFACE SetValue MODULE PROCEDURE setValue_1 END INTERFACE PUBLIC :: SetValue !---------------------------------------------------------------------------- !                                                                Display@IO !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE RealVectorDisplay ( Obj , msg , UnitNo , path , filename , & & extension ) CLASS ( RealVector_ ), INTENT ( IN ) :: Obj ( : ) CHARACTER ( LEN = * ), INTENT ( IN ) :: msg INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: UnitNo CHARACTER ( LEN = * ), OPTIONAL , INTENT ( IN ) :: path CHARACTER ( LEN = * ), OPTIONAL , INTENT ( IN ) :: filename CHARACTER ( LEN = * ), OPTIONAL , INTENT ( IN ) :: extension END SUBROUTINE RealVectorDisplay END INTERFACE !---------------------------------------------------------------------------- !                                                                 Display@IO !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE RealscalarDisplay ( Obj , msg , UnitNo , path , filename , & & extension ) CLASS ( RealVector_ ), INTENT ( IN ) :: Obj CHARACTER ( LEN = * ), INTENT ( IN ) :: msg INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: UnitNo CHARACTER ( LEN = * ), OPTIONAL , INTENT ( IN ) :: path CHARACTER ( LEN = * ), OPTIONAL , INTENT ( IN ) :: filename CHARACTER ( LEN = * ), OPTIONAL , INTENT ( IN ) :: extension END SUBROUTINE RealscalarDisplay END INTERFACE !---------------------------------------------------------------------------- !                                                                 Display@IO !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE Display_Vector_Real ( vec , msg , unitNo , path , filename , & & extension ) ! Define intent of dummy variables INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: unitNo REAL ( DFP ), INTENT ( IN ) :: vec ( : ) CHARACTER ( LEN = * ), INTENT ( IN ) :: msg CHARACTER ( LEN = * ), OPTIONAL , INTENT ( IN ) :: path CHARACTER ( LEN = * ), OPTIONAL , INTENT ( IN ) :: filename CHARACTER ( LEN = * ), OPTIONAL , INTENT ( IN ) :: extension END SUBROUTINE Display_Vector_Real END INTERFACE INTERFACE Display MODULE PROCEDURE RealVectorDisplay , RealscalarDisplay , Display_Vector_Real END INTERFACE Display PUBLIC :: Display !---------------------------------------------------------------------------- !                                                                 Contains !---------------------------------------------------------------------------- #include \"./contains.part\" END MODULE RealVector_Method","tags":"","loc":"sourcefile/realvector_method.f90.html"},{"title":"ElemshapeData_Method.f90 – Fortran Program","text":"Contents Modules ElemshapeData_Method Source Code ElemshapeData_Method.f90 Source Code MODULE ElemshapeData_Method !! This module implements methods related to [[elemShapeData_]] datatype USE BaseType USE GlobalData IMPLICIT NONE PRIVATE !---------------------------------------------------------------------------- !                                                       Initiate@Constructor !---------------------------------------------------------------------------- INTERFACE !! This subroutine allocate the memory for various matrices in the object !> authors: Dr. Vikas Sharma ! ! This subroutine allocates the memory for various arrays in & ! [[elemshapedata_]] object MODULE PURE SUBROUTINE initiate_obj ( Obj , nsd , xidim , nns , nips ) CLASS ( ElemshapeData_ ), INTENT ( INOUT ) :: Obj !! object to be returned INTEGER ( I4B ), INTENT ( IN ) :: nsd !! spatial dimension INTEGER ( I4B ), INTENT ( IN ) :: xidim !! xidimension INTEGER ( I4B ), INTENT ( IN ) :: nns !! number of nodes in element INTEGER ( I4B ), INTENT ( IN ) :: nips !! number of integration points END SUBROUTINE initiate_obj END INTERFACE INTERFACE AllocateData MODULE PROCEDURE initiate_obj END INTERFACE AllocateData PUBLIC :: AllocateData !---------------------------------------------------------------------------- !                                                       Initiate@Constructor !---------------------------------------------------------------------------- INTERFACE !! This subroutine initiate time shape function data in [[stelemshapedata_]] !> authors: Dr. Vikas Sharma ! ! This subroutine initiate time shape function data in [[stelemshapedata_]]. ! To do so effeciently we construct local shape function for time element ! externally by using [[elemshapedata_]], and supply this information. ! ! This subroutine set `T`, `dTdTheta`, `Jt`, `Wt`, `Theta` ! ! - it will allocate `Obj` ! - the size of `Obj` will be equal to total number of integration points in !   in time domain MODULE PURE SUBROUTINE stsd_initiate ( Obj , elemsd ) TYPE ( STElemShapeData_ ), ALLOCATABLE , INTENT ( INOUT ) :: Obj ( : ) TYPE ( ElemShapeData_ ), INTENT ( IN ) :: elemsd END SUBROUTINE stsd_initiate END INTERFACE INTERFACE Initiate MODULE PROCEDURE stsd_initiate END INTERFACE Initiate PUBLIC :: Initiate !---------------------------------------------------------------------------- !                                                 DeallocateData@Constructor !---------------------------------------------------------------------------- INTERFACE !! this subroutine deallocates the data stored inside [[elemshapedata_]] !> authors: Dr. Vikas Sharma ! ! This subroutine deallocates the data stored inside [[elemshapedata_]] and ! [[stelemshapedata_]] MODULE PURE SUBROUTINE deallocate_data ( Obj ) CLASS ( ElemshapeData_ ), INTENT ( INOUT ) :: Obj END SUBROUTINE deallocate_data END INTERFACE INTERFACE DeallocateData MODULE PROCEDURE deallocate_data END INTERFACE DeallocateData PUBLIC :: DeallocateData !---------------------------------------------------------------------------- !                                                        Display@Constructor !---------------------------------------------------------------------------- INTERFACE !! This subroutine display the content of object !> authors: Dr. Vikas Sharma ! ! This subroutine displays the content of [[elemshapedata_]] and ! [[stelemshapedata_]] MODULE SUBROUTINE display_obj ( Obj , Msg , UnitNo ) CLASS ( ElemshapeData_ ), INTENT ( IN ) :: Obj CHARACTER ( LEN = * ), INTENT ( IN ) :: Msg INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: UnitNo END SUBROUTINE display_obj END INTERFACE INTERFACE Display MODULE PROCEDURE display_obj END INTERFACE Display PUBLIC :: Display !---------------------------------------------------------------------------- !                                                     setThickness@setMethod !---------------------------------------------------------------------------- INTERFACE !! This subroutine set the thickness field !> authors: Dr. Vikas Sharma ! ! This subroutine set the `thickness` field ! Here `Val` denotes the nodal value of thickeness ! ! d = d_{I} N&#94;{I} MODULE PURE SUBROUTINE set_thickness ( Obj , Val , N ) CLASS ( ElemshapeData_ ), INTENT ( INOUT ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Val ( : ), N ( :, : ) !! Nodal values of thickness END SUBROUTINE set_thickness END INTERFACE !---------------------------------------------------------------------------- !                                                     setThickness@setMethod !---------------------------------------------------------------------------- INTERFACE !! This subroutine set the thickness field !> authors: Dr. Vikas Sharma ! ! This subroutine set the `thickness` field ! Here `Val` denotes the space-time nodal value of thickeness ! ! d = d_{I}&#94;{a} N&#94;{I} T_{a} MODULE PURE SUBROUTINE stsd_set_thickness ( Obj , Val , N , T ) CLASS ( STElemshapeData_ ), INTENT ( INOUT ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Val ( :, : ), N (:,:), T (:) !! Space-time nodal values of thickness END SUBROUTINE stsd_set_thickness END INTERFACE INTERFACE setThickness MODULE PROCEDURE set_thickness , stsd_set_thickness END INTERFACE PUBLIC :: setThickness !---------------------------------------------------------------------------- !                                              setBarycentricCoord@setMethod !---------------------------------------------------------------------------- INTERFACE !! This subroutine set the Barycentric coordinates !> authors: Dr. Vikas Sharma ! ! This subroutine set the barycentric coordinates ! ! x_i = x_{iI} N&#94;{I} MODULE PURE SUBROUTINE set_coord ( Obj , Val , N ) CLASS ( ElemshapeData_ ), INTENT ( INOUT ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Val ( :, : ) !! Nodal coordinates in `xiJ` format REAL ( DFP ), INTENT ( IN ) :: N (:,:) !! When element is not an isoparametric we can supply N. END SUBROUTINE set_coord END INTERFACE !---------------------------------------------------------------------------- !                                              setBarycentricCoord@setMethod !---------------------------------------------------------------------------- INTERFACE !! This subroutine set the Barycentric coordinates !> authors: Dr. Vikas Sharma ! ! This subroutine set the barycentric coordinates by using ! space-time nodal coordinates ! ! x=x_{I}&#94;{a} N&#94;I T_a MODULE PURE SUBROUTINE stsd_set_coord ( Obj , Val , N , T ) CLASS ( STElemshapeData_ ), INTENT ( INOUT ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Val ( :, :, : ) !! space-time Nodal coordinates in `xiJ` format REAL ( DFP ), INTENT ( IN ) :: N ( :, : ), T ( : ) !! N and T are required to handle non isoparametric elements END SUBROUTINE stsd_set_coord END INTERFACE INTERFACE setBarycentricCoord MODULE PROCEDURE set_coord , stsd_set_coord END INTERFACE setBarycentricCoord PUBLIC :: setBarycentricCoord !---------------------------------------------------------------------------- !                                                            setJs@setMethod !---------------------------------------------------------------------------- INTERFACE !! This subroutine set the determinent of jacobian !> authors: Dr. Vikas Sharma ! ! This subroutine will internally set the value of jacobian MODULE PURE SUBROUTINE set_Js ( Obj ) CLASS ( ElemShapeData_ ), INTENT ( INOUT ) :: Obj END SUBROUTINE set_Js END INTERFACE INTERFACE setJs MODULE PROCEDURE set_Js END INTERFACE setJs PUBLIC setJs !---------------------------------------------------------------------------- !                                                          setdNdXt@setMethod !---------------------------------------------------------------------------- INTERFACE !! This subroutine set $\\frac{d N}{d X_t}$ internally !> authors: Dr. Vikas Sharma ! ! This subroutine will internally set `dNdXt`. ! It use the inverse of jacobian stored internally, so make sure jacobian is ! set before calling this  subroutine. MODULE PURE SUBROUTINE set_dNdXt_internally ( Obj ) CLASS ( ElemshapeData_ ), INTENT ( INOUT ) :: Obj END SUBROUTINE set_dNdXt_internally END INTERFACE INTERFACE setdNdXt MODULE PROCEDURE set_dNdXt_internally END INTERFACE setdNdXt PUBLIC :: setdNdXt !---------------------------------------------------------------------------- !                                                      setJacobian@setMethod !---------------------------------------------------------------------------- INTERFACE !! This subroutine set the jacobian !> authors: Dr. Vikas Sharma ! ! This subroutine set the jacobian by using the nodal coordinates ! ! \\frac{d x_i}{d \\xi_j} = x_{iI}\\frac{d N&#94;I}{d \\xi_j} MODULE PURE SUBROUTINE set_jacobian ( Obj , Val , dNdXi ) CLASS ( ElemshapeData_ ), INTENT ( INOUT ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Val ( :, : ) !! nodal coordinates in `xiJ` format REAL ( DFP ), INTENT ( IN ) :: dNdXi ( :, :, : ) END SUBROUTINE set_jacobian END INTERFACE !---------------------------------------------------------------------------- !                                                      setJacobian@setMethod !---------------------------------------------------------------------------- INTERFACE !! This subroutine set the jacobian using space-time nodal coords !> authors: Dr. Vikas Sharma ! ! This subroutine set the jacobian by using space-time nodal coords, `dNdXi` ! `T` are used to handle non-isoparameteric elements. ! ! \\frac{d x_i}{d \\xi_j} = x_{iI}&#94;{a}T_a\\frac{d N&#94;I}{d \\xi_j} MODULE PURE SUBROUTINE stsd_set_jacobian ( Obj , Val , dNdXi , T ) CLASS ( STElemshapeData_ ), INTENT ( INOUT ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Val ( :, :, : ) !! Space time nodal values of coordinates REAL ( DFP ), INTENT ( IN ) :: dNdXi (:,:,:) !! Local derivative of shape function for geometry REAL ( DFP ), INTENT ( IN ) :: T (:) !! Shape function for time element END SUBROUTINE stsd_set_jacobian END INTERFACE INTERFACE setJacobian MODULE PROCEDURE set_jacobian , stsd_set_jacobian END INTERFACE setJacobian PUBLIC :: setJacobian !---------------------------------------------------------------------------- !                                                         setdNTdt@setMethod !---------------------------------------------------------------------------- INTERFACE !! This subroutine set `dNTdt` by using the space-time nodal values !> authors: Dr. Vikas Sharma ! ! - This subroutine set `dNTdt` by using space-time nodal values ! - It is important to note that `dNTdXt` should be allocated before calling ! - This subroutine uses following formula ! ! \\frac{\\partial N&#94;{I\\  }T_{a}}{\\partial t} =N&#94;{I}\\frac{\\partial T_{a}} ! {\\partial \\theta } J&#94;{-1}_{t}-\\frac{\\partial N&#94;{I}T_{a}}{\\partial x_{k}} ! \\hat{v}_{k}  MODULE PURE SUBROUTINE stsd_set_dNTdt ( Obj , Val ) CLASS ( STElemShapeData_ ), INTENT ( INOUT ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Val ( :, :, : ) !! Space-time nodal values END SUBROUTINE stsd_set_dNTdt END INTERFACE INTERFACE setdNTdt MODULE PROCEDURE stsd_set_dNTdt END INTERFACE setdNTdt PUBLIC :: setdNTdt !---------------------------------------------------------------------------- !                                                        setdNTdXt@setMethod !---------------------------------------------------------------------------- INTERFACE !! This subroutine set `dNTdXt` by using internal data !> authors: Dr. Vikas Sharma ! ! This subroutine set `dNTdXt` by using internal data ! This subroutine uses inverse of Jacobian, therefore, before calling ! this subroutine make sure to set jacobian ! ! \\frac{\\partial N&#94;{I\\  }T_{a}}{\\partial x_{i\\  }} ! =\\frac{\\partial N&#94;{I}T_{a}}{\\partial \\xi_{j} } \\frac{\\partial \\xi_{j} } ! {\\partial x_{i}}  MODULE PURE SUBROUTINE stsd_set_dNTdXt_internally ( Obj ) CLASS ( STElemShapeData_ ), INTENT ( INOUT ) :: Obj !! Space-time nodal values END SUBROUTINE stsd_set_dNTdXt_internally END INTERFACE INTERFACE setdNTdXt MODULE PROCEDURE stsd_set_dNTdXt_internally END INTERFACE setdNTdXt PUBLIC :: setdNTdXt !---------------------------------------------------------------------------- !                                                         setValue@setMethod !---------------------------------------------------------------------------- INTERFACE !! This subroutine set parameters defined on physical element !> authors: Dr. Vikas Sharma ! ! This subroutine set parameters defined on physical element ! ! - `Val` denotes nodal coordinates of element in `xiJ` format ! - This subroutine will call !     - `setJacobian` !     - `setJs` !     - `setdNdXt` !     - `setBarycentricCoord` ! - The facility of `N` and `dNdXi` allow us to handle non-isoparametric ! elements ! ! @note ! In case `Obj` is instance of [[stelemshapedata_]] then `val` will denotes ! coordinates of spatial nodes at some time in [tn, tn+1] ! @endnote MODULE PURE SUBROUTINE set_value ( Obj , Val , N , dNdXi ) CLASS ( ElemshapeData_ ), INTENT ( INOUT ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Val ( :, : ) !! Spatial nodal coordinates REAL ( DFP ), INTENT ( IN ) :: N (:, :) !! Shape function for geometry REAL ( DFP ), INTENT ( IN ) :: dNdXi ( :, :, : ) !! Local derivative of shape functions for geometry END SUBROUTINE set_value END INTERFACE !---------------------------------------------------------------------------- !                                                         setValue@setMethod !---------------------------------------------------------------------------- INTERFACE !! This subroutine set parameters defined on physical element !> authors: Dr. Vikas Sharma ! ! This subroutine set parameters defined on physical element ! ! - `Val` denotes coordinates of the space-time element in `xiJa` format ! - The facility of supplying `N`, `T`, and `dNdXi` allows us to handle ! non-isoparametric element ! - This subroutine will call !     - `setJacobian` uses `dNdXi` !     - `setJs` !     - `setdNdXt` !     - `setBarycentricCoord` uses `N` and `T` !     - `setdNTdXt` !     - `setdNTdt` ! ! @note ! In case of [[stelemshapedata_]] `val` denotes nodal coordinate at ! some intermediate space-time slab ! @endnote MODULE PURE SUBROUTINE stsd_set_value ( Obj , Val , N , T , dNdXi ) CLASS ( STElemshapeData_ ), INTENT ( INOUT ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Val ( :, :, : ) !! Spatial nodal coordinates REAL ( DFP ), INTENT ( IN ) :: N ( :, : ) REAL ( DFP ), INTENT ( IN ) :: T ( : ) REAL ( DFP ), INTENT ( IN ) :: dNdXi ( :, :, : ) END SUBROUTINE stsd_set_value END INTERFACE INTERFACE setValue MODULE PROCEDURE set_value , stsd_set_value END INTERFACE setValue PUBLIC :: setValue !---------------------------------------------------------------------------- !                                                                 setNormal !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE set_normal ( Obj ) CLASS ( ElemShapeData_ ), INTENT ( INOUT ) :: Obj END SUBROUTINE set_normal END INTERFACE INTERFACE setNormal MODULE PROCEDURE set_normal END INTERFACE setNormal PUBLIC :: setNormal !---------------------------------------------------------------------------- !                                                 getInterpolation@getMethod !---------------------------------------------------------------------------- INTERFACE !! This subroutine performs interpolations !> authors: Dr. Vikas Sharma ! ! This subroutine performs interpolation of a scalar from its spatial nodal ! values. ! u=u_{I}N&#94;{I} MODULE PURE SUBROUTINE get_interpol_scalar ( Obj , Interpol , Val ) CLASS ( ElemshapeData_ ), INTENT ( IN ) :: Obj REAL ( DFP ), INTENT ( INOUT ), ALLOCATABLE :: Interpol ( : ) !! Interpolation value of `val` at integration points REAL ( DFP ), INTENT ( IN ) :: Val ( : ) !! spatial nodal values of scalar END SUBROUTINE get_interpol_scalar END INTERFACE !---------------------------------------------------------------------------- !                                                getInterpolation@getMethod !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE get_interpol_fevar_scalar ( Obj , Interpol , Val ) CLASS ( ElemShapeData_ ), INTENT ( IN ) :: Obj TYPE ( FEVariable_ ), INTENT ( IN ) :: Val REAL ( DFP ), INTENT ( INOUT ) :: Interpol (:) END SUBROUTINE get_interpol_fevar_scalar END INTERFACE !---------------------------------------------------------------------------- !                                                 getInterpolation@getMethod !---------------------------------------------------------------------------- INTERFACE !! This subroutine performs interpolation of a vector !> authors: Dr. Vikas Sharma ! ! This subroutine performs interpolation of a vector from its spatial ! nodal values ! ! u_{i}=u_{iI}N&#94;{I} MODULE PURE SUBROUTINE get_interpol_vector ( Obj , Interpol , Val ) CLASS ( ElemshapeData_ ), INTENT ( IN ) :: Obj REAL ( DFP ), INTENT ( INOUT ), ALLOCATABLE :: Interpol ( :, : ) !! Interpol(:,ips) => interpolation value at integration points REAL ( DFP ), INTENT ( IN ) :: Val ( :, : ) !! nodal values of vector in `xiJ` format END SUBROUTINE get_interpol_vector END INTERFACE !---------------------------------------------------------------------------- !                                                 getInterpolation@getMethod !---------------------------------------------------------------------------- INTERFACE !! This subroutine performs interpolation of matrix !> authors: Dr. Vikas Sharma ! ! This subroutine performs interpolation of matrix MODULE PURE SUBROUTINE get_interpol_matrix ( Obj , Interpol , Val ) CLASS ( ElemshapeData_ ), INTENT ( IN ) :: Obj REAL ( DFP ), INTENT ( INOUT ), ALLOCATABLE :: Interpol ( :, :, : ) REAL ( DFP ), INTENT ( IN ) :: Val ( :, :, : ) !! nodal value of matrix END SUBROUTINE get_interpol_matrix END INTERFACE !---------------------------------------------------------------------------- !                                                 getInterpolation@getMethod !---------------------------------------------------------------------------- INTERFACE !! This subroutine performs interpolation of matrix !> authors: Dr. Vikas Sharma ! ! This subroutine performs interpolation of matrix MODULE PURE SUBROUTINE get_interpol_fevar_matrix ( Obj , Interpol , Val ) CLASS ( ElemshapeData_ ), INTENT ( IN ) :: Obj REAL ( DFP ), INTENT ( INOUT ) :: Interpol ( :, :, : ) TYPE ( FEVariable_ ), INTENT ( IN ) :: Val END SUBROUTINE get_interpol_fevar_matrix END INTERFACE INTERFACE getInterpolation MODULE PROCEDURE get_interpol_scalar , get_interpol_vector , & & get_interpol_matrix , get_interpol_fevar_scalar , & & get_interpol_fevar_matrix END INTERFACE getInterpolation PUBLIC :: getInterpolation !---------------------------------------------------------------------------- !                                                    Interpolation@getMethod !---------------------------------------------------------------------------- INTERFACE !! This function returns the interpolation of a scalar !> authors: Dr. Vikas Sharma ! ! This function returns interpolation of scalar MODULE PURE FUNCTION interpol_scalar ( Obj , Val ) RESULT ( Interpol ) CLASS ( ElemshapeData_ ), INTENT ( IN ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Val ( : ) REAL ( DFP ), ALLOCATABLE :: Interpol ( : ) END FUNCTION interpol_scalar END INTERFACE !---------------------------------------------------------------------------- !                                                    Interpolation@getMethod !---------------------------------------------------------------------------- INTERFACE !! This function returns the interpolation of vector !> authors: Dr. Vikas Sharma ! ! This function returns the interpolation of vectors MODULE PURE FUNCTION interpol_vector ( Obj , Val ) RESULT ( Interpol ) CLASS ( ElemshapeData_ ), INTENT ( IN ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Val ( :, : ) REAL ( DFP ), ALLOCATABLE :: Interpol ( :, : ) END FUNCTION interpol_vector END INTERFACE !---------------------------------------------------------------------------- !                                                    Interpolation@getMethod !---------------------------------------------------------------------------- INTERFACE !! This function returns the interpolation of matrix !> authors: Dr. Vikas Sharma ! ! This function returns the interpolation of matrix MODULE PURE FUNCTION interpol_matrix ( Obj , Val ) RESULT ( Interpol ) CLASS ( ElemshapeData_ ), INTENT ( IN ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Val ( :, :, : ) REAL ( DFP ), ALLOCATABLE :: Interpol ( :, :, : ) END FUNCTION interpol_matrix END INTERFACE INTERFACE Interpolation MODULE PROCEDURE interpol_scalar , interpol_vector , interpol_matrix END INTERFACE Interpolation PUBLIC :: Interpolation !---------------------------------------------------------------------------- !                                               getSTInterpolation@getMethod !---------------------------------------------------------------------------- INTERFACE !! This subroutine performs interpolations of scalar !> authors: Dr. Vikas Sharma ! ! This subroutine performs interpolation of a scalar from its space-time nodal ! values. ! u=u&#94;{a}_{I}N&#94;{I}T_{a} MODULE PURE SUBROUTINE stsd_get_interpol_scalar ( Obj , Interpol , Val ) CLASS ( STElemshapeData_ ), INTENT ( IN ) :: Obj REAL ( DFP ), INTENT ( INOUT ), ALLOCATABLE :: Interpol ( : ) !! Interpolation value of `val` at integration points REAL ( DFP ), INTENT ( IN ) :: Val ( :, : ) !! spatial nodal values of scalar END SUBROUTINE stsd_get_interpol_scalar END INTERFACE !---------------------------------------------------------------------------- !                                                getInterpolation@getMethod !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE stsd_get_interpol_fevar_scalar ( Obj , Interpol , Val ) CLASS ( STElemShapeData_ ), INTENT ( IN ) :: Obj ( : ) TYPE ( FEVariable_ ), INTENT ( IN ) :: Val REAL ( DFP ), INTENT ( INOUT ) :: Interpol (:, :) END SUBROUTINE stsd_get_interpol_fevar_scalar END INTERFACE !---------------------------------------------------------------------------- !                                               getSTInterpolation@getMethod !---------------------------------------------------------------------------- INTERFACE !! This subroutine performs interpolation of a vector !> authors: Dr. Vikas Sharma ! ! This subroutine performs interpolation of a vector from its space-time ! nodal values ! ! u_{i}=u&#94;{a}_{iI}N&#94;{I}T_{a} MODULE PURE SUBROUTINE stsd_get_interpol_vector ( Obj , Interpol , Val ) CLASS ( STElemshapeData_ ), INTENT ( IN ) :: Obj REAL ( DFP ), INTENT ( INOUT ), ALLOCATABLE :: Interpol ( :, : ) !! Interpol(:,ips) => interpolation value at integration points REAL ( DFP ), INTENT ( IN ) :: Val ( :, :, : ) !! space-time nodal values of vector in `xiJa` format END SUBROUTINE stsd_get_interpol_vector END INTERFACE !---------------------------------------------------------------------------- !                                               getSTInterpolation@getMethod !---------------------------------------------------------------------------- INTERFACE !! This subroutine performs interpolation of matrix !> authors: Dr. Vikas Sharma ! ! This subroutine performs interpolation of matrix from its space-time ! nodal values MODULE PURE SUBROUTINE stsd_get_interpol_matrix ( Obj , Interpol , Val ) CLASS ( STElemshapeData_ ), INTENT ( IN ) :: Obj REAL ( DFP ), INTENT ( INOUT ), ALLOCATABLE :: Interpol ( :, :, : ) REAL ( DFP ), INTENT ( IN ) :: Val ( :, :, :, : ) !! nodal value of matrix END SUBROUTINE stsd_get_interpol_matrix END INTERFACE !---------------------------------------------------------------------------- !                                                getInterpolation@getMethod !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE stsd_get_interpol_fevar_matrix ( Obj , Interpol , Val ) CLASS ( STElemShapeData_ ), INTENT ( IN ) :: Obj ( : ) TYPE ( FEVariable_ ), INTENT ( IN ) :: Val REAL ( DFP ), INTENT ( INOUT ) :: Interpol (:, :, :, :) END SUBROUTINE stsd_get_interpol_fevar_matrix END INTERFACE !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- INTERFACE getInterpolation MODULE PROCEDURE stsd_get_interpol_scalar , stsd_get_interpol_vector , & & stsd_get_interpol_matrix , stsd_get_interpol_fevar_scalar , & & stsd_get_interpol_fevar_matrix END INTERFACE getInterpolation !---------------------------------------------------------------------------- !                                                 STInterpolation@getMethod !---------------------------------------------------------------------------- INTERFACE !! This function performs interpolations of scalar !> authors: Dr. Vikas Sharma ! ! This function performs interpolation of a scalar from its space-time nodal ! values. ! u=u&#94;{a}_{I}N&#94;{I}T_{a} MODULE PURE FUNCTION stsd_interpol_scalar ( Obj , Val ) RESULT ( interpol ) CLASS ( STElemshapeData_ ), INTENT ( IN ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Val ( :, : ) !! space-time nodal values of scalar REAL ( DFP ), ALLOCATABLE :: Interpol ( : ) !! Interpolation value of `val` at integration points END FUNCTION stsd_interpol_scalar END INTERFACE !---------------------------------------------------------------------------- !                                                 STInterpolation@getMethod !---------------------------------------------------------------------------- INTERFACE !! This function performs interpolations of vector !> authors: Dr. Vikas Sharma ! ! This function performs interpolation of a vector from its space-time nodal ! values. ! u=u&#94;{a}_{I}N&#94;{I}T_{a} MODULE PURE FUNCTION stsd_interpol_vector ( Obj , Val ) RESULT ( interpol ) CLASS ( STElemshapeData_ ), INTENT ( IN ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Val ( :, :, : ) !! spatial nodal values of vector REAL ( DFP ), ALLOCATABLE :: Interpol ( :, : ) !! Interpolation value of `val` at integration points END FUNCTION stsd_interpol_vector END INTERFACE !---------------------------------------------------------------------------- !                                                 STInterpolation@getMethod !---------------------------------------------------------------------------- INTERFACE !! This function performs interpolations of matrix !> authors: Dr. Vikas Sharma ! ! This function performs interpolation of a matrix from its space-time nodal ! values. ! u=u&#94;{a}_{I}N&#94;{I}T_{a} MODULE PURE FUNCTION stsd_interpol_matrix ( Obj , Val ) RESULT ( interpol ) CLASS ( STElemshapeData_ ), INTENT ( IN ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Val ( :, :, :, : ) !! spatial nodal values of matrix REAL ( DFP ), ALLOCATABLE :: Interpol ( :, :, : ) !! Interpolation value of `val` at integration points END FUNCTION stsd_interpol_matrix END INTERFACE INTERFACE STInterpolation MODULE PROCEDURE stsd_interpol_scalar , stsd_interpol_vector , & & stsd_interpol_matrix END INTERFACE STInterpolation !---------------------------------------------------------------------------- !                                                 getLocalGradient@getMethod !---------------------------------------------------------------------------- INTERFACE !! This subroutine returns the local gradient of a scalar !> authors: Dr. Vikas Sharma ! ! This subroutine returns the local gradient of a scalar from space ! nodal values ! ! \\frac{\\partial \\phi }{\\partial \\xi_{i} } =\\phi_{I} \\frac{\\partial N&#94;{I}} ! {\\partial \\xi_{i} } MODULE PURE SUBROUTINE getLocalGradient_scalar ( Obj , dPhidXi , Val ) CLASS ( ElemShapeData_ ), INTENT ( IN ) :: Obj REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: dPhidXi ( :, : ) REAL ( DFP ), INTENT ( IN ) :: Val ( : ) !! Space nodal values of scalar END SUBROUTINE getLocalGradient_scalar END INTERFACE !---------------------------------------------------------------------------- !                                                 getLocalGradient@getMethod !---------------------------------------------------------------------------- INTERFACE !! This subroutine returns the local gradient of a vector !> authors: Dr. Vikas Sharma ! ! This subroutine returns the local gradient of a vector MODULE PURE SUBROUTINE getLocalGradient_vector ( Obj , dVdXi , Val ) CLASS ( ElemshapeData_ ), INTENT ( IN ) :: Obj REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: dVdXi ( :, :, : ) !! local gradient at integration points REAL ( DFP ), INTENT ( IN ) :: Val ( :, : ) !! nodal values of vector in `xiJ` format END SUBROUTINE getLocalGradient_vector END INTERFACE !---------------------------------------------------------------------------- !                                                 getLocalGradient@getMethod !---------------------------------------------------------------------------- INTERFACE !! This subroutine returns the local gradient of a scalar !> authors: Dr. Vikas Sharma ! ! This subroutine returns the local gradient of a scalar from space ! time nodal values ! ! \\frac{\\partial \\phi }{\\partial \\xi_{i} } =\\phi&#94;{a}_{I} T_{a}\\frac !{\\partial N&#94;{I}}{\\partial \\xi_{i} } MODULE PURE SUBROUTINE stsd_getLocalGradient_scalar ( Obj , dPhidXi , Val ) CLASS ( STElemShapeData_ ), INTENT ( IN ) :: Obj REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: dPhidXi ( :, : ) !! local gradient of scalar REAL ( DFP ), INTENT ( IN ) :: Val ( :, : ) !! space-time nodal values END SUBROUTINE stsd_getLocalGradient_scalar END INTERFACE !---------------------------------------------------------------------------- !                                                 getLocalGradient@getMethod !---------------------------------------------------------------------------- INTERFACE !! This subroutine returns the local gradient of a vector !> authors: Dr. Vikas Sharma ! ! This subroutine returns the local gradient of a vector using space-time ! nodal coordinates MODULE PURE SUBROUTINE stsd_getLocalGradient_vector ( Obj , dVdXi , Val ) CLASS ( STElemshapeData_ ), INTENT ( IN ) :: Obj REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: dVdXi ( :, :, : ) !! local gradient at integration points REAL ( DFP ), INTENT ( IN ) :: Val ( :, :, : ) !! space-time nodal values of vector in `xiJa` format END SUBROUTINE stsd_getLocalGradient_vector END INTERFACE !---------------------------------------------------------------------------- !                                                           getLocalGradient !---------------------------------------------------------------------------- INTERFACE getLocalGradient MODULE PROCEDURE getLocalGradient_scalar , getLocalGradient_vector , & & stsd_getLocalGradient_scalar , stsd_getLocalGradient_vector END INTERFACE getLocalGradient ! PUBLIC :: getLocalGradient/ !---------------------------------------------------------------------------- !                                               getSpatialGradient@getMethod !---------------------------------------------------------------------------- INTERFACE !! This subroutine returns the spatial gradient of vector !> authors: Dr. Vikas Sharma ! ! This subroutine returns the spatial gradient of a vector MODULE PURE SUBROUTINE getSpatialGradient_vector ( Obj , dVdXt , Val ) CLASS ( ElemshapeData_ ), INTENT ( IN ) :: Obj REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: dVdXt ( :, :, : ) !! spatial gradient of `val` at integration points REAL ( DFP ), INTENT ( IN ) :: Val ( :, : ) !! nodal values of vector in `xiJ` format END SUBROUTINE getSpatialGradient_vector END INTERFACE !---------------------------------------------------------------------------- !                                               getSpatialGradient@getMethod !---------------------------------------------------------------------------- INTERFACE !! This subroutine returns the spatial gradient of scalar !> authors: Dr. Vikas Sharma ! ! This subroutine returns the spatial gradient of scalar MODULE PURE SUBROUTINE getSpatialGradient_scalar ( Obj , dPhidXt , Val ) CLASS ( ElemShapeData_ ), INTENT ( IN ) :: Obj REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: dPhidXt ( :, : ) !! Spatial gradient of scalar REAL ( DFP ), INTENT ( IN ) :: Val ( : ) !! Nodal values of scalar END SUBROUTINE getSpatialGradient_scalar END INTERFACE !---------------------------------------------------------------------------- !                                               getSpatialGradient@getMethod !---------------------------------------------------------------------------- INTERFACE !! This subroutine returns the spatial gradient of scalar !> authors: Dr. Vikas Sharma ! ! This subroutine returns the spatial gradient of scalar MODULE PURE SUBROUTINE stsd_getSpatialGradient_scalar ( Obj , dPhidXt , Val ) CLASS ( STElemShapeData_ ), INTENT ( IN ) :: Obj REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: dPhidXt ( :, : ) !! Spatial gradient of scalar REAL ( DFP ), INTENT ( IN ) :: Val ( :, : ) !! space-time Nodal values of scalar END SUBROUTINE stsd_getSpatialGradient_scalar END INTERFACE !---------------------------------------------------------------------------- !                                               getSpatialGradient@getMethod !---------------------------------------------------------------------------- INTERFACE !! This subroutine returns the spatial gradient of vector !> authors: Dr. Vikas Sharma ! ! This subroutine returns the spatial gradient of a vector from its ! space-time nodal values MODULE PURE SUBROUTINE stsd_getSpatialGradient_vector ( Obj , dVdXt , Val ) CLASS ( STElemshapeData_ ), INTENT ( IN ) :: Obj REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: dVdXt ( :, :, : ) !! spatial gradient of `val` at integration points REAL ( DFP ), INTENT ( IN ) :: Val ( :, :, : ) !! space-time nodal values of vector in `xiJa` format END SUBROUTINE stsd_getSpatialGradient_vector END INTERFACE INTERFACE getSpatialGradient MODULE PROCEDURE getSpatialGradient_scalar , getSpatialGradient_vector , & & stsd_getSpatialGradient_scalar , & & stsd_getSpatialGradient_vector END INTERFACE getSpatialGradient PUBLIC :: getSpatialGradient !---------------------------------------------------------------------------- !                                            getProjectionOfdNdXt@getMethod !---------------------------------------------------------------------------- INTERFACE !! This subroutine computes the projection of dNdXt on a vector !> authors: Dr. Vikas Sharma ! ! This subroutine computes the projcetion cdNdXt on the vector `Val` ! Here the vector `Val` is constant in space and time ! ! P&#94;{I}=c_{i}\\frac{\\partial N&#94;{I}}{\\partial x_{i}}  ! MODULE PURE SUBROUTINE getProjectionOfdNdXt_spacevalues ( Obj , cdNdXt , Val ) CLASS ( ElemshapeData_ ), INTENT ( IN ) :: Obj REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: cdNdXt ( :, : ) !! returned $c_{i}\\frac{\\partial N&#94;{I}}{\\partial x_{i}}$ REAL ( DFP ), INTENT ( IN ) :: Val ( : ) !! constant value of vector END SUBROUTINE getProjectionOfdNdXt_spacevalues END INTERFACE !---------------------------------------------------------------------------- !                                            getProjectionOfdNdXt@getMethod !---------------------------------------------------------------------------- INTERFACE !! This subroutine computes the projection of dNdXt on a vector !> authors: Dr. Vikas Sharma ! ! This subroutine computes the projcetion cdNdXt on the vector `Val` ! Here the vector `Val` is constant in space and time ! ! P&#94;{I}=c_{i}\\frac{\\partial N&#94;{I}}{\\partial x_{i}}  ! MODULE PURE SUBROUTINE getProjectionOfdNdXt_fevar ( Obj , cdNdXt , Val ) CLASS ( ElemshapeData_ ), INTENT ( IN ) :: Obj REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: cdNdXt ( :, : ) !! returned $c_{i}\\frac{\\partial N&#94;{I}}{\\partial x_{i}}$ CLASS ( FEVariable_ ), INTENT ( IN ) :: Val !! constant value of vector END SUBROUTINE getProjectionOfdNdXt_fevar END INTERFACE INTERFACE getProjectionOfdNdXt MODULE PROCEDURE & & getProjectionOfdNdXt_spacevalues ,& & getProjectionOfdNdXt_fevar END INTERFACE getProjectionOfdNdXt PUBLIC :: getProjectionOfdNdXt !---------------------------------------------------------------------------- !                                            getProjectionOfdNTdXt@getMethod !---------------------------------------------------------------------------- INTERFACE !! This subroutine computes the projection of dNTdXt on a vector !> authors: Dr. Vikas Sharma ! ! This subroutine computes the projcetion cdNTdXt on the vector `Val` ! Here the vector `Val` is constant in space and time ! ! P&#94;{I,a}=c_{i}\\frac{\\partial N&#94;{I} T_a}{\\partial x_{i}} ! MODULE PURE SUBROUTINE getProjectionOfdNTdXt_constvector ( Obj , cdNTdXt , Val ) CLASS ( STElemshapeData_ ), INTENT ( IN ) :: Obj REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: cdNTdXt ( :, :, : ) !! returned $c_{i}\\frac{\\partial N&#94;{I} T_a}{\\partial x_{i}}$ REAL ( DFP ), INTENT ( IN ) :: Val ( : ) !! constant value of vector END SUBROUTINE getProjectionOfdNTdXt_constvector END INTERFACE !---------------------------------------------------------------------------- !                                            getProjectionOfdNTdXt@getMethod !---------------------------------------------------------------------------- INTERFACE !! This subroutine computes the projection of dNTdXt on a vector !> authors: Dr. Vikas Sharma ! ! This subroutine computes the projcetion cdNTdXt on the vector `Val` ! Here the vector `Val` is constant in space and time ! ! P&#94;{I,a}=c_{i}\\frac{\\partial N&#94;{I} T_a}{\\partial x_{i}} ! MODULE PURE SUBROUTINE getProjectionOfdNTdXt_fevar ( Obj , cdNTdXt , Val ) CLASS ( STElemshapeData_ ), INTENT ( IN ) :: Obj REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: cdNTdXt ( :, :, : ) !! returned $c_{i}\\frac{\\partial N&#94;{I} T_a}{\\partial x_{i}}$ TYPE ( FEVariable_ ), INTENT ( IN ) :: Val !! constant value of vector END SUBROUTINE getProjectionOfdNTdXt_fevar END INTERFACE !---------------------------------------------------------------------------- !                                            getProjectionOfdNTdXt@getMethod !---------------------------------------------------------------------------- INTERFACE getProjectionOfdNTdXt MODULE PROCEDURE & & getProjectionOfdNTdXt_constvector , & & getProjectionOfdNTdXt_fevar END INTERFACE getProjectionOfdNTdXt PUBLIC :: getProjectionOfdNTdXt !---------------------------------------------------------------------------- !                                                    getUnitNormal@getMethod !---------------------------------------------------------------------------- INTERFACE !! This subroutine can be used in SUPG formulation !> authors: Dr. Vikas Sharma ! ! This routine can be used in the SUPG formulation ! !  \\nabla \\vert phi \\vert / \\vert (\\nabla \\vert phi \\vert) \\vert ! MODULE PURE SUBROUTINE getUnitNormal_scalar ( Obj , R , Val ) CLASS ( ElemshapeData_ ), INTENT ( IN ) :: Obj REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: R ( :, : ) REAL ( DFP ), INTENT ( IN ) :: Val ( : ) END SUBROUTINE getUnitNormal_scalar END INTERFACE !---------------------------------------------------------------------------- !                                                    getUnitNormal@getMethod !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE getUnitNormal_vector ( Obj , R , Val ) CLASS ( ElemshapeData_ ), INTENT ( INOUT ) :: Obj REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: R ( :, : ) REAL ( DFP ), INTENT ( IN ) :: Val ( :, : ) END SUBROUTINE getUnitNormal_vector END INTERFACE INTERFACE getUnitNormal MODULE PROCEDURE getUnitNormal_vector , getUnitNormal_scalar END INTERFACE getUnitNormal PUBLIC :: getUnitNormal !---------------------------------------------------------------------------- !                                                    Initiate@LineH1Lagrange !---------------------------------------------------------------------------- INTERFACE !! This subroutine computes the shape functions given by Lagrange polynomials !! over reference line element !> authors: Dr. Vikas Sharma ! ! This subroutine computes shape functions, lagrange polynomials, over ! reference line element ! The interpolation functions are defined inside the reference element itself ! The order of shape functions are also included inside the refelem MODULE PURE SUBROUTINE Line_H1_Lagrange ( Obj , Quad , RefElem , & & ContinuityType , InterpolType ) CLASS ( ElemshapeData_ ), INTENT ( INOUT ) :: Obj CLASS ( QuadraturePoint_ ), INTENT ( IN ) :: Quad !! Quadrature points where shapefunctions will be evaluated CLASS ( ReferenceLine_ ), INTENT ( IN ) :: RefElem !! Reference element where shape functions will be defined CLASS ( H1_ ), INTENT ( IN ) :: ContinuityType !! H1 (nodal) Continuity type CLASS ( LagrangeInterpolation_ ), INTENT ( IN ) :: InterpolType !! Lagrange polynomial will be used for interpolation END SUBROUTINE Line_H1_Lagrange END INTERFACE !---------------------------------------------------------------------------- !                                                Initiate@TriangleH1Lagrange !---------------------------------------------------------------------------- INTERFACE !! This subroutine computes the shape functions given by Lagrange polynomials !! over reference triangle element !> authors: Dr. Vikas Sharma ! ! This subroutine computes shape functions, lagrange polynomials, over ! reference triangle element MODULE PURE SUBROUTINE Triangle_H1_Lagrange ( Obj , Quad , RefElem , & & ContinuityType , InterpolType ) CLASS ( ElemshapeData_ ), INTENT ( INOUT ) :: Obj CLASS ( QuadraturePoint_ ), INTENT ( IN ) :: Quad CLASS ( ReferenceTriangle_ ), INTENT ( IN ) :: RefElem CLASS ( H1_ ), INTENT ( IN ) :: ContinuityType CLASS ( LagrangeInterpolation_ ), INTENT ( IN ) :: InterpolType END SUBROUTINE Triangle_H1_Lagrange END INTERFACE !---------------------------------------------------------------------------- !                                              Initiate@QuadrangleH1Lagrange !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE Quadrangle_H1_Lagrange ( Obj , Quad , RefElem , & & ContinuityType , InterpolType ) CLASS ( ElemshapeData_ ), INTENT ( INOUT ) :: Obj CLASS ( QuadraturePoint_ ), INTENT ( IN ) :: Quad CLASS ( ReferenceQuadrangle_ ), INTENT ( IN ) :: RefElem CLASS ( H1_ ), INTENT ( IN ) :: ContinuityType CLASS ( LagrangeInterpolation_ ), INTENT ( IN ) :: InterpolType END SUBROUTINE Quadrangle_H1_Lagrange END INTERFACE !---------------------------------------------------------------------------- !                                              Initiate@TetrahedronH1Lagrange !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE Tetrahedron_H1_Lagrange ( Obj , Quad , RefElem , & & ContinuityType , InterpolType ) CLASS ( ElemshapeData_ ), INTENT ( INOUT ) :: Obj CLASS ( QuadraturePoint_ ), INTENT ( IN ) :: Quad CLASS ( ReferenceTetrahedron_ ), INTENT ( IN ) :: RefElem CLASS ( H1_ ), INTENT ( IN ) :: ContinuityType CLASS ( LagrangeInterpolation_ ), INTENT ( IN ) :: InterpolType END SUBROUTINE Tetrahedron_H1_Lagrange END INTERFACE !---------------------------------------------------------------------------- !                                              Initiate@HexahedronH1Lagrange !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE Hexahedron_H1_Lagrange ( Obj , Quad , RefElem , & & ContinuityType , InterpolType ) CLASS ( ElemshapeData_ ), INTENT ( INOUT ) :: Obj CLASS ( QuadraturePoint_ ), INTENT ( IN ) :: Quad CLASS ( ReferenceHexahedron_ ), INTENT ( IN ) :: RefElem CLASS ( H1_ ), INTENT ( IN ) :: ContinuityType CLASS ( LagrangeInterpolation_ ), INTENT ( IN ) :: InterpolType END SUBROUTINE Hexahedron_H1_Lagrange END INTERFACE !---------------------------------------------------------------------------- !                                              Initiate@PrismH1Lagrange !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE Prism_H1_Lagrange ( Obj , Quad , RefElem , & & ContinuityType , InterpolType ) CLASS ( ElemshapeData_ ), INTENT ( INOUT ) :: Obj CLASS ( QuadraturePoint_ ), INTENT ( IN ) :: Quad CLASS ( ReferencePrism_ ), INTENT ( IN ) :: RefElem CLASS ( H1_ ), INTENT ( IN ) :: ContinuityType CLASS ( LagrangeInterpolation_ ), INTENT ( IN ) :: InterpolType END SUBROUTINE Prism_H1_Lagrange END INTERFACE !---------------------------------------------------------------------------- !                                              Initiate@PyramidH1Lagrange !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE Pyramid_H1_Lagrange ( Obj , Quad , RefElem , & & ContinuityType , InterpolType ) CLASS ( ElemshapeData_ ), INTENT ( INOUT ) :: Obj CLASS ( QuadraturePoint_ ), INTENT ( IN ) :: Quad CLASS ( ReferencePyramid_ ), INTENT ( IN ) :: RefElem CLASS ( H1_ ), INTENT ( IN ) :: ContinuityType CLASS ( LagrangeInterpolation_ ), INTENT ( IN ) :: InterpolType END SUBROUTINE Pyramid_H1_Lagrange END INTERFACE !---------------------------------------------------------------------------- !                                                        Initiate@H1Lagrange !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE H1_Lagrange ( Obj , Quad , RefElem , & & ContinuityType , InterpolType ) CLASS ( ElemshapeData_ ), INTENT ( INOUT ) :: Obj CLASS ( QuadraturePoint_ ), INTENT ( IN ) :: Quad CLASS ( ReferenceElement_ ), INTENT ( IN ) :: RefElem CLASS ( H1_ ), INTENT ( IN ) :: ContinuityType CLASS ( LagrangeInterpolation_ ), INTENT ( IN ) :: InterpolType END SUBROUTINE H1_Lagrange END INTERFACE INTERFACE Initiate MODULE PROCEDURE H1_Lagrange END INTERFACE Initiate !---------------------------------------------------------------------------- !                                                                   Contains !---------------------------------------------------------------------------- END MODULE ElemshapeData_Method","tags":"","loc":"sourcefile/elemshapedata_method.f90.html"},{"title":"RealMatrix_Method.f90 – Fortran Program","text":"Contents Modules RealMatrix_Method Source Code RealMatrix_Method.f90 Source Code MODULE RealMatrix_Method !! This module contains methods for [[RealMatrix_]] USE GlobalData USE BaseType IMPLICIT NONE PRIVATE #include \"./constructor.inc\" #include \"./lapack.inc\" #include \"./getvalue.inc\" #include \"./setvalue.inc\" !---------------------------------------------------------------------------- !                                                MatMul@MatrixMultiplication !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION MatMul_1 ( Obj1 , Obj2 ) RESULT ( Ans ) TYPE ( RealMatrix_ ), INTENT ( IN ) :: Obj1 , Obj2 TYPE ( RealMatrix_ ) :: Ans END FUNCTION MatMul_1 END INTERFACE INTERFACE MODULE PURE FUNCTION MatMul_2 ( Obj , Vec ) RESULT ( Ans ) TYPE ( RealMatrix_ ), INTENT ( IN ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Vec ( : ) REAL ( DFP ), ALLOCATABLE :: Ans ( : ) END FUNCTION MatMul_2 END INTERFACE INTERFACE MODULE PURE FUNCTION MatMul_3 ( Obj , Vec ) RESULT ( Ans ) TYPE ( RealMatrix_ ), INTENT ( IN ) :: Obj TYPE ( RealVector_ ), INTENT ( IN ) :: Vec TYPE ( RealVector_ ) :: Ans END FUNCTION MatMul_3 END INTERFACE INTERFACE Matmul MODULE PROCEDURE MatMul_1 , MatMul_2 , MatMul_3 END INTERFACE Matmul PUBLIC :: Matmul !---------------------------------------------------------------------------- !                                                                 Contains !---------------------------------------------------------------------------- #include \"./contains.part\" END MODULE RealMatrix_Method","tags":"","loc":"sourcefile/realmatrix_method.f90.html"},{"title":"FEVariable_Method.f90 – Fortran Program","text":"Contents Modules FEVariable_Method Source Code FEVariable_Method.f90 Source Code MODULE FEVariable_Method USE GlobalData USE BaseType IMPLICIT NONE PRIVATE !---------------------------------------------------------------------------- !                                                         Display@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE Display_Obj ( Obj , Msg , UnitNo ) TYPE ( FEVariable_ ), INTENT ( IN ) :: Obj CHARACTER ( LEN = * ), INTENT ( IN ) :: Msg INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: UnitNo END SUBROUTINE Display_obj END INTERFACE INTERFACE Display MODULE PROCEDURE Display_Obj END INTERFACE Display PUBLIC :: Display !---------------------------------------------------------------------------- !                                                 DeallocateData@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE SUBROUTINE fe_deallocate ( Obj ) TYPE ( FEVariable_ ), INTENT ( INOUT ) :: Obj END SUBROUTINE fe_deallocate END INTERFACE INTERFACE DeallocateData MODULE PROCEDURE fe_deallocate END INTERFACE DeallocateData PUBLIC :: DeallocateData !---------------------------------------------------------------------------- !                                                  NodalVariable@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE MODULE PURE FUNCTION Nodal_Scalar_Constant ( Val , Rank , VarType ) & & RESULT ( Obj ) TYPE ( FEVariable_ ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Val CLASS ( FEVariableScalar_ ), INTENT ( IN ) :: Rank CLASS ( FEVariableConstant_ ), INTENT ( IN ) :: VarType END FUNCTION Nodal_Scalar_Constant END INTERFACE INTERFACE NodalVariable MODULE PROCEDURE Nodal_Scalar_Constant END INTERFACE NodalVariable PUBLIC :: NodalVariable !---------------------------------------------------------------------------- !                                                  NodalVariable@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION Nodal_Scalar_Space ( Val , Rank , VarType ) RESULT ( Obj ) TYPE ( FEVariable_ ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Val ( : ) TYPE ( FEVariableScalar_ ), INTENT ( IN ) :: Rank TYPE ( FEVariableSpace_ ), INTENT ( IN ) :: VarType END FUNCTION Nodal_Scalar_Space END INTERFACE INTERFACE NodalVariable MODULE PROCEDURE Nodal_Scalar_Space END INTERFACE NodalVariable !---------------------------------------------------------------------------- !                                                   NodalVariable@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION Nodal_Scalar_SpaceTime ( Val , Rank , VarType ) RESULT ( Obj ) TYPE ( FEVariable_ ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Val ( :, : ) TYPE ( FEVariableScalar_ ), INTENT ( IN ) :: Rank TYPE ( FEVariableSpaceTime_ ), INTENT ( IN ) :: VarType END FUNCTION Nodal_Scalar_SpaceTime END INTERFACE INTERFACE NodalVariable MODULE PROCEDURE Nodal_Scalar_SpaceTime END INTERFACE NodalVariable !---------------------------------------------------------------------------- !                                                  NodalVariable@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE MODULE PURE FUNCTION Nodal_Vector_Constant ( Val , Rank , VarType ) & & RESULT ( Obj ) TYPE ( FEVariable_ ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Val ( : ) TYPE ( FEVariableVector_ ), INTENT ( IN ) :: Rank TYPE ( FEVariableConstant_ ), INTENT ( IN ) :: VarType END FUNCTION Nodal_Vector_Constant END INTERFACE INTERFACE NodalVariable MODULE PROCEDURE Nodal_Vector_Constant END INTERFACE NodalVariable !---------------------------------------------------------------------------- !                                                  NodalVariable@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION Nodal_Vector_Space ( Val , Rank , VarType ) RESULT ( Obj ) TYPE ( FEVariable_ ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Val ( :, : ) TYPE ( FEVariableVector_ ), INTENT ( IN ) :: Rank TYPE ( FEVariableSpace_ ), INTENT ( IN ) :: VarType END FUNCTION Nodal_Vector_Space END INTERFACE INTERFACE NodalVariable MODULE PROCEDURE Nodal_Vector_Space END INTERFACE NodalVariable !---------------------------------------------------------------------------- !                                                  NodalVariable@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION Nodal_Vector_SpaceTime ( Val , Rank , VarType ) & & RESULT ( Obj ) TYPE ( FEVariable_ ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Val ( :, :, : ) TYPE ( FEVariableVector_ ), INTENT ( IN ) :: Rank TYPE ( FEVariableSpaceTime_ ), INTENT ( IN ) :: VarType END FUNCTION Nodal_Vector_SpaceTime END INTERFACE INTERFACE NodalVariable MODULE PROCEDURE Nodal_Vector_SpaceTime END INTERFACE NodalVariable !---------------------------------------------------------------------------- !                                                  NodalVariable@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE MODULE PURE FUNCTION Nodal_Matrix_Constant ( Val , Rank , VarType ) & & RESULT ( Obj ) TYPE ( FEVariable_ ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Val ( :, : ) TYPE ( FEVariableMatrix_ ), INTENT ( IN ) :: Rank TYPE ( FEVariableConstant_ ), INTENT ( IN ) :: VarType END FUNCTION Nodal_Matrix_Constant END INTERFACE INTERFACE NodalVariable MODULE PROCEDURE Nodal_Matrix_Constant END INTERFACE NodalVariable !---------------------------------------------------------------------------- !                                                  NodalVariable@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION Nodal_Matrix_Space ( Val , Rank , VarType ) RESULT ( Obj ) TYPE ( FEVariable_ ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Val ( :, :, : ) TYPE ( FEVariableMatrix_ ), INTENT ( IN ) :: Rank TYPE ( FEVariableSpace_ ), INTENT ( IN ) :: VarType END FUNCTION Nodal_Matrix_Space END INTERFACE INTERFACE NodalVariable MODULE PROCEDURE Nodal_Matrix_Space END INTERFACE NodalVariable !---------------------------------------------------------------------------- !                                                  NodalVariable@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION Nodal_Matrix_SpaceTime ( Val , Rank , VarType ) & & RESULT ( Obj ) TYPE ( FEVariable_ ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Val ( :, :, :, : ) TYPE ( FEVariableMatrix_ ), INTENT ( IN ) :: Rank TYPE ( FEVariableSpaceTime_ ), INTENT ( IN ) :: VarType END FUNCTION Nodal_Matrix_SpaceTime END INTERFACE INTERFACE NodalVariable MODULE PROCEDURE Nodal_Matrix_SpaceTime END INTERFACE NodalVariable !---------------------------------------------------------------------------- !                                                  NodalVariable@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE MODULE PURE FUNCTION Quadrature_Scalar_Constant ( Val , Rank , VarType ) & & RESULT ( Obj ) TYPE ( FEVariable_ ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Val TYPE ( FEVariableScalar_ ), INTENT ( IN ) :: Rank TYPE ( FEVariableConstant_ ), INTENT ( IN ) :: VarType END FUNCTION Quadrature_Scalar_Constant END INTERFACE INTERFACE QuadratureVariable MODULE PROCEDURE Quadrature_Scalar_Constant END INTERFACE QuadratureVariable PUBLIC :: QuadratureVariable !---------------------------------------------------------------------------- !                                             QuadratureVariable@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION Quadrature_Scalar_Space ( Val , Rank , VarType ) & & RESULT ( Obj ) TYPE ( FEVariable_ ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Val ( : ) TYPE ( FEVariableScalar_ ), INTENT ( IN ) :: Rank TYPE ( FEVariableSpace_ ), INTENT ( IN ) :: VarType END FUNCTION Quadrature_Scalar_Space END INTERFACE INTERFACE QuadratureVariable MODULE PROCEDURE Quadrature_Scalar_Space END INTERFACE QuadratureVariable !---------------------------------------------------------------------------- !                                             QuadratureVariable@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION Quadrature_Scalar_SpaceTime ( Val , Rank , VarType ) & & RESULT ( Obj ) TYPE ( FEVariable_ ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Val ( :, : ) TYPE ( FEVariableScalar_ ), INTENT ( IN ) :: Rank TYPE ( FEVariableSpaceTime_ ), INTENT ( IN ) :: VarType END FUNCTION Quadrature_Scalar_SpaceTime END INTERFACE INTERFACE QuadratureVariable MODULE PROCEDURE Quadrature_Scalar_SpaceTime END INTERFACE QuadratureVariable !---------------------------------------------------------------------------- !                                                  NodalVariable@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE MODULE PURE FUNCTION Quadrature_Vector_Constant ( Val , Rank , VarType ) & & RESULT ( Obj ) TYPE ( FEVariable_ ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Val ( : ) TYPE ( FEVariableVector_ ), INTENT ( IN ) :: Rank TYPE ( FEVariableConstant_ ), INTENT ( IN ) :: VarType END FUNCTION Quadrature_Vector_Constant END INTERFACE INTERFACE QuadratureVariable MODULE PROCEDURE Quadrature_Vector_Constant END INTERFACE QuadratureVariable !---------------------------------------------------------------------------- !                                                  QuadratureVariable@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION Quadrature_Vector_Space ( Val , Rank , VarType ) & & RESULT ( Obj ) TYPE ( FEVariable_ ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Val ( :, : ) TYPE ( FEVariableVector_ ), INTENT ( IN ) :: Rank TYPE ( FEVariableSpace_ ), INTENT ( IN ) :: VarType END FUNCTION Quadrature_Vector_Space END INTERFACE INTERFACE QuadratureVariable MODULE PROCEDURE Quadrature_Vector_Space END INTERFACE QuadratureVariable !---------------------------------------------------------------------------- !                                              QuadratureVariable@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION Quadrature_Vector_SpaceTime ( Val , Rank , VarType ) & & RESULT ( Obj ) TYPE ( FEVariable_ ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Val ( :, :, : ) TYPE ( FEVariableVector_ ), INTENT ( IN ) :: Rank TYPE ( FEVariableSpaceTime_ ), INTENT ( IN ) :: VarType END FUNCTION Quadrature_Vector_SpaceTime END INTERFACE INTERFACE QuadratureVariable MODULE PROCEDURE Quadrature_Vector_SpaceTime END INTERFACE QuadratureVariable !---------------------------------------------------------------------------- !                                             QuadratureVariable@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE MODULE PURE FUNCTION Quadrature_Matrix_Constant ( Val , Rank , VarType ) & & RESULT ( Obj ) TYPE ( FEVariable_ ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Val ( :, : ) TYPE ( FEVariableMatrix_ ), INTENT ( IN ) :: Rank TYPE ( FEVariableConstant_ ), INTENT ( IN ) :: VarType END FUNCTION Quadrature_Matrix_Constant END INTERFACE INTERFACE QuadratureVariable MODULE PROCEDURE Quadrature_Matrix_Constant END INTERFACE QuadratureVariable !---------------------------------------------------------------------------- !                                             QuadratureVariable@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION Quadrature_Matrix_Space ( Val , Rank , VarType ) & & RESULT ( Obj ) TYPE ( FEVariable_ ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Val ( :, :, : ) TYPE ( FEVariableMatrix_ ), INTENT ( IN ) :: Rank TYPE ( FEVariableSpace_ ), INTENT ( IN ) :: VarType END FUNCTION Quadrature_Matrix_Space END INTERFACE INTERFACE QuadratureVariable MODULE PROCEDURE Quadrature_Matrix_Space END INTERFACE QuadratureVariable !---------------------------------------------------------------------------- !                                             QuadratureVariable@Constructor !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION Quadrature_Matrix_SpaceTime ( Val , Rank , VarType ) & & RESULT ( Obj ) TYPE ( FEVariable_ ) :: Obj REAL ( DFP ), INTENT ( IN ) :: Val ( :, :, :, : ) TYPE ( FEVariableMatrix_ ), INTENT ( IN ) :: Rank TYPE ( FEVariableSpaceTime_ ), INTENT ( IN ) :: VarType END FUNCTION Quadrature_Matrix_SpaceTime END INTERFACE INTERFACE QuadratureVariable MODULE PROCEDURE Quadrature_Matrix_SpaceTime END INTERFACE QuadratureVariable !---------------------------------------------------------------------------- !                                                             SIZE@GetMethod !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION Size_obj ( Obj , Dim ) RESULT ( Ans ) CLASS ( FEVariable_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Dim INTEGER ( I4B ) :: Ans END FUNCTION Size_Obj END INTERFACE INTERFACE SIZE MODULE PROCEDURE Size_Obj END INTERFACE SIZE PUBLIC :: SIZE !---------------------------------------------------------------------------- !                                                             SHAPE@GetMethod !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION Shape_obj ( Obj ) RESULT ( Ans ) CLASS ( FEVariable_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), ALLOCATABLE :: Ans ( : ) END FUNCTION Shape_Obj END INTERFACE INTERFACE Shape MODULE PROCEDURE Shape_Obj END INTERFACE Shape PUBLIC :: Shape !---------------------------------------------------------------------------- !                                                       getValues@GetMethod !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION Scalar_Constant ( Obj , Rank , VarType ) RESULT ( Val ) CLASS ( FEVariable_ ), INTENT ( IN ) :: Obj TYPE ( FEVariableScalar_ ), INTENT ( IN ) :: Rank TYPE ( FEVariableConstant_ ), INTENT ( IN ) :: VarType REAL ( DFP ) :: Val END FUNCTION Scalar_Constant END INTERFACE INTERFACE getValues MODULE PROCEDURE Scalar_Constant END INTERFACE getValues PUBLIC :: getValues !---------------------------------------------------------------------------- !                                                   getValues@GetMethod !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION Scalar_Space ( Obj , Rank , VarType ) RESULT ( Val ) CLASS ( FEVariable_ ), INTENT ( IN ) :: Obj TYPE ( FEVariableScalar_ ), INTENT ( IN ) :: Rank TYPE ( FEVariableSpace_ ), INTENT ( IN ) :: VarType REAL ( DFP ), ALLOCATABLE :: Val ( : ) END FUNCTION Scalar_Space END INTERFACE INTERFACE getValues MODULE PROCEDURE Scalar_Space END INTERFACE getValues !---------------------------------------------------------------------------- !                                                   getValues@GetMethod !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION Scalar_SpaceTime ( Obj , Rank , VarType ) RESULT ( Val ) CLASS ( FEVariable_ ), INTENT ( IN ) :: Obj TYPE ( FEVariableScalar_ ), INTENT ( IN ) :: Rank TYPE ( FEVariableSpaceTime_ ), INTENT ( IN ) :: VarType REAL ( DFP ), ALLOCATABLE :: Val ( :, : ) END FUNCTION Scalar_SpaceTime END INTERFACE INTERFACE getValues MODULE PROCEDURE Scalar_SpaceTime END INTERFACE getValues !---------------------------------------------------------------------------- !                                                   getValues@GetMethod !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION Vector_Constant ( Obj , Rank , VarType ) RESULT ( Val ) CLASS ( FEVariable_ ), INTENT ( IN ) :: Obj TYPE ( FEVariableVector_ ), INTENT ( IN ) :: Rank TYPE ( FEVariableConstant_ ), INTENT ( IN ) :: VarType REAL ( DFP ), ALLOCATABLE :: Val ( : ) END FUNCTION Vector_Constant END INTERFACE INTERFACE getValues MODULE PROCEDURE Vector_Constant END INTERFACE getValues !---------------------------------------------------------------------------- !                                                   getValues@GetMethod !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION Vector_Space ( Obj , Rank , VarType ) RESULT ( Val ) CLASS ( FEVariable_ ), INTENT ( IN ) :: Obj TYPE ( FEVariableVector_ ), INTENT ( IN ) :: Rank TYPE ( FEVariableSpace_ ), INTENT ( IN ) :: VarType REAL ( DFP ), ALLOCATABLE :: Val ( :, : ) END FUNCTION Vector_Space END INTERFACE INTERFACE getValues MODULE PROCEDURE Vector_Space END INTERFACE getValues !---------------------------------------------------------------------------- !                                                   getValues@GetMethod !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION Vector_SpaceTime ( Obj , Rank , VarType ) RESULT ( Val ) CLASS ( FEVariable_ ), INTENT ( IN ) :: Obj TYPE ( FEVariableVector_ ), INTENT ( IN ) :: Rank TYPE ( FEVariableSpaceTime_ ), INTENT ( IN ) :: VarType REAL ( DFP ), ALLOCATABLE :: Val ( :, :, : ) END FUNCTION Vector_SpaceTime END INTERFACE INTERFACE getValues MODULE PROCEDURE Vector_SpaceTime END INTERFACE getValues !---------------------------------------------------------------------------- !                                                   getValues@GetMethod !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION Matrix_Constant ( Obj , Rank , VarType ) RESULT ( Val ) CLASS ( FEVariable_ ), INTENT ( IN ) :: Obj TYPE ( FEVariableMatrix_ ), INTENT ( IN ) :: Rank TYPE ( FEVariableConstant_ ), INTENT ( IN ) :: VarType REAL ( DFP ), ALLOCATABLE :: Val ( :, : ) END FUNCTION Matrix_Constant END INTERFACE INTERFACE getValues MODULE PROCEDURE Matrix_Constant END INTERFACE getValues !---------------------------------------------------------------------------- !                                                   getValues@GetMethod !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION Matrix_Space ( Obj , Rank , VarType ) RESULT ( Val ) CLASS ( FEVariable_ ), INTENT ( IN ) :: Obj TYPE ( FEVariableMatrix_ ), INTENT ( IN ) :: Rank TYPE ( FEVariableSpace_ ), INTENT ( IN ) :: VarType REAL ( DFP ), ALLOCATABLE :: Val ( :, :, : ) END FUNCTION Matrix_Space END INTERFACE INTERFACE getValues MODULE PROCEDURE Matrix_Space END INTERFACE getValues !---------------------------------------------------------------------------- !                                                   getValues@GetMethod !---------------------------------------------------------------------------- INTERFACE MODULE PURE FUNCTION Matrix_SpaceTime ( Obj , Rank , VarType ) RESULT ( Val ) CLASS ( FEVariable_ ), INTENT ( IN ) :: Obj TYPE ( FEVariableMatrix_ ), INTENT ( IN ) :: Rank TYPE ( FEVariableSpaceTime_ ), INTENT ( IN ) :: VarType REAL ( DFP ), ALLOCATABLE :: Val ( :, :, :, : ) END FUNCTION Matrix_SpaceTime END INTERFACE INTERFACE getValues MODULE PROCEDURE Matrix_SpaceTime END INTERFACE getValues END MODULE FEVariable_Method","tags":"","loc":"sourcefile/fevariable_method.f90.html"},{"title":"Buffer_Method.f90 – Fortran Program","text":"Contents Modules Buffer_Method Source Code Buffer_Method.f90 Source Code MODULE Buffer_Method USE BaseType USE GlobalData IMPLICIT NONE PRIVATE !---------------------------------------------------------------------------- ! !---------------------------------------------------------------------------- INTERFACE MODULE SUBROUTINE buffer_append_str ( Obj , Entry ) TYPE ( Buffer_ ), INTENT ( INOUT ) :: Obj TYPE ( String ), INTENT ( IN ), TARGET :: Entry END SUBROUTINE buffer_append_str END INTERFACE INTERFACE Append MODULE PROCEDURE buffer_append_str END INTERFACE Append PUBLIC :: Append END MODULE Buffer_Method","tags":"","loc":"sourcefile/buffer_method.f90.html"},{"title":"MeshDataPointer_ – Fortran Program ","text":"type, public :: MeshDataPointer_ Contains MeshData_ pointer as its field Contents Variables Ptr Source Code MeshDataPointer_ Components Type Visibility Attributes Name Initial class( MeshData_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: MeshDataPointer_ CLASS ( MeshData_ ), POINTER :: Ptr => NULL ( ) END TYPE MeshDataPointer_","tags":"","loc":"type/meshdatapointer_.html"},{"title":"MeshData_ – Fortran Program ","text":"type, public :: MeshData_ MeshData_ contains data related to a mesh Note In EASIFEM mesh-data is separated from the Mesh_ mainly because\n very often we only require connectivity information which is already\n stored inside the Mesh_ . MeshData_ is contains mesh realated data Contents Variables BoundaryData BoundaryNptrs ElemToElem ElemToNode InternalBndyElemNum InternalBoundaryData InternalNptrs LBndyIndex Local_Nptrs MaxNptrs MinNptrs NTN NodeToElem Nptrs isInitiated refelem tNodes Type-Bound Procedures BoundaryElementData BoundingBox ElementToElements ElementToNodes Finalize FindElement GlobalNptrs Initiate InitiateBoundaryData InitiateElementToElements InitiateElementToNodes InitiateInternalBoundaryData InitiateInternalNptrs InitiateNodeToElements InitiateNodeToNodes LocalNptrs MeshQuality NodeToElements NodeToNodes TotalBoundaryElements TotalBoundaryNodes TotalInternalNodes TotalNodes connectFacetToCell getFacetElements get_elem_elems_1 get_elem_elems_2 global_from_local global_from_local_scalar isBoundaryDataInitiated isBoundaryElement isBoundaryNptrsInitiated isElementToElementsInitiated isElementToNodesInitiated isInternalBoundaryDataInitiated isInternalNptrsInitiated isLocalNptrsInitiated isNodePresent isNodeToElementsInitiated isNodeToNodesInitiated local_from_global local_from_global_scalar setSparsity Source Code MeshData_ Components Type Visibility Attributes Name Initial type(IntVector_), public, ALLOCATABLE :: BoundaryData (:) If iel is boundary element;\n then Vec=BoundaryData( LBndyIndex(iel) ) contains boundary data, where vec(1) is equal to iel , and vec(2:) are ids of local facets which are boundaries of mesh integer(kind=I4B), public, ALLOCATABLE :: BoundaryNptrs (:) Node number of boundary of mesh type(IntVector_), public, ALLOCATABLE :: ElemToElem (:) ElemToElem( iel ) denotes data of elements\n connected to the element iel type(IntVector_), public, ALLOCATABLE :: ElemToNode (:) ElemToNode( iel ) denotes the node numbers in element iel type(IntVector_), public, ALLOCATABLE :: InternalBndyElemNum (:) To do type(IntVector_), public, ALLOCATABLE :: InternalBoundaryData (:) To do integer(kind=I4B), public, ALLOCATABLE :: InternalNptrs (:) Node number of internal nodes integer(kind=I4B), public, ALLOCATABLE :: LBndyIndex (:) For a given element if LBndyIndex(iel) .eq. 0 then iel is not a\n a boundary element else it a boundary element which represents the\n index of iel in BoundaryData() . integer(kind=I4B), public, ALLOCATABLE :: Local_Nptrs (:) This converts a given global node into local-node which can be\n used for accessing data inside NodeToElem, NodeToNode integer(kind=I4B), public :: MaxNptrs Largest node number present inside mesh integer(kind=I4B), public :: MinNptrs Smallest node number present inside mesh type(IntVector_), public, ALLOCATABLE :: NTN (:) NTN( iLocalNode ) denotes node-ids that are connected to a node GlobalNode( iLocalNode ) type(IntVector_), public, ALLOCATABLE :: NodeToElem (:) NodeToElem( iLocalNode ) denotes indx of elems in mesh which are\n directly connected to node GlobalNptrs( iLocalNode ) integer(kind=I4B), public, ALLOCATABLE :: Nptrs (:) Node number of mesh Nptrs( minNptrs : maxNptrs ) logical(kind=LGT), public :: isInitiated .True. if MeshObj_ is initiated type(ReferenceElement_), public, POINTER :: refelem => NULL() Reference element integer(kind=I4B), public :: tNodes Total number of nodes in mesh Type-Bound Procedures procedure, public, PASS( Obj ) :: BoundaryElementData => get_bndy_elem return boundary element data of a boundary element iel if it is\n boundary element interface Returns boundary element data private pure function get_bndy_elem(Obj, iel) result(Ans) If element is a boundary element then it Returns a integer vector\n containing the id of local facets which is boundary of mesh\n otherwise it will return [0] Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj mesh data integer(kind=I4B), intent(in) :: iel element number Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) boundary data procedure, public, PASS( Obj ) :: BoundingBox => get_Bbox return boundingbox of mesh interface Return the boundinb box of mesh private pure function get_Bbox(Obj, nodes) result(Ans) Return the bounding box of mesh Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj mesh data object real(kind=DFP), intent(in) :: nodes (:,:) nodal coordinates in xiJ format Return Value type(BoundingBox_) bounding box for mesh generic, public :: ElementToElements => get_elem_elems_1 , get_elem_elems_2 return element to element connectivity data for iel element private interface get_elem_elems_1 () Return element to element connectivity information Arguments None private interface get_elem_elems_2 () Return element to element connectivity information Arguments None procedure, public, PASS( Obj ) :: ElementToNodes => get_elem_nodes return element to node connectivity data for iel element interface Return element to nodes data private pure function get_elem_nodes(Obj, iel) result(Ans) Return element to nodes data Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj mesh data integer(kind=I4B), intent(in) :: iel element number Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) list of elements surrounding the nodes procedure, public, PASS( Obj ) :: Finalize => Deallocate_meshdata Deallocate mesh data interface Deallocate data stored inside MeshData_ private subroutine Deallocate_meshdata(Obj) Deallocate data stored inside MeshData_ Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(inout) :: Obj mesh data object procedure, public, PASS( Obj ) :: FindElement => md_findelement interface private function md_findelement(Obj, MeshObj, coord, nodes) result(Ans) Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj class(Mesh_), intent(in) :: MeshObj real(kind=DFP), intent(in) :: coord (:,:) real(kind=DFP), intent(in) :: nodes (:,:) Return Value real(kind=DFP)\n  (SIZE(coord,2)) generic, public :: GlobalNptrs => global_from_local , global_from_local_scalar return global node nuber of a given local node number private interface global_from_local () Convert local node number to global node number Arguments None private interface global_from_local_scalar () Convert local node number to global node number Arguments None procedure, public, PASS( Obj ) :: Initiate => init_meshdata_1 Initiate mesh data interface Initiate MeshData_ object private subroutine init_meshdata_1(Obj, MeshObj) Initiate MeshData_ object Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(inout) :: Obj mesh data container class(Mesh_), intent(inout) :: MeshObj mesh object procedure, public, PASS( Obj ) :: InitiateBoundaryData => init_bndy_data construct boundary data information interface Initiate boundary data of mesh private subroutine init_bndy_data(Obj, MeshObj) Initiate boundary data of mesh Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(inout) :: Obj mesh data class(Mesh_), intent(inout) :: MeshObj mesh object procedure, public, PASS( Obj ) :: InitiateElementToElements => init_element_elements construct element to element connectivity data interface Initiate element to element connectivity data private subroutine init_element_elements(Obj, MeshObj) Initiate element to element connectivity data Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(inout) :: Obj mesh data class(Mesh_), intent(inout) :: MeshObj mesh object procedure, public, PASS( Obj ) :: InitiateElementToNodes => init_elem_nodes construct element to node connectivity data interface Initiate element to node data private subroutine init_elem_nodes(Obj, MeshObj) Initiate element to node data Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(inout) :: Obj mesh data class(Mesh_), intent(inout) :: MeshObj mesh object procedure, public, PASS( Obj ) :: InitiateInternalBoundaryData => init_int_bndydata construct details about the internal boundary interface Initiate internal boundary data private subroutine init_int_bndydata(Obj, MeshObj) Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(inout) :: Obj class(Mesh_), intent(inout) :: MeshObj procedure, public, PASS( Obj ) :: InitiateInternalNptrs => init_int_nptrs construct details about the internal boundary interface Initiate internal node numbers private subroutine init_int_nptrs(Obj, MeshObj) Initiate internal node numbers Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(inout) :: Obj mesh data class(Mesh_), intent(inout) :: MeshObj mesh object procedure, public, PASS( Obj ) :: InitiateNodeToElements => init_node_elements construct node to element connectivity data interface generate Elements surrounding a node mapping private subroutine init_node_elements(Obj, MeshObj) This subroutine generate Elements surrounding a node mapping\n - The mapping is stored in the array called NodeToElem - The size of NodeToElem array is same as Obj % Nptrs - Always use method called NodeToElements() to access this information Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(inout) :: Obj mesh data class(Mesh_), intent(inout) :: MeshObj mesh object procedure, public, PASS( Obj ) :: InitiateNodeToNodes => init_node_nodes construct node to node connectivity data interface Initiate node to node connectivity data private subroutine init_node_nodes(Obj, MeshObj) Initiate node to node connectivity data Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(inout) :: Obj mesh data class(Mesh_), intent(inout) :: MeshObj mesh object generic, public :: LocalNptrs => local_from_global , local_from_global_scalar return local node number of a given global node number private interface local_from_global () Convert global node number to local node  number Arguments None private interface local_from_global_scalar () Convert global node numbr to local node number Arguments None procedure, public, PASS( Obj ) :: MeshQuality => md_quality return mesh quality interface private function md_quality(Obj, Meshobj, Nodes, Measure) result(Ans) Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(inout) :: Obj class(Mesh_), intent(inout), TARGET :: Meshobj real(kind=DFP), intent(in) :: Nodes (:,:) integer(kind=I4B), intent(in) :: Measure Return Value real(kind=DFP),\n  ALLOCATABLE, (:) procedure, public, PASS( Obj ) :: NodeToElements => node_elements return node to element connectivity data for GlobalIndx interface Returns the element numbers which are connected to the a global node private pure function node_elements(Obj, GlobalPt) result(Ans) Returns the element numbers which are connected to the a global node Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj mesh data integer(kind=I4B), intent(in) :: GlobalPt global node number Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) vec of element number procedure, public, PASS( Obj ) :: NodeToNodes => get_node_nodes return node to node connectivity data for GlobalIndx interface Return a list of nodes surrounding a given global node number private pure function get_node_nodes(Obj, GlobalNode, IncludeSelf) result(Ans) Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj mesh data integer(kind=I4B), intent(in) :: GlobalNode global node number logical(kind=LGT), intent(in) :: IncludeSelf logical variable Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) vec of node number surrounding GlobalNode procedure, public, PASS( Obj ) :: TotalBoundaryElements => get_tbndy_elems Rertuns total boundary elements in mesh interface This function returns the total boundary elements in mesh private pure function get_tbndy_elems(Obj) result(Ans) This function returns the total bounadry elements in mesh Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj Return Value integer(kind=I4B) procedure, public, PASS( Obj ) :: TotalBoundaryNodes => get_tbndy_nodes Returns total number of boundary nodes in mesh interface Return total number of boundary nodes private pure function get_tbndy_nodes(Obj) result(Ans) Return total number of boundary nodes Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj mesh data Return Value integer(kind=I4B) total boundary nodes procedure, public, PASS( Obj ) :: TotalInternalNodes => get_tint_nodes Return total number of internal nodes in mesh interface Returns total number of internal bounary nodes private pure function get_tint_nodes(Obj) result(Ans) Returns total number of internal bounary nodes Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj mesh data Return Value integer(kind=I4B) total number of internal boundary nodes procedure, public, PASS( Obj ) :: TotalNodes => get_total_nodes Returns total number of nodes in mesh interface Return total number of nodes private pure function get_total_nodes(Obj) result(Ans) This function will Return the total number of nodes present in meshdata Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj Mesh data object Return Value integer(kind=I4B) Total number of nodes procedure, public, PASS( CellMeshData ) :: connectFacetToCell => mc_connect_facet_cell connect facet to cell interface Connect facet to cell elements private subroutine mc_connect_facet_cell(CellMeshData, CellMesh, FacetMesh) This subroutine connects the mesh of facet elements to the mesh of\n cell elements. Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(inout) :: CellMeshData Mesh data of cell mesh class(Mesh_), intent(inout), TARGET :: CellMesh Mesh of  cell elements class(Mesh_), intent(inout), TARGET :: FacetMesh Mesh of facet elements procedure, public, PASS( mdObj ) :: getFacetElements => get_facet_elements return the boundary elements interface This subroutine returns the mesh of facet/boundary elements of mesh obj private subroutine get_facet_elements(mdObj, Obj, facetmesh, feObj) This subroutine returns the mesh of boundary/facet elements of parent mesh Obj Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(inout) :: mdObj Mesh data of parent mesh class(Mesh_), intent(inout) :: Obj Parent mesh class(Mesh_), intent(inout) :: facetmesh facet mesh to be constructed class(Element_), intent(in) :: feObj Finite element procedure, public, PASS( Obj ) :: get_elem_elems_1 return element to element connectivity data for iel element interface Return element to element connectivity information private pure function get_elem_elems_1(Obj, iel) result(Ans) Return element to element connectivity information for a given element\n number iel - This routine return full information about elements surrounding\n element iel - Rows of Ans denote the element to which iel is connected to\n - Column-1 of Ans denotes element number\n - Column-2 denotes the local face number of element iel , and\n - Column-3 denotes the local face number of element whose element number is\n given in the column-1 Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj mesh data integer(kind=I4B), intent(in) :: iel element number Return Value integer(kind=I4B),\n  ALLOCATABLE, (:,:) list of elements surrounding elements procedure, public, PASS( Obj ) :: get_elem_elems_2 return element to element connectivity data for iel element interface Return element to element connectivity information private pure function get_elem_elems_2(Obj, iel) result(Ans) Return element to element connectivity information for a given element\n number iel - iel( 2 ) denotes the extra options\n     0 —> only Return the element numbers\n     1 —> Return the full information\n - This routine return full information when iel(2)=1 about elements surrounding element iel - Rows of Ans denote the element to which iel is connected to\n - Column-1 of Ans denotes element number\n - Column-2 denotes the local face number of element iel , and\n - Column-3 denotes the local face number of element whose element number is\n given in the column-1 Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: iel (2) Return Value integer(kind=I4B),\n  ALLOCATABLE, (:,:) procedure, public, PASS( Obj ) :: global_from_local return global node nuber of a given local node number interface Convert local node number to global node number private pure function global_from_local(Obj, LocalIndx) result(Ans) Convert local node number to global node number Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj mesh data integer(kind=I4B), intent(in) :: LocalIndx (:) vec of local node number Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) vec of global node number procedure, public, PASS( Obj ) :: global_from_local_scalar return global node nuber of a given local node number interface Convert local node number to global node number private pure function global_from_local_scalar(Obj, LocalIndx) result(Ans) Convert local node number to global node number Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj mesh data integer(kind=I4B), intent(in) :: LocalIndx local node number Return Value integer(kind=I4B) global node number procedure, public, PASS( Obj ) :: isBoundaryDataInitiated => is_boundarydata returns .true. if BoundaryData array is allocated interface Returns .true. if boundary data is initiated. private pure function is_boundarydata(Obj) result(Ans) Returns .true. if boundary data is initiated. Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj Return Value logical(kind=LGT) procedure, public, PASS( Obj ) :: isBoundaryElement => is_bndy_elem return .true. if element iel is a boundary element interface Returns .true. if a given element number iel is boundary element private pure function is_bndy_elem(Obj, iel) result(Ans) Returns .true. if a given element number iel is boundary element Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj mesh data integer(kind=I4B), intent(in) :: iel element number Return Value logical(kind=LGT) .true. if iel is a boundary element procedure, public, PASS( Obj ) :: isBoundaryNptrsInitiated => is_bndy_nptrs interface Returns .true. if data related to boundary nptrs is initiated. private pure function is_bndy_nptrs(Obj) result(Ans) Returns .true. if data related to boundary nptrs is initiated. Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj Return Value logical(kind=LGT) procedure, public, PASS( Obj ) :: isElementToElementsInitiated => is_element_elements_initiated returns .true. if ElemToElem array is allocated interface Returns .true. if elem to elem connectivity data is initiated. private pure function is_element_elements_initiated(Obj) result(Ans) Returns .true. if elem to elem connectivity data is initiated. Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj Return Value logical(kind=LGT) procedure, public, PASS( Obj ) :: isElementToNodesInitiated => is_element_nodes_initiated returns .true. if ElemToNode array is allocated interface Returns .true. if elem to node connectivity data is initiated. private pure function is_element_nodes_initiated(Obj) result(Ans) Returns .true. if elem to node connectivity data is initiated. Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj Return Value logical(kind=LGT) procedure, public, PASS( Obj ) :: isInternalBoundaryDataInitiated => is_int_bndy_data returns .true. if InternalBoundaryData array is allocated interface Returns .true. if internal bounary data is initiated private pure function is_int_bndy_data(Obj) result(Ans) Returns .true. if internal bounary data is initiated Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj Return Value logical(kind=LGT) procedure, public, PASS( Obj ) :: isInternalNptrsInitiated => is_internalnptrs returns .true. if InternalNptrs array is allocated interface Returns .true. if data related to internal nptrs is initiated. private pure function is_internalnptrs(Obj) result(Ans) Returns .true. if data related to internal nptrs is initiated. Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj Return Value logical(kind=LGT) procedure, public, PASS( Obj ) :: isLocalNptrsInitiated => is_local_nptrs returns .true. if Local_Nptrs array is allocated interface Returns .true. if data local_nptrs array is initiated. private pure function is_local_nptrs(Obj) result(Ans) Returns .true. if data local_nptrs array is initiated. Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj Return Value logical(kind=LGT) procedure, public, PASS( Obj ) :: isNodePresent => is_node_present returns .true. if a given node is present in the mesh interface Returns .true. if the a global node is present inside the mesh-data private pure function is_node_present(Obj, Nptrs) result(Ans) Returns .true. if the a global node is present inside the mesh-data Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj mesh data integer(kind=I4B), intent(in) :: Nptrs global node number Return Value logical(kind=LGT) Returns true if present procedure, public, PASS( Obj ) :: isNodeToElementsInitiated => is_node_elements_initiated returns .true. if NodeToElem array is allocated interface Returns .true. if node to elem connectivity data is initiated. private pure function is_node_elements_initiated(Obj) result(Ans) Returns .true. if node to elem connectivity data is initiated. Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj Return Value logical(kind=LGT) procedure, public, PASS( Obj ) :: isNodeToNodesInitiated => is_node_nodes_initiated returns .true. if NToN array is allocated interface Returns .true. if node to node connectivity data is initiated. private pure function is_node_nodes_initiated(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj Return Value logical(kind=LGT) procedure, public, PASS( Obj ) :: local_from_global return local node number of a given global node number interface Convert global node number to local node  number private pure function local_from_global(Obj, GlobalIndx) result(Ans) Convert global node number to local node  number Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj mesh data integer(kind=I4B), intent(in) :: GlobalIndx (:) vec of global node numbers Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) vec of local node number procedure, public, PASS( Obj ) :: local_from_global_scalar return local node number of a given global node number interface Convert global node numbr to local node number private pure function local_from_global_scalar(Obj, GlobalIndx) result(Ans) Convert global node numbr to local node number Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj mesh data integer(kind=I4B), intent(in) :: GlobalIndx global node number Return Value integer(kind=I4B) local node number procedure, public, PASS( Obj ) :: setSparsity => setSparsity_1 set sparsity in sparseMatrix_ interface This routine set the sparsity pattern in SparseMatrix_ object private subroutine setSparsity_1(Obj, MeshObj, Mat, map) This routine set the sparsity pattern in SparseMatrix_ object Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(inout) :: Obj mesh data type(Mesh_), intent(inout) :: MeshObj mesh object type(SparseMatrix_), intent(inout) :: Mat sparsematrix object integer(kind=I4B), intent(in), optional :: map (:) Global to local node number map Source Code TYPE :: MeshData_ !! [[MeshData_]] is contains mesh realated data INTEGER ( I4B ) :: MaxNptrs !! Largest node number present inside mesh INTEGER ( I4B ) :: MinNptrs !! Smallest node number present inside mesh INTEGER ( I4B ) :: tNodes !! Total number of nodes in mesh LOGICAL ( LGT ) :: isInitiated !! `.True.` if `MeshObj_` is initiated INTEGER ( I4B ), ALLOCATABLE :: LBndyIndex ( : ) !! For a given element if `LBndyIndex(iel) .eq. 0` then `iel` is not a !! a boundary element else it a boundary element which represents the !! index of `iel` in `BoundaryData()`. INTEGER ( I4B ), ALLOCATABLE :: Nptrs ( : ) !! Node number of mesh `Nptrs( minNptrs : maxNptrs )` INTEGER ( I4B ), ALLOCATABLE :: BoundaryNptrs ( : ) !! Node number of boundary of mesh INTEGER ( I4B ), ALLOCATABLE :: InternalNptrs ( : ) !! Node number of internal nodes INTEGER ( I4B ), ALLOCATABLE :: Local_Nptrs ( : ) !! This converts a given global node into local-node which can be !! used for accessing data inside `NodeToElem, NodeToNode` TYPE ( ReferenceElement_ ), POINTER :: refelem => NULL () !! Reference element TYPE ( IntVector_ ), ALLOCATABLE :: NodeToElem ( : ) !! `NodeToElem( iLocalNode )` denotes indx of elems in mesh which are !! directly connected to node `GlobalNptrs( iLocalNode )` TYPE ( IntVector_ ), ALLOCATABLE :: ElemToElem ( : ) !! `ElemToElem( iel )` denotes data of elements !! connected to the element`iel` TYPE ( IntVector_ ), ALLOCATABLE :: NTN ( : ) !! `NTN( iLocalNode )` denotes node-ids that are connected to a node !! `GlobalNode( iLocalNode )` TYPE ( IntVector_ ), ALLOCATABLE :: ElemToNode ( : ) !! ElemToNode( iel ) denotes the node numbers in element `iel` TYPE ( IntVector_ ), ALLOCATABLE :: BoundaryData ( : ) !! If `iel` is boundary element; !! then `Vec=BoundaryData( LBndyIndex(iel) ) ` !! contains boundary data, where `vec(1)` is equal to `iel`, and !! `vec(2:)` are ids of local facets which are boundaries of mesh TYPE ( IntVector_ ), ALLOCATABLE :: InternalBndyElemNum ( : ) !! To do TYPE ( IntVector_ ), ALLOCATABLE :: InternalBoundaryData ( : ) !! To do CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: Finalize => Deallocate_meshdata !! Deallocate mesh data PROCEDURE , PUBLIC , PASS ( Obj ) :: Initiate => init_meshdata_1 !! Initiate mesh data PROCEDURE , PUBLIC , PASS ( Obj ) :: TotalNodes => get_total_nodes !! Returns total number of nodes in mesh PROCEDURE , PUBLIC , PASS ( Obj ) :: TotalBoundaryNodes => get_tbndy_nodes !! Returns total number of boundary nodes in mesh PROCEDURE , PUBLIC , PASS ( Obj ) :: TotalInternalNodes => get_tint_nodes !! Return total number of internal nodes in mesh PROCEDURE , PUBLIC , PASS ( Obj ) :: TotalBoundaryElements => get_tbndy_elems !! Rertuns total boundary elements in mesh PROCEDURE , PUBLIC , PASS ( Obj ) :: BoundingBox => get_bBox !! return boundingbox of mesh PROCEDURE , PUBLIC , PASS ( Obj ) :: local_from_global !! return local node number of a given global node number PROCEDURE , PUBLIC , PASS ( Obj ) :: local_from_global_scalar !! return local node number of a given global node number GENERIC , PUBLIC :: LocalNptrs => local_from_global , & & local_from_global_scalar !! return local node number of a given global node number PROCEDURE , PUBLIC , PASS ( Obj ) :: global_from_local !! return global node nuber of a given local node number PROCEDURE , PUBLIC , PASS ( Obj ) :: global_from_local_scalar !! return global node nuber of a given local node number GENERIC , PUBLIC :: GlobalNptrs => global_from_local , & & global_from_local_scalar !! return global node nuber of a given local node number PROCEDURE , PUBLIC , PASS ( Obj ) :: isNodePresent => is_node_present !! returns `.true.` if a given node is present in the mesh PROCEDURE , PUBLIC , PASS ( Obj ) :: isNodeToNodesInitiated => & & is_node_nodes_initiated !! returns `.true.` if `NToN` array is allocated PROCEDURE , PUBLIC , PASS ( Obj ) :: isNodeToElementsInitiated => & & is_node_elements_initiated !! returns `.true.` if `NodeToElem` array is allocated PROCEDURE , PUBLIC , PASS ( Obj ) :: isElementToElementsInitiated => & & is_element_elements_initiated !! returns `.true.` if `ElemToElem` array is allocated PROCEDURE , PUBLIC , PASS ( Obj ) :: isElementToNodesInitiated => & & is_element_nodes_initiated !! returns `.true.` if `ElemToNode` array is allocated PROCEDURE , PUBLIC , PASS ( Obj ) :: isBoundaryDataInitiated => & & is_boundarydata !! returns `.true.` if `BoundaryData` array is allocated PROCEDURE , PUBLIC , PASS ( Obj ) :: isInternalNptrsInitiated => & & is_internalnptrs !! returns `.true.` if `InternalNptrs` array is allocated PROCEDURE , PUBLIC , PASS ( Obj ) :: isBoundaryNptrsInitiated => & & is_bndy_nptrs PROCEDURE , PUBLIC , PASS ( Obj ) :: isLocalNptrsInitiated => & & is_local_nptrs !! returns `.true.` if `Local_Nptrs` array is allocated PROCEDURE , PUBLIC , PASS ( Obj ) :: isInternalBoundaryDataInitiated => & & is_int_bndy_data !! returns `.true.` if `InternalBoundaryData` array is allocated PROCEDURE , PUBLIC , PASS ( Obj ) :: InitiateNodeToElements => & & init_node_elements !! construct node to element connectivity data PROCEDURE , PUBLIC , PASS ( Obj ) :: InitiateNodeToNodes => & & init_node_nodes !! construct node to node connectivity data PROCEDURE , PUBLIC , PASS ( Obj ) :: InitiateElementToElements => & & init_element_elements !! construct element to element connectivity data PROCEDURE , PUBLIC , PASS ( Obj ) :: InitiateElementToNodes => & & init_elem_nodes !! construct element to node connectivity data PROCEDURE , PUBLIC , PASS ( Obj ) :: InitiateBoundaryData => init_bndy_data !! construct boundary data information PROCEDURE , PUBLIC , PASS ( Obj ) :: InitiateInternalNptrs => init_int_nptrs !! construct details about the internal boundary PROCEDURE , PUBLIC , PASS ( Obj ) :: InitiateInternalBoundaryData => & & init_int_bndydata !! construct details about the internal boundary PROCEDURE , PUBLIC , PASS ( Obj ) :: NodeToElements => node_elements !! return node to element connectivity data for `GlobalIndx` PROCEDURE , PUBLIC , PASS ( Obj ) :: NodeToNodes => get_node_nodes !! return node to node connectivity data for `GlobalIndx` PROCEDURE , PUBLIC , PASS ( Obj ) :: get_elem_elems_1 !! return element to element connectivity data for `iel` element PROCEDURE , PUBLIC , PASS ( Obj ) :: get_elem_elems_2 !! return element to element connectivity data for `iel` element GENERIC , PUBLIC :: ElementToElements => get_elem_elems_1 , get_elem_elems_2 !! return element to element connectivity data for `iel` element PROCEDURE , PUBLIC , PASS ( Obj ) :: ElementToNodes => get_elem_nodes !! return element to node connectivity data for `iel` element PROCEDURE , PUBLIC , PASS ( Obj ) :: isBoundaryElement => is_bndy_elem !! return `.true.` if element `iel` is a boundary element PROCEDURE , PUBLIC , PASS ( Obj ) :: BoundaryElementData => get_bndy_elem !! return boundary element data of a boundary element `iel` if it is !! boundary element PROCEDURE , PUBLIC , PASS ( Obj ) :: setSparsity => setSparsity_1 !! set sparsity in sparseMatrix_ PROCEDURE , PUBLIC , PASS ( mdObj ) :: getFacetElements => get_facet_elements !! return the boundary elements PROCEDURE , PUBLIC , PASS ( CellMeshData ) :: connectFacetToCell => & & mc_connect_facet_cell !! connect facet to cell PROCEDURE , PUBLIC , PASS ( Obj ) :: MeshQuality => md_quality !! return mesh quality PROCEDURE , PUBLIC , PASS ( Obj ) :: FindElement => md_findElement END TYPE MeshData_","tags":"","loc":"type/meshdata_.html"},{"title":"MeshPointer_ – Fortran Program ","text":"type, public :: MeshPointer_ MeshPointer_ is a userdefine datatype which contains the pointer to\n a mesh Contents Variables Ptr Source Code MeshPointer_ Components Type Visibility Attributes Name Initial type( Mesh_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: MeshPointer_ TYPE ( Mesh_ ), POINTER :: Ptr => NULL ( ) END TYPE MeshPointer_","tags":"","loc":"type/meshpointer_.html"},{"title":"Mesh_ – Fortran Program ","text":"type, public :: Mesh_ In EASIFEM Mesh_ datatype is simply a collection of finite elements.\n To avoid working with linked list I have encapsulated a vector of ElementPointer_ . This way, adding or removing of an element\n to existing mesh becomes simple. Warning Dont use Obj % SetTotalElements() method in external programs Contents Variables Elem NSD maxElements tElements Type-Bound Procedures Append ElementPointer Finalize Initiate RemoveElement SIZE SetElement SetSize SetTotalElements TotalElements getNptrs setMaterialType Source Code Mesh_ Components Type Visibility Attributes Name Initial type(ElementPointer_), public, ALLOCATABLE :: Elem (:) Collection of finite elements integer(kind=I4B), public :: NSD spatial dimension integer(kind=I4B), public :: maxElements maximum size of the wrapper integer(kind=I4B), public :: tElements total elements in mesh Type-Bound Procedures procedure, public, PASS( Obj ) :: Append => add_element Append an element to a mesh interface Add an element to mesh private subroutine add_element(Obj, Elem) Append an element, increate total elements in mesh by one Read more… Arguments Type Intent Optional Attributes Name class( Mesh_ ), intent(inout) :: Obj mesh obj class(Element_), intent(inout), TARGET :: Elem finite element to be added procedure, public, PASS( Obj ) :: ElementPointer => getElement_Pointer Get Pointer to an element in mesh interface Return the pointer to an element Obj % Elem(iel) private function getElement_Pointer(Obj, iel) result(Ans) Return the pointer to an element Obj % Elem(iel) Read more… Arguments Type Intent Optional Attributes Name class( Mesh_ ), intent(in) :: Obj mesh object integer(kind=I4B), intent(in) :: iel element number Return Value class(Element_),\n  POINTER pointer to finite element procedure, public, PASS( Obj ) :: Finalize => Deallocate_Data Deallocate data interface Deallocate data stored in Mesh_ private subroutine Deallocate_Data(Obj) Deallocate data stored in Mesh_ Read more… Arguments Type Intent Optional Attributes Name class( Mesh_ ), intent(inout) :: Obj mesh object procedure, public, PASS( Obj ) :: Initiate => allocateMeshSize Allocate size of a mesh interface Allocate the size of the mesh private subroutine allocateMeshSize(Obj, NSD, tElements, factor) Allocate the size of the mesh. Generic name —> Initiate() Read more… Arguments Type Intent Optional Attributes Name class( Mesh_ ), intent(inout) :: Obj mesh object integer(kind=I4B), intent(in) :: NSD spatial dimension integer(kind=I4B), intent(in) :: tElements total number of elements in mesh real(kind=DFP), intent(in), optional :: factor maxLength = factor * telements procedure, public, PASS( Obj ) :: RemoveElement => remove_element Remove an element from a mesh interface Remove an element from the mesh private subroutine remove_element(Obj, iel, extraoption) Remove an element from the mesh Read more… Arguments Type Intent Optional Attributes Name class( Mesh_ ), intent(inout) :: Obj mesh object integer(kind=I4B), intent(in) :: iel element number integer(kind=I4B), intent(in) :: extraoption procedure, public, PASS( Obj ) :: SIZE => total_elements Returns the total elements in a mesh interface Returns total elements in the mesh private pure function total_elements(Obj) result(Ans) Returns total elements in the mesh Read more… Arguments Type Intent Optional Attributes Name class( Mesh_ ), intent(in) :: Obj mesh object Return Value integer(kind=I4B) procedure, public, PASS( Obj ) :: SetElement => Set_element Set an element to a mesh interface Set an element to a mesh private subroutine Set_element(Obj, Elem, iel) Seting element; total number of elements remain same\n Size of mesh should be sufficient while using this. Read more… Arguments Type Intent Optional Attributes Name class( Mesh_ ), intent(inout) :: Obj Mesh object class(Element_), intent(inout), TARGET :: Elem Finite element to be put in mesh integer(kind=I4B), intent(in) :: iel element number procedure, public, PASS( Obj ) :: SetSize => set_total_elements Set total elements in a mesh interface Set total elements in mesh object private subroutine set_total_elements(Obj) Set total elements in mesh object Read more… Arguments Type Intent Optional Attributes Name class( Mesh_ ), intent(inout) :: Obj mesh object procedure, public, PASS( Obj ) :: SetTotalElements => set_total_elements Alias of SetSize interface Set total elements in mesh object private subroutine set_total_elements(Obj) Set total elements in mesh object Read more… Arguments Type Intent Optional Attributes Name class( Mesh_ ), intent(inout) :: Obj mesh object procedure, public, PASS( Obj ) :: TotalElements => total_elements Alias of SIZE interface Returns total elements in the mesh private pure function total_elements(Obj) result(Ans) Returns total elements in the mesh Read more… Arguments Type Intent Optional Attributes Name class( Mesh_ ), intent(in) :: Obj mesh object Return Value integer(kind=I4B) procedure, public, PASS( Obj ) :: getNptrs => get_nptrs Get node numbers in a mesh interface Returns the node numbers in mesh private subroutine get_nptrs(Obj, Nptrs) Returns the node numbers in mesh Read more… Arguments Type Intent Optional Attributes Name class( Mesh_ ), intent(inout) :: Obj mesh object integer(kind=I4B), intent(inout), ALLOCATABLE :: Nptrs (:) node numbers procedure, public, PASS( Obj ) :: setMaterialType => setMaterialType_1 Set material type of a mesh interface Set material propertie private subroutine setMaterialType_1(Obj, MatType) set material properties of element in the mesh. Currently, this routine\n add same material property to all elements Read more… Arguments Type Intent Optional Attributes Name class( Mesh_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: MatType Source Code TYPE :: Mesh_ TYPE ( ElementPointer_ ), ALLOCATABLE :: Elem ( : ) !! Collection of finite elements INTEGER ( I4B ) :: NSD !! spatial dimension INTEGER ( I4B ) :: tElements !! total elements in mesh INTEGER ( I4B ) :: maxElements !! maximum size of the wrapper CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: Finalize => Deallocate_Data !! Deallocate data PROCEDURE , PUBLIC , PASS ( Obj ) :: Initiate => allocateMeshSize !! Allocate size of a mesh PROCEDURE , PUBLIC , PASS ( Obj ) :: SetTotalElements => set_total_elements !! Alias of SetSize PROCEDURE , PUBLIC , PASS ( Obj ) :: Append => add_element !! Append an element to a mesh PROCEDURE , PUBLIC , PASS ( Obj ) :: SetSize => set_total_elements !! Set total elements in a mesh PROCEDURE , PUBLIC , PASS ( Obj ) :: SetElement => Set_element !! Set an element to a mesh PROCEDURE , PUBLIC , PASS ( Obj ) :: ElementPointer => getElement_Pointer !! Get Pointer to an element in mesh PROCEDURE , PUBLIC , PASS ( Obj ) :: RemoveElement => remove_element !! Remove an element from a mesh PROCEDURE , PUBLIC , PASS ( Obj ) :: SIZE => total_elements !! Returns the total elements in a mesh PROCEDURE , PUBLIC , PASS ( Obj ) :: TotalElements => total_elements !! Alias of SIZE PROCEDURE , PUBLIC , PASS ( Obj ) :: getNptrs => get_nptrs !! Get node numbers in a mesh PROCEDURE , PUBLIC , PASS ( Obj ) :: setMaterialType => setMaterialType_1 !! Set material type of a mesh END TYPE Mesh_","tags":"","loc":"type/mesh_.html"},{"title":"MeshConnectivityPointer_ – Fortran Program ","text":"type, public :: MeshConnectivityPointer_ This data type contains the pointer of MeshConnectivity_ Contents Variables Ptr Source Code MeshConnectivityPointer_ Components Type Visibility Attributes Name Initial class( MeshConnectivity_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: MeshConnectivityPointer_ CLASS ( MeshConnectivity_ ), POINTER :: Ptr => NULL ( ) END TYPE MeshConnectivityPointer_","tags":"","loc":"type/meshconnectivitypointer_.html"},{"title":"MeshConnectivity_ – Fortran Program ","text":"type, public :: MeshConnectivity_ MeshConnectivity_ contains data connectivity data between two meshobject Contents Variables CellCell CellFacet NodeToNodes Type-Bound Procedures CellNumber FacetLocalID Finalize InitiateFacetToCellData InitiateNodeToNodeData mc_cell_of_facet mc_cells_of_facets mc_facet_local_id_1 mc_facet_local_id_2 Components Type Visibility Attributes Name Initial integer(kind=I4B), public, ALLOCATABLE :: CellCell (:,:) Cell to cell connectivity data integer(kind=I4B), public, ALLOCATABLE :: CellFacet (:,:) Cell to facet connectivity data integer(kind=I4B), public, ALLOCATABLE :: NodeToNodes (:,:) Node to nodes connectivity data Type-Bound Procedures generic, public :: CellNumber => mc_cell_of_facet , mc_cells_of_facets Return the cell numbers of given facet elements private interface mc_cell_of_facet () Returns cell number of given facet number Arguments None private interface mc_cells_of_facets () Returns cell number of given facet number Arguments None generic, public :: FacetLocalID => mc_facet_local_id_1 , mc_facet_local_id_2 Return the facet local id in cell element private interface mc_facet_local_id_1 () Returns the local facet id of cell element Arguments None private interface mc_facet_local_id_2 () Returns the local facet id of cell element Arguments None procedure, public, PASS( Obj ) :: Finalize => mc_deallocate_data Deallocate data stored in the object interface This subroutine deallocate the data stored in MeshConnectivity_ private subroutine mc_deallocate_data(Obj) This subroutine deallocate the data stored in MeshConnectivity_ Read more… Arguments Type Intent Optional Attributes Name class( MeshConnectivity_ ), intent(inout) :: Obj Mesh connectivity object procedure, public, PASS( Obj ) :: InitiateFacetToCellData => mc_init_cell_facet Initiate facet to cell connectivity data interface Generate the connectivity matrix between cell and facet mesh. private subroutine mc_init_cell_facet(Obj, CellMesh, FacetMesh, CellMeshData) This subroutine generate the connectivity matrix called Obj % CellFacet\n between cell and facet mesh. Read more… Arguments Type Intent Optional Attributes Name class( MeshConnectivity_ ), intent(inout) :: Obj Mesh connectivity data class(Mesh_), intent(inout) :: CellMesh Mesh of cell elements class(Mesh_), intent(inout) :: FacetMesh Mesh of facet mesh class(MeshData_), intent(inout) :: CellMeshData Mesh data for CellMesh procedure, public, PASS( Obj ) :: InitiateNodeToNodeData => mc_init_node_node Initiate the node to node connectivity between two meshes interface Generate the connectivity matrix between two meshes private subroutine mc_init_node_node(Obj, Mesh1, Mesh2, Node1, Node2, MeshData1, MeshData2) The output result will be an integer array with 2 columns\n       - first column: contains the node number of Mesh1\n       - second column: contains the node number of Mesh2 which is\n       - directly connected to the node 1 Read more… Arguments Type Intent Optional Attributes Name class( MeshConnectivity_ ), intent(inout) :: Obj mesh connectivity object class(Mesh_), intent(in) :: Mesh1 Mesh object class(Mesh_), intent(in) :: Mesh2 Mesh object real(kind=DFP), intent(in) :: Node1 (:,:) Nodal coordinates in Mesh1 real(kind=DFP), intent(in) :: Node2 (:,:) Nodal coordinate in Mesh2 class(MeshData_), intent(inout) :: MeshData1 Mesh data for mesh 1 class(MeshData_), intent(inout) :: MeshData2 Mesh data for mesh 2 procedure, public, PASS( Obj ) :: mc_cell_of_facet Return the cell number of a given facet interface Returns cell number of given facet number private pure function mc_cell_of_facet(Obj, FacetNum) result(Ans) fortran\n    id = obj % CellNumber( facetNum ) Read more… Arguments Type Intent Optional Attributes Name class( MeshConnectivity_ ), intent(in) :: Obj Mesh connectivity data integer(kind=I4B), intent(in) :: FacetNum Facet element number Return Value integer(kind=I4B) Cell number procedure, public, PASS( Obj ) :: mc_cells_of_facets Return the cell numbers of given facet elements interface Returns cell number of given facet number private pure function mc_cells_of_facets(Obj, FacetNum) result(Ans) fortran\n    id = obj % CellNumber( facetNum ) Read more… Arguments Type Intent Optional Attributes Name class( MeshConnectivity_ ), intent(in) :: Obj Mesh connectivity data integer(kind=I4B), intent(in) :: FacetNum (:) List of facet element numbers Return Value integer(kind=I4B)\n  (SIZE(FacetNum)) List of cell element numbers procedure, public, PASS( Obj ) :: mc_facet_local_id_1 Return the facet local id in cell element interface Returns the local facet id of cell element private pure function mc_facet_local_id_1(Obj, FacetNum) result(Ans) Returns the local facet id of cell element which is in contact with\n facet element Read more… Arguments Type Intent Optional Attributes Name class( MeshConnectivity_ ), intent(in) :: Obj Mesh connectivity object integer(kind=I4B), intent(in) :: FacetNum Facet element number Return Value integer(kind=I4B) Local facet ID procedure, public, PASS( Obj ) :: mc_facet_local_id_2 Return the facet local id in cell element interface Returns the local facet id of cell element private pure function mc_facet_local_id_2(Obj, FacetNum) result(Ans) Returns the local facet id of cell element which is in contact with\n facet element Read more… Arguments Type Intent Optional Attributes Name class( MeshConnectivity_ ), intent(in) :: Obj Mesh connectivity data integer(kind=I4B), intent(in) :: FacetNum (:) List of facet element numbers Return Value integer(kind=I4B)\n  (SIZE(FacetNum)) List of local facet IDs","tags":"","loc":"type/meshconnectivity_.html"},{"title":"DomainPointer_ – Fortran Program ","text":"type, public :: DomainPointer_ It contains pointer to Domain_ object Contents Variables Ptr Source Code DomainPointer_ Components Type Visibility Attributes Name Initial class( Domain_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: DomainPointer_ CLASS ( Domain_ ), POINTER :: Ptr => NULL ( ) END TYPE DomainPointer_","tags":"","loc":"type/domainpointer_.html"},{"title":"Domain_ – Fortran Program ","text":"type, public :: Domain_ Domain_ contains the collection of meshes which represent specific\n parts of domain Contents Variables Boundary Edge NodalAcceleration NodalVelocity Nodes Omega allocateNodes boundary_name edge_name mdBoundary mdEdge mdOmega omega_name Type-Bound Procedures ConnectFacetToCell Finalize Initiate Source Code Domain_ Components Type Visibility Attributes Name Initial type(MeshPointer_), public, ALLOCATABLE :: Boundary (:) Mesh of boundary elements type(MeshPointer_), public, ALLOCATABLE :: Edge (:) Mesh of lines real(kind=DFP), public, ALLOCATABLE :: NodalAcceleration (:,:) real(kind=DFP), public, ALLOCATABLE :: NodalVelocity (:,:) real(kind=DFP), public, POINTER :: Nodes (:,:) => NULL() type(MeshPointer_), public, ALLOCATABLE :: Omega (:) Mesh of cell elements logical(kind=LGT), public :: allocateNodes = .FALSE. This indicates whether nodes are allocated inside the domain or outside type(String), public, ALLOCATABLE :: boundary_name (:) physical names of boundary type(String), public, ALLOCATABLE :: edge_name (:) physical names of edge type(MeshDataPointer_), public, ALLOCATABLE :: mdBoundary (:) Mesh data for Boundary(:) type(MeshDataPointer_), public, ALLOCATABLE :: mdEdge (:) Mesh data for Boundary(:) type(MeshDataPointer_), public, ALLOCATABLE :: mdOmega (:) Mesh data for Omega(:) type(String), public, ALLOCATABLE :: omega_name (:) Physical names of omega Type-Bound Procedures procedure, public, PASS( Dom ) :: ConnectFacetToCell => mc_connect_facet_cell interface Connect Mesh_ of FacetElement_ to Mesh_ of cell Element_ private subroutine mc_connect_facet_cell(Dom, OmegaIndx, BoundaryIndx) This subroutine connects the mesh of facet elements to the mesh of\n cell elements Read more… Arguments Type Intent Optional Attributes Name class( Domain_ ), intent(inout), TARGET :: Dom integer(kind=I4B), intent(in) :: OmegaIndx integer(kind=I4B), intent(in) :: BoundaryIndx procedure, public, PASS( Obj ) :: Finalize => deallocate_obj Deallocate data store inside the domain interface Deallocate data in Domain_ object private subroutine deallocate_obj(Obj) Deallocate data stored in Domain_ object Arguments Type Intent Optional Attributes Name class( Domain_ ), intent(inout) :: Obj Domain object procedure, public, PASS( Obj ) :: Initiate => Initiate_obj Constructor for domain interface Initiate Domain_ object private subroutine Initiate_obj(Obj, tOmega, tBoundary, tEdge) This routine allocate the memory for Domain_ obj.\n - allocate size of Obj % Omega( 1:tOmega ) - allocate Obj % Boundary( 1:tBoundary ) ,\n - allocate Obj % mdOmega( 1:tOmega ) - allocate Obj % mdBoundary( 1:tBoundary ) Read more… Arguments Type Intent Optional Attributes Name class( Domain_ ), intent(inout) :: Obj Domain integer(kind=I4B), intent(in), optional :: tOmega total number of $\\Omega$ domains integer(kind=I4B), intent(in), optional :: tBoundary total number of $\\Gamma$ domains integer(kind=I4B), intent(in), optional :: tEdge total number of line domains Source Code TYPE :: Domain_ TYPE ( MeshPointer_ ), ALLOCATABLE :: Omega ( : ) !! Mesh of cell elements TYPE ( MeshPointer_ ), ALLOCATABLE :: Boundary ( : ) !! Mesh of boundary elements TYPE ( MeshPointer_ ), ALLOCATABLE :: Edge ( : ) !! Mesh of lines TYPE ( MeshDataPointer_ ), ALLOCATABLE :: mdOmega ( : ) !! Mesh data for `Omega(:)` TYPE ( MeshDataPointer_ ), ALLOCATABLE :: mdBoundary ( : ) !! Mesh data for `Boundary(:)` TYPE ( MeshDataPointer_ ), ALLOCATABLE :: mdEdge ( : ) !! Mesh data for `Boundary(:)` REAL ( DFP ), POINTER :: Nodes ( :, : ) => NULL ( ) REAL ( DFP ), ALLOCATABLE :: NodalVelocity ( :, : ) REAL ( DFP ), ALLOCATABLE :: NodalAcceleration ( :, : ) LOGICAL ( LGT ) :: allocateNodes = . FALSE . !! This indicates whether nodes are allocated inside the domain or outside TYPE ( String ), ALLOCATABLE :: omega_name ( : ) !! Physical names of omega TYPE ( String ), ALLOCATABLE :: boundary_name ( : ) !! physical names of boundary TYPE ( String ), ALLOCATABLE :: edge_name ( : ) !! physical names of edge CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: Initiate => Initiate_obj !! Constructor for domain PROCEDURE , PUBLIC , PASS ( Obj ) :: Finalize => deallocate_obj !! Deallocate data store inside the domain PROCEDURE , PUBLIC , PASS ( Dom ) :: ConnectFacetToCell => & & mc_connect_facet_cell END TYPE Domain_","tags":"","loc":"type/domain_.html"},{"title":"ElementPointer_ – Fortran Program ","text":"type, public :: ElementPointer_ Contents Variables Ptr Source Code ElementPointer_ Components Type Visibility Attributes Name Initial class( Element_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: ElementPointer_ CLASS ( Element_ ), POINTER :: Ptr => NULL ( ) END TYPE ElementPointer_","tags":"","loc":"type/elementpointer_.html"},{"title":"Element_ – Fortran Program ","text":"type, public :: Element_ Contents Variables MAT_Type Nptrs RefElem Type-Bound Procedures CellNptrs CellPointer Display FacetLocalID FacetLocalNptrs FreePointerToCell Initiate OPERATOR( .Nptrs. ) PointerToCell getElemShapeData getNptrs get_elemsd_H1_Lagrange isBoundaryElement m_Initiate_obj m_initiate_from_obj setFacetLocalID setMaterialType setNptrs setPointerToCell Source Code Element_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: MAT_Type integer(kind=I4B), public, ALLOCATABLE :: Nptrs (:) class(ReferenceElement_), public, POINTER :: RefElem => NULL() Type-Bound Procedures procedure, public, PASS( Obj ) :: CellNptrs => getCellNptrs interface private pure function getCellNptrs(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(in) :: Obj Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) procedure, public, PASS( Obj ) :: CellPointer => getPointerToCell interface private function getPointerToCell(Obj) result(CellObj) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(in), TARGET :: Obj Return Value class( Element_ ),\n  POINTER procedure, public, PASS( Obj ) :: Display => m_display_Obj interface private subroutine m_display_Obj(Obj, Msg, UnitNo, FullDisp) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(in) :: Obj character(len=*), intent(in) :: Msg integer(kind=I4B), intent(in), optional :: UnitNo logical(kind=LGT), intent(in), optional :: FullDisp procedure, public, PASS( Obj ) :: FacetLocalID => getFacetLocalID interface private pure function getFacetLocalID(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(in) :: Obj Return Value integer(kind=I4B) procedure, public, PASS( Obj ) :: FacetLocalNptrs => getFacetLocalNptrs interface private pure function getFacetLocalNptrs(Obj) result(Nptrs) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(in) :: Obj Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) procedure, public, PASS( Obj ) :: FreePointerToCell interface private subroutine FreePointerToCell(Obj) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(inout) :: Obj generic, public :: Initiate => m_Initiate_obj , m_initiate_from_obj private interface m_Initiate_obj () Arguments None private interface m_initiate_from_obj () Arguments None generic, public :: OPERATOR( .Nptrs. ) => getNptrs private interface m_getNptrs () Arguments None procedure, public, PASS( Obj ) :: PointerToCell => getPointerToCell interface private function getPointerToCell(Obj) result(CellObj) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(in), TARGET :: Obj Return Value class( Element_ ),\n  POINTER generic, public :: getElemShapeData => get_elemsd_H1_Lagrange private interface get_elemsd_H1_Lagrange () Arguments None procedure, public, PASS( Obj ) :: getNptrs => m_getNptrs interface private pure function m_getNptrs(Obj) result(Nptrs) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(in) :: Obj Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) procedure, public, PASS ( Obj ) :: get_elemsd_H1_Lagrange interface private subroutine get_elemsd_H1_Lagrange(Obj, ElemSD, Quad, xIJ, ContinuityType, InterpolType) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(inout) :: Obj class(ElemShapeData_), intent(inout) :: ElemSD type(QuadraturePoint_), intent(in) :: Quad real(kind=DFP), intent(in) :: xIJ (:,:) type(H1_), intent(in) :: ContinuityType type(LagrangeInterpolation_), intent(in) :: InterpolType procedure, public, PASS( Obj ) :: isBoundaryElement => m_isBoundaryElement interface private pure function m_isBoundaryElement(Obj, NSD) result(Ans) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: NSD Return Value logical(kind=LGT) procedure, public, PASS( Obj ) :: m_Initiate_obj interface private subroutine m_Initiate_obj(Obj, Nptrs, Mat_Type, RefElem) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Nptrs (:) integer(kind=I4B), intent(in) :: Mat_Type class(ReferenceElement_), intent(inout), TARGET :: RefElem procedure, public, PASS( Obj ) :: m_initiate_from_obj interface private subroutine m_initiate_from_obj(Obj, AnotherObj) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(inout) :: Obj class( Element_ ), intent(inout), TARGET :: AnotherObj procedure, public, PASS( Obj ) :: setFacetLocalID interface private subroutine setFacetLocalID(Obj, Id) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Id procedure, public, PASS( Obj ) :: setMaterialType => setMaterialType_1 interface private subroutine setMaterialType_1(Obj, MatType) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: MatType procedure, public, PASS( Obj ) :: setNptrs => m_setNptrs interface private subroutine m_setNptrs(Obj, Nptrs) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Nptrs (:) procedure, public, PASS( Obj ) :: setPointerToCell => SetPointerToCell interface private subroutine SetPointerToCell(Obj, CellObj) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(inout) :: Obj class( Element_ ), intent(inout), TARGET :: CellObj Source Code TYPE :: Element_ INTEGER ( I4B ), ALLOCATABLE :: Nptrs ( : ) INTEGER ( I4B ) :: MAT_Type CLASS ( ReferenceElement_ ), POINTER :: RefElem => NULL ( ) CONTAINS ! Constructor PROCEDURE , PUBLIC , PASS ( Obj ) :: m_Initiate_obj , m_initiate_from_obj GENERIC , PUBLIC :: Initiate => m_Initiate_obj , m_initiate_from_obj PROCEDURE , PUBLIC , PASS ( Obj ) :: Display => m_display_Obj PROCEDURE , PUBLIC , PASS ( Obj ) :: isBoundaryElement => m_isBoundaryElement PROCEDURE , PUBLIC , PASS ( Obj ) :: getNptrs => m_getNptrs PROCEDURE , PUBLIC , PASS ( Obj ) :: setNptrs => m_setNptrs GENERIC , PUBLIC :: OPERATOR ( . Nptrs . ) => getNptrs PROCEDURE , PUBLIC , PASS ( Obj ) :: setMaterialType => setMaterialType_1 ! ShapeData PROCEDURE , PUBLIC , PASS ( Obj ) :: get_elemsd_H1_Lagrange GENERIC , PUBLIC :: getElemShapeData => get_elemsd_H1_Lagrange ! Virtual PROCEDURE , PUBLIC , PASS ( Obj ) :: CellNptrs => getCellNptrs PROCEDURE , PUBLIC , PASS ( Obj ) :: PointerToCell => getPointerToCell PROCEDURE , PUBLIC , PASS ( Obj ) :: CellPointer => getPointerToCell PROCEDURE , PUBLIC , PASS ( Obj ) :: FacetLocalID => getFacetLocalID PROCEDURE , PUBLIC , PASS ( Obj ) :: FacetLocalNptrs => getFacetLocalNptrs PROCEDURE , PUBLIC , PASS ( Obj ) :: setPointerToCell PROCEDURE , PUBLIC , PASS ( Obj ) :: FreePointerToCell PROCEDURE , PUBLIC , PASS ( Obj ) :: setFacetLocalID END TYPE Element_","tags":"","loc":"type/element_.html"},{"title":"FacetElementPointer_ – Fortran Program ","text":"type, public :: FacetElementPointer_ Contents Variables Ptr Source Code FacetElementPointer_ Components Type Visibility Attributes Name Initial class( FacetElementPointer_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: FacetElementPointer_ CLASS ( FacetElementPointer_ ), POINTER :: Ptr => NULL ( ) END TYPE FacetElementPointer_","tags":"","loc":"type/facetelementpointer_.html"},{"title":"FacetElement_ – Fortran Program ","text":"type, public, EXTENDS( Element_ ) :: FacetElement_ Contents Variables Cell LocalID OuterCell Type-Bound Procedures CellNptrs Display FacetLocalID FacetLocalNptrs FreePointerToCell PointerToCell get_elemsd_H1_Lagrange setFacetLocalID setPointerToCell Source Code FacetElement_ Components Type Visibility Attributes Name Initial class(Element_), public, POINTER :: Cell => NULL() integer(kind=I4B), public :: LocalID class(Element_), public, POINTER :: OuterCell => NULL() Type-Bound Procedures procedure, public, PASS( Obj ) :: CellNptrs => getCellNptrs interface private pure function getCellNptrs(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( FacetElement_ ), intent(in) :: Obj Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) procedure, public, PASS( Obj ) :: Display => m_display_Obj interface private subroutine m_display_Obj(Obj, Msg, UnitNo, FullDisp) Arguments Type Intent Optional Attributes Name class( FacetElement_ ), intent(in) :: Obj character(len=*), intent(in) :: Msg integer(kind=I4B), intent(in), optional :: UnitNo logical(kind=LGT), intent(in), optional :: FullDisp procedure, public, PASS( Obj ) :: FacetLocalID => getFacetLocalID interface private pure function getFacetLocalID(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( FacetElement_ ), intent(in) :: Obj Return Value integer(kind=I4B) procedure, public, PASS( Obj ) :: FacetLocalNptrs => getFacetLocalNptrs interface private pure function getFacetLocalNptrs(Obj) result(Nptrs) Arguments Type Intent Optional Attributes Name class( FacetElement_ ), intent(in) :: Obj Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) procedure, public, PASS( Obj ) :: FreePointerToCell interface private subroutine FreePointerToCell(Obj) Arguments Type Intent Optional Attributes Name class( FacetElement_ ), intent(inout) :: Obj procedure, public, PASS( Obj ) :: PointerToCell => getPointerToCell interface private function getPointerToCell(Obj) result(CellObj) Arguments Type Intent Optional Attributes Name class( FacetElement_ ), intent(in), TARGET :: Obj Return Value class(Element_),\n  POINTER procedure, public, PASS( Obj ) :: get_elemsd_H1_Lagrange interface private subroutine get_elemsd_H1_Lagrange(Obj, ElemSD, Quad, xIJ, ContinuityType, InterpolType) Arguments Type Intent Optional Attributes Name class( FacetElement_ ), intent(inout) :: Obj class(ElemShapeData_), intent(inout) :: ElemSD type(QuadraturePoint_), intent(in) :: Quad real(kind=DFP), intent(in) :: xIJ (:,:) type(H1_), intent(in) :: ContinuityType type(LagrangeInterpolation_), intent(in) :: InterpolType procedure, public, PASS( Obj ) :: setFacetLocalID interface private subroutine setFacetLocalID(Obj, Id) Arguments Type Intent Optional Attributes Name class( FacetElement_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Id procedure, public, PASS( Obj ) :: setPointerToCell => SetPointerToCell interface private subroutine SetPointerToCell(Obj, CellObj) Arguments Type Intent Optional Attributes Name class( FacetElement_ ), intent(inout) :: Obj class(Element_), intent(inout), TARGET :: CellObj Source Code TYPE , EXTENDS ( Element_ ) :: FacetElement_ INTEGER ( I4B ) :: LocalID CLASS ( Element_ ), POINTER :: Cell => NULL ( ) CLASS ( Element_ ), POINTER :: OuterCell => NULL ( ) CONTAINS ! Constructor PROCEDURE , PUBLIC , PASS ( Obj ) :: CellNptrs => getCellNptrs PROCEDURE , PUBLIC , PASS ( Obj ) :: PointerToCell => getPointerToCell PROCEDURE , PUBLIC , PASS ( Obj ) :: FacetLocalID => getFacetLocalID PROCEDURE , PUBLIC , PASS ( Obj ) :: FacetLocalNptrs => getFacetLocalNptrs PROCEDURE , PUBLIC , PASS ( Obj ) :: setPointerToCell PROCEDURE , PUBLIC , PASS ( Obj ) :: FreePointerToCell PROCEDURE , PUBLIC , PASS ( Obj ) :: setFacetLocalID PROCEDURE , PUBLIC , PASS ( Obj ) :: Display => m_display_Obj ! ! getElemShapeData.part PROCEDURE , PUBLIC , PASS ( Obj ) :: get_elemsd_H1_Lagrange ! PROCEDURE, PUBLIC, PASS( Obj ) :: getElemShapeData_From_XiJ2 END TYPE FacetElement_","tags":"","loc":"type/facetelement_.html"},{"title":"vtkPointer_ – Fortran Program ","text":"type, public :: vtkPointer_ Contents Variables Ptr Source Code vtkPointer_ Components Type Visibility Attributes Name Initial class( vtk_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: vtkPointer_ CLASS ( vtk_ ), POINTER :: Ptr => NULL ( ) END TYPE vtkPointer_","tags":"","loc":"type/vtkpointer_.html"},{"title":"vtk_ – Fortran Program ","text":"type, public :: vtk_ Contents Variables afile extension filename fmt inPiece meshTopology nx1 nx2 ny1 ny2 nz1 nz2 path Type-Bound Procedures Finalize Initiate WriteGeometry WriteNodeData WriteQuadratureData closeElementData closeNodeData closePiece openElementData openNodeData openPiece vtk_write_cell_data_1 vtk_write_cell_data_2 vtk_write_mesh_data_1 vtk_write_mesh_data_2 vtk_write_mesh_data_3 vtk_write_node_data_1 vtk_write_node_data_2 Source Code vtk_ Components Type Visibility Attributes Name Initial type(vtk_file), public :: afile type(String), public :: extension type(String), public :: filename character(len=10), public :: fmt = \"ascii\" logical(kind=LGT), public :: inPiece = .FALSE. character(len=10), public :: meshTopology = \"UnstructuredGrid\" integer(kind=I4B), public :: nx1 = 0 integer(kind=I4B), public :: nx2 = 0 integer(kind=I4B), public :: ny1 = 0 integer(kind=I4B), public :: ny2 = 0 integer(kind=I4B), public :: nz1 = 0 integer(kind=I4B), public :: nz2 = 0 type(String), public :: path Type-Bound Procedures procedure, public, PASS( obj ) :: Finalize => vtk_final interface This subroutine closes the opened vtk file private subroutine vtk_final(obj) This subroutine close the open vtk file Arguments Type Intent Optional Attributes Name class( vtk_ ), intent(inout) :: obj procedure, public, PASS( obj ) :: Initiate => vtk_init interface This subroutine initiate the vtk object private subroutine vtk_init(obj, path, filename, extension, fmt, meshTopology, indx, nx1, nx2, ny1, ny2, nz1, nz2) This subroutine initate the vtk file object Arguments Type Intent Optional Attributes Name class( vtk_ ), intent(inout) :: obj vtk_ filename object character(len=*), intent(in) :: path path of the filename to be created character(len=*), intent(in) :: filename name of the file to be created character(len=*), intent(in) :: extension extension of the file .vtu character(len=*), intent(in) :: fmt storage format ascii, binary_append, binary character(len=*), intent(in) :: meshTopology mesh topology UnstructuredGrid integer(kind=I4B), intent(in) :: indx (:) its(1) = time-step its(2) = iteration number, if present integer(kind=I4B), intent(in), optional :: nx1 for structured grid only integer(kind=I4B), intent(in), optional :: nx2 for structured grid only integer(kind=I4B), intent(in), optional :: ny1 for structured grid only integer(kind=I4B), intent(in), optional :: ny2 for structured grid only integer(kind=I4B), intent(in), optional :: nz1 for structured grid only integer(kind=I4B), intent(in), optional :: nz2 for structured grid only generic, public :: WriteGeometry => vtk_write_mesh_data_1 , vtk_write_mesh_data_2 , vtk_write_mesh_data_3 private interface vtk_write_mesh_data_1 () This subroutine writes the mesh data information in the Arguments None private interface vtk_write_mesh_data_2 () This subroutine writes the mesh data information in the Arguments None private interface vtk_write_mesh_data_3 () This subroutine writes the mesh data information in the Arguments None generic, public :: WriteNodeData => vtk_write_node_data_1 , vtk_write_node_data_2 private interface vtk_write_node_data_1 () This subroutine writes the node data information in a vtk file format Arguments None private interface vtk_write_node_data_2 () This subroutine writes the node data information in a vtk file format Arguments None generic, public :: WriteQuadratureData => vtk_write_cell_data_1 , vtk_write_cell_data_2 private interface vtk_write_cell_data_1 () This subroutine writes the cell data information in a vtk file format Arguments None private interface vtk_write_cell_data_2 () This subroutine writes the cell data information in a vtk file format Arguments None procedure, public, PASS( Obj ) :: closeElementData => vtk_stop_write_elem_data interface private subroutine vtk_stop_write_elem_data(obj) Arguments Type Intent Optional Attributes Name class( vtk_ ), intent(inout) :: obj procedure, public, PASS( Obj ) :: closeNodeData => vtk_stop_write_node_data interface private subroutine vtk_stop_write_node_data(obj) Arguments Type Intent Optional Attributes Name class( vtk_ ), intent(inout) :: obj procedure, public, PASS( obj ) :: closePiece => vtk_stop_write_geo interface Should be called before vtk_ call private subroutine vtk_stop_write_geo(obj) This subroutine should be called after we are done writing the mesh\n information, point data and cell data. Read more… Arguments Type Intent Optional Attributes Name class( vtk_ ), intent(inout) :: obj procedure, public, PASS( Obj ) :: openElementData => vtk_start_write_elem_data interface private subroutine vtk_start_write_elem_data(obj) Arguments Type Intent Optional Attributes Name class( vtk_ ), intent(inout) :: obj procedure, public, PASS( Obj ) :: openNodeData => vtk_start_write_node_data interface private subroutine vtk_start_write_node_data(obj) Arguments Type Intent Optional Attributes Name class( vtk_ ), intent(inout) :: obj procedure, public, PASS( obj ) :: openPiece => vtk_start_write_geo interface Should be called before vtk_ call private subroutine vtk_start_write_geo(obj) This subroutine should be called before start writing the geometry\n in the <piece> tag Read more… Arguments Type Intent Optional Attributes Name class( vtk_ ), intent(inout) :: obj procedure, public, PASS( Obj ) :: vtk_write_cell_data_1 interface This subroutine writes the cell data information in a vtk file format private subroutine vtk_write_cell_data_1(obj, val, name) This subroutine writes the cell data (single scalars) into a vtk file Arguments Type Intent Optional Attributes Name class( vtk_ ), intent(inout) :: obj real(kind=DFP), intent(in) :: val (:) size(val) should be equal to totol number of cell character(len=*), intent(in) :: name procedure, public, PASS( Obj ) :: vtk_write_cell_data_2 interface This subroutine writes the cell data information in a vtk file format private subroutine vtk_write_cell_data_2(obj, val, name) This subroutine writes the cell data (single vector) into a vtk file Arguments Type Intent Optional Attributes Name class( vtk_ ), intent(inout) :: obj real(kind=DFP), intent(in) :: val (:,:) size(val,2) should be equal to totol number of cell\n size(val,1) number of components character(len=*), intent(in) :: name procedure, public, PASS( obj ) :: vtk_write_mesh_data_1 interface This subroutine writes the mesh data information in the private subroutine vtk_write_mesh_data_1(obj, meshobj, mdobj, nodes) This subroutine writes the information of the mesh in vtkfile\n In this interface use must provide the MeshData_ object. Read more… Arguments Type Intent Optional Attributes Name class( vtk_ ), intent(inout) :: obj vtk_ file class(Mesh_), intent(inout), TARGET :: meshobj Mesh_ instance class(MeshData_), intent(inout) :: mdobj MeshData_ instance real(kind=DFP), intent(in) :: nodes (:,:) Nodal coordinates in xij format procedure, public, PASS( obj ) :: vtk_write_mesh_data_2 interface This subroutine writes the mesh data information in the private subroutine vtk_write_mesh_data_2(obj, meshobj, nodes) This subroutine writes the information of the mesh in vtkfile\n This subroutine should be used carefully\n We advise you to avoide using this subroutine as much as possible Arguments Type Intent Optional Attributes Name class( vtk_ ), intent(inout) :: obj vtk_ file class(Mesh_), intent(inout), TARGET :: meshobj Mesh_ instance real(kind=DFP), intent(in) :: nodes (:,:) Nodal coordinates in xij format procedure, public, PASS( obj ) :: vtk_write_mesh_data_3 interface This subroutine writes the mesh data information in the private subroutine vtk_write_mesh_data_3(obj, meshobj, nodes, tag, local2global, map, lb, ub) This subroutine writes the information of the mesh in vtkfile\n In this interface use must provide the MeshData_ object. Read more… Arguments Type Intent Optional Attributes Name class( vtk_ ), intent(inout) :: obj vtk_ file class(MeshPointer_), intent(inout), TARGET :: meshobj (:) Mesh_ instance real(kind=DFP), intent(in) :: nodes (:,:) Nodal coordinates in xij format integer(kind=I4B), intent(in) :: tag (:) integer(kind=I4B), intent(in) :: local2global (:) integer(kind=I4B), intent(in) :: map (lb:ub) integer(kind=I4B), intent(in) :: lb integer(kind=I4B), intent(in) :: ub procedure, public, PASS( obj ) :: vtk_write_node_data_1 interface This subroutine writes the node data information in a vtk file format private subroutine vtk_write_node_data_1(obj, x, dofobj, name, prefix) This subroutine writes the nodal values of a variable x into vtk file Read more… Arguments Type Intent Optional Attributes Name class( vtk_ ), intent(inout) :: obj real(kind=DFP), intent(in) :: x (:) type(DOF_), intent(in) :: dofobj character(len=1), intent(in) :: name character(len=*), intent(in) :: prefix It is the name of a DOF present inside dofobj; we will find this name\n and write data corresponding to that physical name procedure, public, PASS( obj ) :: vtk_write_node_data_2 interface This subroutine writes the node data information in a vtk file format private subroutine vtk_write_node_data_2(obj, x, dofobj, prefix) This subroutine writes the nodal values of a variable x into vtk file Read more… Arguments Type Intent Optional Attributes Name class( vtk_ ), intent(inout) :: obj real(kind=DFP), intent(in) :: x (:) type(DOF_), intent(in) :: dofobj character(len=*), intent(in), optional :: prefix Source Code TYPE :: vtk_ TYPE ( vtk_file ) :: afile TYPE ( String ) :: path TYPE ( String ) :: filename TYPE ( String ) :: extension CHARACTER ( LEN = 10 ) :: fmt = \"ascii\" CHARACTER ( LEN = 10 ) :: meshTopology = \"UnstructuredGrid\" INTEGER ( I4B ) :: nx1 = 0 , nx2 = 0 , ny1 = 0 , ny2 = 0 , nz1 = 0 , nz2 = 0 LOGICAL ( LGT ) :: inPiece = . FALSE . CONTAINS PROCEDURE , PUBLIC , PASS ( obj ) :: Initiate => vtk_init PROCEDURE , PUBLIC , PASS ( obj ) :: Finalize => vtk_final PROCEDURE , PUBLIC , PASS ( obj ) :: openPiece => vtk_start_write_geo PROCEDURE , PUBLIC , PASS ( obj ) :: closePiece => vtk_stop_write_geo GENERIC , PUBLIC :: WriteGeometry => vtk_write_mesh_data_1 ,& & vtk_write_mesh_data_2 , vtk_write_mesh_data_3 PROCEDURE , PUBLIC , PASS ( obj ) :: vtk_write_mesh_data_1 PROCEDURE , PUBLIC , PASS ( obj ) :: vtk_write_mesh_data_2 PROCEDURE , PUBLIC , PASS ( obj ) :: vtk_write_mesh_data_3 PROCEDURE , PUBLIC , PASS ( Obj ) :: openNodeData & & => vtk_start_write_node_data PROCEDURE , PUBLIC , PASS ( Obj ) :: closeNodeData & & => vtk_stop_write_node_data GENERIC , PUBLIC :: WriteNodeData => & & vtk_write_node_data_1 , & & vtk_write_node_data_2 PROCEDURE , PUBLIC , PASS ( obj ) :: vtk_write_node_data_1 PROCEDURE , PUBLIC , PASS ( obj ) :: vtk_write_node_data_2 PROCEDURE , PUBLIC , PASS ( Obj ) :: openElementData & & => vtk_start_write_elem_data PROCEDURE , PUBLIC , PASS ( Obj ) :: closeElementData & & => vtk_stop_write_elem_data GENERIC , PUBLIC :: WriteQuadratureData => & & vtk_write_cell_data_1 , & & vtk_write_cell_data_2 PROCEDURE , PUBLIC , PASS ( Obj ) :: vtk_write_cell_data_1 , & & vtk_write_cell_data_2 END TYPE vtk_","tags":"","loc":"type/vtk_.html"},{"title":"QuadratureVariablesPointer_ – Fortran Program ","text":"type, public :: QuadratureVariablesPointer_ QuadratureVariablesPointer_ contains a pointer to QuadratureVariables_ Contents Variables Ptr Source Code QuadratureVariablesPointer_ Components Type Visibility Attributes Name Initial class( QuadratureVariables_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: QuadratureVariablesPointer_ CLASS ( QuadratureVariables_ ), POINTER :: Ptr => NULL ( ) END TYPE QuadratureVariablesPointer_","tags":"","loc":"type/quadraturevariablespointer_.html"},{"title":"QuadratureVariables_ – Fortran Program ","text":"type, public :: QuadratureVariables_ authors: Dr. Vikas Sharma QuadratureVariables_ class contains the variables and parameters defined\n in a collection of finite elements at quadrature points.\n - If all variables inside an element do not change then\n one can initiate the object with the ColID = ‘M’ which then indicates\n that material-parameters are stored\n - If one or all variables in elements chages then one must\n initiate the obhect with the ColID = ‘E’ which then indicates that\n element variables are stored Usage ```fortran\n    type( QuadratureVariables_ ) :: obj !initiate obj-----------\n                        |\n call obj % initiate( tprop = 3, tpoint = 1, telem=100, names=names )\n call obj %  setValue( ipoint, elemnum, Val, is, ie )\n Val = obj % Value( ColIndx = 1 )\n call deallocateData( Obj )\n ``` Note When colID = M then tPoint argument in initiate call will be ignored Contents Variables Names Val tpoint tprop Type-Bound Procedures AddContribution ArrayValues Finalize Initiate setValue Source Code QuadratureVariables_ Components Type Visibility Attributes Name Initial type(String), public, ALLOCATABLE :: Names (:) Names of variables stored; its length should be equal to\n tprops real(kind=DFP), public, ALLOCATABLE :: Val (:,:,:) This array contains the varialbe/parameter information Val( :, i ) denotes material properties or element variables integer(kind=I4B), public :: tpoint = 0 Total number of quadrature points inside an element integer(kind=I4B), public :: tprop = 0 Total number of properties defined at a quadrature points Type-Bound Procedures procedure, public, PASS( Obj ) :: AddContribution => elem_var_add_val Subroutine that Adds contribution to the existing values interface Subroutine that adds values in QuadratureVariables_ object private subroutine elem_var_add_val(Obj, ipoint, elemnum, Scale, Val, is, ie) This subroutine adds values of Obj % Val( :, ipoint, icol ) Arguments Type Intent Optional Attributes Name class( QuadratureVariables_ ), intent(inout) :: Obj Instance of QuadratureVariables_ integer(kind=I4B), intent(in) :: ipoint Quadrature point number integer(kind=I4B), intent(in) :: elemnum It represents id of element or material depending on storage type real(kind=DFP), intent(in) :: Scale Scaling used for Values real(kind=DFP), intent(in) :: Val (:) Values integer(kind=I4B), intent(in), optional :: is is starting index integer(kind=I4B), intent(in), optional :: ie ie ending index procedure, public, PASS( Obj ) :: ArrayValues => elem_var_get_value Subroutine that gets element variables interface Return values stored inside QuadratureVariables_ private pure function elem_var_get_value(Obj, elemnum) result(Ans) This subroutine returns Obj % Val(:,:,elemnum) Arguments Type Intent Optional Attributes Name class( QuadratureVariables_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: elemnum Element number or material number Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) procedure, public, PASS( Obj ) :: Finalize => elem_var_deallocate_data deallocate data interface Deallocat data stored inside QuadratureVariables_ object private subroutine elem_var_deallocate_data(Obj) Arguments Type Intent Optional Attributes Name class( QuadratureVariables_ ), intent(inout) :: Obj procedure, public, PASS( Obj ) :: Initiate => elem_var_initiate Subroutine that Initiates the object interface Subroutine that initiate QuadratureVariables_ object private subroutine elem_var_initiate(Obj, tprop, tpoint, telem, names) This subroutine initiates QuadratureVariables_ object\n - If colID=M then object stores material properties\n - In above case tpoint is not considered and set to 1 internally\n - If names are present then size( names ) == tprop - If names are not present then variables will be named as V1, V2,... Arguments Type Intent Optional Attributes Name class( QuadratureVariables_ ), intent(inout) :: Obj Instance integer(kind=I4B), intent(in) :: tprop Total number of properties integer(kind=I4B), intent(in) :: tpoint Total number of quadrature points integer(kind=I4B), intent(in) :: telem Total number of columns type(String), intent(in), optional :: names (:) Names of variables procedure, public, PASS( Obj ) :: setValue => elem_var_set_value Subroutine that Sets values/change values interface Subroutine that sets values in QuadratureVariables_ object private subroutine elem_var_set_value(Obj, ipoint, elemnum, Val, is, ie) This subroutine set values of Obj % Val( :, ipoint, icol ) - Obj % Val( i_s:i_e, ipoint, icol) = Val( : ) Arguments Type Intent Optional Attributes Name class( QuadratureVariables_ ), intent(inout) :: Obj Instance of QuadratureVariables_ integer(kind=I4B), intent(in) :: ipoint Quadrature point number integer(kind=I4B), intent(in) :: elemnum element number real(kind=DFP), intent(in) :: Val (:) Values integer(kind=I4B), intent(in), optional :: is is starting index integer(kind=I4B), intent(in), optional :: ie ie ending index Source Code TYPE :: QuadratureVariables_ INTEGER ( I4B ) :: tprop = 0 !! Total number of properties defined at a quadrature points INTEGER ( I4B ) :: tpoint = 0 !! Total number of quadrature points inside an element TYPE ( String ), ALLOCATABLE :: Names ( : ) !! Names of variables stored; its length should be equal to !! tprops REAL ( DFP ), ALLOCATABLE :: Val ( :, :, : ) !! This array contains the varialbe/parameter information !! `Val( :, i )` denotes material properties or element variables CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: Initiate => elem_var_initiate !! Subroutine that Initiates the object PROCEDURE , PUBLIC , PASS ( Obj ) :: Finalize => elem_var_deallocate_data !! deallocate data PROCEDURE , PUBLIC , PASS ( Obj ) :: setValue => elem_var_set_value !! Subroutine that Sets values/change values PROCEDURE , PUBLIC , PASS ( Obj ) :: AddContribution => elem_var_add_val !! Subroutine that Adds contribution to the existing values PROCEDURE , PUBLIC , PASS ( Obj ) :: ArrayValues => elem_var_get_value !! Subroutine that gets element variables END TYPE QuadratureVariables_","tags":"","loc":"type/quadraturevariables_.html"},{"title":"gmsh_ – Fortran Program ","text":"type, public :: gmsh_ This a data type for prepossing and post-processing in Gmsh Usage fortran\n    type( gmsh_ ) :: gmsh\n ierr = gmsh % initialize\n ierr = gmsh % open( filename )\n ierr = gmsh % merge( filename )\n ierr = gmsh % write( filename )\n ierr = gmsh % clear( filename )\n ierr = gmsh % finalize Contents Variables model nsd Type-Bound Procedures clear finalize initialize initiate merge open remesh write Source Code gmsh_ Components Type Visibility Attributes Name Initial type(gmshModel_), public, POINTER :: model => NULL() integer(kind=I4B), public :: nsd = 0 Type-Bound Procedures procedure, public, PASS( Obj ) :: clear => gmsh_clear Clear the content private function gmsh_clear (Obj) result(Ans) This function will clear all model and option and create an blank model Arguments Type Intent Optional Attributes Name class( gmsh_ ), intent(inout) :: Obj Return Value integer(kind=I4B) procedure, public, PASS( Obj ) :: finalize => gmsh_final Closes the gmsh engine private function gmsh_final (Obj) result(Ans) This function will stop the gmsh engine Read more… Arguments Type Intent Optional Attributes Name class( gmsh_ ), intent(inout) :: Obj Return Value integer(kind=I4B) procedure, public, PASS( Obj ) :: initialize => gmsh_init Initialize the gmsh engine private function gmsh_init (Obj, NSD) result(Ans) This function will start the gmsh engine\n It allocates obj % model Read more… Arguments Type Intent Optional Attributes Name class( gmsh_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: NSD Return Value integer(kind=I4B) procedure, public, PASS( Obj ) :: initiate => gmsh_init Initialize the gmsh engine private function gmsh_init (Obj, NSD) result(Ans) This function will start the gmsh engine\n It allocates obj % model Read more… Arguments Type Intent Optional Attributes Name class( gmsh_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: NSD Return Value integer(kind=I4B) procedure, public, PASS( Obj ) :: merge => gmsh_merge private function gmsh_merge (Obj, P, F, E) result(Ans) This function will open a file and read its content\n Based upon the extension of the file it can take different actions\n IF the file represents a model file then it will merge the content to the\n current model Arguments Type Intent Optional Attributes Name class( gmsh_ ), intent(inout) :: Obj character(len=*), intent(in) :: P Path of file character(len=*), intent(in) :: F File name character(len=*), intent(in) :: E Extension Return Value integer(kind=I4B) procedure, public, PASS( Obj ) :: open => gmsh_open open file to load private function gmsh_open (Obj, P, F, E) result(Ans) This function will open a file and read its content\n Based upon the extension of the file it can take different actions\n If file represents a model file then a new model will be created Arguments Type Intent Optional Attributes Name class( gmsh_ ), intent(inout) :: Obj character(len=*), intent(in) :: P Path of file character(len=*), intent(in) :: F File name character(len=*), intent(in) :: E Extension Return Value integer(kind=I4B) procedure, public, PASS( Obj ) :: remesh => gmsh_from_gmsh generate new gmsh file interface This function generate a gmsh model from the mesh data stored inside private function gmsh_from_gmsh(Obj, gmsh, Nodes) result(Ans) This function generates a gmsh model by reading mesh data stored inside gmsh_ object. Arguments Type Intent Optional Attributes Name class( gmsh_ ), intent(inout), TARGET :: Obj Old gmsh class( gmsh_ ), intent(inout), TARGET :: gmsh new gmsh real(kind=DFP), intent(in) :: Nodes (:,:) nodes Return Value integer(kind=I4B) procedure, public, PASS( Obj ) :: write => gmsh_write Write content in a file private function gmsh_write (Obj, P, F, E) result(Ans) This function will write the data in a file depending upon the extension\n of the file Arguments Type Intent Optional Attributes Name class( gmsh_ ), intent(inout) :: Obj character(len=*), intent(in) :: P Path of file character(len=*), intent(in) :: F File name character(len=*), intent(in) :: E Extension Return Value integer(kind=I4B) Source Code TYPE :: gmsh_ TYPE ( gmshModel_ ), POINTER :: model => NULL ( ) INTEGER ( I4B ) :: nsd = 0 CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: initialize => gmsh_init !! Initialize the gmsh engine PROCEDURE , PUBLIC , PASS ( Obj ) :: initiate => gmsh_init !! Initialize the gmsh engine PROCEDURE , PUBLIC , PASS ( Obj ) :: finalize => gmsh_final !! Closes the gmsh engine PROCEDURE , PUBLIC , PASS ( Obj ) :: open => gmsh_open !! open file to load PROCEDURE , PUBLIC , PASS ( Obj ) :: merge => gmsh_merge PROCEDURE , PUBLIC , PASS ( Obj ) :: write => gmsh_write !! Write content in a file PROCEDURE , PUBLIC , PASS ( Obj ) :: clear => gmsh_clear !! Clear the content PROCEDURE , PUBLIC , PASS ( Obj ) :: remesh => gmsh_from_gmsh !! generate new gmsh file END TYPE gmsh_","tags":"","loc":"type/gmsh_.html"},{"title":"gmshMeshPointer_ – Fortran Program ","text":"type, public :: gmshMeshPointer_ Contents Variables Ptr Source Code gmshMeshPointer_ Components Type Visibility Attributes Name Initial class( gmshMesh_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: gmshMeshPointer_ CLASS ( gmshMesh_ ), POINTER :: Ptr => NULL () END TYPE gmshMeshPointer_","tags":"","loc":"type/gmshmeshpointer_.html"},{"title":"gmshMesh_ – Fortran Program ","text":"type, public :: gmshMesh_ This class handles the mesh generation by gmsh\n This class can generate the mesh and reads the mesh file Contents Variables CurveEntities Elements Format Nodes PhysicalNames PointEntities SurfaceEntities VolumeEntities buffer mshFile nsd Type-Bound Procedures Finalize Initiate TotalElements TotalNodes WriteMesh WriteNodeData dom_init_from_gmshMesh generate getElements getNodes gmsh_mesh_getelements_1 gmsh_mesh_getelements_2 gmsh_mesh_getelements_2c gmsh_mesh_getelements_3 gmsh_mesh_getelements_3c gmsh_mesh_getelements_4 gmsh_mesh_getelements_4c gmsh_mesh_getnodes_array gmsh_mesh_getnodes_file gmsh_mesh_telements_1 gmsh_mesh_telements_2 gmsh_mesh_telements_3 gmsh_mesh_write_nodedata_1 gmsh_mesh_write_nodedata_2 write Source Code gmshMesh_ Components Type Visibility Attributes Name Initial type(mshEntity_), public, ALLOCATABLE :: CurveEntities (:) curve entities type(mshElements_), public :: Elements elements type(mshFormat_), public :: Format mesh format type(mshNodes_), public :: Nodes nodes type(mshPhysicalNames_), public :: PhysicalNames mesh physical groups type(mshEntity_), public, ALLOCATABLE :: PointEntities (:) point entities type(mshEntity_), public, ALLOCATABLE :: SurfaceEntities (:) surface entities type(mshEntity_), public, ALLOCATABLE :: VolumeEntities (:) volume entities type(Buffer_), public, POINTER :: buffer => NULL() buffer to recoord coommands type(File_), public :: mshFile mesh file integer(kind=I4B), public :: nsd = 0 Spatial dimension Type-Bound Procedures procedure, public, PASS( Obj ) :: Finalize => gmsh_mesh_deallocatedata deallocate the data interface This will deallocate data private subroutine gmsh_mesh_deallocatedata(obj) This subroutine deallocate data Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(inout) :: obj procedure, public, PASS( Obj ) :: Initiate => gmsh_mesh_initiate initiate the object interface This subroutine generates the gmshMesh_ object private subroutine gmsh_mesh_initiate(obj, Path, FileName, Extension, NSD) This subroutine reads the .msh file and creates the object Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(inout) :: obj character(len=*), intent(in) :: Path character(len=*), intent(in) :: FileName character(len=*), intent(in) :: Extension integer(kind=I4B), intent(in) :: NSD generic, public :: TotalElements => gmsh_mesh_telements_1 , gmsh_mesh_telements_2 , gmsh_mesh_telements_3 private interface gmsh_mesh_telements_1 () This function returns the total element in the mesh Arguments None private interface gmsh_mesh_telements_2 () This function returns the total element in the mesh Arguments None private interface gmsh_mesh_telements_3 () This function returns the total element in the mesh Arguments None procedure, public, PASS( Obj ) :: TotalNodes => gmsh_mesh_totalnodes returns total nodes in mesh interface This function will return the total number of nodes in mesh private pure function gmsh_mesh_totalnodes(obj) result(Ans) This function will return the total number of nodes in mesh Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: obj Return Value integer(kind=I4B) procedure, public, PASS( Obj ) :: WriteMesh => gmsh_mesh_write_mesh interface private subroutine gmsh_mesh_write_mesh(obj, Path, FileName, Extension, Nodes) Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: obj character(len=*), intent(in) :: Path character(len=*), intent(in) :: FileName character(len=*), intent(in) :: Extension real(kind=DFP), intent(in) :: Nodes (:,:) generic, public :: WriteNodeData => gmsh_mesh_write_nodedata_1 , gmsh_mesh_write_nodedata_2 private interface gmsh_mesh_write_nodedata_1 () This subroutine writes the node data information in a msh file format Arguments None private interface gmsh_mesh_write_nodedata_2 () This subroutine writes the node data information in a gmshMesh file format Arguments None procedure, public, PASS( mshobj ) :: dom_init_from_gmshMesh interface This subroutine initiate Domain_ by reading gmshMesh file private subroutine dom_init_from_gmshMesh(mshobj, obj, facetmesh) This subroutine initiate Domain_ by reading gmshMesh file\n This is a high level routine Read more… Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: mshobj class(Domain_), intent(inout) :: obj type(String), intent(in), optional :: facetmesh (:,:) procedure, public, PASS( Obj ) :: generate => mesh_generate interface This will add mesh generation command to .geo file private function mesh_generate(Obj, dim) result(Ans) This will add mesh generation command to .geo file Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: dim Return Value integer(kind=I4B) generic, public :: getElements => gmsh_mesh_getelements_1 , gmsh_mesh_getelements_2 , gmsh_mesh_getelements_2c , gmsh_mesh_getelements_3 , gmsh_mesh_getelements_3c , gmsh_mesh_getelements_4 , gmsh_mesh_getelements_4c , dom_init_from_gmshMesh private interface gmsh_mesh_getelements_1 () This subroutine returns a mesh of elements; Arguments None private interface gmsh_mesh_getelements_2 () This subroutine builds a mesh of elements with same co-dimensions Arguments None private interface gmsh_mesh_getelements_2c () This subroutine build a Mesh_ in Domain_ by using gmshMesh_ Arguments None private interface gmsh_mesh_getelements_3 () This subroutine returns the mesh of elements Arguments None private interface gmsh_mesh_getelements_3c () This subroutine build a Mesh_ in Domain_ by using gmshMesh_ Arguments None private interface gmsh_mesh_getelements_4 () This subroutine returns the mesh of elements Arguments None private interface gmsh_mesh_getelements_4c () This subroutine build a Mesh_ in Domain_ by using gmshMesh_ Arguments None private interface dom_init_from_gmshMesh () This subroutine initiate Domain_ by reading gmshMesh file Arguments None generic, public :: getNodes => gmsh_mesh_getnodes_array , gmsh_mesh_getnodes_file private interface gmsh_mesh_getnodes_array () This subroutine retunr the nodal coordinates Arguments None private interface gmsh_mesh_getnodes_file () This subroutine retunr the nodal coordinates Arguments None procedure, public, PASS( Obj ) :: gmsh_mesh_getelements_1 return finite element mesh interface This subroutine returns a mesh of elements; private subroutine gmsh_mesh_getelements_1(obj, MeshObj, FEObj) This subroutine returns a single Mesh_ object containing all elements Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: obj class(Mesh_), intent(inout), TARGET :: MeshObj class(Element_), intent(in) :: FEObj procedure, public, PASS( Obj ) :: gmsh_mesh_getelements_2 interface This subroutine builds a mesh of elements with same co-dimensions private subroutine gmsh_mesh_getelements_2(obj, MeshObj, XiDim, FEObj, Offset) This subroutine builds a mesh of elements with same co-dimensions Read more… Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: obj class(Mesh_), intent(inout), TARGET :: MeshObj integer(kind=I4B), intent(in) :: XiDim class(Element_), intent(in) :: FEObj integer(kind=I4B), intent(in), optional :: Offset procedure, public, PASS( Obj ) :: gmsh_mesh_getelements_2c interface This subroutine build a Mesh_ in Domain_ by using gmshMesh_ private subroutine gmsh_mesh_getelements_2c(Obj, Dom, indx, XiDim, FEObj, Offset) This subroutine builds a mesh of elements with same co-dimensions Read more… Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: Obj class(Domain_), intent(inout), TARGET :: Dom integer(kind=I4B), intent(in) :: indx integer(kind=I4B), intent(in) :: XiDim class(Element_), intent(in) :: FEObj integer(kind=I4B), intent(in), optional :: Offset procedure, public, PASS( Obj ) :: gmsh_mesh_getelements_3 interface This subroutine returns the mesh of elements private subroutine gmsh_mesh_getelements_3(obj, MeshObj, XiDim, Tag, FEObj, Offset) This subroutine returns the mesh of elements; it applies two levels of\n filter Read more… Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: obj class(Mesh_), intent(inout), TARGET :: MeshObj integer(kind=I4B), intent(in) :: XiDim integer(kind=I4B), intent(in) :: Tag (:) class(Element_), intent(in) :: FEObj integer(kind=I4B), intent(in), optional :: Offset procedure, public, PASS( Obj ) :: gmsh_mesh_getelements_3c interface This subroutine build a Mesh_ in Domain_ by using gmshMesh_ private subroutine gmsh_mesh_getelements_3c(Obj, Dom, Indx, XiDim, Tag, FEObj, Offset) This subroutine returns the mesh of elements; it applies two levels of\n filter Read more… Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: Obj class(Domain_), intent(inout), TARGET :: Dom integer(kind=I4B), intent(in) :: Indx integer(kind=I4B), intent(in) :: XiDim integer(kind=I4B), intent(in) :: Tag (:) class(Element_), intent(in) :: FEObj integer(kind=I4B), intent(in), optional :: Offset procedure, public, PASS( Obj ) :: gmsh_mesh_getelements_4 interface This subroutine returns the mesh of elements private subroutine gmsh_mesh_getelements_4(obj, MeshObj, XiDim, TagNames, FEObj, Offset) This subroutine returns the mesh of elements; it applies two levels of\n filter Read more… Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: obj class(Mesh_), intent(inout), TARGET :: MeshObj integer(kind=I4B), intent(in) :: XiDim type(String), intent(in) :: TagNames (:) class(Element_), intent(in) :: FEObj integer(kind=I4B), intent(in), optional :: Offset procedure, public, PASS( Obj ) :: gmsh_mesh_getelements_4c interface This subroutine build a Mesh_ in Domain_ by using gmshMesh_ private subroutine gmsh_mesh_getelements_4c(Obj, Dom, Indx, XiDim, TagNames, FEObj, Offset) This subroutine returns the mesh of elements; it applies two levels of\n filter Read more… Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: Obj class(Domain_), intent(inout), TARGET :: Dom integer(kind=I4B), intent(in) :: Indx integer(kind=I4B), intent(in) :: XiDim type(String), intent(in) :: TagNames (:) class(Element_), intent(in) :: FEObj integer(kind=I4B), intent(in), optional :: Offset procedure, private, PASS( Obj ) :: gmsh_mesh_getnodes_array returns nodes in an array interface This subroutine retunr the nodal coordinates private subroutine gmsh_mesh_getnodes_array(obj, Nodes) This subroutine returns the nodal coordinates Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: obj real(kind=DFP), intent(inout), ALLOCATABLE :: Nodes (:,:) procedure, private, PASS( Obj ) :: gmsh_mesh_getnodes_file writes notes to a file interface This subroutine retunr the nodal coordinates private subroutine gmsh_mesh_getnodes_file(obj, UnitNo, Str, EndStr) This subroutine returns the nodal coordinates Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: obj integer(kind=I4B), intent(in), optional :: UnitNo character(len=*), intent(in), optional :: Str character(len=*), intent(in), optional :: EndStr procedure, private, PASS( Obj ) :: gmsh_mesh_telements_1 returns total elements in mesh interface This function returns the total element in the mesh private pure function gmsh_mesh_telements_1(obj) result(Ans) This function returns the total element in the mesh Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: obj Return Value integer(kind=I4B) procedure, private, PASS( Obj ) :: gmsh_mesh_telements_2 returns total elements in mesh interface This function returns the total element in the mesh private pure function gmsh_mesh_telements_2(obj, XiDim) result(Ans) This function returns the total element in the mesh\n Xidim is a codimension based filter\n Xidim=0 => Point\n Xidim=1 => Curve\n Xidim=2 => Surface\n Xidim=3 => Volume Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: obj integer(kind=I4B), intent(in) :: XiDim Return Value integer(kind=I4B) procedure, private, PASS( Obj ) :: gmsh_mesh_telements_3 returns total elements in mesh interface This function returns the total element in the mesh private pure function gmsh_mesh_telements_3(obj, XiDim, Tag) result(Ans) This function returns the total element in the mesh\n We can filter elements based on Xidim and tag Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: obj integer(kind=I4B), intent(in) :: XiDim integer(kind=I4B), intent(in) :: Tag (:) Return Value integer(kind=I4B) procedure, public, PASS( Obj ) :: gmsh_mesh_write_nodedata_1 interface This subroutine writes the node data information in a msh file format private subroutine gmsh_mesh_write_nodedata_1(obj, x, dofobj, name, indx, local_nptrs, nodes) This subroutine writes the nodal values of a variable x into msh file Read more… Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: obj real(kind=DFP), intent(in) :: x (:) type(DOF_), intent(in) :: dofobj character(len=1), intent(in) :: name integer(kind=I4B), intent(in) :: indx (:) integer(kind=I4B), intent(in) :: local_nptrs (:) real(kind=DFP), intent(in), optional :: nodes (:,:) procedure, public, PASS( Obj ) :: gmsh_mesh_write_nodedata_2 interface This subroutine writes the node data information in a gmshMesh file format private subroutine gmsh_mesh_write_nodedata_2(obj, x, dofobj, indx, local_nptrs, nodes) This subroutine writes the nodal values of a variable x into gmshMesh file Read more… Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: obj real(kind=DFP), intent(in) :: x (:) type(DOF_), intent(in) :: dofobj integer(kind=I4B), intent(in) :: indx (:) integer(kind=I4B), intent(in) :: local_nptrs (:) real(kind=DFP), intent(in), optional :: nodes (:,:) procedure, public, PASS( Obj ) :: write => mesh_write interface This function will dump the buffer content in to a file private function mesh_write(Obj, UnitNo) result(Ans) This function will dump the buffer content in to a file Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: UnitNo Return Value integer(kind=I4B) Source Code TYPE :: gmshMesh_ TYPE ( Buffer_ ), POINTER :: buffer => NULL ( ) !! buffer to recoord coommands INTEGER ( I4B ) :: nsd = 0 !! Spatial dimension TYPE ( File_ ) :: mshFile !! mesh file TYPE ( mshFormat_ ) :: Format !! mesh format TYPE ( mshPhysicalNames_ ) :: PhysicalNames !! mesh physical groups TYPE ( mshEntity_ ), ALLOCATABLE :: PointEntities ( : ) !! point entities TYPE ( mshEntity_ ), ALLOCATABLE :: CurveEntities ( : ) !! curve entities TYPE ( mshEntity_ ), ALLOCATABLE :: SurfaceEntities ( : ) !! surface entities TYPE ( mshEntity_ ), ALLOCATABLE :: VolumeEntities ( : ) !! volume entities TYPE ( mshNodes_ ) :: Nodes !! nodes TYPE ( mshElements_ ) :: Elements !! elements CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: generate => mesh_generate PROCEDURE , PUBLIC , PASS ( Obj ) :: write => mesh_write PROCEDURE , PUBLIC , PASS ( Obj ) :: Finalize => gmsh_mesh_deallocateData !! deallocate the data PROCEDURE , PUBLIC , PASS ( Obj ) :: Initiate => gmsh_mesh_initiate !! initiate the object PROCEDURE , PUBLIC , PASS ( Obj ) :: TotalNodes => gmsh_mesh_totalnodes !! returns total nodes in mesh GENERIC , PUBLIC :: getNodes => gmsh_mesh_getnodes_array , & & gmsh_mesh_getnodes_file PROCEDURE , PRIVATE , PASS ( Obj ) :: gmsh_mesh_getnodes_array !! returns nodes in an array PROCEDURE , PRIVATE , PASS ( Obj ) :: gmsh_mesh_getnodes_file !! writes notes to a file GENERIC , PUBLIC :: TotalElements => gmsh_mesh_telements_1 , & & gmsh_mesh_telements_2 , & & gmsh_mesh_telements_3 PROCEDURE , PRIVATE , PASS ( Obj ) :: gmsh_mesh_telements_1 !! returns total elements in mesh PROCEDURE , PRIVATE , PASS ( Obj ) :: gmsh_mesh_telements_2 !! returns total elements in mesh PROCEDURE , PRIVATE , PASS ( Obj ) :: gmsh_mesh_telements_3 !! returns total elements in mesh GENERIC , PUBLIC :: getElements => & & gmsh_mesh_getelements_1 , & & gmsh_mesh_getelements_2 , & & gmsh_mesh_getelements_2c , & & gmsh_mesh_getelements_3 , & & gmsh_mesh_getelements_3c , & & gmsh_mesh_getelements_4 , & & gmsh_mesh_getelements_4c , & & dom_init_from_gmshMesh PROCEDURE , PUBLIC , PASS ( Obj ) :: gmsh_mesh_getelements_1 !! return finite element mesh PROCEDURE , PUBLIC , PASS ( Obj ) :: gmsh_mesh_getelements_2 PROCEDURE , PUBLIC , PASS ( Obj ) :: gmsh_mesh_getelements_2c PROCEDURE , PUBLIC , PASS ( Obj ) :: gmsh_mesh_getelements_3 PROCEDURE , PUBLIC , PASS ( Obj ) :: gmsh_mesh_getelements_3c PROCEDURE , PUBLIC , PASS ( Obj ) :: gmsh_mesh_getelements_4 PROCEDURE , PUBLIC , PASS ( Obj ) :: gmsh_mesh_getelements_4c PROCEDURE , PUBLIC , PASS ( mshobj ) :: dom_init_from_gmshMesh PROCEDURE , PUBLIC , PASS ( Obj ) :: WriteMesh => gmsh_mesh_write_mesh GENERIC , PUBLIC :: WriteNodeData => & & gmsh_mesh_write_nodedata_1 , & & gmsh_mesh_write_nodedata_2 PROCEDURE , PUBLIC , PASS ( Obj ) :: gmsh_mesh_write_nodedata_1 PROCEDURE , PUBLIC , PASS ( Obj ) :: gmsh_mesh_write_nodedata_2 END TYPE gmshMesh_","tags":"","loc":"type/gmshmesh_.html"},{"title":"gmshBSplinePointer_ – Fortran Program ","text":"type, public :: gmshBSplinePointer_ Contents Variables Ptr Source Code gmshBSplinePointer_ Components Type Visibility Attributes Name Initial class( gmshBSpline_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: gmshBSplinePointer_ CLASS ( gmshBSpline_ ), POINTER :: Ptr => NULL ( ) END TYPE gmshBSplinePointer_","tags":"","loc":"type/gmshbsplinepointer_.html"},{"title":"gmshBSpline_ – Fortran Program ","text":"type, public, EXTENDS( gmshCurve_ ) :: gmshBSpline_ Contents Variables pointTags Type-Bound Procedures encodedStr Source Code gmshBSpline_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public, ALLOCATABLE :: pointTags (:) Type-Bound Procedures procedure, public, PASS( Obj ) :: encodedStr => BSpline_encode private function BSpline_encode (obj) result(ans) Arguments Type Intent Optional Attributes Name class( gmshBSpline_ ), intent(in) :: obj Return Value type(String) Source Code TYPE , EXTENDS ( gmshCurve_ ) :: gmshBSpline_ INTEGER ( I4B ), ALLOCATABLE :: pointTags ( : ) CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: encodedStr => BSpline_encode END TYPE gmshBSpline_","tags":"","loc":"type/gmshbspline_.html"},{"title":"gmshBezierPointer_ – Fortran Program ","text":"type, public :: gmshBezierPointer_ Contents Variables Ptr Source Code gmshBezierPointer_ Components Type Visibility Attributes Name Initial class( gmshBezier_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: gmshBezierPointer_ CLASS ( gmshBezier_ ), POINTER :: Ptr => NULL ( ) END TYPE gmshBezierPointer_","tags":"","loc":"type/gmshbezierpointer_.html"},{"title":"gmshBezier_ – Fortran Program ","text":"type, public, EXTENDS( gmshCurve_ ) :: gmshBezier_ Contents Variables pointTags Type-Bound Procedures encodedStr Source Code gmshBezier_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public, ALLOCATABLE :: pointTags (:) Type-Bound Procedures procedure, public, PASS( Obj ) :: encodedStr => Bezier_encode private function Bezier_encode (obj) result(ans) Arguments Type Intent Optional Attributes Name class( gmshBezier_ ), intent(in) :: obj Return Value type(String) Source Code TYPE , EXTENDS ( gmshCurve_ ) :: gmshBezier_ INTEGER ( I4B ), ALLOCATABLE :: pointTags ( : ) CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: encodedStr => Bezier_encode END TYPE gmshBezier_","tags":"","loc":"type/gmshbezier_.html"},{"title":"gmshCirclePointer_ – Fortran Program ","text":"type, public :: gmshCirclePointer_ Contents Variables Ptr Source Code gmshCirclePointer_ Components Type Visibility Attributes Name Initial class( gmshCircle_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: gmshCirclePointer_ CLASS ( gmshCircle_ ), POINTER :: Ptr => NULL ( ) END TYPE gmshCirclePointer_","tags":"","loc":"type/gmshcirclepointer_.html"},{"title":"gmshCircle_ – Fortran Program ","text":"type, public, EXTENDS( gmshCurve_ ) :: gmshCircle_ Contents Variables centerTag endTag nx ny nz startTag Type-Bound Procedures encodedStr Source Code gmshCircle_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: centerTag integer(kind=I4B), public :: endTag real(kind=DFP), public :: nx real(kind=DFP), public :: ny real(kind=DFP), public :: nz integer(kind=I4B), public :: startTag Type-Bound Procedures procedure, public, PASS( Obj ) :: encodedStr => Circle_encode private function Circle_encode (obj) result(ans) Arguments Type Intent Optional Attributes Name class( gmshCircle_ ), intent(in) :: obj Return Value type(String) Source Code TYPE , EXTENDS ( gmshCurve_ ) :: gmshCircle_ INTEGER ( I4B ) :: startTag , endTag , centerTag REAL ( DFP ) :: nx , ny , nz CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: encodedStr => circle_encode END TYPE gmshCircle_","tags":"","loc":"type/gmshcircle_.html"},{"title":"gmshCompoundBSplinePointer_ – Fortran Program ","text":"type, public :: gmshCompoundBSplinePointer_ Contents Variables Ptr Source Code gmshCompoundBSplinePointer_ Components Type Visibility Attributes Name Initial class( gmshCompoundBSpline_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: gmshCompoundBSplinePointer_ CLASS ( gmshCompoundBSpline_ ), POINTER :: Ptr => NULL ( ) END TYPE gmshCompoundBSplinePointer_","tags":"","loc":"type/gmshcompoundbsplinepointer_.html"},{"title":"gmshCompoundBSpline_ – Fortran Program ","text":"type, public, EXTENDS( gmshCurve_ ) :: gmshCompoundBSpline_ Contents Variables curveTags numIntervals Type-Bound Procedures encodedStr Source Code gmshCompoundBSpline_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public, ALLOCATABLE :: curveTags (:) integer(kind=I4B), public :: numIntervals Type-Bound Procedures procedure, public, PASS( Obj ) :: encodedStr => CompoundBSpline_encode private function CompoundBSpline_encode (obj) result(ans) Arguments Type Intent Optional Attributes Name class( gmshCompoundBSpline_ ), intent(in) :: obj Return Value type(String) Source Code TYPE , EXTENDS ( gmshCurve_ ) :: gmshCompoundBSpline_ INTEGER ( I4B ), ALLOCATABLE :: curveTags ( : ) INTEGER ( I4B ) :: numIntervals CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: encodedStr => CompoundBSpline_encode END TYPE gmshCompoundBSpline_","tags":"","loc":"type/gmshcompoundbspline_.html"},{"title":"gmshCompoundSplinePointer_ – Fortran Program ","text":"type, public :: gmshCompoundSplinePointer_ Contents Variables Ptr Source Code gmshCompoundSplinePointer_ Components Type Visibility Attributes Name Initial class( gmshCompoundSpline_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: gmshCompoundSplinePointer_ CLASS ( gmshCompoundSpline_ ), POINTER :: Ptr => NULL ( ) END TYPE gmshCompoundSplinePointer_","tags":"","loc":"type/gmshcompoundsplinepointer_.html"},{"title":"gmshCompoundSpline_ – Fortran Program ","text":"type, public, EXTENDS( gmshCurve_ ) :: gmshCompoundSpline_ Contents Variables curveTags numIntervals Type-Bound Procedures encodedStr Source Code gmshCompoundSpline_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public, ALLOCATABLE :: curveTags (:) integer(kind=I4B), public :: numIntervals Type-Bound Procedures procedure, public, PASS( Obj ) :: encodedStr => CompoundSpline_encode private function CompoundSpline_encode (obj) result(ans) Arguments Type Intent Optional Attributes Name class( gmshCompoundSpline_ ), intent(in) :: obj Return Value type(String) Source Code TYPE , EXTENDS ( gmshCurve_ ) :: gmshCompoundSpline_ INTEGER ( I4B ), ALLOCATABLE :: curveTags ( : ) INTEGER ( I4B ) :: numIntervals CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: encodedStr => CompoundSpline_encode END TYPE gmshCompoundSpline_","tags":"","loc":"type/gmshcompoundspline_.html"},{"title":"gmshCurveLoopPointer_ – Fortran Program ","text":"type, public :: gmshCurveLoopPointer_ Contents Variables Ptr Source Code gmshCurveLoopPointer_ Components Type Visibility Attributes Name Initial class( gmshCurveLoop_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: gmshCurveLoopPointer_ CLASS ( gmshCurveLoop_ ), POINTER :: Ptr => NULL ( ) END TYPE gmshCurveLoopPointer_","tags":"","loc":"type/gmshcurvelooppointer_.html"},{"title":"gmshCurveLoop_ – Fortran Program ","text":"type, public, EXTENDS( gmshCurve_ ) :: gmshCurveLoop_ Contents Variables curveTags Type-Bound Procedures encodedStr Source Code gmshCurveLoop_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public, ALLOCATABLE :: curveTags (:) Type-Bound Procedures procedure, public, PASS( Obj ) :: encodedStr => CurveLoop_encode private function CurveLoop_encode (obj) result(ans) Arguments Type Intent Optional Attributes Name class( gmshCurveLoop_ ), intent(in) :: obj Return Value type(String) Source Code TYPE , EXTENDS ( gmshCurve_ ) :: gmshCurveLoop_ INTEGER ( I4B ), ALLOCATABLE :: curveTags ( : ) CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: encodedStr => CurveLoop_encode END TYPE gmshCurveLoop_","tags":"","loc":"type/gmshcurveloop_.html"},{"title":"gmshCurvePointer_ – Fortran Program ","text":"type, public :: gmshCurvePointer_ Contents Variables Ptr Source Code gmshCurvePointer_ Components Type Visibility Attributes Name Initial class( gmshCurve_ ), public, POINTER :: Ptr => Null() Source Code TYPE :: gmshCurvePointer_ CLASS ( gmshCurve_ ), POINTER :: Ptr => Null ( ) END TYPE gmshCurvePointer_","tags":"","loc":"type/gmshcurvepointer_.html"},{"title":"gmshCurve_ – Fortran Program ","text":"type, public, ABSTRACT, EXTENDS( gmshEntity_ ) :: gmshCurve_ Contents Source Code gmshCurve_ Source Code TYPE , ABSTRACT , EXTENDS ( gmshEntity_ ) :: gmshCurve_ END TYPE gmshCurve_","tags":"","loc":"type/gmshcurve_.html"},{"title":"gmshEllipsePointer_ – Fortran Program ","text":"type, public :: gmshEllipsePointer_ Contents Variables Ptr Source Code gmshEllipsePointer_ Components Type Visibility Attributes Name Initial class( gmshEllipse_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: gmshEllipsePointer_ CLASS ( gmshEllipse_ ), POINTER :: Ptr => NULL ( ) END TYPE gmshEllipsePointer_","tags":"","loc":"type/gmshellipsepointer_.html"},{"title":"gmshEllipse_ – Fortran Program ","text":"type, public, EXTENDS( gmshCurve_ ) :: gmshEllipse_ Contents Variables centerTag endTag majorTag nx ny nz startTag Type-Bound Procedures encodedStr Source Code gmshEllipse_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: centerTag integer(kind=I4B), public :: endTag integer(kind=I4B), public :: majorTag real(kind=DFP), public :: nx real(kind=DFP), public :: ny real(kind=DFP), public :: nz integer(kind=I4B), public :: startTag Type-Bound Procedures procedure, public, PASS( Obj ) :: encodedStr => Ellipse_encode private function Ellipse_encode (obj) result(ans) Arguments Type Intent Optional Attributes Name class( gmshEllipse_ ), intent(in) :: obj Return Value type(String) Source Code TYPE , EXTENDS ( gmshCurve_ ) :: gmshEllipse_ INTEGER ( I4B ) :: startTag , endTag , majorTag , centerTag REAL ( DFP ) :: nx , ny , nz CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: encodedStr => Ellipse_encode END TYPE gmshEllipse_","tags":"","loc":"type/gmshellipse_.html"},{"title":"gmshLinePointer_ – Fortran Program ","text":"type, public :: gmshLinePointer_ Contents Variables Ptr Source Code gmshLinePointer_ Components Type Visibility Attributes Name Initial class( gmshLine_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: gmshLinePointer_ CLASS ( gmshLine_ ), POINTER :: Ptr => NULL ( ) END TYPE gmshLinePointer_","tags":"","loc":"type/gmshlinepointer_.html"},{"title":"gmshLine_ – Fortran Program ","text":"type, public, EXTENDS( gmshCurve_ ) :: gmshLine_ Contents Variables endTag startTag Type-Bound Procedures encodedStr Source Code gmshLine_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: endTag integer(kind=I4B), public :: startTag Type-Bound Procedures procedure, public, PASS( Obj ) :: encodedStr => line_encode private function line_encode (obj) result(ans) Arguments Type Intent Optional Attributes Name class( gmshLine_ ), intent(in) :: obj Return Value type(String) Source Code TYPE , EXTENDS ( gmshCurve_ ) :: gmshLine_ INTEGER ( I4B ) :: startTag , endTag CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: encodedStr => line_encode END TYPE gmshLine_","tags":"","loc":"type/gmshline_.html"},{"title":"gmshSplinePointer_ – Fortran Program ","text":"type, public :: gmshSplinePointer_ Contents Variables Ptr Source Code gmshSplinePointer_ Components Type Visibility Attributes Name Initial class( gmshSpline_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: gmshSplinePointer_ CLASS ( gmshSpline_ ), POINTER :: Ptr => NULL ( ) END TYPE gmshSplinePointer_","tags":"","loc":"type/gmshsplinepointer_.html"},{"title":"gmshSpline_ – Fortran Program ","text":"type, public, EXTENDS( gmshCurve_ ) :: gmshSpline_ Contents Variables pointTags Type-Bound Procedures encodedStr Source Code gmshSpline_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public, ALLOCATABLE :: pointTags (:) Type-Bound Procedures procedure, public, PASS( Obj ) :: encodedStr => Spline_encode private function Spline_encode (obj) result(ans) Arguments Type Intent Optional Attributes Name class( gmshSpline_ ), intent(in) :: obj Return Value type(String) Source Code TYPE , EXTENDS ( gmshCurve_ ) :: gmshSpline_ INTEGER ( I4B ), ALLOCATABLE :: pointTags ( : ) CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: encodedStr => Spline_encode END TYPE gmshSpline_","tags":"","loc":"type/gmshspline_.html"},{"title":"gmshVolumePointer_ – Fortran Program ","text":"type, public :: gmshVolumePointer_ Contents Variables Ptr Source Code gmshVolumePointer_ Components Type Visibility Attributes Name Initial class( gmshVolume_ ), public, POINTER :: Ptr => Null() Source Code TYPE :: gmshVolumePointer_ CLASS ( gmshVolume_ ), POINTER :: Ptr => Null ( ) END TYPE gmshVolumePointer_","tags":"","loc":"type/gmshvolumepointer_.html"},{"title":"gmshVolume_ – Fortran Program ","text":"type, public, EXTENDS( gmshEntity_ ) :: gmshVolume_ Contents Variables shellTags Type-Bound Procedures encodedStr Source Code gmshVolume_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public, ALLOCATABLE :: shellTags (:) Type-Bound Procedures procedure, public, PASS( Obj ) :: encodedStr => Volume_encode private function Volume_encode (obj) result(ans) Arguments Type Intent Optional Attributes Name class( gmshVolume_ ), intent(in) :: obj Return Value type(String) Source Code TYPE , EXTENDS ( gmshEntity_ ) :: gmshVolume_ INTEGER ( I4B ), ALLOCATABLE :: shellTags ( : ) CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: encodedStr => Volume_encode END TYPE gmshVolume_","tags":"","loc":"type/gmshvolume_.html"},{"title":"gmshPlaneSurfacePointer_ – Fortran Program ","text":"type, public :: gmshPlaneSurfacePointer_ Contents Variables Ptr Source Code gmshPlaneSurfacePointer_ Components Type Visibility Attributes Name Initial class( gmshPlaneSurface_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: gmshPlaneSurfacePointer_ CLASS ( gmshPlaneSurface_ ), POINTER :: Ptr => NULL ( ) END TYPE gmshPlaneSurfacePointer_","tags":"","loc":"type/gmshplanesurfacepointer_.html"},{"title":"gmshPlaneSurface_ – Fortran Program ","text":"type, public, EXTENDS( gmshSurface_ ) :: gmshPlaneSurface_ Contents Type-Bound Procedures encodedStr Source Code gmshPlaneSurface_ Type-Bound Procedures procedure, public, PASS( Obj ) :: encodedStr => PlaneSurface_encode private function PlaneSurface_encode (obj) result(ans) Arguments Type Intent Optional Attributes Name class( gmshPlaneSurface_ ), intent(in) :: obj Return Value type(String) Source Code TYPE , EXTENDS ( gmshSurface_ ) :: gmshPlaneSurface_ CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: encodedStr => PlaneSurface_encode END TYPE gmshPlaneSurface_","tags":"","loc":"type/gmshplanesurface_.html"},{"title":"gmshSurfaceLoopPointer_ – Fortran Program ","text":"type, public :: gmshSurfaceLoopPointer_ Contents Variables Ptr Source Code gmshSurfaceLoopPointer_ Components Type Visibility Attributes Name Initial class( gmshSurfaceLoop_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: gmshSurfaceLoopPointer_ CLASS ( gmshSurfaceLoop_ ), POINTER :: Ptr => NULL ( ) END TYPE gmshSurfaceLoopPointer_","tags":"","loc":"type/gmshsurfacelooppointer_.html"},{"title":"gmshSurfaceLoop_ – Fortran Program ","text":"type, public, EXTENDS( gmshSurface_ ) :: gmshSurfaceLoop_ Contents Type-Bound Procedures encodedStr Source Code gmshSurfaceLoop_ Type-Bound Procedures procedure, public, PASS( Obj ) :: encodedStr => SurfaceLoop_encode private function SurfaceLoop_encode (obj) result(ans) Arguments Type Intent Optional Attributes Name class( gmshSurfaceLoop_ ), intent(in) :: obj Return Value type(String) Source Code TYPE , EXTENDS ( gmshSurface_ ) :: gmshSurfaceLoop_ CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: encodedStr => SurfaceLoop_encode END TYPE gmshSurfaceLoop_","tags":"","loc":"type/gmshsurfaceloop_.html"},{"title":"gmshSurfacePointer_ – Fortran Program ","text":"type, public :: gmshSurfacePointer_ Contents Variables Ptr Source Code gmshSurfacePointer_ Components Type Visibility Attributes Name Initial class( gmshSurface_ ), public, POINTER :: Ptr => Null() Source Code TYPE :: gmshSurfacePointer_ CLASS ( gmshSurface_ ), POINTER :: Ptr => Null ( ) END TYPE gmshSurfacePointer_","tags":"","loc":"type/gmshsurfacepointer_.html"},{"title":"gmshSurface_ – Fortran Program ","text":"type, public, EXTENDS( gmshEntity_ ) :: gmshSurface_ Contents Variables sphereCenterTag wireTags Type-Bound Procedures encodedStr Source Code gmshSurface_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: sphereCenterTag = -1 wireTags contains id of curve loops\n The first curve loop defines the exterior contour;\n additional curve loop define holes. integer(kind=I4B), public, ALLOCATABLE :: wireTags (:) Type-Bound Procedures procedure, public, PASS( Obj ) :: encodedStr => Surface_encode private function Surface_encode (obj) result(ans) Arguments Type Intent Optional Attributes Name class( gmshSurface_ ), intent(in) :: obj Return Value type(String) Source Code TYPE , EXTENDS ( gmshEntity_ ) :: gmshSurface_ INTEGER ( I4B ), ALLOCATABLE :: wireTags ( : ) INTEGER ( I4B ) :: sphereCenterTag = - 1 !! wireTags contains id of curve loops !! The first curve loop defines the exterior contour; !! additional curve loop define holes. CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: encodedStr => Surface_encode END TYPE gmshSurface_","tags":"","loc":"type/gmshsurface_.html"},{"title":"gmshEntity_ – Fortran Program ","text":"type, public, ABSTRACT :: gmshEntity_ gmshEntity_ is an abstract class Contents Variables dim uid Type-Bound Procedures encodedStr Source Code gmshEntity_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: dim = 0 Unique id of entity integer(kind=I4B), public :: uid = 0 Type-Bound Procedures procedure( en_encode ), public, deferred, PASS( obj ) :: encodedStr Encode the information stored in gmshEntity_ in sring and returns function en_encode(obj) result(ans) Prototype Arguments Type Intent Optional Attributes Name class( gmshEntity_ ), intent(in) :: obj Return Value type(String) Source Code TYPE , ABSTRACT :: gmshEntity_ INTEGER ( I4B ) :: uid = 0 INTEGER ( I4B ) :: dim = 0 !! Unique id of entity CONTAINS PROCEDURE ( en_encode ), PUBLIC , DEFERRED , PASS ( obj ) :: encodedStr !! Encode the information stored in gmshEntity_ in sring and returns END TYPE gmshEntity_","tags":"","loc":"type/gmshentity_.html"},{"title":"gmshPointPointer_ – Fortran Program ","text":"type, public :: gmshPointPointer_ Contents Variables Ptr Source Code gmshPointPointer_ Components Type Visibility Attributes Name Initial class( gmshPoint_ ), public, POINTER :: Ptr => Null() Source Code TYPE :: gmshPointPointer_ CLASS ( gmshPoint_ ), POINTER :: Ptr => Null ( ) END TYPE gmshPointPointer_","tags":"","loc":"type/gmshpointpointer_.html"},{"title":"gmshPoint_ – Fortran Program ","text":"type, public, EXTENDS( gmshEntity_ ) :: gmshPoint_ gmshPoint_ type represent point entities in gmsh Contents Variables lc x y z Type-Bound Procedures encodedStr Source Code gmshPoint_ Components Type Visibility Attributes Name Initial real(kind=DFP), public :: lc = 0.0 real(kind=DFP), public :: x = 0.0 real(kind=DFP), public :: y = 0.0 real(kind=DFP), public :: z = 0.0 Type-Bound Procedures procedure, public, PASS( Obj ) :: encodedStr => point_encode private function point_encode (obj) result(ans) This function encode the information stored in gmshPoint_ in a string\n data type and return it for printing Arguments Type Intent Optional Attributes Name class( gmshPoint_ ), intent(in) :: obj Return Value type(String) Source Code TYPE , EXTENDS ( gmshEntity_ ) :: gmshPoint_ REAL ( DFP ) :: x = 0.0 REAL ( DFP ) :: y = 0.0 REAL ( DFP ) :: z = 0.0 REAL ( DFP ) :: lc = 0.0 CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: encodedStr => point_encode END TYPE gmshPoint_","tags":"","loc":"type/gmshpoint_.html"},{"title":"gmshGeoMesh_ – Fortran Program ","text":"type, public :: gmshGeoMesh_ Contents Variables buffer Type-Bound Procedures setAlgorithm setRecombine setReverse setSize setSizeFromBoundary setSmoothing setTransfiniteCurve setTransfiniteSurface setTransfiniteVolume write Source Code gmshGeoMesh_ Components Type Visibility Attributes Name Initial type(Buffer_), public, POINTER :: buffer => NULL() Type-Bound Procedures procedure, public, PASS( Obj ) :: setAlgorithm => geoMesh_setAlgorithm private function geoMesh_setAlgorithm (Obj, dim, tag, val) result(Ans) Set the meshing algorithm on the model entity of dimension dim and tag tag.\n Currently only supported for dim == 2. Arguments Type Intent Optional Attributes Name class( gmshGeoMesh_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: dim integer(kind=I4B), intent(in) :: tag integer(kind=I4B), intent(in) :: val Return Value integer(kind=I4B) procedure, public, PASS( Obj ) :: setRecombine => geoMesh_setRecombine private function geoMesh_setRecombine (Obj, dim, tag, angle) result(Ans) Set a recombination meshing constraint on the model entity of dimension\n dim and tag tag. Currently only entities of dimension 2\n (to recombine triangles into quadrangles) are supporte Arguments Type Intent Optional Attributes Name class( gmshGeoMesh_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: dim integer(kind=I4B), intent(in) :: tag real(kind=DFP), intent(in), optional :: angle Return Value integer(kind=I4B) procedure, public, PASS( Obj ) :: setReverse => geoMesh_setReverse private function geoMesh_setReverse (Obj, dim, tag, val) result(Ans) Set a smoothing meshing constraint on the model entity of dimension dim\n and tag tag. val iterations of a Laplace smoother are applied. Arguments Type Intent Optional Attributes Name class( gmshGeoMesh_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: dim integer(kind=I4B), intent(in) :: tag logical(kind=LGT), intent(in) :: val Return Value integer(kind=I4B) procedure, public, PASS( Obj ) :: setSize => geoMesh_setSize private function geoMesh_setSize (Obj, dim, tags, meshsize) result(Ans) Set a mesh size constraint on the model entities dimTags. Currently only\n entities of dimension 0 (points) are handled. Arguments Type Intent Optional Attributes Name class( gmshGeoMesh_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: dim integer(kind=I4B), intent(in) :: tags (:) real(kind=DFP), intent(in) :: meshsize Return Value integer(kind=I4B) procedure, public, PASS( Obj ) :: setSizeFromBoundary => geoMesh_setSizeFromBoundary private function geoMesh_setSizeFromBoundary (Obj, dim, tag, val) result(Ans) Force the mesh size to be extended from the boundary, or not, for the model\n entity of dimension dim and tag tag. Currently only supported for dim == 2. Arguments Type Intent Optional Attributes Name class( gmshGeoMesh_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: dim integer(kind=I4B), intent(in) :: tag integer(kind=I4B), intent(in) :: val Return Value integer(kind=I4B) procedure, public, PASS( Obj ) :: setSmoothing => geoMesh_setSmoothing private function geoMesh_setSmoothing (Obj, dim, tag, val) result(Ans) Set a smoothing meshing constraint on the model entity of dimension dim\n and tag tag. val iterations of a Laplace smoother are applied. Arguments Type Intent Optional Attributes Name class( gmshGeoMesh_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: dim integer(kind=I4B), intent(in) :: tag integer(kind=I4B), intent(in), optional :: val Return Value integer(kind=I4B) procedure, public, PASS( Obj ) :: setTransfiniteCurve => geoMesh_setTransfiniteCurve private function geoMesh_setTransfiniteCurve (Obj, tag, nPoints, meshType, coef) result(Ans) Set a transfinite meshing constraint on the curve tag, with numNodes nodes\n distributed according to meshType and coef. Currently supported types\n are “Progres- sion” (geometrical progression with power coef) and “Bump”\n (refinement toward both extremities of the curve). Arguments Type Intent Optional Attributes Name class( gmshGeoMesh_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: tag integer(kind=I4B), intent(in) :: nPoints character(len=*), intent(in) :: meshType integer(kind=I4B), intent(in), optional :: coef Return Value integer(kind=I4B) procedure, public, PASS( Obj ) :: setTransfiniteSurface => geoMesh_setTransfiniteSurface private function geoMesh_setTransfiniteSurface (Obj, tag, arrangement, cornerTags) result(Ans) Set a transfinite meshing constraint on the surface tag. arrangement\n describes the arrangement of the triangles when the surface is not\n flagged as recombined: cur- rently supported values are “Left”, “Right”,\n “AlternateLeft” and “AlternateRight”. cornerTags can be used to specify\n the (3 or 4) corners of the transfinite interpola- tion explicitly;\n specifying the corners explicitly is mandatory if the surface has more\n that 3 or 4 points on its boundary. Arguments Type Intent Optional Attributes Name class( gmshGeoMesh_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: tag character(len=*), intent(in) :: arrangement integer(kind=I4B), intent(in) :: cornerTags (:) Return Value integer(kind=I4B) procedure, public, PASS( Obj ) :: setTransfiniteVolume => geoMesh_setTransfiniteVolume private function geoMesh_setTransfiniteVolume (Obj, tag, cornerTags) result(Ans) Set a transfinite meshing constraint on the surface tag. arrangement\n describes the arrangement of the triangles when the surface is not\n flagged as recombined: cur- rently supported values are “Left”, “Right”,\n “AlternateLeft” and “AlternateRight”. cornerTags can be used to specify\n the (3 or 4) corners of the transfinite interpola- tion explicitly;\n specifying the corners explicitly is mandatory if the surface has more\n that 3 or 4 points on its boundary. Arguments Type Intent Optional Attributes Name class( gmshGeoMesh_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: tag integer(kind=I4B), intent(in), optional :: cornerTags (:) Return Value integer(kind=I4B) procedure, public, PASS( Obj ) :: write => geoMesh_write private function geoMesh_write (Obj, UnitNo) result(Ans) Arguments Type Intent Optional Attributes Name class( gmshGeoMesh_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: UnitNo Return Value integer(kind=I4B) Source Code TYPE :: gmshGeoMesh_ TYPE ( Buffer_ ), POINTER :: buffer => NULL ( ) CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: write => geoMesh_write PROCEDURE , PUBLIC , PASS ( Obj ) :: setSize => geoMesh_setSize PROCEDURE , PUBLIC , PASS ( Obj ) :: setTransfiniteCurve => & & geoMesh_setTransfiniteCurve PROCEDURE , PUBLIC , PASS ( Obj ) :: setTransfiniteSurface => & & geoMesh_setTransfiniteSurface PROCEDURE , PUBLIC , PASS ( Obj ) :: setTransfiniteVolume => & & geoMesh_setTransfiniteVolume PROCEDURE , PUBLIC , PASS ( Obj ) :: setRecombine => & & geoMesh_setRecombine PROCEDURE , PUBLIC , PASS ( Obj ) :: setSmoothing => & & geoMesh_setSmoothing PROCEDURE , PUBLIC , PASS ( Obj ) :: setReverse => & & geoMesh_setReverse PROCEDURE , PUBLIC , PASS ( Obj ) :: setAlgorithm => & & geoMesh_setAlgorithm PROCEDURE , PUBLIC , PASS ( Obj ) :: setSizeFromBoundary => & & geoMesh_setSizeFromBoundary END TYPE gmshGeoMesh_","tags":"","loc":"type/gmshgeomesh_.html"},{"title":"gmshGeo_ – Fortran Program ","text":"type, public :: gmshGeo_ This class is defined to contain the elements of a geometry\n which will be constructed by Gmsh inbuilt kernel Contents Variables Curve CurveLoop Point Surface SurfaceLoop Volume buffer mesh tCurveLoops tCurves tPoints tSurfaceLoops tSurfaces tVolumes Type-Bound Procedures addBSpline addBezier addCircleArc addCompoundBSpline addCompoundSpline addCurveLoop addEllipseArc addLine addPlaneSurface addPoint addSpline addSurfaceFilling addSurfaceLoop write Source Code gmshGeo_ Components Type Visibility Attributes Name Initial type(gmshCurvePointer_), public, ALLOCATABLE :: Curve (:) type(gmshCurveLoopPointer_), public, ALLOCATABLE :: CurveLoop (:) type(gmshPointPointer_), public, ALLOCATABLE :: Point (:) type(gmshSurfacePointer_), public, ALLOCATABLE :: Surface (:) type(gmshSurfaceLoopPointer_), public, ALLOCATABLE :: SurfaceLoop (:) type(gmshVolumePointer_), public, ALLOCATABLE :: Volume (:) type(Buffer_), public, POINTER :: buffer => NULL() type(gmshGeoMesh_), public, POINTER :: mesh => NULL() integer(kind=I4B), public :: tCurveLoops = 0 integer(kind=I4B), public :: tCurves = 0 integer(kind=I4B), public :: tPoints = 0 integer(kind=I4B), public :: tSurfaceLoops = 0 integer(kind=I4B), public :: tSurfaces = 0 integer(kind=I4B), public :: tVolumes = 0 Type-Bound Procedures procedure, public, PASS( Obj ) :: addBSpline => geo_add_BSpline Add a BSpline entity to geometry private function geo_add_BSpline (Obj, pointTags, uid) result(ans) Arguments Type Intent Optional Attributes Name class( gmshGeo_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: pointTags (:) integer(kind=I4B), intent(in) :: uid Return Value integer(kind=I4B) procedure, public, PASS( Obj ) :: addBezier => geo_add_Bezier Add a Bezier entity to geometry private function geo_add_Bezier (Obj, pointTags, uid) result(ans) Arguments Type Intent Optional Attributes Name class( gmshGeo_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: pointTags (:) integer(kind=I4B), intent(in) :: uid Return Value integer(kind=I4B) procedure, public, PASS( Obj ) :: addCircleArc => geo_add_circle Add a Circular arc entity to geometry private function geo_add_circle (Obj, startTag, centerTag, endTag, uid, nx, ny, nz) result(ans) Arguments Type Intent Optional Attributes Name class( gmshGeo_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: startTag integer(kind=I4B), intent(in) :: centerTag integer(kind=I4B), intent(in) :: endTag integer(kind=I4B), intent(in) :: uid real(kind=DFP), optional :: nx real(kind=DFP), optional :: ny real(kind=DFP), optional :: nz Return Value integer(kind=I4B) procedure, public, PASS( Obj ) :: addCompoundBSpline => geo_add_CompoundBSpline Add a compound BSpline entity to geometry private function geo_add_CompoundBSpline (Obj, curveTags, uid, numIntervals) result(ans) Arguments Type Intent Optional Attributes Name class( gmshGeo_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: curveTags (:) integer(kind=I4B), intent(in) :: uid integer(kind=I4B), optional :: numIntervals Return Value integer(kind=I4B) procedure, public, PASS( Obj ) :: addCompoundSpline => geo_add_CompoundSpline Add a compound Spline entity to geometry private function geo_add_CompoundSpline (Obj, curveTags, uid, numIntervals) result(ans) Arguments Type Intent Optional Attributes Name class( gmshGeo_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: curveTags (:) integer(kind=I4B), intent(in) :: uid integer(kind=I4B), optional :: numIntervals Return Value integer(kind=I4B) procedure, public, PASS( Obj ) :: addCurveLoop => geo_add_CurveLoop Add a Curveloop to geometry private function geo_add_CurveLoop (Obj, curveTags, uid) result(ans) Arguments Type Intent Optional Attributes Name class( gmshGeo_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: curveTags (:) integer(kind=I4B), intent(in) :: uid Return Value integer(kind=I4B) procedure, public, PASS( Obj ) :: addEllipseArc => geo_add_Ellipse Add a Ellipse entity to geometry private function geo_add_Ellipse (Obj, startTag, centerTag, majorTag, endTag, uid, nx, ny, nz) result(ans) Arguments Type Intent Optional Attributes Name class( gmshGeo_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: startTag integer(kind=I4B), intent(in) :: centerTag integer(kind=I4B), intent(in) :: majorTag integer(kind=I4B), intent(in) :: endTag integer(kind=I4B), intent(in) :: uid real(kind=DFP), optional :: nx real(kind=DFP), optional :: ny real(kind=DFP), optional :: nz Return Value integer(kind=I4B) procedure, public, PASS( Obj ) :: addLine => geo_add_line Add a line entity to geometry private function geo_add_line (Obj, startTag, endTag, uid) result(ans) Arguments Type Intent Optional Attributes Name class( gmshGeo_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: startTag integer(kind=I4B), intent(in) :: endTag integer(kind=I4B), intent(in) :: uid Return Value integer(kind=I4B) procedure, public, PASS( Obj ) :: addPlaneSurface => geo_add_PlaneSurface Add a plane surface entity to geometry private function geo_add_PlaneSurface (Obj, wireTags, uid) result(ans) Arguments Type Intent Optional Attributes Name class( gmshGeo_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: wireTags (:) integer(kind=I4B), intent(in) :: uid Return Value integer(kind=I4B) procedure, public, PASS( Obj ) :: addPoint => geo_add_point Add a point entitiy to geometry private function geo_add_point (Obj, x, y, z, lc, uid) result(ans) Arguments Type Intent Optional Attributes Name class( gmshGeo_ ), intent(inout) :: Obj real(kind=DFP), intent(in) :: x real(kind=DFP), intent(in) :: y real(kind=DFP), intent(in) :: z real(kind=DFP), intent(in) :: lc integer(kind=I4B), intent(in) :: uid Return Value integer(kind=I4B) procedure, public, PASS( Obj ) :: addSpline => geo_add_Spline Add a Spline entity to geometry private function geo_add_Spline (Obj, pointTags, uid) result(ans) Arguments Type Intent Optional Attributes Name class( gmshGeo_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: pointTags (:) integer(kind=I4B), intent(in) :: uid Return Value integer(kind=I4B) procedure, public, PASS( Obj ) :: addSurfaceFilling => geo_add_SurfaceFilling Add surfaceFilled private function geo_add_SurfaceFilling (Obj, wireTags, uid, sphereCenterTag) result(ans) Add a surface filling the curve loops in wireTags.\n Currently only a single curve loop is supported; this curve loop should be\n composed by 3 or 4 curves only. If tag is positive, set the tag explicitly;\n otherwise a new tag is selected automatically. Return the tag of the surface. Arguments Type Intent Optional Attributes Name class( gmshGeo_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: wireTags (:) integer(kind=I4B), intent(in) :: uid integer(kind=I4B), intent(in), optional :: sphereCenterTag Return Value integer(kind=I4B) procedure, public, PASS( Obj ) :: addSurfaceLoop => geo_add_SurfaceLoop private function geo_add_SurfaceLoop (Obj, surfaceTags, uid) result(ans) Arguments Type Intent Optional Attributes Name class( gmshGeo_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: surfaceTags (:) integer(kind=I4B), intent(in) :: uid Return Value integer(kind=I4B) procedure, public, PASS( Obj ) :: write => geo_write private function geo_write (Obj, UnitNo) result(Ans) Arguments Type Intent Optional Attributes Name class( gmshGeo_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: UnitNo Return Value integer(kind=I4B) Source Code TYPE :: gmshGeo_ TYPE ( Buffer_ ), POINTER :: buffer => NULL ( ) TYPE ( gmshGeoMesh_ ), POINTER :: mesh => NULL ( ) TYPE ( gmshPointPointer_ ), ALLOCATABLE :: Point ( : ) TYPE ( gmshCurvePointer_ ), ALLOCATABLE :: Curve ( : ) TYPE ( gmshSurfacePointer_ ), ALLOCATABLE :: Surface ( : ) TYPE ( gmshVolumePointer_ ), ALLOCATABLE :: Volume ( : ) TYPE ( gmshCurveLoopPointer_ ), ALLOCATABLE :: CurveLoop ( : ) TYPE ( gmshSurfaceLoopPointer_ ), ALLOCATABLE :: SurfaceLoop ( : ) INTEGER ( I4B ) :: tPoints = 0 INTEGER ( I4B ) :: tCurves = 0 INTEGER ( I4B ) :: tSurfaces = 0 INTEGER ( I4B ) :: tVolumes = 0 INTEGER ( I4B ) :: tCurveLoops = 0 INTEGER ( I4B ) :: tSurfaceLoops = 0 ! TYPE( gmshVolumePointer_ ), ALLOCATABLE :: volume( : ) CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: write => geo_write PROCEDURE , PUBLIC , PASS ( Obj ) :: addPoint => geo_add_point !! Add a point entitiy to geometry PROCEDURE , PUBLIC , PASS ( Obj ) :: addLine => geo_add_line !! Add a line entity to geometry PROCEDURE , PUBLIC , PASS ( Obj ) :: addCircleArc => geo_add_circle !! Add a Circular arc entity to geometry PROCEDURE , PUBLIC , PASS ( Obj ) :: addEllipseArc => geo_add_Ellipse !! Add a Ellipse entity to geometry PROCEDURE , PUBLIC , PASS ( Obj ) :: addSpline => geo_add_Spline !! Add a Spline entity to geometry PROCEDURE , PUBLIC , PASS ( Obj ) :: addCompoundSpline => & & geo_add_CompoundSpline !! Add a compound Spline entity to geometry PROCEDURE , PUBLIC , PASS ( Obj ) :: addBSpline => geo_add_BSpline !! Add a BSpline entity to geometry PROCEDURE , PUBLIC , PASS ( Obj ) :: addCompoundBSpline => & & geo_add_CompoundBSpline !! Add a compound BSpline entity to geometry PROCEDURE , PUBLIC , PASS ( Obj ) :: addBezier => geo_add_Bezier !! Add a Bezier entity to geometry PROCEDURE , PUBLIC , PASS ( Obj ) :: addCurveLoop => geo_add_CurveLoop !! Add a Curveloop to geometry PROCEDURE , PUBLIC , PASS ( Obj ) :: addSurfaceFilling => geo_add_SurfaceFilling !! Add surfaceFilled PROCEDURE , PUBLIC , PASS ( Obj ) :: addPlaneSurface => geo_add_PlaneSurface !! Add a plane surface entity to geometry PROCEDURE , PUBLIC , PASS ( Obj ) :: addSurfaceLoop => geo_add_SurfaceLoop END TYPE gmshGeo_","tags":"","loc":"type/gmshgeo_.html"},{"title":"mshFormatPointer_ – Fortran Program ","text":"type, public :: mshFormatPointer_ Contents Variables Ptr Source Code mshFormatPointer_ Components Type Visibility Attributes Name Initial class( mshFormat_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: mshFormatPointer_ CLASS ( mshFormat_ ), POINTER :: Ptr => NULL () END TYPE mshFormatPointer_","tags":"","loc":"type/mshformatpointer_.html"},{"title":"mshFormat_ – Fortran Program ","text":"type, public :: mshFormat_ This data type stores gmsh mesh format Contents Variables DataSize FileType MeshFormat Version isASCII Type-Bound Procedures Finalize GotoTag ReadFromFile WriteToFile Source Code mshFormat_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: DataSize = 0 integer(kind=I4B), public :: FileType = 0 character(len=100), public :: MeshFormat = \"\" real(kind=DFP), public :: Version = 0.0_DFP logical(kind=LGT), public :: isASCII = .FALSE. Type-Bound Procedures procedure, public, PASS( Obj ) :: Finalize => fmt_deallocatedata Finalize interface This subroutine clears the content of mshFormat_ private subroutine fmt_deallocatedata(Obj) This subroutine clears the content of mshFormat_ Arguments Type Intent Optional Attributes Name class( mshFormat_ ), intent(inout) :: Obj procedure, public, PASS( Obj ) :: GotoTag => fmt_goto Goto a tag interface This subroutine search the mesh format tag in the mesh file private subroutine fmt_goto(Obj, mshFile, ierr) This subroutine search the mesh format tag in the mesh file Arguments Type Intent Optional Attributes Name class( mshFormat_ ), intent(in) :: Obj type(File_), intent(inout) :: mshFile logical(kind=LGT), intent(inout) :: ierr procedure, public, PASS( Obj ) :: ReadFromFile => fmt_read_file Read format from a file interface This subroutine reads format from .msh file private subroutine fmt_read_file(Obj, mshFile, ierr) This subroutine reads mesh format from .mshfile Arguments Type Intent Optional Attributes Name class( mshFormat_ ), intent(inout) :: Obj type(File_), intent(inout) :: mshFile logical(kind=LGT), intent(inout) :: ierr procedure, public, PASS( Obj ) :: WriteToFile => fmt_write_file Write content to a file interface This subroutine writes mesh format to a .msh file private subroutine fmt_write_file(Obj, mshFile, Str, EndStr) This subroutine writes mesh format to a .msh file Arguments Type Intent Optional Attributes Name class( mshFormat_ ), intent(inout) :: Obj type(File_), intent(inout) :: mshFile character(len=*), intent(in), optional :: Str character(len=*), intent(in), optional :: EndStr Source Code TYPE :: mshFormat_ REAL ( DFP ) :: Version = 0.0_DFP INTEGER ( I4B ) :: FileType = 0 , DataSize = 0 LOGICAL ( LGT ) :: isASCII = . FALSE . CHARACTER ( LEN = 100 ) :: MeshFormat = \"\" CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: ReadFromFile => fmt_read_file !! Read format from a file PROCEDURE , PUBLIC , PASS ( Obj ) :: WriteToFile => fmt_write_file !! Write content to a file PROCEDURE , PUBLIC , PASS ( Obj ) :: GotoTag => fmt_goto !! Goto a tag PROCEDURE , PUBLIC , PASS ( Obj ) :: Finalize => fmt_deallocatedata !! Finalize END TYPE mshFormat_","tags":"","loc":"type/mshformat_.html"},{"title":"mshElementsPointer_ – Fortran Program ","text":"type, public :: mshElementsPointer_ Contents Variables Ptr Source Code mshElementsPointer_ Components Type Visibility Attributes Name Initial class( mshElements_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: mshElementsPointer_ CLASS ( mshElements_ ), POINTER :: Ptr => NULL () END TYPE mshElementsPointer_","tags":"","loc":"type/mshelementspointer_.html"},{"title":"mshElements_ – Fortran Program ","text":"type, public :: mshElements_ This class handles the elements present in the mesh file Contents Variables isSparse maxElementTag minElementTag numElements numEntityBlocks Type-Bound Procedures Finalize GotoTag ReadElementLine ReadFromFile TotalElements WriteToFile Source Code mshElements_ Components Type Visibility Attributes Name Initial logical(kind=LGT), public :: isSparse = .FALSE. integer(kind=I4B), public :: maxElementTag = 0 integer(kind=I4B), public :: minElementTag = 0 integer(kind=I4B), public :: numElements = 0 integer(kind=I4B), public :: numEntityBlocks = 0 Type-Bound Procedures procedure, public, PASS( Obj ) :: Finalize => el_deallocatedata deallocate data interface private subroutine el_deallocatedata(Obj) This subroutine deallocates the data from obj Arguments Type Intent Optional Attributes Name class( mshElements_ ), intent(inout) :: Obj procedure, public, PASS( Obj ) :: GotoTag => el_goto go to the tag interface This subroutine go the location of element in mesh file private subroutine el_goto(Obj, mshFile, ierr) This subroutine go the location of element in mesh file Arguments Type Intent Optional Attributes Name class( mshElements_ ), intent(in) :: Obj type(File_), intent(inout) :: mshFile logical(kind=LGT), intent(inout) :: ierr procedure, public, PASS( Obj ) :: ReadElementLine => el_read_elem_line Read element line interface private subroutine el_read_elem_line(Obj, ElemNum, ElemType, PhysicalId, GeometryId, MeshPartitionTags, Nptrs, mshFile) Arguments Type Intent Optional Attributes Name class( mshElements_ ), intent(inout) :: Obj integer(kind=I4B), intent(inout), optional :: ElemNum integer(kind=I4B), intent(inout), optional :: ElemType integer(kind=I4B), intent(inout), optional :: PhysicalId integer(kind=I4B), intent(inout), optional :: GeometryId integer(kind=I4B), intent(inout), optional ALLOCATABLE :: MeshPartitionTags (:) integer(kind=I4B), intent(inout), optional ALLOCATABLE :: Nptrs (:) type(File_), intent(inout) :: mshFile procedure, public, PASS( Obj ) :: ReadFromFile => el_read_file Read data form file interface private subroutine el_read_file(Obj, mshFile, mshFormat, ierr) This subroutine reads data from a file Arguments Type Intent Optional Attributes Name class( mshElements_ ), intent(inout) :: Obj type(File_), intent(inout) :: mshFile type(mshFormat_), intent(inout) :: mshFormat logical(kind=LGT), intent(inout) :: ierr procedure, public, PASS( Obj ) :: TotalElements => el_telements_1 total elements interface private pure function el_telements_1(Obj) result(Ans) This function returns total number of elements Arguments Type Intent Optional Attributes Name class( mshElements_ ), intent(in) :: Obj Return Value integer(kind=I4B) procedure, public, PASS( Obj ) :: WriteToFile => el_write_file Write data to file interface private subroutine el_write_file(Obj, mshFile, mshFormat, Str, EndStr) This subroutine writes the data to a file Arguments Type Intent Optional Attributes Name class( mshElements_ ), intent(inout) :: Obj type(File_), intent(inout) :: mshFile type(mshFormat_), intent(inout) :: mshFormat character(len=*), intent(in), optional :: Str character(len=*), intent(in), optional :: EndStr Source Code TYPE :: mshElements_ INTEGER ( I4B ) :: numElements = 0 INTEGER ( I4B ) :: numEntityBlocks = 0 INTEGER ( I4B ) :: minElementTag = 0 INTEGER ( I4B ) :: maxElementTag = 0 LOGICAL ( LGT ) :: isSparse = . FALSE . CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: Finalize => el_DeallocateData !! deallocate data PROCEDURE , PUBLIC , PASS ( Obj ) :: GotoTag => el_goto !! go to the tag PROCEDURE , PUBLIC , PASS ( Obj ) :: ReadFromFile => el_read_file !! Read data form file PROCEDURE , PUBLIC , PASS ( Obj ) :: WriteToFile => el_write_file !! Write data to file PROCEDURE , PUBLIC , PASS ( Obj ) :: ReadElementLine => el_read_elem_line !! Read element line PROCEDURE , PUBLIC , PASS ( Obj ) :: TotalElements => el_telements_1 !! total elements END TYPE mshElements_","tags":"","loc":"type/mshelements_.html"},{"title":"mshPhysicalNamesPointer_ – Fortran Program ","text":"type, public :: mshPhysicalNamesPointer_ Contents Variables Ptr Source Code mshPhysicalNamesPointer_ Components Type Visibility Attributes Name Initial class( mshPhysicalNames_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: mshPhysicalNamesPointer_ CLASS ( mshPhysicalNames_ ), POINTER :: Ptr => NULL ( ) END TYPE mshPhysicalNamesPointer_","tags":"","loc":"type/mshphysicalnamespointer_.html"},{"title":"mshPhysicalNames_ – Fortran Program ","text":"type, public :: mshPhysicalNames_ This data type contains the Physical Names generate by gmsh Contents Variables Entities NSD PhysicalName Tag numElements numNodes Type-Bound Procedures Finalize GotoTag IndexOfPhysicalCurve IndexOfPhysicalPoint IndexOfPhysicalSurface IndexOfPhysicalVolume OutputFileName PhysicalCurveNames PhysicalCurveTags PhysicalPointNames PhysicalPointTags PhysicalSurfaceNames PhysicalSurfaceTags PhysicalVolumeNames PhysicalVolumeTags ReadFromFile SIZE TotalPhysicalCurves TotalPhysicalPoints TotalPhysicalSurfaces TotalPhysicalVolumes WhoAmI WriteToFile getIndex pn_index_Curve pn_index_Curve_2 pn_index_Surface pn_index_Surface_2 pn_index_Volume pn_index_Volume_2 pn_index_a pn_index_b pn_index_c pn_index_d pn_index_point pn_index_point_2 Source Code mshPhysicalNames_ Components Type Visibility Attributes Name Initial type(IntVector_), public, ALLOCATABLE :: Entities (:) Tags of Entities in each physical group integer(kind=I4B), public, ALLOCATABLE :: NSD (:) spatial dimension of each physical group type(String), public, ALLOCATABLE :: PhysicalName (:) Physical name of each physical group integer(kind=I4B), public, ALLOCATABLE :: Tag (:) Unit ID of each physical group integer(kind=I4B), public, ALLOCATABLE :: numElements (:) Number of elements in each physical group integer(kind=I4B), public, ALLOCATABLE :: numNodes (:) Number of nodes in each physical nodes Type-Bound Procedures procedure, public, PASS( Obj ) :: Finalize => pn_deallocatedata To deallocate data interface This subroutine deallocates the data stored in mshPhysicalNames_ private subroutine pn_deallocatedata(Obj) This subroutine deallocates the data stored in mshPhysicalNames_ Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(inout) :: Obj procedure, public, PASS( Obj ) :: GotoTag => pn_goto Search tag for physical group in mesh file interface This suboutine find the tag for Physical groups in mesh private subroutine pn_goto(Obj, mshFile, ierr) This suboutine find the tag for Physical groups in mesh Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj type(File_), intent(inout) :: mshFile logical(kind=LGT), intent(inout) :: ierr generic, public :: IndexOfPhysicalCurve => pn_index_Curve , pn_index_Curve_2 private interface pn_index_Curve () This function return the index of physical Curve from its physical id Arguments None private interface pn_index_Curve_2 () This function return the index of physical Curve from its physical id Arguments None generic, public :: IndexOfPhysicalPoint => pn_index_point , pn_index_point_2 private interface pn_index_point () Arguments None private interface pn_index_point_2 () Arguments None generic, public :: IndexOfPhysicalSurface => pn_index_Surface , pn_index_Surface_2 private interface pn_index_Surface () This function return the index of physical Surface from its physical id Arguments None private interface pn_index_Surface_2 () Arguments None generic, public :: IndexOfPhysicalVolume => pn_index_Volume , pn_index_Volume_2 private interface pn_index_Volume () This function return the index of physical Volume from its physical id Arguments None private interface pn_index_Volume_2 () This function return the index of physical Volume from its physical id Arguments None procedure, public, PASS( Obj ) :: OutputFileName => pn_output_file interface This function retunrns the name of output file private pure function pn_output_file(Obj, mshFile, indx) result(Ans) Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj type(File_), intent(in) :: mshFile integer(kind=I4B), intent(in) :: indx Return Value type(String) procedure, public, PASS( Obj ) :: PhysicalCurveNames => pn_Curve_names Returns names of a physical curves interface This function returns the names of physical curves private pure function pn_Curve_names(Obj) result(Ans) This subroutine returns the names of physical curves Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj Return Value type(String),\n  ALLOCATABLE, (:) procedure, public, PASS( Obj ) :: PhysicalCurveTags => pn_Curve_tags Returns tags of physical points interface This function returns the physical tags of all physical curves private pure function pn_Curve_tags(Obj) result(Ans) This function returns the physical tags of all physical curves Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) procedure, public, PASS( Obj ) :: PhysicalPointNames => pn_point_names Returns the names of physical points interface This function returns the names of physical poins private pure function pn_point_names(Obj) result(Ans) This subroutine returns the names of physical points Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj Return Value type(String),\n  ALLOCATABLE, (:) procedure, public, PASS( Obj ) :: PhysicalPointTags => pn_Point_tags Returns tags of physical points interface This function returns the physical tags of all physical points private pure function pn_Point_tags(Obj) result(Ans) This function returns the physical tags of all physical points Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) procedure, public, PASS( Obj ) :: PhysicalSurfaceNames => pn_Surface_names Returns names of Physical surface interface This function returns the names of physical surfaces private pure function pn_Surface_names(Obj) result(Ans) This subroutine returns the names of physical surfaces Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj Return Value type(String),\n  ALLOCATABLE, (:) procedure, public, PASS( Obj ) :: PhysicalSurfaceTags => pn_Surface_tags Returns tags of physical surfaces interface This function returns the physical tags of all physical surfaces private pure function pn_Surface_tags(Obj) result(Ans) This function returns the physical tags of all physical surfaces Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) procedure, public, PASS( Obj ) :: PhysicalVolumeNames => pn_Volume_names Returns names of physical volumes interface This function returns the names of physical volumes private pure function pn_Volume_names(Obj) result(Ans) This subroutine returns the names of physical volumes Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj Return Value type(String),\n  ALLOCATABLE, (:) procedure, public, PASS( Obj ) :: PhysicalVolumeTags => pn_Volume_tags Returns tags of physical volumes interface This function returns the physical tags of all physical volumes private pure function pn_Volume_tags(Obj) result(Ans) This function returns the physical tags of all physical volumes Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) procedure, public, PASS( Obj ) :: ReadFromFile => pn_read_file Read contents from mesh file interface This subroutine reads physical groupds info from mesh file private subroutine pn_read_file(Obj, mshFile, ierr) This subroutine reads physical groupds info from mesh file Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(inout) :: Obj type(File_), intent(inout) :: mshFile logical(kind=LGT), intent(inout) :: ierr procedure, public, PASS( Obj ) :: SIZE => pn_get_size Returns total number of physical groups interface This function returns total number of physical entities private pure function pn_get_size(Obj) result(Ans) This function returns total number of physical entities Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj Return Value integer(kind=I4B) procedure, public, PASS( Obj ) :: TotalPhysicalCurves => pn_size_Curve Returns total number of physical curves interface This function returns total number of physical curves private pure function pn_size_Curve(Obj) result(Ans) This function returns total number of physical curves Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj Return Value integer(kind=I4B) procedure, public, PASS( Obj ) :: TotalPhysicalPoints => pn_size_point Returns total number of physical points in mesh interface This function returns total number of physical points private pure function pn_size_point(Obj) result(Ans) This function returns total number of physical points Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj Return Value integer(kind=I4B) procedure, public, PASS( Obj ) :: TotalPhysicalSurfaces => pn_size_Surface Returns total number of physical surface interface This function returns total number of physical surfaces private pure function pn_size_Surface(Obj) result(Ans) This function returns total number of physical surfaces Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj Return Value integer(kind=I4B) procedure, public, PASS( Obj ) :: TotalPhysicalVolumes => pn_size_Volume Returns total number of physical volumes interface This function returns total number of physical volumes private pure function pn_size_Volume(Obj) result(Ans) This function returns total number of physical volumes Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj Return Value integer(kind=I4B) procedure, public, PASS( Obj ) :: WhoAmI => pn_who_am_i Enquire about “volume, surface, curve, point’ interface private pure function pn_who_am_i(Obj, I) result(Ans) Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: I Return Value type(String) procedure, public, PASS( Obj ) :: WriteToFile => pn_write_file Write contents to a mesh file interface This subroutine writes physical groupds info in mesh file private subroutine pn_write_file(Obj, mshFile, Str, EndStr) This subroutine writes physical groupds info in mesh file Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(inout) :: Obj type(File_), intent(inout) :: mshFile character(len=*), intent(in), optional :: Str character(len=*), intent(in), optional :: EndStr generic, public :: getIndex => pn_index_a , pn_index_b , pn_index_c , pn_index_d private interface pn_index_a () This function returns index of a given physical name Arguments None private interface pn_index_b () Arguments None private interface pn_index_c () This function returns index of a given physical name Arguments None private interface pn_index_d () This function returns index of a given physical name Arguments None procedure, private, PASS( Obj ) :: pn_index_Curve Return index of physical curve interface This function return the index of physical Curve from its physical id private pure function pn_index_Curve(Obj, Tag) result(Ans) This function returns the index of physical Curve from its physical id Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Tag Return Value integer(kind=I4B) procedure, private, PASS( Obj ) :: pn_index_Curve_2 Return index of physical curve interface This function return the index of physical Curve from its physical id private pure function pn_index_Curve_2(Obj, Tag) result(Ans) This function returns the index of physical Curve from its physical id Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Tag (:) Return Value integer(kind=I4B)\n  (SIZE(Tag)) procedure, private, PASS( Obj ) :: pn_index_Surface Return index of physical surface interface This function return the index of physical Surface from its physical id private pure function pn_index_Surface(Obj, Tag) result(Ans) This function returns the index of physical Surface from its physical id Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Tag Return Value integer(kind=I4B) procedure, private, PASS( Obj ) :: pn_index_Surface_2 Return index of physical surface interface private pure function pn_index_Surface_2(Obj, Tag) result(Ans) Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Tag (:) Return Value integer(kind=I4B)\n  (SIZE(Tag)) procedure, private, PASS( Obj ) :: pn_index_Volume interface This function return the index of physical Volume from its physical id private pure function pn_index_Volume(Obj, Tag) result(Ans) This function returns the index of physical Volume from its physical id Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Tag Return Value integer(kind=I4B) procedure, private, PASS( Obj ) :: pn_index_Volume_2 interface This function return the index of physical Volume from its physical id private pure function pn_index_Volume_2(Obj, Tag) result(Ans) This function returns the index of physical Volume from its physical id Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Tag (:) Return Value integer(kind=I4B)\n  (SIZE(Tag)) procedure, private, PASS( Obj ) :: pn_index_a Returns the index of a physical group interface This function returns index of a given physical name private pure function pn_index_a(Obj, Name) result(Ans) This function returns index of a given physical name Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj character(len=*), intent(in) :: Name Return Value integer(kind=I4B) procedure, private, PASS( Obj ) :: pn_index_b Returns the index of a physical group interface private pure function pn_index_b(Obj, Name) result(Ans) Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj type(String), intent(in) :: Name (:) Return Value integer(kind=I4B)\n  (SIZE(Name)) procedure, private, PASS( Obj ) :: pn_index_c Returns the index of a physical group interface This function returns index of a given physical name private pure function pn_index_c(Obj, XiDimTag) result(Ans) This function returns index of a given physical name Read more… Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: XiDimTag (2) Return Value integer(kind=I4B) procedure, private, PASS( Obj ) :: pn_index_d Returns the index of a physical group interface This function returns index of a given physical name private pure function pn_index_d(Obj, XiDimTag) result(Ans) This function returns index of a given physical name Read more… Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: XiDimTag Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) procedure, private, PASS( Obj ) :: pn_index_point Return index of physical points interface private pure function pn_index_point(Obj, Tag) result(Ans) Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Tag Return Value integer(kind=I4B) procedure, private, PASS( Obj ) :: pn_index_point_2 Return index of physical points interface private pure function pn_index_point_2(Obj, Tag) result(Ans) Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Tag (:) Return Value integer(kind=I4B)\n  (SIZE(Tag)) Source Code TYPE :: mshPhysicalNames_ INTEGER ( I4B ), ALLOCATABLE :: NSD ( : ) !! spatial dimension of each physical group INTEGER ( I4B ), ALLOCATABLE :: Tag ( : ) !! Unit ID of each physical group INTEGER ( I4B ), ALLOCATABLE :: numElements ( : ) !! Number of elements in each physical group INTEGER ( I4B ), ALLOCATABLE :: numNodes ( : ) !! Number of nodes in each physical nodes TYPE ( IntVector_ ), ALLOCATABLE :: Entities ( : ) !! Tags of Entities in each physical group TYPE ( String ), ALLOCATABLE :: PhysicalName ( : ) !! Physical name of each physical group CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: Finalize => pn_deallocatedata !! To deallocate data PROCEDURE , PUBLIC , PASS ( Obj ) :: GotoTag => pn_goto !! Search tag for physical group in mesh file PROCEDURE , PUBLIC , PASS ( Obj ) :: ReadFromFile => pn_read_file !! Read contents from mesh file PROCEDURE , PUBLIC , PASS ( Obj ) :: WriteToFile => pn_write_file !! Write contents to a mesh file PROCEDURE , PUBLIC , PASS ( Obj ) :: SIZE => pn_get_size !! Returns total number of physical groups PROCEDURE , PUBLIC , PASS ( Obj ) :: TotalPhysicalPoints => pn_size_point !! Returns total number of physical points in mesh PROCEDURE , PUBLIC , PASS ( Obj ) :: TotalPhysicalCurves => pn_size_Curve !! Returns total number of physical curves PROCEDURE , PUBLIC , PASS ( Obj ) :: TotalPhysicalSurfaces => pn_size_Surface !! Returns total number of physical surface PROCEDURE , PUBLIC , PASS ( Obj ) :: TotalPhysicalVolumes => pn_size_Volume !! Returns total number of physical volumes GENERIC , PUBLIC :: & & getIndex => & & pn_index_a , & & pn_index_b , & & pn_index_c , & & pn_index_d PROCEDURE , PRIVATE , PASS ( Obj ) :: pn_index_a !! Returns the index of a physical group PROCEDURE , PRIVATE , PASS ( Obj ) :: pn_index_b !! Returns the index of a physical group PROCEDURE , PRIVATE , PASS ( Obj ) :: pn_index_c !! Returns the index of a physical group PROCEDURE , PRIVATE , PASS ( Obj ) :: pn_index_d !! Returns the index of a physical group PROCEDURE , PUBLIC , PASS ( Obj ) :: PhysicalPointNames => pn_point_names !! Returns the names of physical points PROCEDURE , PUBLIC , PASS ( Obj ) :: PhysicalCurveNames => pn_Curve_names !! Returns names of a physical curves PROCEDURE , PUBLIC , PASS ( Obj ) :: PhysicalSurfaceNames => pn_Surface_names !! Returns names of Physical surface PROCEDURE , PUBLIC , PASS ( Obj ) :: PhysicalVolumeNames => pn_Volume_names !! Returns names of physical volumes PROCEDURE , PUBLIC , PASS ( Obj ) :: PhysicalPointTags => pn_Point_tags !! Returns tags of physical points PROCEDURE , PUBLIC , PASS ( Obj ) :: PhysicalCurveTags => pn_Curve_tags !! Returns tags of physical points PROCEDURE , PUBLIC , PASS ( Obj ) :: PhysicalSurfaceTags => pn_Surface_tags !! Returns tags of physical surfaces PROCEDURE , PUBLIC , PASS ( Obj ) :: PhysicalVolumeTags => pn_Volume_tags !! Returns tags of physical volumes PROCEDURE , PUBLIC , PASS ( Obj ) :: WhoAmI => pn_who_am_i !! Enquire about \"volume, surface, curve, point' GENERIC , PUBLIC :: IndexOfPhysicalPoint => pn_index_point , & & pn_index_point_2 PROCEDURE , PRIVATE , PASS ( Obj ) :: pn_index_point !! Return index of physical points PROCEDURE , PRIVATE , PASS ( Obj ) :: pn_index_point_2 !! Return index of physical points GENERIC , PUBLIC :: IndexOfPhysicalCurve => & & pn_index_Curve , & & pn_index_Curve_2 PROCEDURE , PRIVATE , PASS ( Obj ) :: pn_index_Curve !! Return index of physical curve PROCEDURE , PRIVATE , PASS ( Obj ) :: pn_index_Curve_2 !! Return index of physical curve GENERIC , PUBLIC :: IndexOfPhysicalSurface => & & pn_index_Surface , & & pn_index_Surface_2 PROCEDURE , PRIVATE , PASS ( Obj ) :: pn_index_Surface !! Return index of physical surface PROCEDURE , PRIVATE , PASS ( Obj ) :: pn_index_Surface_2 !! Return index of physical surface GENERIC , PUBLIC :: IndexOfPhysicalVolume => pn_index_Volume , & & pn_index_Volume_2 PROCEDURE , PRIVATE , PASS ( Obj ) :: pn_index_Volume PROCEDURE , PRIVATE , PASS ( Obj ) :: pn_index_Volume_2 PROCEDURE , PUBLIC , PASS ( Obj ) :: OutputFileName => pn_output_file END TYPE mshPhysicalNames_","tags":"","loc":"type/mshphysicalnames_.html"},{"title":"mshEntityPointer_ – Fortran Program ","text":"type, public :: mshEntityPointer_ Contents Variables Ptr Source Code mshEntityPointer_ Components Type Visibility Attributes Name Initial class( mshEntity_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: mshEntityPointer_ CLASS ( mshEntity_ ), POINTER :: Ptr => NULL ( ) END TYPE mshEntityPointer_","tags":"","loc":"type/mshentitypointer_.html"},{"title":"mshEntity_ – Fortran Program ","text":"type, public :: mshEntity_ This class handles the mesh entities defined in msh file Contents Variables BoundingEntity ElemNumber ElemType NodeCoord NodeNumber Nptrs PhysicalTag X XiDim Y Z maxX maxY maxZ minX minY minZ uid Type-Bound Procedures Finalize GotoTag ReadCurveEntity ReadPointEntity ReadSurfaceEntity ReadVolumeEntity TotalBoundingTags TotalElements TotalPhysicalTags WriteToFile Source Code mshEntity_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public, ALLOCATABLE :: BoundingEntity (:) tag of bounding entity integer(kind=I4B), public, ALLOCATABLE :: ElemNumber (:) element numbers in mesh integer(kind=I4B), public :: ElemType = 0 element type in meshing real(kind=DFP), public, ALLOCATABLE :: NodeCoord (:,:) nodal coordinates in xiJ format integer(kind=I4B), public, ALLOCATABLE :: NodeNumber (:) node numbers in mesh integer(kind=I4B), public, ALLOCATABLE :: Nptrs (:,:) connectivity integer(kind=I4B), public, ALLOCATABLE :: PhysicalTag (:) Physical tags associated real(kind=DFP), public :: X = 0.0_DFP used only for point entity integer(kind=I4B), public :: XiDim = 0 for point=0, curve=1, surface = 2, volume = 3 real(kind=DFP), public :: Y = 0.0_DFP used only for point entity real(kind=DFP), public :: Z = 0.0_DFP used only for point entity real(kind=DFP), public :: maxX = 0.0_DFP bounding box of entity real(kind=DFP), public :: maxY = 0.0_DFP bounding box of entity real(kind=DFP), public :: maxZ = 0.0_DFP bounding box of entity real(kind=DFP), public :: minX = 0.0_DFP bounding box of entity real(kind=DFP), public :: minY = 0.0_DFP bounding box of entity real(kind=DFP), public :: minZ = 0.0_DFP bounding box of entity integer(kind=I4B), public :: uid = 0 unique id of entity Type-Bound Procedures procedure, public, PASS( Obj ) :: Finalize => ent_deallocatedata To deallocate data interface This subroutine deallocate the data from mshEntity_ private subroutine ent_deallocatedata(Obj) This subroutine deallocate the data from mshEntity_ Arguments Type Intent Optional Attributes Name class( mshEntity_ ), intent(inout) :: Obj procedure, public, PASS( Obj ) :: GotoTag => ent_goto To find tag interface This subroutine finds the tag in the mesh file private subroutine ent_goto(Obj, mshFile, ierr) Arguments Type Intent Optional Attributes Name class( mshEntity_ ), intent(in) :: Obj type(File_), intent(inout) :: mshFile logical(kind=LGT), intent(inout) :: ierr procedure, public, PASS( Obj ) :: ReadCurveEntity => ent_read_Curve Read the entry from file for curve interface This subroutine reads the entry for curve entity private subroutine ent_read_Curve(Obj, mshFile, readTag, ierr) This subroutine reads the entry for curve entity Arguments Type Intent Optional Attributes Name class( mshEntity_ ), intent(inout) :: Obj type(File_), intent(inout) :: mshFile logical(kind=LGT), intent(in) :: readTag logical(kind=LGT), intent(inout) :: ierr procedure, public, PASS( Obj ) :: ReadPointEntity => ent_read_point Read the entry from file for point interface This subroutine reads the entry for point entity private subroutine ent_read_point(Obj, mshFile, readTag, ierr) This subroutine reads the entry for point entity Arguments Type Intent Optional Attributes Name class( mshEntity_ ), intent(inout) :: Obj type(File_), intent(inout) :: mshFile logical(kind=LGT), intent(in) :: readTag logical(kind=LGT), intent(inout) :: ierr procedure, public, PASS( Obj ) :: ReadSurfaceEntity => ent_read_Surface Read the entry from file for surface interface This subroutine reads the entry for surface entity private subroutine ent_read_Surface(Obj, mshFile, readTag, ierr) This subroutine reads the entry for surface entity Arguments Type Intent Optional Attributes Name class( mshEntity_ ), intent(inout) :: Obj type(File_), intent(inout) :: mshFile logical(kind=LGT), intent(in) :: readTag logical(kind=LGT), intent(inout) :: ierr procedure, public, PASS( Obj ) :: ReadVolumeEntity => ent_read_Volume Read the entry from file for volume interface This subroutine reads the entry for volume entity private subroutine ent_read_Volume(Obj, mshFile, readTag, ierr) This subroutine reads the entry for volume entity Arguments Type Intent Optional Attributes Name class( mshEntity_ ), intent(inout) :: Obj type(File_), intent(inout) :: mshFile logical(kind=LGT), intent(in) :: readTag logical(kind=LGT), intent(inout) :: ierr procedure, public, PASS( Obj ) :: TotalBoundingTags => ent_tBoundingtag Returns the total bounding tags interface This function returns the total number of bounding tags in entity private pure function ent_tBoundingtag(Obj) result(Ans) This function returns the total number of bounding tags in entity Arguments Type Intent Optional Attributes Name class( mshEntity_ ), intent(in) :: Obj Return Value integer(kind=I4B) procedure, public, PASS( Obj ) :: TotalElements => ent_telements Returns the total elements interface This function returns the total number of elements in entity private pure function ent_telements(Obj) result(Ans) This function returns the total number of elements in entity Arguments Type Intent Optional Attributes Name class( mshEntity_ ), intent(in) :: Obj Return Value integer(kind=I4B) procedure, public, PASS( Obj ) :: TotalPhysicalTags => ent_tphysicaltag Return total physical tags associated interface This function returns the total number of physical tags in entity private pure function ent_tphysicaltag(Obj) result(Ans) This function returns the total number of physical tags in entity Arguments Type Intent Optional Attributes Name class( mshEntity_ ), intent(in) :: Obj Return Value integer(kind=I4B) procedure, public, PASS( Obj ) :: WriteToFile => ent_write_file Write data to a file interface This subroutine write the data to a file private subroutine ent_write_file(Obj, mshFile, Str, EndStr) This subroutine write the data to a file Arguments Type Intent Optional Attributes Name class( mshEntity_ ), intent(inout) :: Obj type(File_), intent(inout) :: mshFile character(len=*), intent(in), optional :: Str character(len=*), intent(in), optional :: EndStr Source Code TYPE :: mshEntity_ INTEGER ( I4B ) :: uid = 0 !! unique id of entity INTEGER ( I4B ) :: XiDim = 0 !! for point=0, curve=1, surface = 2, volume = 3 INTEGER ( I4B ) :: ElemType = 0 !! element type in meshing INTEGER ( I4B ), ALLOCATABLE :: PhysicalTag ( : ) !! Physical tags associated INTEGER ( I4B ), ALLOCATABLE :: NodeNumber ( : ) !! node numbers in mesh INTEGER ( I4B ), ALLOCATABLE :: ElemNumber ( : ) !! element numbers in mesh INTEGER ( I4B ), ALLOCATABLE :: Nptrs ( :, : ) !! connectivity INTEGER ( I4B ), ALLOCATABLE :: BoundingEntity ( : ) !! tag of bounding entity REAL ( DFP ) :: minX = 0.0_DFP !! bounding box of entity REAL ( DFP ) :: minY = 0.0_DFP !! bounding box of entity REAL ( DFP ) :: minZ = 0.0_DFP !! bounding box of entity REAL ( DFP ) :: maxX = 0.0_DFP !! bounding box of entity REAL ( DFP ) :: maxY = 0.0_DFP !! bounding box of entity REAL ( DFP ) :: maxZ = 0.0_DFP !! bounding box of entity REAL ( DFP ) :: X = 0.0_DFP !! used only for point entity REAL ( DFP ) :: Y = 0.0_DFP !! used only for point entity REAL ( DFP ) :: Z = 0.0_DFP !! used only for point entity REAL ( DFP ), ALLOCATABLE :: NodeCoord ( :, : ) !! nodal coordinates in xiJ format CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: Finalize => ent_deallocateData !! To deallocate data PROCEDURE , PUBLIC , PASS ( Obj ) :: GotoTag => ent_goto !! To find tag PROCEDURE , PUBLIC , PASS ( Obj ) :: ReadPointEntity => ent_read_point !! Read the entry from file for point PROCEDURE , PUBLIC , PASS ( Obj ) :: ReadCurveEntity => ent_Read_Curve !! Read the entry from file for curve PROCEDURE , PUBLIC , PASS ( Obj ) :: ReadSurfaceEntity => ent_Read_Surface !! Read the entry from file for surface PROCEDURE , PUBLIC , PASS ( Obj ) :: ReadVolumeEntity => ent_Read_Volume !! Read the entry from file for volume PROCEDURE , PUBLIC , PASS ( Obj ) :: TotalPhysicalTags => ent_tphysicaltag !! Return total physical tags associated PROCEDURE , PUBLIC , PASS ( Obj ) :: TotalBoundingTags => ent_tboundingtag !! Returns the total bounding tags PROCEDURE , PUBLIC , PASS ( Obj ) :: TotalElements => ent_telements !! Returns the total elements PROCEDURE , PUBLIC , PASS ( Obj ) :: WriteToFile => ent_write_file !! Write data to a file END TYPE mshEntity_","tags":"","loc":"type/mshentity_.html"},{"title":"mshNodesPointer_ – Fortran Program ","text":"type, public :: mshNodesPointer_ Contents Variables Ptr Source Code mshNodesPointer_ Components Type Visibility Attributes Name Initial class( mshNodes_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: mshNodesPointer_ CLASS ( mshNodes_ ), POINTER :: Ptr => NULL ( ) END TYPE mshNodesPointer_","tags":"","loc":"type/mshnodespointer_.html"},{"title":"mshNodes_ – Fortran Program ","text":"type, public :: mshNodes_ This class is defined to handle the nodes in mesh file Contents Variables isSparse maxNodeTag minNodeTag numEntityBlocks numNodes Type-Bound Procedures Finalize GotoTag ReadFromFile WriteToFile Source Code mshNodes_ Components Type Visibility Attributes Name Initial logical(kind=LGT), public :: isSparse = .FALSE. isSparse integer(kind=I4B), public :: maxNodeTag = 0 maximum node number integer(kind=I4B), public :: minNodeTag = 0 minimum node number integer(kind=I4B), public :: numEntityBlocks = 0 number of entity blocks integer(kind=I4B), public :: numNodes = 0 number of nodes Type-Bound Procedures procedure, public, PASS( Obj ) :: Finalize => n_deallocatedata DeallocateData From the object interface This subroutine deallocate the data form the instance private subroutine n_deallocatedata(Obj) This subroutine deallocate the data from instance Arguments Type Intent Optional Attributes Name class( mshNodes_ ), intent(inout) :: Obj procedure, public, PASS( Obj ) :: GotoTag => n_goto Go to the node tag in mesh file interface This subroutine go to the position where nodes are defined private subroutine n_goto(Obj, mshFile, ierr) This subroutine go to the position where nodes are defined Arguments Type Intent Optional Attributes Name class( mshNodes_ ), intent(in) :: Obj type(File_), intent(inout) :: mshFile logical(kind=LGT), intent(inout) :: ierr procedure, public, PASS( Obj ) :: ReadFromFile => n_read_file read content from file interface This subroutine read data from mesh file private subroutine n_read_file(Obj, mshFile, mshFormat, ierr) This subroutine read data from mesh file Arguments Type Intent Optional Attributes Name class( mshNodes_ ), intent(inout) :: Obj type(File_), intent(inout) :: mshFile type(mshFormat_), intent(inout) :: mshFormat logical(kind=LGT), intent(inout) :: ierr procedure, public, PASS( Obj ) :: WriteToFile => n_write_file write data to file interface This subroutine write data to a file private subroutine n_write_file(Obj, mshFile, mshFormat, Str, EndStr) This subroutine writes data to a file Arguments Type Intent Optional Attributes Name class( mshNodes_ ), intent(inout) :: Obj type(File_), intent(inout) :: mshFile type(mshFormat_), intent(inout) :: mshFormat character(len=*), intent(in), optional :: Str character(len=*), intent(in), optional :: EndStr Source Code TYPE :: mshNodes_ INTEGER ( I4B ) :: numNodes = 0 !! number of nodes INTEGER ( I4B ) :: numEntityBlocks = 0 !msh4 !! number of entity blocks INTEGER ( I4B ) :: minNodeTag = 0 !msh4 !! minimum node number INTEGER ( I4B ) :: maxNodeTag = 0 !msh4 !! maximum node number LOGICAL ( LGT ) :: isSparse = . FALSE . !msh4 !! isSparse CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: Finalize => n_deallocateData !! DeallocateData From the object PROCEDURE , PUBLIC , PASS ( Obj ) :: GotoTag => n_goto !! Go to the node tag in mesh file PROCEDURE , PUBLIC , PASS ( Obj ) :: ReadFromFile => n_read_file !! read content from file PROCEDURE , PUBLIC , PASS ( Obj ) :: WriteToFile => n_write_file !! write data to file END TYPE mshNodes_","tags":"","loc":"type/mshnodes_.html"},{"title":"gmshModel_ – Fortran Program ","text":"type, public :: gmshModel_ This data type is container for all the gmsh models Contents Variables Curve_EntityToPhysical Curve_PhysicalToEntity EntityCurveName EntityPointName EntitySurfaceName EntityVolumeName PhysicalCurveName PhysicalCurveUID PhysicalPointName PhysicalPointUID PhysicalSurfaceName PhysicalSurfaceUID PhysicalVolumeName PhysicalVolumeUID Point_EntityToPhysical Point_PhysicalToEntity Surface_EntityToPhysical Surface_PhysicalToEntity Volume_EntityToPhysical Volume_PhysicalToEntity buffer geo mesh name next Type-Bound Procedures add addPhysicalGroup getEntities getEntitiesForPhysicalGroup getEntityName getPhysicalGroups getPhysicalGroupsForEntity getPhysicalName setEntityName setPhysicalName write Source Code gmshModel_ Components Type Visibility Attributes Name Initial type(IntVectorPointer_), public, ALLOCATABLE :: Curve_EntityToPhysical (:) type(IntVectorPointer_), public, ALLOCATABLE :: Curve_PhysicalToEntity (:) type(String), public, ALLOCATABLE :: EntityCurveName (:) type(String), public, ALLOCATABLE :: EntityPointName (:) type(String), public, ALLOCATABLE :: EntitySurfaceName (:) type(String), public, ALLOCATABLE :: EntityVolumeName (:) type(String), public, ALLOCATABLE :: PhysicalCurveName (:) integer(kind=I4B), public, ALLOCATABLE :: PhysicalCurveUID (:) type(String), public, ALLOCATABLE :: PhysicalPointName (:) integer(kind=I4B), public, ALLOCATABLE :: PhysicalPointUID (:) type(String), public, ALLOCATABLE :: PhysicalSurfaceName (:) integer(kind=I4B), public, ALLOCATABLE :: PhysicalSurfaceUID (:) type(String), public, ALLOCATABLE :: PhysicalVolumeName (:) integer(kind=I4B), public, ALLOCATABLE :: PhysicalVolumeUID (:) type(IntVectorPointer_), public, ALLOCATABLE :: Point_EntityToPhysical (:) type(IntVectorPointer_), public, ALLOCATABLE :: Point_PhysicalToEntity (:) type(IntVectorPointer_), public, ALLOCATABLE :: Surface_EntityToPhysical (:) type(IntVectorPointer_), public, ALLOCATABLE :: Surface_PhysicalToEntity (:) type(IntVectorPointer_), public, ALLOCATABLE :: Volume_EntityToPhysical (:) type(IntVectorPointer_), public, ALLOCATABLE :: Volume_PhysicalToEntity (:) type(Buffer_), public, POINTER :: buffer => NULL() type(gmshGeo_), public, POINTER :: geo => NULL() geometry due to internal kernel This experimental feature type(gmshMesh_), public, POINTER :: mesh => NULL() character(len=5), public :: name = \"\" We can use this file two take backups and write content of model type( gmshModel_ ), public, POINTER :: next => NULL() Pointer to the next model for linked list Type-Bound Procedures procedure, public, PASS( Obj ) :: add => model_add private function model_add (Obj, Name) result(Ans) This function add the model\n Currently only one model can be added\n model_name_buffer.txt Arguments Type Intent Optional Attributes Name class( gmshModel_ ), intent(inout), TARGET :: Obj character(len=*), intent(in) :: Name Return Value integer(kind=I4B) procedure, public, PASS( Obj ) :: addPhysicalGroup => model_addPhysicalGroup private function model_addPhysicalGroup (Obj, dim, tags, uid) result(Ans) Add a physical group of dimension dim, grouping the model entities with\n tags tags. Return the tag of the physical group, equal to tag if tag is\n positive, or a new tag if tag < 0.\n check\n check\n If it is the first call then\n check\n check\n If it is the first call then\n check\n check\n If it is the first call then\n check\n check\n If it is the first call then Arguments Type Intent Optional Attributes Name class( gmshModel_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: dim integer(kind=I4B), intent(in) :: tags (:) integer(kind=I4B), intent(in) :: uid Return Value integer(kind=I4B) procedure, public, PASS( Obj ) :: getEntities => model_getEntities private function model_getEntities (Obj, dim) result(Ans) Get all the entities in the current model. If dim is >= 0, return only\n the entities of the specified dimension (e.g. points if dim == 0).\n The entities are returned as a vector of (dim, tag) integer pairs. Arguments Type Intent Optional Attributes Name class( gmshModel_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: dim Return Value integer(kind=I4B),\n  ALLOCATABLE, (:,:) procedure, public, PASS( Obj ) :: getEntitiesForPhysicalGroup => model_getEntitiesForPhysicalGroup private function model_getEntitiesForPhysicalGroup (Obj, dim, tag) result(Ans) Get the tags of the model entities making up the physical group of\n dimension dim and tag tag. Arguments Type Intent Optional Attributes Name class( gmshModel_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: dim integer(kind=I4B), intent(in) :: tag Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) procedure, public, PASS( Obj ) :: getEntityName => model_getEntityName private function model_getEntityName (Obj, dim, tag) result(Ans) get the name of the entity of dimension dim and tag tag Arguments Type Intent Optional Attributes Name class( gmshModel_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: dim integer(kind=I4B), intent(in) :: tag Return Value type(String) procedure, public, PASS( Obj ) :: getPhysicalGroups => model_getPhysicalGroups private function model_getPhysicalGroups (Obj, dim) result(Ans) Get all the physical groups in the current model. If dim is >= 0, return\n only the entities of the specified dimension (e.g. physical points\n if dim == 0). The entities are returned as a vector of (dim, tag)\n integer pairs. Arguments Type Intent Optional Attributes Name class( gmshModel_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: dim Return Value integer(kind=I4B),\n  ALLOCATABLE, (:,:) procedure, public, PASS( Obj ) :: getPhysicalGroupsForEntity => model_getPhysicalGroupsForEntity private function model_getPhysicalGroupsForEntity (Obj, dim, tag) result(Ans) Get the tags of the physical groups (if any) to which the model entity of\n dimension dim and tag tag belongs. Arguments Type Intent Optional Attributes Name class( gmshModel_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: dim integer(kind=I4B), intent(in) :: tag Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) procedure, public, PASS( Obj ) :: getPhysicalName => model_getPhysicalName private function model_getPhysicalName (Obj, dim, tag) result(Ans) Arguments Type Intent Optional Attributes Name class( gmshModel_ ), intent(in) :: Obj integer(kind=I4B) :: dim integer(kind=I4B) :: tag Return Value type(String) procedure, public, PASS( Obj ) :: setEntityName => model_setEntityName private function model_setEntityName (Obj, dim, tag, name) result(Ans) Set the name of the entity of dimension dim and tag tag Arguments Type Intent Optional Attributes Name class( gmshModel_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: dim integer(kind=I4B), intent(in) :: tag character(len=*), intent(in) :: name Return Value integer(kind=I4B) procedure, public, PASS( Obj ) :: setPhysicalName => model_setPhysicalName private function model_setPhysicalName (Obj, dim, tag, name) result(Ans) Set the name of the physical group of dimension dim and tag tag. Arguments Type Intent Optional Attributes Name class( gmshModel_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: dim integer(kind=I4B), intent(in) :: tag character(len=*), intent(in) :: name Return Value integer(kind=I4B) procedure, public, PASS( Obj ) :: write => model_write private function model_write (Obj, UnitNo) result(Ans) Arguments Type Intent Optional Attributes Name class( gmshModel_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: UnitNo Return Value integer(kind=I4B) Source Code TYPE :: gmshModel_ TYPE ( Buffer_ ), POINTER :: buffer => NULL ( ) CHARACTER ( LEN = 5 ) :: name = \"\" !! We can use this file two take backups and write content of model TYPE ( gmshGeo_ ), POINTER :: geo => NULL ( ) !! geometry due to internal kernel ! TYPE( gmshOCC_ ), POINTER :: occ => NULL( ) !! This experimental feature TYPE ( gmshMesh_ ), POINTER :: mesh => NULL ( ) TYPE ( String ), ALLOCATABLE :: EntityPointName ( : ) TYPE ( String ), ALLOCATABLE :: EntityCurveName ( : ) TYPE ( String ), ALLOCATABLE :: EntitySurfaceName ( : ) TYPE ( String ), ALLOCATABLE :: EntityVolumeName ( : ) TYPE ( String ), ALLOCATABLE :: PhysicalPointName ( : ) TYPE ( String ), ALLOCATABLE :: PhysicalCurveName ( : ) TYPE ( String ), ALLOCATABLE :: PhysicalSurfaceName ( : ) TYPE ( String ), ALLOCATABLE :: PhysicalVolumeName ( : ) INTEGER ( I4B ), ALLOCATABLE :: PhysicalPointUID ( : ) INTEGER ( I4B ), ALLOCATABLE :: PhysicalCurveUID ( : ) INTEGER ( I4B ), ALLOCATABLE :: PhysicalSurfaceUID ( : ) INTEGER ( I4B ), ALLOCATABLE :: PhysicalVolumeUID ( : ) TYPE ( IntVectorPointer_ ), ALLOCATABLE :: Point_PhysicalToEntity ( : ) TYPE ( IntVectorPointer_ ), ALLOCATABLE :: Curve_PhysicalToEntity ( : ) TYPE ( IntVectorPointer_ ), ALLOCATABLE :: Surface_PhysicalToEntity ( : ) TYPE ( IntVectorPointer_ ), ALLOCATABLE :: Volume_PhysicalToEntity ( : ) TYPE ( IntVectorPointer_ ), ALLOCATABLE :: Point_EntityToPhysical ( : ) TYPE ( IntVectorPointer_ ), ALLOCATABLE :: Curve_EntityToPhysical ( : ) TYPE ( IntVectorPointer_ ), ALLOCATABLE :: Surface_EntityToPhysical ( : ) TYPE ( IntVectorPointer_ ), ALLOCATABLE :: Volume_EntityToPhysical ( : ) TYPE ( gmshModel_ ), POINTER :: next => NULL ( ) !! Pointer to the next model for linked list CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: add => model_add ! PROCEDURE, PUBLIC, PASS( Obj ) :: remove => model_remove ! PROCEDURE, PUBLIC, PASS( Obj ) :: list => model_list ! PROCEDURE, PUBLIC, PASS( Obj ) :: getCurrent => model_getCurrent ! PROCEDURE, PUBLIC, PASS( Obj ) :: setCurrent => model_setCurrent PROCEDURE , PUBLIC , PASS ( Obj ) :: write => model_write PROCEDURE , PUBLIC , PASS ( Obj ) :: getEntities => model_getEntities PROCEDURE , PUBLIC , PASS ( Obj ) :: setEntityName => model_setEntityName PROCEDURE , PUBLIC , PASS ( Obj ) :: getEntityName => model_getEntityName PROCEDURE , PUBLIC , PASS ( Obj ) :: addPhysicalGroup => & & model_addPhysicalGroup PROCEDURE , PUBLIC , PASS ( Obj ) :: getPhysicalGroups => & & model_getPhysicalGroups PROCEDURE , PUBLIC , PASS ( Obj ) :: getEntitiesForPhysicalGroup => & & model_getEntitiesForPhysicalGroup PROCEDURE , PUBLIC , PASS ( Obj ) :: getPhysicalGroupsForEntity => & & model_getPhysicalGroupsForEntity PROCEDURE , PUBLIC , PASS ( Obj ) :: setPhysicalName => & & model_setPhysicalName PROCEDURE , PUBLIC , PASS ( Obj ) :: getPhysicalName => & & model_getPhysicalName END TYPE gmshModel_","tags":"","loc":"type/gmshmodel_.html"},{"title":"ExpSFCC_ – Fortran Program ","text":"type, public, EXTENDS( SFCCModel_ ) :: ExpSFCC_ Contents Variables Coeff Temp_l Temp_s Theta_r Theta_w Source Code ExpSFCC_ Components Type Visibility Attributes Name Initial real(kind=DFP), public :: Coeff = 1.0_DFP exponent real(kind=DFP), public :: Temp_l = 0.0_DFP Freezing temp liquid side real(kind=DFP), public :: Temp_s = 0.0_DFP Freezing temp solid dide real(kind=DFP), public :: Theta_r = 0.0_DFP residual real(kind=DFP), public :: Theta_w = 0.0_DFP TotalWater content Source Code TYPE , EXTENDS ( SFCCModel_ ) :: ExpSFCC_ REAL ( DFP ) :: Theta_r = 0.0_DFP !! residual REAL ( DFP ) :: Theta_w = 0.0_DFP !! TotalWater content REAL ( DFP ) :: Temp_l = 0.0_DFP !! Freezing temp liquid side REAL ( DFP ) :: Temp_s = 0.0_DFP !! Freezing temp solid dide REAL ( DFP ) :: Coeff = 1.0_DFP !! exponent END TYPE ExpSFCC_","tags":"","loc":"type/expsfcc_.html"},{"title":"SFCCModelPointer_ – Fortran Program ","text":"type, public :: SFCCModelPointer_ Contents Variables Ptr Source Code SFCCModelPointer_ Components Type Visibility Attributes Name Initial class( SFCCModel_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: SFCCModelPointer_ CLASS ( SFCCModel_ ), POINTER :: Ptr => NULL () END TYPE SFCCModelPointer_","tags":"","loc":"type/sfccmodelpointer_.html"},{"title":"SFCCModel_ – Fortran Program ","text":"type, public, ABSTRACT :: SFCCModel_ Contents Variables PhaseInfo getSlope getValue Source Code SFCCModel_ Components Type Visibility Attributes Name Initial procedure( ExpSFCC_PhaseInfo ), public, POINTER, PASS( Obj ) :: PhaseInfo => NULL() procedure( ExpSFCC_get_slope ), public, POINTER, PASS( Obj ) :: getSlope => NULL() procedure( ExpSFCC_get_val ), public, POINTER, PASS( Obj ) :: getValue => NULL() Source Code TYPE , ABSTRACT :: SFCCModel_ PROCEDURE ( ExpSFCC_get_val ), POINTER , PASS ( Obj ) :: getValue => NULL () PROCEDURE ( ExpSFCC_get_slope ), POINTER , PASS ( Obj ) :: getSlope => NULL () PROCEDURE ( ExpSFCC_PhaseInfo ), POINTER , PASS ( Obj ) :: PhaseInfo => NULL () END TYPE SFCCModel_","tags":"","loc":"type/sfccmodel_.html"},{"title":"UserSFCC_ – Fortran Program ","text":"type, public, EXTENDS( SFCCModel_ ) :: UserSFCC_ Contents Source Code UserSFCC_ Source Code TYPE , EXTENDS ( SFCCModel_ ) :: UserSFCC_ END TYPE UserSFCC_","tags":"","loc":"type/usersfcc_.html"},{"title":"MixVolHeatCap_ – Fortran Program ","text":"type, public, EXTENDS( VolHeatCapModel_ ) :: MixVolHeatCap_ Contents Variables Frozen State Unfrozen Source Code MixVolHeatCap_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: Frozen = STATE_FROZEN integer(kind=I4B), public :: State = STATE_UNFROZEN integer(kind=I4B), public :: Unfrozen = STATE_UNFROZEN Source Code TYPE , EXTENDS ( VolHeatCapModel_ ) :: MixVolHeatCap_ INTEGER ( I4B ) :: State = STATE_UNFROZEN INTEGER ( I4B ) :: Frozen = STATE_FROZEN INTEGER ( I4B ) :: Unfrozen = STATE_UNFROZEN END TYPE MixVolHeatCap_","tags":"","loc":"type/mixvolheatcap_.html"},{"title":"UserVolHeatCap_ – Fortran Program ","text":"type, private, EXTENDS( volHeatCapModel_ ) :: UserVolHeatCap_ Contents Source Code UserVolHeatCap_ Source Code TYPE , EXTENDS ( volHeatCapModel_ ) :: UserVolHeatCap_ END TYPE UserVolHeatCap_","tags":"","loc":"type/uservolheatcap_.html"},{"title":"VolHeatCapModelPointer_ – Fortran Program ","text":"type, public :: VolHeatCapModelPointer_ Contents Variables Ptr Source Code VolHeatCapModelPointer_ Components Type Visibility Attributes Name Initial class( VolHeatCapModel_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: VolHeatCapModelPointer_ CLASS ( VolHeatCapModel_ ), POINTER :: Ptr => NULL () END TYPE VolHeatCapModelPointer_","tags":"","loc":"type/volheatcapmodelpointer_.html"},{"title":"VolHeatCapModel_ – Fortran Program ","text":"type, public, ABSTRACT :: VolHeatCapModel_ Contents Variables ConstVolHeatCapVal getValue is_volHeatCap_solid_given volHeatCap_solid Source Code VolHeatCapModel_ Components Type Visibility Attributes Name Initial real(kind=DFP), public :: ConstVolHeatCapVal = 0.0_DFP procedure( mixvolheatcap_getval ), public, POINTER, PASS( Obj ) :: getValue => NULL() logical(kind=LGT), public :: is_volHeatCap_solid_given = .FALSE. real(kind=DFP), public :: volHeatCap_solid = 2650.0_DFP*733.0_DFP Source Code TYPE , ABSTRACT :: VolHeatCapModel_ REAL ( DFP ) :: ConstVolHeatCapVal = 0.0_DFP REAL ( DFP ) :: volHeatCap_solid = 265 0.0_DFP * 73 3.0_DFP LOGICAL ( LGT ) :: is_volHeatCap_solid_given = . FALSE . PROCEDURE ( mixvolheatcap_getval ), POINTER , PASS ( Obj ) :: & & getValue => NULL () END TYPE VolHeatCapModel_","tags":"","loc":"type/volheatcapmodel_.html"},{"title":"JohansenThermCond_ – Fortran Program ","text":"type, public, EXTENDS( ThermCondModel_ ) :: JohansenThermCond_ Contents Variables CoarseGrained FineGrained Frozen Gamma_d Lambda_Dry Lambda_Sat Lambda_e Lambda_s Peat QuartzContent SoilType State Unfrozen isLambda_dry_given isLambda_e_given isLambda_sat_given Source Code JohansenThermCond_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: CoarseGrained = SOIL_COARSE_GRAINED integer(kind=I4B), public :: FineGrained = SOIL_FINE_GRAINED integer(kind=I4B), public :: Frozen = STATE_FROZEN real(kind=DFP), public :: Gamma_d = 1600.0_DFP real(kind=DFP), public :: Lambda_Dry = 0.0_DFP real(kind=DFP), public :: Lambda_Sat = 0.0_DFP real(kind=DFP), public :: Lambda_e = 0.0_DFP real(kind=DFP), public :: Lambda_s = 0.0_DFP integer(kind=I4B), public :: Peat = SOIL_PEAT real(kind=DFP), public :: QuartzContent = 1.0_DFP integer(kind=I4B), public :: SoilType = SOIL_COARSE_GRAINED integer(kind=I4B), public :: State = STATE_UNFROZEN integer(kind=I4B), public :: Unfrozen = STATE_UNFROZEN logical, public :: isLambda_dry_given = .FALSE. logical, public :: isLambda_e_given = .FALSE. logical, public :: isLambda_sat_given = .FALSE. Source Code TYPE , EXTENDS ( ThermCondModel_ ) :: JohansenThermCond_ INTEGER ( I4B ) :: State = STATE_UNFROZEN INTEGER ( I4B ) :: Frozen = STATE_FROZEN INTEGER ( I4B ) :: Unfrozen = STATE_UNFROZEN INTEGER ( I4B ) :: SoilType = SOIL_COARSE_GRAINED INTEGER ( I4B ) :: FineGrained = SOIL_FINE_GRAINED INTEGER ( I4B ) :: CoarseGrained = SOIL_COARSE_GRAINED INTEGER ( I4B ) :: Peat = SOIL_PEAT REAL ( DFP ) :: Lambda_Sat = 0.0_DFP REAL ( DFP ) :: Lambda_Dry = 0.0_DFP REAL ( DFP ) :: Lambda_e = 0.0_DFP REAL ( DFP ) :: Lambda_s = 0.0_DFP LOGICAL :: isLambda_sat_given = . FALSE . LOGICAL :: isLambda_dry_given = . FALSE . LOGICAL :: isLambda_e_given = . FALSE . REAL ( DFP ) :: Gamma_d = 160 0.0_DFP REAL ( DFP ) :: QuartzContent = 1.0_DFP END TYPE JohansenThermCond_","tags":"","loc":"type/johansenthermcond_.html"},{"title":"ThermCondModelPointer_ – Fortran Program ","text":"type, public :: ThermCondModelPointer_ Contents Variables Ptr Source Code ThermCondModelPointer_ Components Type Visibility Attributes Name Initial class( ThermCondModel_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: ThermCondModelPointer_ CLASS ( ThermCondModel_ ), POINTER :: Ptr => NULL () END TYPE ThermCondModelPointer_","tags":"","loc":"type/thermcondmodelpointer_.html"},{"title":"ThermCondModel_ – Fortran Program ","text":"type, public, ABSTRACT :: ThermCondModel_ Contents Variables ConstThermCondVal getValue Source Code ThermCondModel_ Components Type Visibility Attributes Name Initial real(kind=DFP), public :: ConstThermCondVal = 0.0_DFP procedure( johansen_getval ), public, POINTER, PASS( Obj ) :: getValue => NULL() Source Code TYPE , ABSTRACT :: ThermCondModel_ REAL ( DFP ) :: ConstThermCondVal = 0.0_DFP PROCEDURE ( johansen_getval ), POINTER , PASS ( Obj ) :: getValue => NULL () END TYPE ThermCondModel_","tags":"","loc":"type/thermcondmodel_.html"},{"title":"UserThermCond_ – Fortran Program ","text":"type, public, EXTENDS( ThermCondModel_ ) :: UserThermCond_ Contents Source Code UserThermCond_ Source Code TYPE , EXTENDS ( ThermCondModel_ ) :: UserThermCond_ END TYPE UserThermCond_","tags":"","loc":"type/userthermcond_.html"},{"title":"LIS_ – Fortran Program ","text":"type, public, EXTENDS( LinSolver_ ) :: LIS_ Contents Variables A IA JA dbcIA dbcIndx dbcJA dbcNptrs lis_mat lis_precon lis_res lis_rhs lis_sol lis_solver Type-Bound Procedures DeallocateData Display Initiate Solve setMatrix setPrecondition setSparsity set_dbcNodes_1 set_dbcNodes_2 writeResidueHistory Source Code LIS_ Components Type Visibility Attributes Name Initial real(kind=DFP), public, ALLOCATABLE :: A (:) integer(kind=I4B), public, ALLOCATABLE :: IA (:) integer(kind=I4B), public, ALLOCATABLE :: JA (:) integer(kind=I4B), public, ALLOCATABLE :: dbcIA (:) integer(kind=I4B), public, ALLOCATABLE :: dbcIndx (:) integer(kind=I4B), public, ALLOCATABLE :: dbcJA (:) integer(kind=I4B), public, ALLOCATABLE :: dbcNptrs (:) type(integer), public :: lis_mat = 0 type(integer), public :: lis_precon = 0 type(integer), public :: lis_res = 0 type(integer), public :: lis_rhs = 0 type(integer), public :: lis_sol = 0 type(integer), public :: lis_solver = 0 Type-Bound Procedures procedure, public, PASS( Obj ) :: DeallocateData => lis_deallocatedata Deallocate Data interface private subroutine lis_deallocatedata(Obj) Arguments Type Intent Optional Attributes Name class( LIS_ ), intent(inout) :: Obj procedure, public, PASS( Obj ) :: Display => lis_display Display the contents interface private subroutine lis_display(Obj, msg, unitno) Arguments Type Intent Optional Attributes Name class( LIS_ ), intent(in) :: Obj character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitno procedure, public, PASS( Obj ) :: Initiate => lis_initiate Initiate object interface — fpar( 1 ) : contains value of omega private subroutine lis_initiate(Obj, SolverName, MaxIter, Tol, diagScale, ipar, fpar) Arguments Type Intent Optional Attributes Name class( LIS_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: SolverName integer(kind=I4B), intent(in) :: MaxIter real(kind=DFP), intent(in) :: Tol integer(kind=I4B), intent(in), optional :: diagScale integer(kind=I4B), intent(in), optional :: ipar (:) real(kind=DFP), intent(in), optional :: fpar (:) procedure, public, PASS( Obj ) :: Solve => lis_solve_1 Solve the system of linear equation interface private subroutine lis_solve_1(Obj, sol, rhs) Arguments Type Intent Optional Attributes Name class( LIS_ ), intent(inout) :: Obj real(kind=DFP), intent(inout) :: sol (:) real(kind=DFP), intent(inout) :: rhs (:) procedure, public, PASS( To ) :: setMatrix => lis_setmatrix set/link tangent matrix to the linear solver engine interface private subroutine lis_setmatrix(From, To) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(in), TARGET :: From class( LIS_ ), intent(inout) :: To procedure, public, PASS( Obj ) :: setPrecondition => lis_setprecond Set preconditioner properties interface private subroutine lis_setprecond(Obj, precondtype, ipar, fpar) Arguments Type Intent Optional Attributes Name class( LIS_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: precondtype integer(kind=I4B), intent(in), optional :: ipar (:) real(kind=DFP), intent(in), optional :: fpar (:) procedure, public, PASS( To ) :: setSparsity => lis_set_sparsity Set sparsity pattern related information of tangent matrix interface — set all values of lis_rhs and lis_sol to zero\n— set csr private subroutine lis_set_sparsity(From, To) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(in), TARGET :: From class( LIS_ ), intent(inout) :: To procedure, public, PASS( Obj ) :: set_dbcNodes_1 => lis_setDBC_1 set Information about the Dirichlet boundary nodes interface private subroutine lis_setDBC_1(Obj, Nptrs, dofs) Arguments Type Intent Optional Attributes Name class( LIS_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Nptrs (:) integer(kind=I4B), intent(in) :: dofs (:) procedure, public, PASS( Obj ) :: set_dbcNodes_2 => lis_setDBC_2 set Information about the Dirichlet boundary nodes interface private subroutine lis_setDBC_2(Obj, Nptrs, dofs) Arguments Type Intent Optional Attributes Name class( LIS_ ), intent(inout) :: Obj type(IntVector_), intent(in) :: Nptrs (:) integer(kind=I4B), intent(in) :: dofs (:) procedure, public, PASS( Obj ) :: writeResidueHistory => lis_write_res_his Output the residue history interface private subroutine lis_write_res_his(Obj, path, prefix, fmt, iter) Arguments Type Intent Optional Attributes Name class( LIS_ ), intent(in) :: Obj character(len=*), intent(in) :: path character(len=*), intent(in) :: prefix character(len=*), intent(in) :: fmt integer(kind=I4B), intent(in), optional :: iter Source Code TYPE , EXTENDS ( LinSolver_ ) :: LIS_ TYPE ( LIS_MATRIX ) :: lis_mat = 0 TYPE ( LIS_VECTOR ) :: lis_rhs = 0 TYPE ( LIS_VECTOR ) :: lis_sol = 0 TYPE ( LIS_VECTOR ) :: lis_res = 0 TYPE ( LIS_PRECON ) :: lis_precon = 0 TYPE ( LIS_SOLVER ) :: lis_solver = 0 REAL ( DFP ), ALLOCATABLE :: A ( : ) INTEGER ( I4B ), ALLOCATABLE :: IA ( : ) INTEGER ( I4B ), ALLOCATABLE :: JA ( : ) INTEGER ( I4B ), ALLOCATABLE :: dbcNptrs ( : ) INTEGER ( I4B ), ALLOCATABLE :: dbcIndx ( : ) INTEGER ( I4B ), ALLOCATABLE :: dbcJA ( : ) INTEGER ( I4B ), ALLOCATABLE :: dbcIA ( : ) CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: Initiate => lis_initiate !! Initiate object PROCEDURE , PUBLIC , PASS ( Obj ) :: setPrecondition => lis_setprecond !! Set preconditioner properties PROCEDURE , PUBLIC , PASS ( To ) :: setSparsity => lis_set_sparsity !! Set sparsity pattern related information of tangent matrix PROCEDURE , PUBLIC , PASS ( Obj ) :: set_dbcNodes_1 => lis_setDBC_1 !! set Information about the Dirichlet boundary nodes PROCEDURE , PUBLIC , PASS ( Obj ) :: set_dbcNodes_2 => lis_setDBC_2 !! set Information about the Dirichlet boundary nodes PROCEDURE , PUBLIC , PASS ( To ) :: setMatrix => lis_setmatrix !! set/link tangent matrix to the linear solver engine PROCEDURE , PUBLIC , PASS ( Obj ) :: Solve => lis_solve_1 !! Solve the system of linear equation PROCEDURE , PUBLIC , PASS ( Obj ) :: Display => lis_display !! Display the contents PROCEDURE , PUBLIC , PASS ( Obj ) :: writeResidueHistory => lis_write_res_his !! Output the residue history PROCEDURE , PUBLIC , PASS ( Obj ) :: DeallocateData => lis_deallocatedata !! Deallocate Data END TYPE LIS_","tags":"","loc":"type/lis_.html"},{"title":"LinSolverPointer_ – Fortran Program ","text":"type, private :: LinSolverPointer_ This data type contains pointer to LinSolver_ Contents Variables Ptr Source Code LinSolverPointer_ Components Type Visibility Attributes Name Initial class( LinSolver_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: LinSolverPointer_ CLASS ( LinSolver_ ), POINTER :: Ptr => NULL ( ) END TYPE LinSolverPointer_","tags":"","loc":"type/linsolverpointer_.html"},{"title":"LinSolver_ – Fortran Program ","text":"type, public, ABSTRACT :: LinSolver_ LinSolver_ is an abstract class for solving system of linear equation Note It is important to node that LinSolver_ is created just to create an\n interface between EASIFEM library and other existing open-source\n and powerful linear solver libraries. Usage fortran\n    CALL Obj % Initiate( Obj, SolverName, MaxIter, SolverName &\n    & <, diagScale, ipar, fpar> )\n CALL Obj % setPrecondition( Obj, precondtype <,ipar, fpar> )\n CALL Obj % setSparsity( From )\n CALL Obj % setDirichletBCNodes( Nptrs, dofs )\n CALL Obj % setMatrix( From )\n CALL Obj % solve( sol, rhs )\n CALL Obj % Display( msg <,unitno > )\n CALL Obj % writeResidueHistory( path, prefix, fmt, iter )\n CALL Obj % DeallocateData( ) Contents Variables Matrixprop comm ierr myRank numproc precondType solverName storageFMT tNodes tdof Type-Bound Procedures DeallocateData Display Initiate Solve setDirichletBCNodes setMatrix setPrecondition setSparsity set_dbcNodes_1 set_dbcNodes_2 writeResidueHistory Source Code LinSolver_ Components Type Visibility Attributes Name Initial character(len=5), public :: Matrixprop = \"UNSYM\" Matrix Property integer(kind=I4B), public :: comm = 0 MPI COMM integer(kind=I4B), public :: ierr = 0 error code returned by the solver integer(kind=I4B), public :: myRank = 0 MPI Rank integer(kind=I4B), public :: numproc = 0 Number of processor running integer(kind=I4B), public :: precondType = 0 Name of preconditioner integer(kind=I4B), public :: solverName = 0 Solver name integer(kind=I4B), public :: storageFMT = Nodes_FMT storageFMT integer(kind=I4B), public, ALLOCATABLE :: tNodes (:) Total number of spatial nodes in each dof integer(kind=I4B), public :: tdof = 1 Total number of degrees of freedom per node Type-Bound Procedures procedure( ls_deallocate ), public, deferred, PASS( Obj ) :: DeallocateData Deallocate Data subroutine ls_deallocate(Obj) Prototype Arguments Type Intent Optional Attributes Name class( LinSolver_ ), intent(inout) :: Obj procedure( ls_display ), public, deferred, PASS( Obj ) :: Display Display the content subroutine ls_display(Obj, msg, Unitno) Prototype Arguments Type Intent Optional Attributes Name class( LinSolver_ ), intent(in) :: Obj character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: Unitno procedure( ls_init ), public, deferred, PASS( Obj ) :: Initiate Initiate the object subroutine ls_init(Obj, SolverName, MaxIter, Tol, diagScale, ipar, fpar) Prototype Arguments Type Intent Optional Attributes Name class( LinSolver_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: SolverName integer(kind=I4B), intent(in) :: MaxIter real(kind=DFP), intent(in) :: Tol integer(kind=I4B), intent(in), optional :: diagScale integer(kind=I4B), intent(in), optional :: ipar (:) real(kind=DFP), intent(in), optional :: fpar (:) procedure( ls_solve ), public, deferred, PASS( Obj ) :: Solve Solve system of linear equation subroutine ls_solve(Obj, sol, rhs) Prototype Arguments Type Intent Optional Attributes Name class( LinSolver_ ), intent(inout) :: Obj real(kind=DFP), intent(inout) :: sol (:) real(kind=DFP), intent(inout) :: rhs (:) generic, public :: setDirichletBCNodes => set_dbcNodes_1 , set_dbcNodes_2 Set Dirichlet boundary condition information subroutine ls_set_dbc_1(Obj, Nptrs, dofs) Prototype Arguments Type Intent Optional Attributes Name class( LinSolver_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Nptrs (:) integer(kind=I4B), intent(in) :: dofs (:) subroutine ls_set_dbc_2(Obj, Nptrs, dofs) Prototype Arguments Type Intent Optional Attributes Name class( LinSolver_ ), intent(inout) :: Obj type(IntVector_), intent(in) :: Nptrs (:) integer(kind=I4B), intent(in) :: dofs (:) procedure( ls_set_matrix ), public, deferred, PASS( To ) :: setMatrix Set the matrix subroutine ls_set_matrix(From, To) Prototype Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(in), TARGET :: From class( LinSolver_ ), intent(inout) :: To procedure( ls_set_precon ), public, deferred, PASS( Obj ) :: setPrecondition Set preconditioner and its properties subroutine ls_set_precon(Obj, precondtype, ipar, fpar) Prototype Arguments Type Intent Optional Attributes Name class( LinSolver_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: precondtype integer(kind=I4B), intent(in), optional :: ipar (:) real(kind=DFP), intent(in), optional :: fpar (:) procedure( ls_set_sparsity ), public, deferred, PASS( To ) :: setSparsity Set sparsity pattern subroutine ls_set_sparsity(From, To) Prototype Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(in), TARGET :: From class( LinSolver_ ), intent(inout) :: To procedure( ls_set_dbc_1 ), public, deferred, PASS( Obj ) :: set_dbcNodes_1 Set Dirichlet boundary condition information subroutine ls_set_dbc_1(Obj, Nptrs, dofs) Prototype Arguments Type Intent Optional Attributes Name class( LinSolver_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Nptrs (:) integer(kind=I4B), intent(in) :: dofs (:) procedure( ls_set_dbc_2 ), public, deferred, PASS( Obj ) :: set_dbcNodes_2 Set Dirichlet boundary condition information subroutine ls_set_dbc_2(Obj, Nptrs, dofs) Prototype Arguments Type Intent Optional Attributes Name class( LinSolver_ ), intent(inout) :: Obj type(IntVector_), intent(in) :: Nptrs (:) integer(kind=I4B), intent(in) :: dofs (:) procedure( ls_w_res ), public, deferred, PASS( Obj ) :: writeResidueHistory Write the residue history to a file subroutine ls_w_res(Obj, path, prefix, fmt, iter) Prototype Arguments Type Intent Optional Attributes Name class( LinSolver_ ), intent(in) :: Obj character(len=*), intent(in) :: path character(len=*), intent(in) :: prefix character(len=*), intent(in) :: fmt integer(kind=I4B), intent(in), optional :: iter Source Code TYPE , ABSTRACT :: LinSolver_ INTEGER ( I4B ) :: solverName = 0 !! Solver name INTEGER ( I4B ) :: ierr = 0 !! error code returned by the solver INTEGER ( I4B ) :: tdof = 1 !! Total number of degrees of freedom per node INTEGER ( I4B ), ALLOCATABLE :: tNodes ( : ) !! Total number of spatial nodes in each dof INTEGER ( I4B ) :: storageFMT = Nodes_FMT !! storageFMT INTEGER ( I4B ) :: precondType = 0 !! Name of preconditioner INTEGER ( I4B ) :: myRank = 0 !! MPI Rank INTEGER ( I4B ) :: comm = 0 !! MPI COMM INTEGER ( I4B ) :: numproc = 0 !! Number of processor running CHARACTER ( LEN = 5 ) :: Matrixprop = \"UNSYM\" !! Matrix Property CONTAINS PROCEDURE ( ls_init ), PUBLIC , DEFERRED , PASS ( Obj ) :: Initiate !! Initiate the object PROCEDURE ( ls_set_precon ), PUBLIC , DEFERRED , PASS ( Obj ) :: setPrecondition !! Set preconditioner and its properties PROCEDURE ( ls_set_sparsity ), PUBLIC , DEFERRED , PASS ( To ) :: setSparsity !! Set sparsity pattern PROCEDURE ( ls_set_dbc_1 ), PUBLIC , DEFERRED , PASS ( Obj ) :: set_dbcNodes_1 !! Set Dirichlet boundary condition information PROCEDURE ( ls_set_dbc_2 ), PUBLIC , DEFERRED , PASS ( Obj ) :: set_dbcNodes_2 !! Set Dirichlet boundary condition information GENERIC , PUBLIC :: setDirichletBCNodes => set_dbcNodes_1 , set_dbcNodes_2 !! Set Dirichlet boundary condition information PROCEDURE ( ls_set_matrix ), PUBLIC , DEFERRED , PASS ( To ) :: setMatrix !! Set the matrix PROCEDURE ( ls_solve ), PUBLIC , DEFERRED , PASS ( Obj ) :: Solve !! Solve system of linear equation PROCEDURE ( ls_display ), PUBLIC , DEFERRED , PASS ( Obj ) :: Display !! Display the content PROCEDURE ( ls_w_res ), PUBLIC , DEFERRED , PASS ( Obj ) :: writeResidueHistory !! Write the residue history to a file PROCEDURE ( ls_deallocate ), PUBLIC , DEFERRED , PASS ( Obj ) :: DeallocateData !! Deallocate Data END TYPE LinSolver_","tags":"","loc":"type/linsolver_.html"},{"title":"LisPointer_ – Fortran Program ","text":"type, public :: LisPointer_ Contents Variables Ptr Source Code LisPointer_ Components Type Visibility Attributes Name Initial class( LIS_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: LisPointer_ CLASS ( Lis_ ), POINTER :: Ptr => NULL ( ) END TYPE LisPointer_","tags":"","loc":"type/lispointer_.html"},{"title":"SparsekitPointer_ – Fortran Program ","text":"type, public :: SparsekitPointer_ Contents Variables Ptr Source Code SparsekitPointer_ Components Type Visibility Attributes Name Initial class( Sparsekit_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: SparsekitPointer_ CLASS ( Sparsekit_ ), POINTER :: Ptr => NULL ( ) END TYPE SparsekitPointer_","tags":"","loc":"type/sparsekitpointer_.html"},{"title":"Sparsekit_ – Fortran Program ","text":"type, public, EXTENDS( LinSolver_ ) :: Sparsekit_ Sparsekit_ data type is a container around Yusef Saad’s SparseKit\n lib. Reference : https://www-users.cs.umn.edu/~saad/software/SPARSKIT/ This class interface sparsekit and EASIFEM Usage fortran\n    CALL Obj % Initiate( Obj, SolverName, MaxIter, SolverName &\n    & <, diagScale, ipar, fpar> )\n CALL Obj % setPrecondition( Obj, precondtype <,ipar, fpar> )\n CALL Obj % setSparsity( From )\n CALL Obj % setDirichletBCNodes( Nptrs, dofs )\n CALL Obj % setMatrix( From )\n CALL Obj % solve( sol, rhs )\n CALL Obj % Display( msg <,unitno > )\n CALL Obj % writeResidueHistory( path, prefix, fmt, iter )\n CALL Obj % DeallocateData( ) Solver name Precondition Name Todo Todo - Implement ilutp ans iludp preconditioners Contents Variables A ALU IA IPERM JA JLU JU JW RES W WK alpha dbcIA dbcIndx dbcJA dbcNptrs droptol fpar ipar lfil mbloc permtol Type-Bound Procedures DeallocateData Display Initiate Solve setMatrix setPrecondition setSparsity set_dbcNodes_1 set_dbcNodes_2 writeResidueHistory Source Code Sparsekit_ Components Type Visibility Attributes Name Initial real(kind=DFP), public, POINTER :: A (:) => NULL() CSR format real(kind=DFP), public, ALLOCATABLE :: ALU (:) integer(kind=I4B), public, POINTER :: IA (:) => NULL() CSR format integer(kind=I4B), public, ALLOCATABLE :: IPERM (:) Internal var integer(kind=I4B), public, POINTER :: JA (:) => NULL() CSR format integer(kind=I4B), public, ALLOCATABLE :: JLU (:) Internal var integer(kind=I4B), public, ALLOCATABLE :: JU (:) Internal var integer(kind=I4B), public, ALLOCATABLE :: JW (:) Internal var real(kind=DFP), public, ALLOCATABLE :: RES (:) real(kind=DFP), public, ALLOCATABLE :: W (:) real(kind=DFP), public, ALLOCATABLE :: WK (:) real(kind=DFP), public :: alpha = 0.0 integer(kind=I4B), public, ALLOCATABLE :: dbcIA (:) integer(kind=I4B), public, ALLOCATABLE :: dbcIndx (:) integer(kind=I4B), public, ALLOCATABLE :: dbcJA (:) integer(kind=I4B), public, ALLOCATABLE :: dbcNptrs (:) Ids of nodal variables where Dirichlet boundary condition is imposed real(kind=DFP), public :: droptol = 0.0 real(kind=DFP), public :: fpar (14) = 0.0_DFP integer(kind=I4B), public :: ipar (14) = 0 integer(kind=I4B), public :: lfil = 0 integer(kind=I4B), public :: mbloc = 0 real(kind=DFP), public :: permtol = 0.0 Type-Bound Procedures procedure, public, PASS( Obj ) :: DeallocateData => skit_deallocatedata DeallocateData interface private subroutine skit_deallocatedata(Obj) Arguments Type Intent Optional Attributes Name class( Sparsekit_ ), intent(inout) :: Obj procedure, public, PASS( Obj ) :: Display => skit_display Display the contents interface private subroutine skit_display(Obj, msg, Unitno) Arguments Type Intent Optional Attributes Name class( Sparsekit_ ), intent(in) :: Obj character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: Unitno procedure, public, PASS( Obj ) :: Initiate => skit_initiate Initiate object interface Initiate Sparsekit_ private subroutine skit_initiate(Obj, SolverName, MaxIter, Tol, diagScale, ipar, fpar) This subroutine initiate the Sparsekit_ object Read more… Arguments Type Intent Optional Attributes Name class( Sparsekit_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: SolverName integer(kind=I4B), intent(in) :: MaxIter real(kind=DFP), intent(in) :: Tol integer(kind=I4B), intent(in), optional :: diagScale integer(kind=I4B), intent(in), optional :: ipar (:) real(kind=DFP), intent(in), optional :: fpar (:) procedure, public, PASS( Obj ) :: Solve => skit_solve Solve the system of linear equation interface private subroutine skit_solve(Obj, sol, rhs) Arguments Type Intent Optional Attributes Name class( Sparsekit_ ), intent(inout) :: Obj real(kind=DFP), intent(inout) :: sol (:) real(kind=DFP), intent(inout) :: rhs (:) procedure, public, PASS( To ) :: setMatrix => skit_setmatrix set/link tangent matrix to the linear solver engine interface set Matrix private subroutine skit_setmatrix(From, To) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(in), TARGET :: From class( Sparsekit_ ), intent(inout) :: To procedure, public, PASS( Obj ) :: setPrecondition => skit_setprecond Set preconditioner properties interface Set preconditioners in Sparsekit_ private subroutine skit_setprecond(Obj, precondtype, ipar, fpar) This subroutine set the preconditioner required to solve system of\n linear equations by using the Read more… Arguments Type Intent Optional Attributes Name class( Sparsekit_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: precondtype integer(kind=I4B), intent(in), optional :: ipar (:) real(kind=DFP), intent(in), optional :: fpar (:) procedure, public, PASS( To ) :: setSparsity => skit_set_sparsity Set sparsity pattern related information of tangent matrix interface Set sparsity pattern in Sparsekit_ private subroutine skit_set_sparsity(From, To) This subroutine set the sparsity pattern in Sparsekit_ Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(in), TARGET :: From class( Sparsekit_ ), intent(inout) :: To procedure, public, PASS( Obj ) :: set_dbcNodes_1 => skit_setDBC_1 set Information about the Dirichlet boundary nodes interface set Dirichlet boundary condition information private subroutine skit_setDBC_1(Obj, Nptrs, dofs) This subroutine set the Dirichlet boundary condition in the linear solver\n In this case all DOFs have the same dirichlet nodes pointers Nptrs denotes the dirichlet node numbers storageFMT can be DOF_FMT or Nodes_FMT Arguments Type Intent Optional Attributes Name class( Sparsekit_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Nptrs (:) integer(kind=I4B), intent(in) :: dofs (:) procedure, public, PASS( Obj ) :: set_dbcNodes_2 => skit_setDBC_2 set Information about the Dirichlet boundary nodes interface set Dirichlet boundary condition information private subroutine skit_setDBC_2(Obj, Nptrs, dofs) Arguments Type Intent Optional Attributes Name class( Sparsekit_ ), intent(inout) :: Obj type(IntVector_), intent(in) :: Nptrs (:) integer(kind=I4B), intent(in) :: dofs (:) procedure, public, PASS( Obj ) :: writeResidueHistory => skit_write_res_his Output the residue history interface private subroutine skit_write_res_his(Obj, path, prefix, fmt, iter) Arguments Type Intent Optional Attributes Name class( Sparsekit_ ), intent(in) :: Obj character(len=*), intent(in) :: path character(len=*), intent(in) :: prefix character(len=*), intent(in) :: fmt integer(kind=I4B), intent(in), optional :: iter Source Code TYPE , EXTENDS ( LinSolver_ ) :: Sparsekit_ INTEGER ( I4B ), ALLOCATABLE :: dbcNptrs ( : ) !! Ids of nodal variables where Dirichlet boundary condition is imposed INTEGER ( I4B ), ALLOCATABLE :: dbcIndx ( : ) INTEGER ( I4B ), ALLOCATABLE :: dbcJA ( : ) INTEGER ( I4B ), ALLOCATABLE :: dbcIA ( : ) INTEGER ( I4B ), POINTER :: IA ( : ) => NULL ( ) !! CSR format INTEGER ( I4B ), POINTER :: JA ( : ) => NULL ( ) !! CSR format INTEGER ( I4B ), ALLOCATABLE :: JLU ( : ) !! Internal var INTEGER ( I4B ), ALLOCATABLE :: JU ( : ) !! Internal var INTEGER ( I4B ), ALLOCATABLE :: IPERM ( : ) !! Internal var INTEGER ( I4B ), ALLOCATABLE :: JW ( : ) !! Internal var REAL ( DFP ), POINTER :: A ( : ) => NULL ( ) !! CSR format REAL ( DFP ), ALLOCATABLE :: ALU ( : ) REAL ( DFP ), ALLOCATABLE :: WK ( : ) REAL ( DFP ), ALLOCATABLE :: W ( : ) REAL ( DFP ), ALLOCATABLE :: RES ( : ) REAL ( DFP ) :: fpar ( 14 ) = 0.0_DFP REAL ( DFP ) :: droptol = 0.0 REAL ( DFP ) :: permtol = 0.0 REAL ( DFP ) :: alpha = 0.0 INTEGER ( I4B ) :: ipar ( 14 ) = 0 INTEGER ( I4B ) :: lfil = 0 INTEGER ( I4B ) :: mbloc = 0 CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: Initiate => skit_initiate !! Initiate object PROCEDURE , PUBLIC , PASS ( Obj ) :: setPrecondition => skit_setprecond !! Set preconditioner properties PROCEDURE , PUBLIC , PASS ( To ) :: setSparsity => skit_set_sparsity !! Set sparsity pattern related information of tangent matrix PROCEDURE , PUBLIC , PASS ( Obj ) :: set_dbcNodes_1 => skit_setDBC_1 !! set Information about the Dirichlet boundary nodes PROCEDURE , PUBLIC , PASS ( Obj ) :: set_dbcNodes_2 => skit_setDBC_2 !! set Information about the Dirichlet boundary nodes PROCEDURE , PUBLIC , PASS ( To ) :: setMatrix => skit_setmatrix !! set/link tangent matrix to the linear solver engine PROCEDURE , PUBLIC , PASS ( Obj ) :: Solve => skit_solve !! Solve the system of linear equation PROCEDURE , PUBLIC , PASS ( Obj ) :: Display => skit_display !! Display the contents PROCEDURE , PUBLIC , PASS ( Obj ) :: writeResidueHistory => skit_write_res_his !! Output the residue history PROCEDURE , PUBLIC , PASS ( Obj ) :: DeallocateData => skit_deallocatedata !! DeallocateData END TYPE Sparsekit_","tags":"","loc":"type/sparsekit_.html"},{"title":"Material_ – Fortran Program ","text":"type, public :: Material_ Material_ type contains materials properties Contents Variables DynamicViscosity boilTemp bulkModulus criticalPressure criticalTemp density latentHeatBoil latentHeatMelt meltTemp specificHeatCap thermCond thermDiffusivity triplePointPressure triplePointTemp volHeatCap volThermCoeff Source Code Material_ Components Type Visibility Attributes Name Initial real(kind=DFP), public :: DynamicViscosity = 0.0_DFP real(kind=DFP), public :: boilTemp = 0.0_DFP real(kind=DFP), public :: bulkModulus = 0.0_DFP real(kind=DFP), public :: criticalPressure = 0.0_DFP real(kind=DFP), public :: criticalTemp = 0.0_DFP real(kind=DFP), public :: density = 0.0_DFP real(kind=DFP), public :: latentHeatBoil = 0.0_DFP real(kind=DFP), public :: latentHeatMelt = 0.0_DFP real(kind=DFP), public :: meltTemp = 0.0_DFP real(kind=DFP), public :: specificHeatCap = 0.0_DFP real(kind=DFP), public :: thermCond = 0.0_DFP real(kind=DFP), public :: thermDiffusivity = 0.0_DFP real(kind=DFP), public :: triplePointPressure = 0.0_DFP real(kind=DFP), public :: triplePointTemp = 0.0_DFP real(kind=DFP), public :: volHeatCap = 0.0_DFP real(kind=DFP), public :: volThermCoeff = 0.0_DFP Source Code TYPE :: Material_ REAL ( DFP ) :: thermCond = 0.0_DFP REAL ( DFP ) :: specificHeatCap = 0.0_DFP REAL ( DFP ) :: volHeatCap = 0.0_DFP REAL ( DFP ) :: thermDiffusivity = 0.0_DFP REAL ( DFP ) :: density = 0.0_DFP REAL ( DFP ) :: DynamicViscosity = 0.0_DFP REAL ( DFP ) :: meltTemp = 0.0_DFP REAL ( DFP ) :: boilTemp = 0.0_DFP REAL ( DFP ) :: criticalTemp = 0.0_DFP REAL ( DFP ) :: criticalPressure = 0.0_DFP REAL ( DFP ) :: triplePointPressure = 0.0_DFP REAL ( DFP ) :: triplePointTemp = 0.0_DFP REAL ( DFP ) :: latentHeatMelt = 0.0_DFP REAL ( DFP ) :: latentHeatBoil = 0.0_DFP REAL ( DFP ) :: volThermCoeff = 0.0_DFP REAL ( DFP ) :: bulkModulus = 0.0_DFP END TYPE Material_","tags":"","loc":"type/material_~2.html"},{"title":"MatetrialPointer_ – Fortran Program ","text":"type, public :: MatetrialPointer_ Contents Variables Ptr Source Code MatetrialPointer_ Components Type Visibility Attributes Name Initial class( Material_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: MatetrialPointer_ CLASS ( Material_ ), POINTER :: Ptr => NULL ( ) END TYPE MatetrialPointer_","tags":"","loc":"type/matetrialpointer_~2.html"},{"title":"Soil_ – Fortran Program ","text":"type, public, EXTENDS( Material_ ) :: Soil_ soil state; frozen and unfrozen Contents Variables Clay CoarseGrained ConstantThermCond ConstantVolHeatCap DryDensity ExpSFCC FineGrained Frozen Gravel Gravimetric_Moisture JohansenThermCond Minerals OrganicMatter Peat Porosity Quartz SFCCModel SFCC_Model Sand Silt SoilType SpecificGravity State ThermCond_Model Unfrozen UserSFCC UserThermCond UserVolHeatCap mixVolHeatCap thermCondModel voidRatio volFrac_air volFrac_ice volFrac_solid volFrac_water volHeatCapModel volHeatCap_Model Components Type Visibility Attributes Name Initial real(kind=DFP), public :: Clay = 0.0_DFP integer(kind=I4B), public :: CoarseGrained = SOIL_COARSE_GRAINED integer(kind=I4B), public :: ConstantThermCond = Constant_ThermCond integer(kind=I4B), public :: ConstantVolHeatCap = Constant_volHeatCap real(kind=DFP), public :: DryDensity = 0.0_DFP integer(kind=I4B), public :: ExpSFCC = Exp_SFCC integer(kind=I4B), public :: FineGrained = SOIL_FINE_GRAINED integer(kind=I4B), public :: Frozen = STATE_FROZEN real(kind=DFP), public :: Gravel = 0.0_DFP real(kind=DFP), public :: Gravimetric_Moisture = 0.0_DFP integer(kind=I4B), public :: JohansenThermCond = Johansen_ThermCond real(kind=DFP), public :: Minerals (MAX_NUM_MINERALS) = 0.0_DFP real(kind=DFP), public :: OrganicMatter = 0.0_DFP index properties integer(kind=I4B), public :: Peat = SOIL_PEAT grain size distribution real(kind=DFP), public :: Porosity = 0.0_DFP integer(kind=I4B), public :: Quartz = Mineral_Quartz thermal conductivity model class(SFCCModel_), public, POINTER :: SFCCModel => NULL() Consolidation characteristics\n Hydraulic characteristics\n Undrained characteristics\n Drained characteristics integer(kind=I4B), public :: SFCC_Model = Exp_SFCC real(kind=DFP), public :: Sand = 0.0_DFP real(kind=DFP), public :: Silt = 0.0_DFP integer(kind=I4B), public :: SoilType = SOIL_COARSE_GRAINED real(kind=DFP), public :: SpecificGravity = 0.0_DFP integer(kind=I4B), public :: State = STATE_UNFROZEN soil type; fine-grained, coarse-grained, peat integer(kind=I4B), public :: ThermCond_Model = Constant_ThermCond integer(kind=I4B), public :: Unfrozen = STATE_UNFROZEN integer(kind=I4B), public :: UserSFCC = User_SFCC integer(kind=I4B), public :: UserThermCond = User_ThermCond integer(kind=I4B), public :: UserVolHeatCap = User_volHeatCap integer(kind=I4B), public :: mixVolHeatCap = Mix_VolHeatCap class(ThermCondModel_), public, POINTER :: thermCondModel => NULL() volumetric heat capacity model real(kind=DFP), public :: voidRatio = 0.0_DFP real(kind=DFP), public :: volFrac_air = 0.0_DFP mineral composition real(kind=DFP), public :: volFrac_ice = 0.0_DFP real(kind=DFP), public :: volFrac_solid = 0.0_DFP real(kind=DFP), public :: volFrac_water = 0.0_DFP class(volHeatCapModel_), public, POINTER :: volHeatCapModel => NULL() volumetric heat capacity model integer(kind=I4B), public :: volHeatCap_Model = Constant_volHeatCap","tags":"","loc":"type/soil_.html"},{"title":"Material_ – Fortran Program ","text":"type, public :: Material_ Material_ type contains materials properties Contents Variables Props Type-Bound Procedures Append Initiate Property Size Source Code Material_ Components Type Visibility Attributes Name Initial type(KeyValue_), public, ALLOCATABLE :: Props (:) Each entry in prop denotes a material parameter Type-Bound Procedures procedure, public, PASS( Obj ) :: Append => mat_append Append value to the list interface Append keyval object to Material_ private subroutine mat_append(Obj, KeyValObj) Arguments Type Intent Optional Attributes Name class( Material_ ), intent(inout) :: Obj type(KeyValue_), intent(in) :: KeyValObj procedure, public, PASS( Obj ) :: Initiate => mat_initiate Construct the object interface Subroutine that constructs Material_ private subroutine mat_initiate(Obj, tprop) Arguments Type Intent Optional Attributes Name class( Material_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: tprop procedure, public, PASS( Obj ) :: Property => mat_get_prop Returns property as a [keyvalue_] instance interface Function that return a property as an instance of KeyValue_ private pure function mat_get_prop(Obj, Key) result(Ans) Arguments Type Intent Optional Attributes Name class( Material_ ), intent(in) :: Obj character(len=*), intent(in) :: Key Return Value type(KeyValue_) procedure, public, PASS( Obj ) :: Size => mat_size get total number of properties/parameters interface Get total number of parameters stored in Material_ private pure function mat_size(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( Material_ ), intent(in) :: Obj Return Value integer(kind=I4B) Source Code TYPE :: Material_ TYPE ( KeyValue_ ), ALLOCATABLE :: Props ( : ) !! Each entry in prop denotes a material parameter CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: Initiate => mat_initiate !! Construct the object PROCEDURE , PUBLIC , PASS ( Obj ) :: Append => mat_append !! Append value to the list PROCEDURE , PUBLIC , PASS ( Obj ) :: Size => mat_size !! get total number of properties/parameters PROCEDURE , PUBLIC , PASS ( Obj ) :: Property => mat_get_prop !! Returns property as a [keyvalue_] instance END TYPE Material_","tags":"","loc":"type/material_.html"},{"title":"MatetrialPointer_ – Fortran Program ","text":"type, public :: MatetrialPointer_ Contents Variables Ptr Source Code MatetrialPointer_ Components Type Visibility Attributes Name Initial class( Material_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: MatetrialPointer_ CLASS ( Material_ ), POINTER :: Ptr => NULL ( ) END TYPE MatetrialPointer_","tags":"","loc":"type/matetrialpointer_.html"},{"title":"KernelPointer_ – Fortran Program ","text":"type, public :: KernelPointer_ Contents Variables Ptr Source Code KernelPointer_ Components Type Visibility Attributes Name Initial class( Kernel_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: KernelPointer_ CLASS ( Kernel_ ), POINTER :: Ptr => NULL ( ) END TYPE KernelPointer_","tags":"","loc":"type/kernelpointer_.html"},{"title":"Kernel_ – Fortran Program ","text":"type, public :: Kernel_ Contents Variables Assemble AssembleRHS AssembleTanMat DB DBCinfo Dom ITER ITS LIS_FPAR LIS_IPAR MAXITER NNT NSD NTS Nptrs OmegaNo OmegaNoToMaterials OneD_Horizontal OneD_Vertical PRECOND_FPAR PRECOND_IPAR STATIC Solve SpatialCoordType TOL TRANSIENT ThreeD TwoD_AxiSymmetric TwoD_Cartesian Update WriteData dof dt err err0 err0_res err_res intvec isConverged linsol local_nptrs matprops meshq nodalVar precondType saveState setKernel solverName tDOF tELEMENTS tMaterials tNODES tanmat tn tol_res tol_sol Type-Bound Procedures Finalize Initiate SetDomain getMeshQuality setAlgorithm setLinearSolver setMaterial setPrecondition setTanMat setTotalMaterials Source Code Kernel_ Components Type Visibility Attributes Name Initial procedure( kernel_assemble ), public, POINTER, PASS(Obj) :: Assemble => NULL() procedure( kernel_assemble ), public, POINTER, PASS(Obj) :: AssembleRHS => NULL() procedure( kernel_assemble ), public, POINTER, PASS(Obj) :: AssembleTanMat => NULL() type(IntVector_), public, ALLOCATABLE :: DB (:) DB(1) uniform pressure DB\n DB(2) hydrostate pressure DB\n DB(3) uniform discharge/flux NB\n DB(4) drainage/ filter / robin/ boundary NB integer(kind=I4B), public, ALLOCATABLE :: DBCinfo (:) Boundary info class(Domain_), public, POINTER :: Dom => NULL() integer(kind=I4B), public :: ITER = 0 integer(kind=I4B), public :: ITS = 0 real(kind=DFP), public :: LIS_FPAR (LIS_FPAR_LEN) = 0.0 real parameters for linear iterative solver integer(kind=I4B), public :: LIS_IPAR (LIS_IPAR_LEN) = 0 integer parameters for linear iterative solver integer(kind=I4B), public :: MAXITER = 100 integer(kind=I4B), public :: NNT = 2 number of nodes in time finite element method integer(kind=I4B), public :: NSD = 2 Spatial dimension of problem integer(kind=I4B), public :: NTS = 0 maximum iteration number for linear iterative solver integer(kind=I4B), public, ALLOCATABLE :: Nptrs (:) Global Nptrs integer(kind=I4B), public, ALLOCATABLE :: OmegaNo (:) Id of cell mesh in domain integer(kind=I4B), public, ALLOCATABLE :: OmegaNoToMaterials (:) Mesh region to material mapping integer(kind=I4B), public :: OneD_Horizontal = NSD_1_HORIZONTAL integer(kind=I4B), public :: OneD_Vertical = NSD_1_VERTICAL real(kind=DFP), public :: PRECOND_FPAR (LIS_PRECOND_FPAR_LEN) = 0.0 real parameter for linear iterative solver integer(kind=I4B), public :: PRECOND_IPAR (LIS_PRECOND_IPAR_LEN) = 0 integer parameters for linear iterative solver integer(kind=I4B), public :: STATIC = ALGO_OPT_STATIC procedure( kernel_solve ), public, POINTER, PASS(Obj) :: Solve => NULL() integer(kind=I4B), public :: SpatialCoordType = 0 Spatial coordinate type real(kind=DFP), public :: TOL = 1.0E-5 tolerance for linear iterative solver integer(kind=I4B), public :: TRANSIENT = ALGO_OPT_TRANSIENT integer(kind=I4B), public :: ThreeD = NSD_3 integer(kind=I4B), public :: TwoD_AxiSymmetric = NSD_2_AXISYMMETRIC integer(kind=I4B), public :: TwoD_Cartesian = NSD_2_CARTESIAN procedure( kernel_update ), public, POINTER, PASS(Obj) :: Update => NULL() procedure( kernel_writedata ), public, POINTER, PASS(Obj) :: WriteData => NULL() type(DOF_), public, ALLOCATABLE :: dof (:) dof( 1 ) :: pressure\n dof( 2 ) :: right hand side (residual)\n dof( 3 ) :: velocity real(kind=DFP), public :: dt = 0.01_DFP real(kind=DFP), public :: err = 0.0_DFP real(kind=DFP), public :: err0 = 0.0_DFP real(kind=DFP), public :: err0_res = 0.0_DFP real(kind=DFP), public :: err_res = 0.0_DFP type(IntVector_), public, ALLOCATABLE :: intvec (:) procedure( kernel_isconverg ), public, POINTER, PASS(Obj) :: isConverged => NULL() class(LinSolver_), public, POINTER :: linsol => NULL() integer(kind=I4B), public, ALLOCATABLE :: local_nptrs (:) Local Nptrs real(kind=DFP), public, ALLOCATABLE :: matprops (:,:) material properties real(kind=DFP), public, ALLOCATABLE :: meshq (:) Mesh quality type(RealVector_), public, ALLOCATABLE :: nodalVar (:) nodalVar( 1 ) :: pressure\n nodalVar( 2 ) :: right hand side (residual)\n nodalVar( 3 ) :: velocity integer(kind=I4B), public :: precondType = P_ILUD linear iterative solver preconditioning procedure( kernel_savestate ), public, POINTER, PASS( Obj ) :: saveState => NULL() procedure( kernel_set_kernel ), public, POINTER, PASS( Obj ) :: setKernel => NULL() integer(kind=I4B), public :: solverName = LIS_CG linear iterative solver name integer(kind=I4B), public :: tDOF = 0 total number of degrees of freedom per node integer(kind=I4B), public :: tELEMENTS = 0 total elements integer(kind=I4B), public :: tMaterials = 1 Total number of materials integer(kind=I4B), public :: tNODES = 0 total number of nodes in problem class(SparseMatrix_), public, POINTER :: tanmat => NULL() real(kind=DFP), public :: tn = 0.0_DFP real(kind=DFP), public :: tol_res = 1.0E-5 Time step for solving dynamic/ transient problems real(kind=DFP), public :: tol_sol = 1.0E-5 Time step for solving dynamic/ transient problems Type-Bound Procedures procedure, public, PASS( Obj ) :: Finalize => kernel_dealloc interface private subroutine kernel_dealloc(Obj) Arguments Type Intent Optional Attributes Name class( Kernel_ ), intent(inout) :: Obj procedure, public, PASS( Obj ) :: Initiate => kernel_init interface This subroutine initiate the Kernel private subroutine kernel_init(Obj, nsd, nnt, dt, SpatialCoordType, tn, NTS, tol_res, tol_sol) This subroutine initiate the kernel\n - If NNT (num of nodes in time domain) is not given then NNT=1 - NSD is the spatial dimension of the problem\n - dt is the time step size; default value is ‘1.0’ Arguments Type Intent Optional Attributes Name class( Kernel_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: nsd integer(kind=I4B), intent(in), optional :: nnt real(kind=DFP), intent(in), optional :: dt integer(kind=I4B), intent(in), optional :: SpatialCoordType real(kind=DFP), intent(in), optional :: tn integer(kind=I4B), intent(in), optional :: NTS real(kind=DFP), intent(in), optional :: tol_res real(kind=DFP), intent(in), optional :: tol_sol procedure, public, PASS( Obj ) :: SetDomain => kernel_setdomain interface This subroutine set the domain to the kernel private subroutine kernel_setdomain(Obj, dom, omegaNo) This subroutine set the domain to the kernel\n - Here dom is the domain_ datatype\n - omegaNo is the IDs of regions which is required in the analysis\n - This subroutine will store information of omegano - It also prepares the mapping between local and global node numbers\n - Information such as, obj%tnodes and obj%telements are also stored\n inside the kernel Read more… Arguments Type Intent Optional Attributes Name class( Kernel_ ), intent(inout) :: Obj class(Domain_), intent(inout), TARGET :: dom integer(kind=I4B), intent(in) :: omegaNo (:) procedure, public, PASS( Obj ) :: getMeshQuality => kernel_mesh_quality interface This subroutine computes the mesh quality private subroutine kernel_mesh_quality(Obj, qmin, qmax, qavg, measure, q, nodes) This subroutine computes the mesh quality\n - if q is present then mesh-quality of each element will be returned in it\n   otherwise meshquality will be stored in obj%meshq - qmin qmax and qavg are statistical parameters\n - measure is quality measure which can be\n     - meshquality%area\n     - meshquality%minAngle\n     - meshquality%maxAngle\n     - meshquality%angleRatio\n     - meshquality%radiusRatio\n     - meshquality%edgeRatio\n     - meshquality%aspectRatio\n     - meshquality%scaledJacobian\n - if nodes are not present then dom%nodes are used Arguments Type Intent Optional Attributes Name class( Kernel_ ), intent(inout) :: Obj real(kind=DFP), intent(inout) :: qmin real(kind=DFP), intent(inout) :: qmax real(kind=DFP), intent(inout) :: qavg integer(kind=I4B), intent(in), optional :: measure real(kind=DFP), intent(inout), optional ALLOCATABLE :: q (:) real(kind=DFP), intent(in), optional :: nodes (:,:) procedure, public, PASS( Obj ) :: setAlgorithm => kernel_setalgo interface This subroutine set the algorithm for the kernel private subroutine kernel_setalgo(Obj, mainOption, extraOption) This subroutine set the algorithm of the Kernel\n This subroutine should be defined by specific kernel Arguments Type Intent Optional Attributes Name class( Kernel_ ), intent(inout) :: Obj integer(kind=I4B), intent(in), optional :: mainOption (:) integer(kind=I4B), intent(in), optional :: extraOption (:) procedure, public, PASS( Obj ) :: setLinearSolver => kernel_setlinsol interface private subroutine kernel_setlinsol(Obj, name, maxiter, tol, fpar, ipar) Arguments Type Intent Optional Attributes Name class( Kernel_ ), intent(inout) :: Obj integer(kind=I4B), intent(in), optional :: name integer(kind=I4B), intent(in), optional :: maxiter real(kind=DFP), intent(in), optional :: tol real(kind=DFP), intent(in), optional :: fpar (:) integer(kind=I4B), intent(in), optional :: ipar (:) procedure, public, PASS( Obj ) :: setMaterial => set_material interface private subroutine set_material(Obj, materialNo) Arguments Type Intent Optional Attributes Name class( Kernel_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: materialNo (:) procedure, public, PASS( Obj ) :: setPrecondition => kernel_setprecond interface private subroutine kernel_setprecond(Obj, name, fpar, ipar) Arguments Type Intent Optional Attributes Name class( Kernel_ ), intent(inout) :: Obj integer(kind=I4B), intent(in), optional :: name real(kind=DFP), intent(in), optional :: fpar (:) integer(kind=I4B), intent(in), optional :: ipar (:) procedure, public, PASS( Obj ) :: setTanMat => kernel_settanmat interface private subroutine kernel_settanmat(Obj) Arguments Type Intent Optional Attributes Name class( Kernel_ ), intent(inout) :: Obj procedure, public, PASS( Obj ) :: setTotalMaterials => set_total_materials interface private subroutine set_total_materials(Obj, tMaterials) Arguments Type Intent Optional Attributes Name class( Kernel_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: tMaterials Source Code TYPE :: Kernel_ INTEGER ( I4B ) :: STATIC = ALGO_OPT_STATIC INTEGER ( I4B ) :: TRANSIENT = ALGO_OPT_TRANSIENT INTEGER ( I4B ) :: NSD = 2 !! Spatial dimension of problem INTEGER ( I4B ) :: NNT = 2 !! number of nodes in time finite element method INTEGER ( I4B ) :: tNODES = 0 !! total number of nodes in problem INTEGER ( I4B ) :: tELEMENTS = 0 !! total elements INTEGER ( I4B ) :: tDOF = 0 !! total number of degrees of freedom per node INTEGER ( I4B ) :: SpatialCoordType = 0 !! Spatial coordinate type INTEGER ( I4B ) :: OneD_Horizontal = NSD_1_HORIZONTAL INTEGER ( I4B ) :: OneD_Vertical = NSD_1_VERTICAL INTEGER ( I4B ) :: TwoD_Cartesian = NSD_2_CARTESIAN INTEGER ( I4B ) :: TwoD_AxiSymmetric = NSD_2_AXISYMMETRIC INTEGER ( I4B ) :: ThreeD = NSD_3 INTEGER ( I4B ), ALLOCATABLE :: OmegaNoToMaterials ( : ) !! Mesh region to material mapping INTEGER ( I4B ) :: tMaterials = 1 !! Total number of materials REAL ( DFP ) :: dt = 0.01_DFP , tn = 0.0_DFP , err = 0.0_DFP , err0 = 0.0_DFP REAL ( DFP ) :: err_res = 0.0_DFP , err0_res = 0.0_DFP REAL ( DFP ) :: tol_res = 1.0E-5 , tol_sol = 1.0E-5 !! Time step for solving dynamic/ transient problems REAL ( DFP ), ALLOCATABLE :: matprops ( :, : ) !! material properties INTEGER ( I4B ) :: ITER = 0 INTEGER ( I4B ) :: MAXITER = 100 INTEGER ( I4B ) :: ITS = 0 INTEGER ( I4B ) :: NTS = 0 !! maximum iteration number for linear iterative solver INTEGER ( I4B ) :: solverName = LIS_CG !! linear iterative solver name REAL ( DFP ) :: TOL = 1.0E-5 !! tolerance for linear iterative solver INTEGER ( I4B ) :: LIS_IPAR ( LIS_IPAR_LEN ) = 0 !! integer parameters for linear iterative solver REAL ( DFP ) :: LIS_FPAR ( LIS_FPAR_LEN ) = 0.0 !! real parameters for linear iterative solver INTEGER ( I4B ) :: precondType = P_ILUD !! linear iterative solver preconditioning INTEGER ( I4B ) :: PRECOND_IPAR ( LIS_PRECOND_IPAR_LEN ) = 0 !! integer parameters for linear iterative solver REAL ( DFP ) :: PRECOND_FPAR ( LIS_PRECOND_FPAR_LEN ) = 0.0 !! real parameter for linear iterative solver INTEGER ( I4B ), ALLOCATABLE :: OmegaNo (:) !! Id of cell mesh in domain INTEGER ( I4B ), ALLOCATABLE :: DBCinfo (:) !! Boundary info INTEGER ( I4B ), ALLOCATABLE :: Nptrs ( : ) !! Global Nptrs INTEGER ( I4B ), ALLOCATABLE :: local_nptrs ( : ) !! Local Nptrs TYPE ( IntVector_ ), ALLOCATABLE :: DB (:) !! DB(1) uniform pressure DB !! DB(2) hydrostate pressure DB !! DB(3) uniform discharge/flux NB !! DB(4) drainage/ filter / robin/ boundary NB TYPE ( RealVector_ ), ALLOCATABLE :: nodalVar ( : ) !! nodalVar( 1 ) :: pressure !! nodalVar( 2 ) :: right hand side (residual) !! nodalVar( 3 ) :: velocity TYPE ( DOF_ ), ALLOCATABLE :: dof ( : ) !! dof( 1 ) :: pressure !! dof( 2 ) :: right hand side (residual) !! dof( 3 ) :: velocity TYPE ( IntVector_ ), ALLOCATABLE :: intvec ( : ) CLASS ( Domain_ ), POINTER :: Dom => NULL ( ) CLASS ( SparseMatrix_ ), POINTER :: tanmat => NULL ( ) CLASS ( LinSolver_ ), POINTER :: linsol => NULL ( ) REAL ( DFP ), ALLOCATABLE :: meshq (:) ! TYPE( QuadratureVariables_ ) :: meshq !! Mesh quality PROCEDURE ( kernel_set_kernel ), POINTER , PASS ( Obj ) :: setKernel => NULL () PROCEDURE ( kernel_assemble ), POINTER , PASS ( Obj ) :: Assemble => NULL () PROCEDURE ( kernel_assemble ), POINTER , PASS ( Obj ) :: AssembleTanMat => NULL () PROCEDURE ( kernel_assemble ), POINTER , PASS ( Obj ) :: AssembleRHS => NULL () PROCEDURE ( kernel_solve ), POINTER , PASS ( Obj ) :: Solve => NULL () PROCEDURE ( kernel_update ), POINTER , PASS ( Obj ) :: Update => NULL () PROCEDURE ( kernel_isconverg ), POINTER , PASS ( Obj ) :: isConverged => NULL () PROCEDURE ( kernel_writedata ), POINTER , PASS ( Obj ) :: & & WriteData => NULL () PROCEDURE ( kernel_savestate ), POINTER , PASS ( Obj ) :: saveState => NULL () CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: Initiate => kernel_init PROCEDURE , PUBLIC , PASS ( Obj ) :: SetDomain => kernel_setdomain PROCEDURE , PUBLIC , PASS ( Obj ) :: setAlgorithm => kernel_setalgo PROCEDURE , PUBLIC , PASS ( Obj ) :: setLinearSolver => kernel_setlinsol PROCEDURE , PUBLIC , PASS ( Obj ) :: setPrecondition => kernel_setprecond PROCEDURE , PUBLIC , PASS ( Obj ) :: setTanMat => kernel_settanmat PROCEDURE , PUBLIC , PASS ( Obj ) :: Finalize => kernel_dealloc PROCEDURE , PUBLIC , PASS ( Obj ) :: getMeshQuality => kernel_mesh_quality PROCEDURE , PUBLIC , PASS ( Obj ) :: setTotalMaterials => set_total_materials PROCEDURE , PUBLIC , PASS ( Obj ) :: setMaterial => set_material END TYPE Kernel_","tags":"","loc":"type/kernel_.html"},{"title":"AbstractArrayPointer_ – Fortran Program ","text":"type, public :: AbstractArrayPointer_ Contents Variables Ptr Source Code AbstractArrayPointer_ Components Type Visibility Attributes Name Initial class( AbstractArray_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: AbstractArrayPointer_ CLASS ( AbstractArray_ ), POINTER :: Ptr => NULL ( ) END TYPE AbstractArrayPointer_","tags":"","loc":"type/abstractarraypointer_.html"},{"title":"AbstractArray_ – Fortran Program ","text":"type, public :: AbstractArray_ Contents Variables tDimension Source Code AbstractArray_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: tDimension = 0_I4B Source Code TYPE :: AbstractArray_ INTEGER ( I4B ) :: tDimension = 0_I4B END TYPE AbstractArray_","tags":"","loc":"type/abstractarray_.html"},{"title":"AbstractMatrixPointer_ – Fortran Program ","text":"type, public :: AbstractMatrixPointer_ Contents Variables Ptr Source Code AbstractMatrixPointer_ Components Type Visibility Attributes Name Initial class( AbstractMatrix_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: AbstractMatrixPointer_ CLASS ( AbstractMatrix_ ), POINTER :: Ptr => NULL ( ) END TYPE AbstractMatrixPointer_","tags":"","loc":"type/abstractmatrixpointer_.html"},{"title":"AbstractMatrix_ – Fortran Program ","text":"type, public, EXTENDS( AbstractArray_ ) :: AbstractMatrix_ Contents Source Code AbstractMatrix_ Source Code TYPE , EXTENDS ( AbstractArray_ ) :: AbstractMatrix_ END TYPE AbstractMatrix_","tags":"","loc":"type/abstractmatrix_.html"},{"title":"AbstractVectorPointer_ – Fortran Program ","text":"type, private :: AbstractVectorPointer_ Contents Variables Ptr Source Code AbstractVectorPointer_ Components Type Visibility Attributes Name Initial class( AbstractVector_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: AbstractVectorPointer_ CLASS ( AbstractVector_ ), POINTER :: Ptr => NULL ( ) END TYPE AbstractVectorPointer_","tags":"","loc":"type/abstractvectorpointer_.html"},{"title":"AbstractVector_ – Fortran Program ","text":"type, public, EXTENDS( AbstractArray_ ) :: AbstractVector_ Contents Source Code AbstractVector_ Source Code TYPE , EXTENDS ( AbstractArray_ ) :: AbstractVector_ END TYPE AbstractVector_","tags":"","loc":"type/abstractvector_.html"},{"title":"BaseInterpolation_ – Fortran Program ","text":"type, public :: BaseInterpolation_ Contents Source Code BaseInterpolation_ Source Code TYPE :: BaseInterpolation_ END TYPE BaseInterpolation_","tags":"","loc":"type/baseinterpolation_.html"},{"title":"BasisContinuity_ – Fortran Program ","text":"type, public :: BasisContinuity_ Contents Source Code BasisContinuity_ Source Code TYPE :: BasisContinuity_ END TYPE BasisContinuity_","tags":"","loc":"type/basiscontinuity_.html"},{"title":"BoundingBoxPointer_ – Fortran Program ","text":"type, public :: BoundingBoxPointer_ Contents Variables Ptr Source Code BoundingBoxPointer_ Components Type Visibility Attributes Name Initial class( BoundingBoxPointer_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: BoundingBoxPointer_ CLASS ( BoundingBoxPointer_ ), POINTER :: Ptr => NULL ( ) END TYPE BoundingBoxPointer_","tags":"","loc":"type/boundingboxpointer_.html"},{"title":"BoundingBox_ – Fortran Program ","text":"type, public :: BoundingBox_ Contents Variables Box NSD Source Code BoundingBox_ Components Type Visibility Attributes Name Initial real(kind=DFP), public :: Box (2,3) integer(kind=I4B), public :: NSD Source Code TYPE :: BoundingBox_ INTEGER ( I4B ) :: NSD REAL ( DFP ) :: Box ( 2 , 3 ) END TYPE BoundingBox_","tags":"","loc":"type/boundingbox_.html"},{"title":"Buffer_ – Fortran Program ","text":"type, public :: Buffer_ Contents Variables Line tLine Source Code Buffer_ Components Type Visibility Attributes Name Initial type( StringPointer_ ), public, ALLOCATABLE :: Line (:) integer(kind=I4B), public :: tLine = 0 Source Code TYPE :: Buffer_ TYPE ( StringPointer_ ), ALLOCATABLE :: Line ( : ) INTEGER ( I4B ) :: tLine = 0 END TYPE Buffer_","tags":"","loc":"type/buffer_.html"},{"title":"DG_ – Fortran Program ","text":"type, public, EXTENDS( BasisContinuity_ ) :: DG_ Contents Source Code DG_ Source Code TYPE , EXTENDS ( BasisContinuity_ ) :: DG_ END TYPE DG_","tags":"","loc":"type/dg_.html"},{"title":"DOFPointer_ – Fortran Program ","text":"type, public :: DOFPointer_ Contents Variables Ptr Source Code DOFPointer_ Components Type Visibility Attributes Name Initial class( DOF_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: DOFPointer_ CLASS ( DOF_ ), POINTER :: Ptr => NULL ( ) END TYPE DOFPointer_","tags":"","loc":"type/dofpointer_.html"},{"title":"DOF_ – Fortran Program ","text":"type, public :: DOF_ Contents Variables MAP StorageFMT ValMap Source Code DOF_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public, ALLOCATABLE :: MAP (:,:) integer(kind=I4B), public :: StorageFMT = Nodes_FMT integer(kind=I4B), public, ALLOCATABLE :: ValMap (:) Source Code TYPE :: DOF_ INTEGER ( I4B ), ALLOCATABLE :: MAP ( :, : ) INTEGER ( I4B ), ALLOCATABLE :: ValMap ( : ) INTEGER ( I4B ) :: StorageFMT = Nodes_FMT END TYPE DOF_","tags":"","loc":"type/dof_.html"},{"title":"ElemShapeDataPointer_ – Fortran Program ","text":"type, public :: ElemShapeDataPointer_ Contents Variables Ptr Source Code ElemShapeDataPointer_ Components Type Visibility Attributes Name Initial class( ShapeDataPointer_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: ElemShapeDataPointer_ CLASS ( ShapeDataPointer_ ), POINTER :: Ptr => NULL ( ) END TYPE ElemShapeDataPointer_","tags":"","loc":"type/elemshapedatapointer_.html"},{"title":"ElemShapeData_ – Fortran Program ","text":"type, public :: ElemShapeData_ This data type contains shapefunction related data defined\n at all gauss points of an elements Contents Variables Coord Jacobian Js N Normal Quad RefElem Thickness Ws dNdXi dNdXt Source Code ElemShapeData_ Components Type Visibility Attributes Name Initial real(kind=DFP), public, ALLOCATABLE :: Coord (:,:) Barycentric coordinate real(kind=DFP), public, ALLOCATABLE :: Jacobian (:,:,:) Jacobian of mapping J(:,:,ips) also $\\mathbf{F}_{\\Xi x}$ real(kind=DFP), public, ALLOCATABLE :: Js (:) Determinant of Jacobian at ips real(kind=DFP), public, ALLOCATABLE :: N (:,:) Shape function value N(I,ips) real(kind=DFP), public, ALLOCATABLE :: Normal (:,:) Normal in case of facet element type( QuadraturePoint_ ), public :: Quad Quadrature points type( ReferenceElement_ ), public :: RefElem Refererece element real(kind=DFP), public, ALLOCATABLE :: Thickness (:) Thickness of element real(kind=DFP), public, ALLOCATABLE :: Ws (:) Weighting functions real(kind=DFP), public, ALLOCATABLE :: dNdXi (:,:,:) Local derivative of a shape function real(kind=DFP), public, ALLOCATABLE :: dNdXt (:,:,:) Spatial derivative of shape function Source Code TYPE :: ElemShapeData_ REAL ( DFP ), ALLOCATABLE :: N ( :, : ) !! Shape function value `N(I,ips)` REAL ( DFP ), ALLOCATABLE :: dNdXi ( :, :, : ) !! Local derivative of a shape function REAL ( DFP ), ALLOCATABLE :: Jacobian ( :, :, : ) !! Jacobian of mapping `J(:,:,ips)` also $\\mathbf{F}_{\\Xi x}$ REAL ( DFP ), ALLOCATABLE :: Js ( : ) !! Determinant of Jacobian at ips REAL ( DFP ), ALLOCATABLE :: Ws ( : ) !! Weighting functions REAL ( DFP ), ALLOCATABLE :: dNdXt ( :, :, : ) !! Spatial derivative of shape function REAL ( DFP ), ALLOCATABLE :: Thickness ( : ) !! Thickness of element REAL ( DFP ), ALLOCATABLE :: Coord ( :, : ) !! Barycentric coordinate REAL ( DFP ), ALLOCATABLE :: Normal ( :, : ) !! Normal in case of facet element TYPE ( ReferenceElement_ ) :: RefElem !! Refererece element TYPE ( QuadraturePoint_ ) :: Quad !! Quadrature points END TYPE ElemShapeData_","tags":"","loc":"type/elemshapedata_.html"},{"title":"ElementDataPointer_ – Fortran Program ","text":"type, public :: ElementDataPointer_ Contents Variables Ptr Source Code ElementDataPointer_ Components Type Visibility Attributes Name Initial class( ElementData_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: ElementDataPointer_ CLASS ( ElementData_ ), POINTER :: Ptr => NULL ( ) END TYPE ElementDataPointer_","tags":"","loc":"type/elementdatapointer_.html"},{"title":"ElementData_ – Fortran Program ","text":"type, public :: ElementData_ Contents Variables ElemTopology ElemType MAT_Type NNE NNS NNT NSD SpaceElemTopo TimeElemTopo XiDimension Source Code ElementData_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: ElemTopology integer(kind=I4B), public :: ElemType integer(kind=I4B), public :: MAT_Type integer(kind=I4B), public :: NNE integer(kind=I4B), public :: NNS integer(kind=I4B), public :: NNT integer(kind=I4B), public :: NSD integer(kind=I4B), public :: SpaceElemTopo integer(kind=I4B), public :: TimeElemTopo integer(kind=I4B), public :: XiDimension Source Code TYPE :: ElementData_ INTEGER ( I4B ) :: NSD , NNE , NNS , NNT , XiDimension , ElemTopology , & & SpaceElemTopo , TimeElemTopo , ElemType , MAT_Type END TYPE ElementData_","tags":"","loc":"type/elementdata_.html"},{"title":"FEVariableConstant_ – Fortran Program ","text":"type, public :: FEVariableConstant_ Contents Variables Val Source Code FEVariableConstant_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: Val = 1 Source Code TYPE :: FEVariableConstant_ INTEGER ( I4B ) :: Val = 1 END TYPE FEVariableConstant_","tags":"","loc":"type/fevariableconstant_.html"},{"title":"FEVariableMatrix_ – Fortran Program ","text":"type, public :: FEVariableMatrix_ Contents Variables Val Source Code FEVariableMatrix_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: Val = 2 Source Code TYPE :: FEVariableMatrix_ INTEGER ( I4B ) :: Val = 2 END TYPE FEVariableMatrix_","tags":"","loc":"type/fevariablematrix_.html"},{"title":"FEVariableScalar_ – Fortran Program ","text":"type, public :: FEVariableScalar_ Contents Variables Val Source Code FEVariableScalar_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: Val = 0 Source Code TYPE :: FEVariableScalar_ INTEGER ( I4B ) :: Val = 0 END TYPE FEVariableScalar_","tags":"","loc":"type/fevariablescalar_.html"},{"title":"FEVariableSpaceTime_ – Fortran Program ","text":"type, public :: FEVariableSpaceTime_ Contents Variables Val Source Code FEVariableSpaceTime_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: Val = 3 Source Code TYPE :: FEVariableSpaceTime_ INTEGER ( I4B ) :: Val = 3 END TYPE FEVariableSpaceTime_","tags":"","loc":"type/fevariablespacetime_.html"},{"title":"FEVariableSpace_ – Fortran Program ","text":"type, public :: FEVariableSpace_ Contents Variables Val Source Code FEVariableSpace_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: Val = 2 Source Code TYPE :: FEVariableSpace_ INTEGER ( I4B ) :: Val = 2 END TYPE FEVariableSpace_","tags":"","loc":"type/fevariablespace_.html"},{"title":"FEVariableTime_ – Fortran Program ","text":"type, public :: FEVariableTime_ Contents Variables Val Source Code FEVariableTime_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: Val = 4 Source Code TYPE :: FEVariableTime_ INTEGER ( I4B ) :: Val = 4 END TYPE FEVariableTime_","tags":"","loc":"type/fevariabletime_.html"},{"title":"FEVariableVector_ – Fortran Program ","text":"type, public :: FEVariableVector_ Contents Variables Val Source Code FEVariableVector_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: Val = 1 Source Code TYPE :: FEVariableVector_ INTEGER ( I4B ) :: Val = 1 END TYPE FEVariableVector_","tags":"","loc":"type/fevariablevector_.html"},{"title":"FEVariable_ – Fortran Program ","text":"type, public :: FEVariable_ Contents Variables CaseType DefineOn R0 R1 R2 R3 R4 Rank VarType Source Code FEVariable_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: CaseType = 0 integer(kind=I4B), public :: DefineOn = 0 real(kind=DFP), public :: R0 = 0. real(kind=DFP), public, ALLOCATABLE :: R1 (:) real(kind=DFP), public, ALLOCATABLE :: R2 (:,:) real(kind=DFP), public, ALLOCATABLE :: R3 (:,:,:) real(kind=DFP), public, ALLOCATABLE :: R4 (:,:,:,:) integer(kind=I4B), public :: Rank = 0 integer(kind=I4B), public :: VarType = 0 Source Code TYPE :: FEVariable_ REAL ( DFP ), ALLOCATABLE :: R1 ( : ), R2 ( :, : ), R3 ( :, :, : ), & & R4 ( :, :, :, :) REAL ( DFP ) :: R0 = 0. INTEGER ( I4B ) :: DefineOn = 0 !Nodal, Quadrature INTEGER ( I4B ) :: VarType = 0 !Space, SpaceTime, Constant INTEGER ( I4B ) :: Rank = 0 ! Scalar, Vector, Matrix INTEGER ( I4B ) :: CaseType = 0 END TYPE FEVariable_","tags":"","loc":"type/fevariable_.html"},{"title":"FilePointer_ – Fortran Program ","text":"type, public :: FilePointer_ Contents Variables Ptr Source Code FilePointer_ Components Type Visibility Attributes Name Initial class( File_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: FilePointer_ CLASS ( File_ ), POINTER :: Ptr => NULL ( ) END TYPE FilePointer_","tags":"","loc":"type/filepointer_.html"},{"title":"File_ – Fortran Program ","text":"type, public :: File_ Contents Variables ACCESS ACTION Comment Extension FileName IOSTAT Path STATUS Separator UnitNo WriteNo isBinary isOpen Source Code File_ Components Type Visibility Attributes Name Initial type(String), public :: ACCESS type(String), public :: ACTION character(len=1), public :: Comment = \"#\" type(String), public :: Extension type(String), public :: FileName integer(kind=I4B), public :: IOSTAT = 1 type(String), public :: Path type(String), public :: STATUS character(len=1), public :: Separator = \",\" integer(kind=I4B), public :: UnitNo = 1 integer(kind=I4B), public :: WriteNo = 1 logical(kind=LGT), public :: isBinary = .FALSE. logical(kind=LGT), public :: isOpen = .FALSE. Source Code TYPE :: File_ TYPE ( String ) :: FileName , Path , Extension , ACTION , STATUS , ACCESS INTEGER ( I4B ) :: UnitNo = 1 , WriteNo = 1 , IOSTAT = 1 LOGICAL ( LGT ) :: isOpen = . FALSE ., isBinary = . FALSE . CHARACTER ( LEN = 1 ) :: Comment = \"#\" CHARACTER ( LEN = 1 ) :: Separator = \",\" END TYPE File_","tags":"","loc":"type/file_.html"},{"title":"H1CURL_ – Fortran Program ","text":"type, public, EXTENDS( BasisContinuity_ ) :: H1CURL_ Contents Source Code H1CURL_ Source Code TYPE , EXTENDS ( BasisContinuity_ ) :: H1CURL_ END TYPE H1CURL_","tags":"","loc":"type/h1curl_.html"},{"title":"H1DIV_ – Fortran Program ","text":"type, public, EXTENDS( BasisContinuity_ ) :: H1DIV_ Contents Source Code H1DIV_ Source Code TYPE , EXTENDS ( BasisContinuity_ ) :: H1DIV_ END TYPE H1DIV_","tags":"","loc":"type/h1div_.html"},{"title":"H1_ – Fortran Program ","text":"type, public, EXTENDS( BasisContinuity_ ) :: H1_ Contents Source Code H1_ Source Code TYPE , EXTENDS ( BasisContinuity_ ) :: H1_ END TYPE H1_","tags":"","loc":"type/h1_.html"},{"title":"HermitInterpolation_ – Fortran Program ","text":"type, public, EXTENDS( BaseInterpolation_ ) :: HermitInterpolation_ Contents Source Code HermitInterpolation_ Source Code TYPE , EXTENDS ( BaseInterpolation_ ) :: HermitInterpolation_ END TYPE HermitInterpolation_","tags":"","loc":"type/hermitinterpolation_.html"},{"title":"HierarchyInterpolation_ – Fortran Program ","text":"type, public, EXTENDS( BaseInterpolation_ ) :: HierarchyInterpolation_ Contents Source Code HierarchyInterpolation_ Source Code TYPE , EXTENDS ( BaseInterpolation_ ) :: HierarchyInterpolation_ END TYPE HierarchyInterpolation_","tags":"","loc":"type/hierarchyinterpolation_.html"},{"title":"IndexValuePointer_ – Fortran Program ","text":"type, public :: IndexValuePointer_ Contents Variables Ptr Source Code IndexValuePointer_ Components Type Visibility Attributes Name Initial class( IndexValue_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: IndexValuePointer_ CLASS ( IndexValue_ ), POINTER :: Ptr => NULL ( ) END TYPE IndexValuePointer_","tags":"","loc":"type/indexvaluepointer_.html"},{"title":"IndexValue_ – Fortran Program ","text":"type, public :: IndexValue_ Contents Variables Indx Val Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: Indx real(kind=DFP), public :: Val","tags":"","loc":"type/indexvalue_.html"},{"title":"IntVectorPointer_ – Fortran Program ","text":"type, public :: IntVectorPointer_ Contents Variables Ptr Source Code IntVectorPointer_ Components Type Visibility Attributes Name Initial class( IntVector_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: IntVectorPointer_ CLASS ( IntVector_ ), POINTER :: Ptr => NULL ( ) END TYPE IntVectorPointer_","tags":"","loc":"type/intvectorpointer_.html"},{"title":"IntVector_ – Fortran Program ","text":"type, public, EXTENDS( AbstractVector_ ) :: IntVector_ Contents Variables Val Source Code IntVector_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public, ALLOCATABLE :: Val (:) Source Code TYPE ( IntVector_ ), ALLOCATABLE :: Row ( : ) INTEGER ( I4B ), ALLOCATABLE :: IA ( : ) INTEGER ( I4B ), ALLOCATABLE :: JA ( : ) INTEGER ( I4B ), ALLOCATABLE :: ColSize ( : ) INTEGER ( I4B ), ALLOCATABLE :: RowSize ( : ) INTEGER ( I4B ), ALLOCATABLE :: DiagIndx ( : ) REAL ( DFP ), ALLOCATABLE :: A ( : ), Diag ( : ) INTEGER ( I4B ) :: tDOF = 1 INTEGER ( I4B ) :: tNodes = 0 INTEGER ( I4B ) :: nnz = 0 INTEGER ( I4B ) :: ncol = 0 INTEGER ( I4B ) :: nrow = 0 CHARACTER ( LEN = 5 ) :: MatrixProp = 'UNSYM' INTEGER ( I4B ) :: StorageFMT = Nodes_FMT END TYPE SparseMatrix_ PUBLIC :: SparseMatrix_ TYPE ( SparseMatrix_ ), PUBLIC , PARAMETER :: & & TypeSparseMatrix = SparseMatrix_ ( & & Row = NULL ( ), & & IA = NULL ( ), & & JA = NULL ( ), & & ColSize = NULL ( ), & & RowSize = NULL ( ), & & DiagIndx = NULL ( ), & & A = NULL ( ), & & Diag = NULL ( ) ) TYPE :: SparseMatrixPointer_ CLASS ( SparseMatrix_ ), POINTER :: Ptr => NULL ( ) END TYPE SparseMatrixPointer_ PUBLIC :: SparseMatrixPointer_ !---------------------------------------------------------------------------- !                                                          AbstractVector_ !---------------------------------------------------------------------------- TYPE , EXTENDS ( AbstractArray_ ) :: AbstractVector_ END TYPE AbstractVector_ PUBLIC :: AbstractVector_ TYPE :: AbstractVectorPointer_ CLASS ( AbstractVector_ ), POINTER :: Ptr => NULL ( ) END TYPE AbstractVectorPointer_ !---------------------------------------------------------------------------- !                                                             IntVector_ !---------------------------------------------------------------------------- TYPE , EXTENDS ( AbstractVector_ ) :: IntVector_ INTEGER ( I4B ), ALLOCATABLE :: Val ( : ) END TYPE IntVector_","tags":"","loc":"type/intvector_.html"},{"title":"IterationDataPointer_ – Fortran Program ","text":"type, public :: IterationDataPointer_ Contents Variables Ptr Source Code IterationDataPointer_ Components Type Visibility Attributes Name Initial class( IterationData_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: IterationDataPointer_ CLASS ( IterationData_ ), POINTER :: Ptr => NULL ( ) END TYPE IterationDataPointer_","tags":"","loc":"type/iterationdatapointer_.html"},{"title":"IterationData_ – Fortran Program ","text":"type, public :: IterationData_ Contents Variables Converged ConvergenceIn ConvergenceType ErrorAtEnd ErrorAtStart IterationNumber MaxIter NormType TimeAtEnd TimeAtStart Tolerance Source Code IterationData_ Components Type Visibility Attributes Name Initial logical(kind=LGT), public :: Converged = .FALSE. integer(kind=I4B), public :: ConvergenceIn = ConvergenceInRes integer(kind=I4B), public :: ConvergenceType = RelativeConvergence real(kind=DFP), public :: ErrorAtEnd = 0.0 real(kind=DFP), public :: ErrorAtStart = 0.0 integer(kind=I4B), public :: IterationNumber = 0 integer(kind=I4B), public :: MaxIter = 100 integer(kind=I4B), public :: NormType = NormL2 real(kind=DFP), public :: TimeAtEnd = 0.0 real(kind=DFP), public :: TimeAtStart = 0.0 real(kind=DFP), public :: Tolerance = 1.0E-5 Source Code TYPE :: IterationData_ INTEGER ( I4B ) :: MaxIter = 100 , IterationNumber = 0 REAL ( DFP ) :: Tolerance = 1.0E-5 REAL ( DFP ) :: ErrorAtStart = 0.0 , ErrorAtEnd = 0.0 REAL ( DFP ) :: TimeAtStart = 0.0 , TimeAtEnd = 0.0 INTEGER ( I4B ) :: ConvergenceType = RelativeConvergence INTEGER ( I4B ) :: ConvergenceIn = ConvergenceInRes INTEGER ( I4B ) :: NormType = NormL2 LOGICAL ( LGT ) :: Converged = . FALSE . END TYPE IterationData_","tags":"","loc":"type/iterationdata_.html"},{"title":"KeyValue_ – Fortran Program ","text":"type, public :: KeyValue_ KeyValue_ is a poor implementation of dict Contents Variables DataType Key Value Source Code KeyValue_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: DataType = 0 type(String), public :: Key real(kind=DFP), public, ALLOCATABLE :: Value (:,:) Source Code TYPE :: KeyValue_ INTEGER ( I4B ) :: DataType = 0 TYPE ( String ) :: Key REAL ( DFP ), ALLOCATABLE :: Value ( :, : ) END TYPE KeyValue_","tags":"","loc":"type/keyvalue_.html"},{"title":"LagrangeInterpolation_ – Fortran Program ","text":"type, public, EXTENDS( BaseInterpolation_ ) :: LagrangeInterpolation_ Contents Source Code LagrangeInterpolation_ Source Code TYPE , EXTENDS ( BaseInterpolation_ ) :: LagrangeInterpolation_ END TYPE LagrangeInterpolation_","tags":"","loc":"type/lagrangeinterpolation_.html"},{"title":"QuadraturePointPointer_ – Fortran Program ","text":"type, public :: QuadraturePointPointer_ Contents Variables Ptr Source Code QuadraturePointPointer_ Components Type Visibility Attributes Name Initial class( QuadraturePoint_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: QuadraturePointPointer_ CLASS ( QuadraturePoint_ ), POINTER :: Ptr => NULL ( ) END TYPE QuadraturePointPointer_","tags":"","loc":"type/quadraturepointpointer_.html"},{"title":"QuadraturePoint_ – Fortran Program ","text":"type, public :: QuadraturePoint_ QuadraturePoint_ data type contains the quadrature point information Each of column of Points corresponds to a quadrature point Points(1:tXi, :) contains information of quarature points The last row contains the information about the weighths Contents Variables Points tXi Source Code QuadraturePoint_ Components Type Visibility Attributes Name Initial real(kind=DFP), public, ALLOCATABLE :: Points (:,:) integer(kind=I4B), public :: tXi = 0 Source Code TYPE :: QuadraturePoint_ REAL ( DFP ), ALLOCATABLE :: Points ( :, : ) INTEGER ( I4B ) :: tXi = 0 END TYPE QuadraturePoint_","tags":"","loc":"type/quadraturepoint_.html"},{"title":"QualityMeasure_ – Fortran Program ","text":"type, private :: QualityMeasure_ Contents Variables AngleRatio AspectRatio Default EdgeRatio RadiusRatio ScaledJacobian area maxAngle minAngle Source Code QualityMeasure_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: AngleRatio = 103 integer(kind=I4B), public :: AspectRatio = 106 integer(kind=I4B), public :: Default = 106 integer(kind=I4B), public :: EdgeRatio = 105 integer(kind=I4B), public :: RadiusRatio = 104 integer(kind=I4B), public :: ScaledJacobian = 107 integer(kind=I4B), public :: area = 100 integer(kind=I4B), public :: maxAngle = 101 integer(kind=I4B), public :: minAngle = 102 Source Code TYPE :: QualityMeasure_ INTEGER ( I4B ), PUBLIC :: area = 100 INTEGER ( I4B ), PUBLIC :: maxAngle = 101 INTEGER ( I4B ), PUBLIC :: minAngle = 102 INTEGER ( I4B ), PUBLIC :: AngleRatio = 103 INTEGER ( I4B ), PUBLIC :: RadiusRatio = 104 INTEGER ( I4B ), PUBLIC :: EdgeRatio = 105 INTEGER ( I4B ), PUBLIC :: AspectRatio = 106 INTEGER ( I4B ), PUBLIC :: ScaledJacobian = 107 INTEGER ( I4B ), PUBLIC :: Default = 106 END TYPE QualityMeasure_","tags":"","loc":"type/qualitymeasure_.html"},{"title":"Random_ – Fortran Program ","text":"type, public :: Random_ Contents Variables random_int random_int_seed random_int_vec random_real random_real_vec Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: random_int = 100 integer(kind=I4B), public, ALLOCATABLE :: random_int_seed (:) integer(kind=I4B), public, ALLOCATABLE :: random_int_vec (:) real(kind=DFP), public :: random_real = 0.0_DFP real(kind=DFP), public, ALLOCATABLE :: random_real_vec (:)","tags":"","loc":"type/random_.html"},{"title":"Rank2TensorPointer_ – Fortran Program ","text":"type, public :: Rank2TensorPointer_ Contents Variables Ptr Source Code Rank2TensorPointer_ Components Type Visibility Attributes Name Initial class( Rank2Tensor_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: Rank2TensorPointer_ CLASS ( Rank2Tensor_ ), POINTER :: Ptr => NULL ( ) END TYPE Rank2TensorPointer_","tags":"","loc":"type/rank2tensorpointer_.html"},{"title":"Rank2Tensor_ – Fortran Program ","text":"type, public, EXTENDS( Tensor_ ) :: Rank2Tensor_ Contents Variables T Source Code Rank2Tensor_ Components Type Visibility Attributes Name Initial real(kind=DFP), public :: T (3,3) Source Code TYPE , EXTENDS ( Tensor_ ) :: Rank2Tensor_ REAL ( DFP ) :: T ( 3 , 3 ) END TYPE Rank2Tensor_","tags":"","loc":"type/rank2tensor_.html"},{"title":"RealMatrixPointer_ – Fortran Program ","text":"type, public :: RealMatrixPointer_ Contents Variables Ptr Source Code RealMatrixPointer_ Components Type Visibility Attributes Name Initial class( RealMatrix_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: RealMatrixPointer_ CLASS ( RealMatrix_ ), POINTER :: Ptr => NULL ( ) END TYPE RealMatrixPointer_","tags":"","loc":"type/realmatrixpointer_.html"},{"title":"RealMatrix_ – Fortran Program ","text":"type, public, EXTENDS( AbstractMatrix_ ) :: RealMatrix_ Contents Variables MatrixProp Val Source Code RealMatrix_ Components Type Visibility Attributes Name Initial character(len=5), public :: MatrixProp = 'UNSYM' real(kind=DFP), public, ALLOCATABLE :: Val (:,:) Source Code TYPE , EXTENDS ( AbstractMatrix_ ) :: RealMatrix_ REAL ( DFP ), ALLOCATABLE :: Val ( :, : ) CHARACTER ( LEN = 5 ) :: MatrixProp = 'UNSYM' END TYPE RealMatrix_","tags":"","loc":"type/realmatrix_.html"},{"title":"RealVectorPointer_ – Fortran Program ","text":"type, public :: RealVectorPointer_ Contents Variables Ptr Source Code RealVectorPointer_ Components Type Visibility Attributes Name Initial class( RealVector_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: RealVectorPointer_ CLASS ( RealVector_ ), POINTER :: Ptr => NULL ( ) END TYPE RealVectorPointer_","tags":"","loc":"type/realvectorpointer_.html"},{"title":"RealVector_ – Fortran Program ","text":"type, public, EXTENDS( AbstractVector_ ) :: RealVector_ Contents Variables Val Source Code RealVector_ Components Type Visibility Attributes Name Initial real(kind=DFP), public, ALLOCATABLE :: Val (:) Source Code TYPE , EXTENDS ( AbstractVector_ ) :: RealVector_ REAL ( DFP ), ALLOCATABLE :: Val ( : ) END TYPE RealVector_","tags":"","loc":"type/realvector_.html"},{"title":"ReferenceElementPointer_ – Fortran Program ","text":"type, public :: ReferenceElementPointer_ Contents Variables Ptr Source Code ReferenceElementPointer_ Components Type Visibility Attributes Name Initial class( ReferenceElement_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: ReferenceElementPointer_ CLASS ( ReferenceElement_ ), POINTER :: Ptr => NULL ( ) END TYPE ReferenceElementPointer_","tags":"","loc":"type/referenceelementpointer_.html"},{"title":"ReferenceElement_ – Fortran Program ","text":"type, public :: ReferenceElement_ Contents Variables EntityCounts NSD Name Order Topology XiDimension XiJ Type-Bound Procedures LagrangeElement LagrangePoints Source Code ReferenceElement_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: EntityCounts (4) integer(kind=I4B), public :: NSD integer(kind=I4B), public :: Name integer(kind=I4B), public :: Order type( ReferenceTopology_ ), public, ALLOCATABLE :: Topology (:) integer(kind=I4B), public :: XiDimension real(kind=DFP), public, ALLOCATABLE :: XiJ (:,:) Type-Bound Procedures procedure, public, PASS( Obj ) :: LagrangeElement => lag_elem_refelem interface private module function lag_elem_refelem(Obj, Order) result(Ans) Implementation → Arguments Type Intent Optional Attributes Name class( ReferenceElement_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value class( ReferenceElement_ ),\n  POINTER procedure, public, PASS( Obj ) :: LagrangePoints => lp_refelem interface private pure module function lp_refelem(Obj, Order) result(Ans) Implementation → Arguments Type Intent Optional Attributes Name class( ReferenceElement_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) Source Code TYPE :: ReferenceElement_ REAL ( DFP ), ALLOCATABLE :: XiJ ( :, : ) INTEGER ( I4B ) :: EntityCounts ( 4 ) INTEGER ( I4B ) :: XiDimension , Name , Order , NSD TYPE ( ReferenceTopology_ ), ALLOCATABLE :: Topology ( : ) CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: LagrangePoints => lp_refelem PROCEDURE , PUBLIC , PASS ( Obj ) :: LagrangeElement => lag_elem_refelem END TYPE ReferenceElement_","tags":"","loc":"type/referenceelement_.html"},{"title":"ReferenceHexahedron_ – Fortran Program ","text":"type, public, EXTENDS( ReferenceElement_ ) :: ReferenceHexahedron_ Contents Type-Bound Procedures LagrangeElement LagrangePoints Source Code ReferenceHexahedron_ Type-Bound Procedures procedure, public, PASS( Obj ) :: LagrangeElement => lag_elem_refHexahedron interface private module function lag_elem_refHexahedron(Obj, Order) result(Ans) Implementation → Arguments Type Intent Optional Attributes Name class( ReferenceHexahedron_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value class( ReferenceElement_ ),\n  POINTER procedure, public, PASS( Obj ) :: LagrangePoints => lp_refelem_Hexahedron interface private pure module function lp_refelem_Hexahedron(Obj, Order) result(Ans) Implementation → Arguments Type Intent Optional Attributes Name class( ReferenceHexahedron_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) Source Code TYPE , EXTENDS ( ReferenceElement_ ) :: ReferenceHexahedron_ CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: LagrangePoints => lp_refelem_Hexahedron PROCEDURE , PUBLIC , PASS ( Obj ) :: LagrangeElement => lag_elem_refHexahedron END TYPE ReferenceHexahedron_","tags":"","loc":"type/referencehexahedron_.html"},{"title":"ReferenceLine_ – Fortran Program ","text":"type, public, EXTENDS( ReferenceElement_ ) :: ReferenceLine_ Contents Type-Bound Procedures LagrangeElement LagrangePoints Source Code ReferenceLine_ Type-Bound Procedures procedure, public, PASS( Obj ) :: LagrangeElement => lag_elem_refline interface private module function lag_elem_refline(Obj, Order) result(Ans) Implementation → Arguments Type Intent Optional Attributes Name class( ReferenceLine_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value class( ReferenceElement_ ),\n  POINTER procedure, public, PASS( Obj ) :: LagrangePoints => lp_refelem_line interface private pure module function lp_refelem_line(Obj, Order) result(Ans) Implementation → Arguments Type Intent Optional Attributes Name class( ReferenceLine_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) Source Code TYPE , EXTENDS ( ReferenceElement_ ) :: ReferenceLine_ CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: LagrangePoints => lp_refelem_line PROCEDURE , PUBLIC , PASS ( Obj ) :: LagrangeElement => lag_elem_refLine END TYPE ReferenceLine_","tags":"","loc":"type/referenceline_.html"},{"title":"ReferencePrism_ – Fortran Program ","text":"type, public, EXTENDS( ReferenceElement_ ) :: ReferencePrism_ Contents Type-Bound Procedures LagrangeElement LagrangePoints Source Code ReferencePrism_ Type-Bound Procedures procedure, public, PASS( Obj ) :: LagrangeElement => lag_elem_refPrism interface private module function lag_elem_refPrism(Obj, Order) result(Ans) Implementation → Arguments Type Intent Optional Attributes Name class( ReferencePrism_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value class( ReferenceElement_ ),\n  POINTER procedure, public, PASS( Obj ) :: LagrangePoints => lp_refelem_Prism interface private pure module function lp_refelem_Prism(Obj, Order) result(Ans) Implementation → Arguments Type Intent Optional Attributes Name class( ReferencePrism_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) Source Code TYPE , EXTENDS ( ReferenceElement_ ) :: ReferencePrism_ CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: LagrangePoints => lp_refelem_Prism PROCEDURE , PUBLIC , PASS ( Obj ) :: LagrangeElement => lag_elem_refPrism END TYPE ReferencePrism_","tags":"","loc":"type/referenceprism_.html"},{"title":"ReferencePyramid_ – Fortran Program ","text":"type, public, EXTENDS( ReferenceElement_ ) :: ReferencePyramid_ Contents Type-Bound Procedures LagrangeElement LagrangePoints Source Code ReferencePyramid_ Type-Bound Procedures procedure, public, PASS( Obj ) :: LagrangeElement => lag_elem_refPyramid interface private module function lag_elem_refPyramid(Obj, Order) result(Ans) Implementation → Arguments Type Intent Optional Attributes Name class( ReferencePyramid_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value class( ReferenceElement_ ),\n  POINTER procedure, public, PASS( Obj ) :: LagrangePoints => lp_refelem_Pyramid interface private pure module function lp_refelem_Pyramid(Obj, Order) result(Ans) Implementation → Arguments Type Intent Optional Attributes Name class( ReferencePyramid_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) Source Code TYPE , EXTENDS ( ReferenceElement_ ) :: ReferencePyramid_ CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: LagrangePoints => lp_refelem_Pyramid PROCEDURE , PUBLIC , PASS ( Obj ) :: LagrangeElement => lag_elem_refPyramid END TYPE ReferencePyramid_","tags":"","loc":"type/referencepyramid_.html"},{"title":"ReferenceQuadrangle_ – Fortran Program ","text":"type, public, EXTENDS( ReferenceElement_ ) :: ReferenceQuadrangle_ Contents Type-Bound Procedures LagrangeElement LagrangePoints Source Code ReferenceQuadrangle_ Type-Bound Procedures procedure, public, PASS( Obj ) :: LagrangeElement => lag_elem_refQuadrangle interface private module function lag_elem_refQuadrangle(Obj, Order) result(Ans) Implementation → Arguments Type Intent Optional Attributes Name class( ReferenceQuadrangle_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value class( ReferenceElement_ ),\n  POINTER procedure, public, PASS( Obj ) :: LagrangePoints => lp_refelem_Quadrangle interface private pure module function lp_refelem_Quadrangle(Obj, Order) result(Ans) Implementation → Arguments Type Intent Optional Attributes Name class( ReferenceQuadrangle_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) Source Code TYPE , EXTENDS ( ReferenceElement_ ) :: ReferenceQuadrangle_ CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: LagrangePoints => lp_refelem_Quadrangle PROCEDURE , PUBLIC , PASS ( Obj ) :: LagrangeElement => lag_elem_refQuadrangle END TYPE ReferenceQuadrangle_","tags":"","loc":"type/referencequadrangle_.html"},{"title":"ReferenceTetrahedron_ – Fortran Program ","text":"type, public, EXTENDS( ReferenceElement_ ) :: ReferenceTetrahedron_ Contents Type-Bound Procedures LagrangeElement LagrangePoints Source Code ReferenceTetrahedron_ Type-Bound Procedures procedure, public, PASS( Obj ) :: LagrangeElement => lag_elem_refTetrahedron interface private module function lag_elem_refTetrahedron(Obj, Order) result(Ans) Implementation → Arguments Type Intent Optional Attributes Name class( ReferenceTetrahedron_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value class( ReferenceElement_ ),\n  POINTER procedure, public, PASS( Obj ) :: LagrangePoints => lp_refelem_Tetrahedron interface private pure module function lp_refelem_Tetrahedron(Obj, Order) result(Ans) Implementation → Arguments Type Intent Optional Attributes Name class( ReferenceTetrahedron_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) Source Code TYPE , EXTENDS ( ReferenceElement_ ) :: ReferenceTetrahedron_ CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: LagrangePoints => lp_refelem_Tetrahedron PROCEDURE , PUBLIC , PASS ( Obj ) :: LagrangeElement => lag_elem_refTetrahedron END TYPE ReferenceTetrahedron_","tags":"","loc":"type/referencetetrahedron_.html"},{"title":"ReferenceTopologyPointer_ – Fortran Program ","text":"type, public :: ReferenceTopologyPointer_ Contents Variables Ptr Source Code ReferenceTopologyPointer_ Components Type Visibility Attributes Name Initial class( ReferenceTopology_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: ReferenceTopologyPointer_ CLASS ( ReferenceTopology_ ), POINTER :: Ptr => NULL ( ) END TYPE ReferenceTopologyPointer_","tags":"","loc":"type/referencetopologypointer_.html"},{"title":"ReferenceTopology_ – Fortran Program ","text":"type, public :: ReferenceTopology_ Contents Variables Name Nptrs XiDimension Source Code ReferenceTopology_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: Name integer(kind=I4B), public, ALLOCATABLE :: Nptrs (:) integer(kind=I4B), public :: XiDimension Source Code TYPE :: ReferenceTopology_ INTEGER ( I4B ), ALLOCATABLE :: Nptrs ( : ) INTEGER ( I4B ) :: Name , XiDimension END TYPE ReferenceTopology_","tags":"","loc":"type/referencetopology_.html"},{"title":"ReferenceTriangle_ – Fortran Program ","text":"type, public, EXTENDS( ReferenceElement_ ) :: ReferenceTriangle_ Contents Type-Bound Procedures LagrangeElement LagrangePoints Source Code ReferenceTriangle_ Type-Bound Procedures procedure, public, PASS( Obj ) :: LagrangeElement => lag_elem_refTriangle interface private module function lag_elem_refTriangle(Obj, Order) result(Ans) Implementation → Arguments Type Intent Optional Attributes Name class( ReferenceTriangle_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value class( ReferenceElement_ ),\n  POINTER procedure, public, PASS( Obj ) :: LagrangePoints => lp_refelem_Triangle interface private pure module function lp_refelem_Triangle(Obj, Order) result(Ans) Implementation → Arguments Type Intent Optional Attributes Name class( ReferenceTriangle_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) Source Code TYPE , EXTENDS ( ReferenceElement_ ) :: ReferenceTriangle_ CONTAINS PROCEDURE , PUBLIC , PASS ( Obj ) :: LagrangePoints => lp_refelem_Triangle PROCEDURE , PUBLIC , PASS ( Obj ) :: LagrangeElement => lag_elem_refTriangle END TYPE ReferenceTriangle_","tags":"","loc":"type/referencetriangle_.html"},{"title":"STElemShapeData_ – Fortran Program ","text":"type, public, EXTENDS( ElemShapeData_ ) :: STElemShapeData_ This data type contains shapefunction related data defined\n at all gauss points of an elements ## How to initiate local shape data fortran\n program main\n   !! This program shows how to use space-time element shape data\n use easifem\n implicit none\n   !line order 1\n   type( stelemshapedata_ ), allocatable :: obj( : )\n   type( elemshapedata_ ) :: elemsd\n   type( quadraturepoint_ ) :: quad\n   class( referenceElement_ ), pointer :: refelem\n   integer( i4b ) :: orderInTime, ii\n   real( dfp ) :: xiJ( 1, 2 )\n   orderInTime = 2\n   ALLOCATE( ReferenceLine_ :: refelem )\n   refelem = ReferenceLine( nsd = 1 )\n   quad = GaussLegendreQuadrature(refelem=refelem,order=orderInTime )\n   ! higher order lagrange element\n   SELECT TYPE( refelem )\n   TYPE IS ( ReferenceLine_  )\n     refelem = LagrangeElement( refelem = refelem, order = 1 )\n   END SELECT\n   call initiate( &\n     & obj = elemsd, quad = quad, refelem = refelem, &\n     & ContinuityType= typeH1, InterpolType = TypeLagrangeInterpolation )\n   call initiate( obj = obj, elemsd = elemsd )\n   !! Generating shape functions for space element\n   ALLOCATE( ReferenceTriangle_ :: refelem )\n   refelem = ReferenceTriangle( nsd = 2 )\n   quad = GaussLegendreQuadrature( refelem=refelem, order = 2 )\n   do ii = 1, size( obj )\n     call initiate( &\n       & obj = obj( ii ), quad = quad, refelem = refelem, &\n       & ContinuityType= typeH1, InterpolType = TypeLagrangeInterpolation )\n     call display( obj( ii ), \"ii :: \"// str( ii ) )\n   end do\n end program Contents Variables Jt T Theta Wt dNTdXt dNTdt dTdTheta Source Code STElemShapeData_ Components Type Visibility Attributes Name Initial real(kind=DFP), public :: Jt = 0.0 Jacobian $\\frac{dt}{d\\theta}$ real(kind=DFP), public, ALLOCATABLE :: T (:) Shape function in time domain real(kind=DFP), public :: Theta = 0.0 Gauss point in time domain real(kind=DFP), public :: Wt = 0.0 Weight of gauss point in time domain real(kind=DFP), public, ALLOCATABLE :: dNTdXt (:,:,:,:) real(kind=DFP), public, ALLOCATABLE :: dNTdt (:,:,:) real(kind=DFP), public, ALLOCATABLE :: dTdTheta (:) Local shape function derivative in time domain Source Code TYPE , EXTENDS ( ElemShapeData_ ) :: STElemShapeData_ REAL ( DFP ) :: Wt = 0.0 !! Weight of gauss point in time domain REAL ( DFP ) :: Theta = 0.0 !! Gauss point in time domain REAL ( DFP ) :: Jt = 0.0 !! Jacobian $\\frac{dt}{d\\theta}$ REAL ( DFP ), ALLOCATABLE :: T ( : ) !! Shape function in time domain REAL ( DFP ), ALLOCATABLE :: dTdTheta ( : ) !! Local shape function derivative in time domain REAL ( DFP ), ALLOCATABLE :: dNTdt ( :, :, : ) REAL ( DFP ), ALLOCATABLE :: dNTdXt ( :, :, :, : ) END TYPE STElemShapeData_","tags":"","loc":"type/stelemshapedata_.html"},{"title":"STShapeDataPointer_ – Fortran Program ","text":"type, public :: STShapeDataPointer_ Contents Variables Ptr Source Code STShapeDataPointer_ Components Type Visibility Attributes Name Initial class( STShapeData_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: STShapeDataPointer_ CLASS ( STShapeData_ ), POINTER :: Ptr => NULL ( ) END TYPE STShapeDataPointer_","tags":"","loc":"type/stshapedatapointer_.html"},{"title":"STShapeData_ – Fortran Program ","text":"type, public, EXTENDS( ShapeData_ ) :: STShapeData_ This class extends ShapeData_ class to space-time FEM applcation Contents Variables Jt SpaceElemTopo T Theta TimeElemTopo Wt dNTdXt dNTdt dTdTheta Source Code STShapeData_ Components Type Visibility Attributes Name Initial real(kind=DFP), public :: Jt = 0.0 integer(kind=I4B), public :: SpaceElemTopo = 0 real(kind=DFP), public, ALLOCATABLE :: T (:) values of shape function at different time nodes real(kind=DFP), public :: Theta = 0.0 integer(kind=I4B), public :: TimeElemTopo = 0 real(kind=DFP), public :: Wt = 0.0 real(kind=DFP), public, ALLOCATABLE :: dNTdXt (:,:,:) Spatial gradient of the shape functions at space-time gauss points real(kind=DFP), public, ALLOCATABLE :: dNTdt (:,:) Value of global time derivative of T at time gauss points real(kind=DFP), public, ALLOCATABLE :: dTdTheta (:) Value of local time derivative of T at time gauss point Source Code TYPE , EXTENDS ( ShapeData_ ) :: STShapeData_ REAL ( DFP ) :: Theta = 0.0 REAL ( DFP ) :: Wt = 0.0 REAL ( DFP ) :: Jt = 0.0 INTEGER ( I4B ) :: SpaceElemTopo = 0 INTEGER ( I4B ) :: TimeElemTopo = 0 REAL ( DFP ), ALLOCATABLE :: T (:) !! values of shape function at different time nodes REAL ( DFP ), ALLOCATABLE :: dTdTheta ( : ) !! Value of local time derivative of T at time gauss point REAL ( DFP ), ALLOCATABLE :: dNTdt ( :, : ) !! Value of global time derivative of T at time gauss points REAL ( DFP ), ALLOCATABLE :: dNTdXt ( :, :, : ) !! Spatial gradient of the shape functions at space-time gauss points END TYPE STShapeData_","tags":"","loc":"type/stshapedata_.html"},{"title":"SerendipityInterpolation_ – Fortran Program ","text":"type, public, EXTENDS( BaseInterpolation_ ) :: SerendipityInterpolation_ Contents Source Code SerendipityInterpolation_ Source Code TYPE , EXTENDS ( BaseInterpolation_ ) :: SerendipityInterpolation_ END TYPE SerendipityInterpolation_","tags":"","loc":"type/serendipityinterpolation_.html"},{"title":"ShapeDataPointer_ – Fortran Program ","text":"type, public :: ShapeDataPointer_ Contents Variables Ptr Source Code ShapeDataPointer_ Components Type Visibility Attributes Name Initial class( ShapeDataPointer_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: ShapeDataPointer_ CLASS ( ShapeDataPointer_ ), POINTER :: Ptr => NULL ( ) END TYPE ShapeDataPointer_","tags":"","loc":"type/shapedatapointer_.html"},{"title":"ShapeData_ – Fortran Program ","text":"type, public :: ShapeData_ This Class bundles all required variables(related to shapefunctions)\n at a Gauss Point Contents Variables ElemTopology Jacobian Js N NSD Normal Thickness Ws XBar Xi dNdXi dNdXt Source Code ShapeData_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: ElemTopology = 0 real(kind=DFP), public, ALLOCATABLE :: Jacobian (:,:) real(kind=DFP), public :: Js = 0.0_DFP real(kind=DFP), public, ALLOCATABLE :: N (:) integer(kind=I4B), public :: NSD = 0 real(kind=DFP), public :: Normal (3) = 0.0_DFP real(kind=DFP), public :: Thickness = 1.0_DFP real(kind=DFP), public :: Ws = 0.0_DFP real(kind=DFP), public :: XBar (3) = 0.0_DFP real(kind=DFP), public :: Xi (3) = 0.0_DFP real(kind=DFP), public, ALLOCATABLE :: dNdXi (:,:) real(kind=DFP), public, ALLOCATABLE :: dNdXt (:,:) Source Code TYPE :: ShapeData_ REAL ( DFP ) :: Ws = 0.0_DFP REAL ( DFP ) :: Js = 0.0_DFP REAL ( DFP ) :: Thickness = 1.0_DFP REAL ( DFP ) :: Xi ( 3 ) = 0.0_DFP REAL ( DFP ) :: XBar ( 3 ) = 0.0_DFP REAL ( DFP ) :: Normal ( 3 ) = 0.0_DFP INTEGER ( I4B ) :: ElemTopology = 0 INTEGER ( I4B ) :: NSD = 0 REAL ( DFP ), ALLOCATABLE :: N ( : ) REAL ( DFP ), ALLOCATABLE :: dNdXi ( :, : ) REAL ( DFP ), ALLOCATABLE :: dNdXt ( :, : ) REAL ( DFP ), ALLOCATABLE :: Jacobian ( :, : ) END TYPE ShapeData_","tags":"","loc":"type/shapedata_.html"},{"title":"SparseMatrixPointer_ – Fortran Program ","text":"type, public :: SparseMatrixPointer_ Contents Variables Ptr Source Code SparseMatrixPointer_ Components Type Visibility Attributes Name Initial class( SparseMatrix_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: SparseMatrixPointer_ CLASS ( SparseMatrix_ ), POINTER :: Ptr => NULL ( ) END TYPE SparseMatrixPointer_","tags":"","loc":"type/sparsematrixpointer_.html"},{"title":"SparseMatrix_ – Fortran Program ","text":"type, public, EXTENDS( AbstractMatrix_ ) :: SparseMatrix_ Contents Variables A ColSize Diag DiagIndx IA JA MatrixProp Row RowSize StorageFMT ncol nnz nrow tDOF tNodes Source Code SparseMatrix_ Components Type Visibility Attributes Name Initial real(kind=DFP), public, ALLOCATABLE :: A (:) integer(kind=I4B), public, ALLOCATABLE :: ColSize (:) real(kind=DFP), public, ALLOCATABLE :: Diag (:) integer(kind=I4B), public, ALLOCATABLE :: DiagIndx (:) integer(kind=I4B), public, ALLOCATABLE :: IA (:) integer(kind=I4B), public, ALLOCATABLE :: JA (:) character(len=5), public :: MatrixProp = 'UNSYM' type( IntVector_ ), public, ALLOCATABLE :: Row (:) integer(kind=I4B), public, ALLOCATABLE :: RowSize (:) integer(kind=I4B), public :: StorageFMT = Nodes_FMT integer(kind=I4B), public :: ncol = 0 integer(kind=I4B), public :: nnz = 0 integer(kind=I4B), public :: nrow = 0 integer(kind=I4B), public :: tDOF = 1 integer(kind=I4B), public :: tNodes = 0 Source Code TYPE , EXTENDS ( AbstractMatrix_ ) :: SparseMatrix_ TYPE ( IntVector_ ), ALLOCATABLE :: Row ( : ) INTEGER ( I4B ), ALLOCATABLE :: IA ( : ) INTEGER ( I4B ), ALLOCATABLE :: JA ( : ) INTEGER ( I4B ), ALLOCATABLE :: ColSize ( : ) INTEGER ( I4B ), ALLOCATABLE :: RowSize ( : ) INTEGER ( I4B ), ALLOCATABLE :: DiagIndx ( : ) REAL ( DFP ), ALLOCATABLE :: A ( : ), Diag ( : ) INTEGER ( I4B ) :: tDOF = 1 INTEGER ( I4B ) :: tNodes = 0 INTEGER ( I4B ) :: nnz = 0 INTEGER ( I4B ) :: ncol = 0 INTEGER ( I4B ) :: nrow = 0 CHARACTER ( LEN = 5 ) :: MatrixProp = 'UNSYM' INTEGER ( I4B ) :: StorageFMT = Nodes_FMT END TYPE SparseMatrix_","tags":"","loc":"type/sparsematrix_.html"},{"title":"StringPointer_ – Fortran Program ","text":"type, public :: StringPointer_ Contents Variables Ptr Source Code StringPointer_ Components Type Visibility Attributes Name Initial type(String), public, POINTER :: Ptr => NULL() Source Code TYPE :: StringPointer_ TYPE ( String ), POINTER :: Ptr => NULL () END TYPE StringPointer_","tags":"","loc":"type/stringpointer_.html"},{"title":"Tensor_ – Fortran Program ","text":"type, private :: Tensor_ Contents Source Code Tensor_ Source Code TYPE :: Tensor_ END TYPE Tensor_","tags":"","loc":"type/tensor_.html"},{"title":"VoigtRank2TensorPointer – Fortran Program ","text":"type, public :: VoigtRank2TensorPointer Contents Variables Ptr Source Code VoigtRank2TensorPointer Components Type Visibility Attributes Name Initial class( VoigtRank2Tensor_ ), public, POINTER :: Ptr => NULL() Source Code TYPE :: VoigtRank2TensorPointer CLASS ( VoigtRank2Tensor_ ), POINTER :: Ptr => NULL ( ) END TYPE VoigtRank2TensorPointer","tags":"","loc":"type/voigtrank2tensorpointer.html"},{"title":"VoigtRank2Tensor_ – Fortran Program ","text":"type, public :: VoigtRank2Tensor_ Contents Variables V Source Code VoigtRank2Tensor_ Components Type Visibility Attributes Name Initial real(kind=DFP), public :: V (9) Source Code TYPE :: VoigtRank2Tensor_ REAL ( DFP ) :: V ( 9 ) END TYPE VoigtRank2Tensor_","tags":"","loc":"type/voigtrank2tensor_.html"},{"title":"en_encode – Fortran Program","text":"abstract interface private function en_encode(obj) result(ans) Arguments Type Intent Optional Attributes Name class( gmshEntity_ ), intent(in) :: obj Return Value type(String)","tags":"","loc":"interface/en_encode.html"},{"title":"ls_deallocate – Fortran Program","text":"abstract interface private subroutine ls_deallocate(Obj) Arguments Type Intent Optional Attributes Name class( LinSolver_ ), intent(inout) :: Obj","tags":"","loc":"interface/ls_deallocate.html"},{"title":"ls_display – Fortran Program","text":"abstract interface private subroutine ls_display(Obj, msg, Unitno) Arguments Type Intent Optional Attributes Name class( LinSolver_ ), intent(in) :: Obj character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: Unitno","tags":"","loc":"interface/ls_display.html"},{"title":"ls_init – Fortran Program","text":"abstract interface private subroutine ls_init(Obj, SolverName, MaxIter, Tol, diagScale, ipar, fpar) Arguments Type Intent Optional Attributes Name class( LinSolver_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: SolverName integer(kind=I4B), intent(in) :: MaxIter real(kind=DFP), intent(in) :: Tol integer(kind=I4B), intent(in), optional :: diagScale integer(kind=I4B), intent(in), optional :: ipar (:) real(kind=DFP), intent(in), optional :: fpar (:)","tags":"","loc":"interface/ls_init.html"},{"title":"ls_set_dbc_1 – Fortran Program","text":"abstract interface private subroutine ls_set_dbc_1(Obj, Nptrs, dofs) Arguments Type Intent Optional Attributes Name class( LinSolver_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Nptrs (:) integer(kind=I4B), intent(in) :: dofs (:)","tags":"","loc":"interface/ls_set_dbc_1.html"},{"title":"ls_set_dbc_2 – Fortran Program","text":"abstract interface private subroutine ls_set_dbc_2(Obj, Nptrs, dofs) Arguments Type Intent Optional Attributes Name class( LinSolver_ ), intent(inout) :: Obj type(IntVector_), intent(in) :: Nptrs (:) integer(kind=I4B), intent(in) :: dofs (:)","tags":"","loc":"interface/ls_set_dbc_2.html"},{"title":"ls_set_matrix – Fortran Program","text":"abstract interface private subroutine ls_set_matrix(From, To) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(in), TARGET :: From class( LinSolver_ ), intent(inout) :: To","tags":"","loc":"interface/ls_set_matrix.html"},{"title":"ls_set_precon – Fortran Program","text":"abstract interface private subroutine ls_set_precon(Obj, precondtype, ipar, fpar) Arguments Type Intent Optional Attributes Name class( LinSolver_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: precondtype integer(kind=I4B), intent(in), optional :: ipar (:) real(kind=DFP), intent(in), optional :: fpar (:)","tags":"","loc":"interface/ls_set_precon.html"},{"title":"ls_set_sparsity – Fortran Program","text":"abstract interface private subroutine ls_set_sparsity(From, To) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(in), TARGET :: From class( LinSolver_ ), intent(inout) :: To","tags":"","loc":"interface/ls_set_sparsity.html"},{"title":"ls_solve – Fortran Program","text":"abstract interface private subroutine ls_solve(Obj, sol, rhs) Arguments Type Intent Optional Attributes Name class( LinSolver_ ), intent(inout) :: Obj real(kind=DFP), intent(inout) :: sol (:) real(kind=DFP), intent(inout) :: rhs (:)","tags":"","loc":"interface/ls_solve.html"},{"title":"ls_w_res – Fortran Program","text":"abstract interface private subroutine ls_w_res(Obj, path, prefix, fmt, iter) Arguments Type Intent Optional Attributes Name class( LinSolver_ ), intent(in) :: Obj character(len=*), intent(in) :: path character(len=*), intent(in) :: prefix character(len=*), intent(in) :: fmt integer(kind=I4B), intent(in), optional :: iter","tags":"","loc":"interface/ls_w_res.html"},{"title":"sfcc_get_value – Fortran Program","text":"abstract interface private pure function sfcc_get_value(Obj, Temp) result(Ans) Arguments Type Intent Optional Attributes Name class(SFCCModel_), intent(in) :: Obj real(kind=DFP), intent(in) :: Temp Return Value real(kind=DFP)","tags":"","loc":"interface/sfcc_get_value.html"},{"title":"thermcond_get_value – Fortran Program","text":"abstract interface private pure function thermcond_get_value(Obj, volFrac_solid, volFrac_water, volFrac_ice, volFrac_air, Temp, x, y, z) result(Ans) Arguments Type Intent Optional Attributes Name class(ThermCondModel_), intent(in) :: Obj real(kind=DFP), intent(in), optional :: volFrac_solid real(kind=DFP), intent(in), optional :: volFrac_water real(kind=DFP), intent(in), optional :: volFrac_ice real(kind=DFP), intent(in), optional :: volFrac_air real(kind=DFP), intent(in), optional :: Temp real(kind=DFP), intent(in), optional :: x real(kind=DFP), intent(in), optional :: y real(kind=DFP), intent(in), optional :: z Return Value real(kind=DFP)","tags":"","loc":"interface/thermcond_get_value.html"},{"title":"volHeatCap_get_value – Fortran Program","text":"abstract interface private pure function volHeatCap_get_value(Obj, volFrac_solid, volFrac_water, volFrac_ice, volFrac_air, Temp, x, y, z) result(Ans) Arguments Type Intent Optional Attributes Name class(volHeatCapModel_), intent(in) :: Obj real(kind=DFP), intent(in), optional :: volFrac_solid real(kind=DFP), intent(in), optional :: volFrac_water real(kind=DFP), intent(in), optional :: volFrac_ice real(kind=DFP), intent(in), optional :: volFrac_air real(kind=DFP), intent(in), optional :: Temp real(kind=DFP), intent(in), optional :: x real(kind=DFP), intent(in), optional :: y real(kind=DFP), intent(in), optional :: z Return Value real(kind=DFP)","tags":"","loc":"interface/volheatcap_get_value.html"},{"title":"kernel_assemble – Fortran Program","text":"abstract interface private subroutine kernel_assemble(Obj) Arguments Type Intent Optional Attributes Name class( Kernel_ ), intent(inout) :: Obj","tags":"","loc":"interface/kernel_assemble.html"},{"title":"kernel_isconverg – Fortran Program","text":"abstract interface private function kernel_isconverg(Obj, relTol, absTol, convergeInRes, convergeInSol) result(Ans) Arguments Type Intent Optional Attributes Name class( Kernel_ ), intent(inout) :: Obj real(kind=DFP), intent(in), optional :: relTol real(kind=DFP), intent(in), optional :: absTol logical(kind=LGT), intent(in), optional :: convergeInRes logical(kind=LGT), intent(in), optional :: convergeInSol Return Value logical(kind=LGT)","tags":"","loc":"interface/kernel_isconverg.html"},{"title":"kernel_savestate – Fortran Program","text":"abstract interface private subroutine kernel_savestate(Obj, Path, Filename, Extension, timestep) Arguments Type Intent Optional Attributes Name class( Kernel_ ), intent(inout) :: Obj character(len=*), intent(in) :: Path character(len=*), intent(in) :: Filename character(len=*), intent(in) :: Extension integer(kind=I4B), intent(in) :: timestep","tags":"","loc":"interface/kernel_savestate.html"},{"title":"kernel_set_kernel – Fortran Program","text":"abstract interface private subroutine kernel_set_kernel(Obj) Arguments Type Intent Optional Attributes Name class( Kernel_ ), intent(inout) :: Obj","tags":"","loc":"interface/kernel_set_kernel.html"},{"title":"kernel_solve – Fortran Program","text":"abstract interface private subroutine kernel_solve(Obj) Arguments Type Intent Optional Attributes Name class( Kernel_ ), intent(inout) :: Obj","tags":"","loc":"interface/kernel_solve.html"},{"title":"kernel_update – Fortran Program","text":"abstract interface private subroutine kernel_update(Obj, reset) Arguments Type Intent Optional Attributes Name class( Kernel_ ), intent(inout) :: Obj logical(kind=LGT), intent(in) :: reset","tags":"","loc":"interface/kernel_update.html"},{"title":"kernel_writedata – Fortran Program","text":"abstract interface private subroutine kernel_writedata(Obj, gmsh, path, filename, extension, indx) Arguments Type Intent Optional Attributes Name class( Kernel_ ), intent(inout) :: Obj type(gmsh_), intent(inout), optional :: gmsh character(len=*), intent(in), optional :: path character(len=*), intent(in), optional :: filename character(len=*), intent(in), optional :: extension integer(kind=I4B), intent(in) :: indx (:)","tags":"","loc":"interface/kernel_writedata.html"},{"title":"c8mat_expm1 – Fortran Program","text":"subroutine c8mat_expm1(n, a, e) * * * * * * * * * * * *80 C8MAT_EXPM1 is essentially MATLAB’s built-in matrix exponential algorithm. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n complex(kind=8) :: a (n,n) complex(kind=8) :: e (n,n) Contents None","tags":"","loc":"proc/c8mat_expm1.html"},{"title":"r8mat_expm1 – Fortran Program","text":"subroutine r8mat_expm1(n, a, e) * * * * * * * * * * * *80 R8MAT_EXPM1 is essentially MATLAB’s built-in matrix exponential algorithm. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: a (n,n) real(kind=8) :: e (n,n) Contents None","tags":"","loc":"proc/r8mat_expm1.html"},{"title":"r8mat_expm2 – Fortran Program","text":"subroutine r8mat_expm2(n, a, e) * * * * * * * * * * * *80 R8MAT_EXPM2 uses the Taylor series for the matrix exponential. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: a (n,n) real(kind=8) :: e (n,n) Contents None","tags":"","loc":"proc/r8mat_expm2.html"},{"title":"r8mat_expm3 – Fortran Program","text":"subroutine r8mat_expm3(n, a, e) * * * * * * * * * * * *80 R8MAT_EXPM3 approximates the matrix exponential using an eigenvalue approach. Arguments Type Intent Optional Attributes Name integer :: n real :: a real :: e Contents None","tags":"","loc":"proc/r8mat_expm3.html"},{"title":"DSYTRD3 – Fortran Program","text":"subroutine DSYTRD3(A, Q, D, E) Arguments Type Intent Optional Attributes Name double precision :: A (3,3) double precision :: Q (3,3) double precision :: D (3) double precision :: E (2) Contents None","tags":"","loc":"proc/dsytrd3.html"},{"title":"DSYEVQ3 – Fortran Program","text":"subroutine DSYEVQ3(A, Q, W) Arguments Type Intent Optional Attributes Name double precision :: A (3,3) double precision :: Q (3,3) double precision :: W (3) Contents None","tags":"","loc":"proc/dsyevq3.html"},{"title":"DSYEVH3 – Fortran Program","text":"subroutine DSYEVH3(A, Q, W) Arguments Type Intent Optional Attributes Name double precision :: A (3,3) double precision :: Q (3,3) double precision :: W (3) Contents None","tags":"","loc":"proc/dsyevh3.html"},{"title":"DSYEVC3 – Fortran Program","text":"subroutine DSYEVC3(A, W) Arguments Type Intent Optional Attributes Name double precision :: A (3,3) double precision :: W (3) Contents None","tags":"","loc":"proc/dsyevc3.html"},{"title":"meshdata_ptr_1 – Fortran Program","text":"private function meshdata_ptr_1(MeshObj) result(Ans) Function that returns pointer to the MeshData_ object Usage fortran\n    class( meshdata_ ), pointer :: obj\n obj => MeshData_Pointer( MeshObj ) Arguments Type Intent Optional Attributes Name class(Mesh_), intent(inout) :: MeshObj Mesh_ Object Return Value class( MeshData_ ),\n  POINTER MeshData_ object Contents Source Code meshdata_ptr_1 Source Code FUNCTION meshdata_ptr_1 ( MeshObj ) RESULT ( Ans ) CLASS ( MeshData_ ), POINTER :: Ans !! MeshData_ object CLASS ( Mesh_ ), INTENT ( INOUT ) :: MeshObj !! Mesh_ Object ALLOCATE ( MeshData_ :: Ans ) CALL Ans % Initiate ( MeshObj ) END FUNCTION meshdata_ptr_1","tags":"","loc":"proc/meshdata_ptr_1.html"},{"title":"BoundingBox – Fortran Program","text":"public interface BoundingBox Generic method for obtaining bounding box for a mesh Contents Module Procedures get_bBox Module Procedures private interface get_Bbox () Return the boundinb box of mesh Arguments None","tags":"","loc":"interface/boundingbox.html"},{"title":"DeallocateData – Fortran Program","text":"public interface DeallocateData Generic subroutine to deallocate data stored inside MeshData_ Contents Module Procedures Deallocate_meshdata Module Procedures private interface Deallocate_meshdata () Deallocate data stored inside MeshData_ Arguments None","tags":"","loc":"interface/deallocatedata.html"},{"title":"Deallocate_meshdata – Fortran Program","text":"interface Deallocate data stored inside MeshData_ private subroutine Deallocate_meshdata(Obj) Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(inout) :: Obj mesh data object Description Deallocate data stored inside MeshData_ Usage fortran\n    call deallocateData( Obj )","tags":"","loc":"interface/deallocate_meshdata.html"},{"title":"Initiate – Fortran Program","text":"public interface Initiate Contents Module Procedures init_meshdata_1 Module Procedures private interface init_meshdata_1 () Initiate MeshData_ object Arguments None","tags":"","loc":"interface/initiate.html"},{"title":"MeshData – Fortran Program","text":"public interface MeshData Generic function to construct MeshData_ Contents Module Procedures meshdata_1 Module Procedures private interface meshdata_1 () MeshData() function to construct mesh data Arguments None","tags":"","loc":"interface/meshdata.html"},{"title":"MeshData_Pointer – Fortran Program","text":"public interface MeshData_Pointer Generic function that Returns pointer to MeshData_ object Contents Module Procedures meshdata_ptr_1 Module Procedures private function meshdata_ptr_1 (MeshObj) result(Ans) Function that returns pointer to the MeshData_ object Read more… Arguments Type Intent Optional Attributes Name class(Mesh_), intent(inout) :: MeshObj Mesh_ Object Return Value class( MeshData_ ),\n  POINTER MeshData_ object","tags":"","loc":"interface/meshdata_pointer.html"},{"title":"get_Bbox – Fortran Program","text":"interface Return the boundinb box of mesh private pure function get_Bbox(Obj, nodes) result(Ans) Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj mesh data object real(kind=DFP), intent(in) :: nodes (:,:) nodal coordinates in xiJ format Return Value type(BoundingBox_) bounding box for mesh Description Return the bounding box of mesh Usage fortran\n    bbox = BoundingBox( Obj, nodes )","tags":"","loc":"interface/get_bbox.html"},{"title":"get_bndy_elem – Fortran Program","text":"interface Returns boundary element data private pure function get_bndy_elem(Obj, iel) result(Ans) Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj mesh data integer(kind=I4B), intent(in) :: iel element number Return Value integer(kind=I4B),\n  ALLOCATABLE,(:) boundary data Description If element is a boundary element then it Returns a integer vector\n containing the id of local facets which is boundary of mesh\n otherwise it will return [0] Usage fortran\n    val = Obj % boundaryElementData(iel)","tags":"","loc":"interface/get_bndy_elem.html"},{"title":"get_elem_elems_1 – Fortran Program","text":"interface Return element to element connectivity information private pure function get_elem_elems_1(Obj, iel) result(Ans) Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj mesh data integer(kind=I4B), intent(in) :: iel element number Return Value integer(kind=I4B),\n  ALLOCATABLE,(:,:) list of elements surrounding elements Description Return element to element connectivity information for a given element\n number iel - This routine return full information about elements surrounding\n element iel - Rows of Ans denote the element to which iel is connected to\n - Column-1 of Ans denotes element number\n - Column-2 denotes the local face number of element iel , and\n - Column-3 denotes the local face number of element whose element number is\n given in the column-1 Usage fortran\n    val = Obj % ElementToElements( iel )","tags":"","loc":"interface/get_elem_elems_1.html"},{"title":"get_elem_elems_2 – Fortran Program","text":"interface Return element to element connectivity information private pure function get_elem_elems_2(Obj, iel) result(Ans) Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: iel (2) Return Value integer(kind=I4B),\n  ALLOCATABLE,(:,:) Description Return element to element connectivity information for a given element\n number iel - iel( 2 ) denotes the extra options\n     0 —> only Return the element numbers\n     1 —> Return the full information\n - This routine return full information when iel(2)=1 about elements surrounding element iel - Rows of Ans denote the element to which iel is connected to\n - Column-1 of Ans denotes element number\n - Column-2 denotes the local face number of element iel , and\n - Column-3 denotes the local face number of element whose element number is\n given in the column-1 Usage fortran\n    val = Obj % ElementToElements( iel )","tags":"","loc":"interface/get_elem_elems_2.html"},{"title":"get_elem_nodes – Fortran Program","text":"interface Return element to nodes data private pure function get_elem_nodes(Obj, iel) result(Ans) Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj mesh data integer(kind=I4B), intent(in) :: iel element number Return Value integer(kind=I4B),\n  ALLOCATABLE,(:) list of elements surrounding the nodes Description Return element to nodes data Usage fortran\n    val = Obj % elementToNodes( iel )","tags":"","loc":"interface/get_elem_nodes.html"},{"title":"get_facet_elements – Fortran Program","text":"interface This subroutine returns the mesh of facet/boundary elements of mesh obj private subroutine get_facet_elements(mdObj, Obj, facetmesh, feObj) Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(inout) :: mdObj Mesh data of parent mesh class(Mesh_), intent(inout) :: Obj Parent mesh class(Mesh_), intent(inout) :: facetmesh facet mesh to be constructed class(Element_), intent(in) :: feObj Finite element Description This subroutine returns the mesh of boundary/facet elements of parent mesh Obj","tags":"","loc":"interface/get_facet_elements.html"},{"title":"get_node_nodes – Fortran Program","text":"interface Return a list of nodes surrounding a given global node number private pure function get_node_nodes(Obj, GlobalNode, IncludeSelf) result(Ans) Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj mesh data integer(kind=I4B), intent(in) :: GlobalNode global node number logical(kind=LGT), intent(in) :: IncludeSelf logical variable Return Value integer(kind=I4B),\n  ALLOCATABLE,(:) vec of node number surrounding GlobalNode Description Return a list of nodes surrounding a given global node number IndcludeSelf is a logical parameter; if it is true self number is\n     is also returned, otherwise only surrounding node number is returned","tags":"","loc":"interface/get_node_nodes.html"},{"title":"get_tbndy_elems – Fortran Program","text":"interface This function returns the total boundary elements in mesh private pure function get_tbndy_elems(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj Return Value integer(kind=I4B) Description This function returns the total bounadry elements in mesh","tags":"","loc":"interface/get_tbndy_elems.html"},{"title":"get_tbndy_nodes – Fortran Program","text":"interface Return total number of boundary nodes private pure function get_tbndy_nodes(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj mesh data Return Value integer(kind=I4B) total boundary nodes Description Return total number of boundary nodes Usage fortran\n    tnodes = Obj % totalBoundaryNodes( )","tags":"","loc":"interface/get_tbndy_nodes.html"},{"title":"get_tint_nodes – Fortran Program","text":"interface Returns total number of internal bounary nodes private pure function get_tint_nodes(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj mesh data Return Value integer(kind=I4B) total number of internal boundary nodes Description Returns total number of internal bounary nodes Usage fortran\n    tnodes = obj % totalInternalNodes( )","tags":"","loc":"interface/get_tint_nodes.html"},{"title":"get_total_nodes – Fortran Program","text":"interface Return total number of nodes private pure function get_total_nodes(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj Mesh data object Return Value integer(kind=I4B) Total number of nodes Description This function will Return the total number of nodes present in meshdata Usage fortran\n    tnodes = Obj % TotalNodes( )","tags":"","loc":"interface/get_total_nodes.html"},{"title":"global_from_local – Fortran Program","text":"interface Convert local node number to global node number private pure function global_from_local(Obj, LocalIndx) result(Ans) Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj mesh data integer(kind=I4B), intent(in) :: LocalIndx (:) vec of local node number Return Value integer(kind=I4B),\n  ALLOCATABLE,(:) vec of global node number Description Convert local node number to global node number Usage fortran\n    indx = obj % globalNptrs( localIndx )","tags":"","loc":"interface/global_from_local.html"},{"title":"global_from_local_scalar – Fortran Program","text":"interface Convert local node number to global node number private pure function global_from_local_scalar(Obj, LocalIndx) result(Ans) Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj mesh data integer(kind=I4B), intent(in) :: LocalIndx local node number Return Value integer(kind=I4B) global node number Description Convert local node number to global node number Usage fortran\n    indx = obj % globalNptrs( localIndx )","tags":"","loc":"interface/global_from_local_scalar.html"},{"title":"init_bndy_data – Fortran Program","text":"interface Initiate boundary data of mesh private subroutine init_bndy_data(Obj, MeshObj) Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(inout) :: Obj mesh data class(Mesh_), intent(inout) :: MeshObj mesh object Description Initiate boundary data of mesh Usage fortran\n    call obj % initiateBoundaryData( MeshObj )","tags":"","loc":"interface/init_bndy_data.html"},{"title":"init_elem_nodes – Fortran Program","text":"interface Initiate element to node data private subroutine init_elem_nodes(Obj, MeshObj) Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(inout) :: Obj mesh data class(Mesh_), intent(inout) :: MeshObj mesh object Description Initiate element to node data Usage fortran\n    call obj % elementToNodes( Meshobj )","tags":"","loc":"interface/init_elem_nodes.html"},{"title":"init_element_elements – Fortran Program","text":"interface Initiate element to element connectivity data private subroutine init_element_elements(Obj, MeshObj) Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(inout) :: Obj mesh data class(Mesh_), intent(inout) :: MeshObj mesh object Description Initiate element to element connectivity data Usage fortran\n    call obj % initiateElementToElement( MeshObj )","tags":"","loc":"interface/init_element_elements.html"},{"title":"init_int_bndydata – Fortran Program","text":"interface Initiate internal boundary data private subroutine init_int_bndydata(Obj, MeshObj) Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(inout) :: Obj class(Mesh_), intent(inout) :: MeshObj","tags":"","loc":"interface/init_int_bndydata.html"},{"title":"init_int_nptrs – Fortran Program","text":"interface Initiate internal node numbers private subroutine init_int_nptrs(Obj, MeshObj) Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(inout) :: Obj mesh data class(Mesh_), intent(inout) :: MeshObj mesh object Description Initiate internal node numbers Usage fortran\n    call obj % initiateInternalNptrs( MeshObj )","tags":"","loc":"interface/init_int_nptrs.html"},{"title":"init_meshdata_1 – Fortran Program","text":"interface Initiate MeshData_ object private subroutine init_meshdata_1(Obj, MeshObj) Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(inout) :: Obj mesh data container class(Mesh_), intent(inout) :: MeshObj mesh object Description Initiate MeshData_ object Usage fortran\n    call obj % initiate( meshobj )","tags":"","loc":"interface/init_meshdata_1.html"},{"title":"init_node_elements – Fortran Program","text":"interface generate Elements surrounding a node mapping private subroutine init_node_elements(Obj, MeshObj) Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(inout) :: Obj mesh data class(Mesh_), intent(inout) :: MeshObj mesh object Description This subroutine generate Elements surrounding a node mapping\n - The mapping is stored in the array called NodeToElem - The size of NodeToElem array is same as Obj % Nptrs - Always use method called NodeToElements() to access this information Warning Always use the mapping between global node number and local node number to\n avoid segmentation fault Usage fortran\n    call Obj % initiateNodeToElements( MeshObj )","tags":"","loc":"interface/init_node_elements.html"},{"title":"init_node_nodes – Fortran Program","text":"interface Initiate node to node connectivity data private subroutine init_node_nodes(Obj, MeshObj) Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(inout) :: Obj mesh data class(Mesh_), intent(inout) :: MeshObj mesh object Description Initiate node to node connectivity data Usage fortran\n    call obj % initiateNodeToNode( meshobj )","tags":"","loc":"interface/init_node_nodes.html"},{"title":"is_bndy_elem – Fortran Program","text":"interface Returns .true. if a given element number iel is boundary element private pure function is_bndy_elem(Obj, iel) result(Ans) Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj mesh data integer(kind=I4B), intent(in) :: iel element number Return Value logical(kind=LGT) .true. if iel is a boundary element Description Returns .true. if a given element number iel is boundary element Usage fortran\n    is = Obj % isBoundaryElement( iel )","tags":"","loc":"interface/is_bndy_elem.html"},{"title":"is_bndy_nptrs – Fortran Program","text":"interface Returns .true. if data related to boundary nptrs is initiated. private pure function is_bndy_nptrs(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj Return Value logical(kind=LGT) Description Returns .true. if data related to boundary nptrs is initiated.","tags":"","loc":"interface/is_bndy_nptrs.html"},{"title":"is_boundarydata – Fortran Program","text":"interface Returns .true. if boundary data is initiated. private pure function is_boundarydata(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj Return Value logical(kind=LGT) Description Returns .true. if boundary data is initiated.","tags":"","loc":"interface/is_boundarydata.html"},{"title":"is_element_elements_initiated – Fortran Program","text":"interface Returns .true. if elem to elem connectivity data is initiated. private pure function is_element_elements_initiated(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj Return Value logical(kind=LGT) Description Returns .true. if elem to elem connectivity data is initiated.","tags":"","loc":"interface/is_element_elements_initiated.html"},{"title":"is_element_nodes_initiated – Fortran Program","text":"interface Returns .true. if elem to node connectivity data is initiated. private pure function is_element_nodes_initiated(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj Return Value logical(kind=LGT) Description Returns .true. if elem to node connectivity data is initiated.","tags":"","loc":"interface/is_element_nodes_initiated.html"},{"title":"is_int_bndy_data – Fortran Program","text":"interface Returns .true. if internal bounary data is initiated private pure function is_int_bndy_data(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj Return Value logical(kind=LGT) Description Returns .true. if internal bounary data is initiated","tags":"","loc":"interface/is_int_bndy_data.html"},{"title":"is_internalnptrs – Fortran Program","text":"interface Returns .true. if data related to internal nptrs is initiated. private pure function is_internalnptrs(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj Return Value logical(kind=LGT) Description Returns .true. if data related to internal nptrs is initiated.","tags":"","loc":"interface/is_internalnptrs.html"},{"title":"is_local_nptrs – Fortran Program","text":"interface Returns .true. if data local_nptrs array is initiated. private pure function is_local_nptrs(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj Return Value logical(kind=LGT) Description Returns .true. if data local_nptrs array is initiated.","tags":"","loc":"interface/is_local_nptrs.html"},{"title":"is_node_elements_initiated – Fortran Program","text":"interface Returns .true. if node to elem connectivity data is initiated. private pure function is_node_elements_initiated(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj Return Value logical(kind=LGT) Description Returns .true. if node to elem connectivity data is initiated.","tags":"","loc":"interface/is_node_elements_initiated.html"},{"title":"is_node_nodes_initiated – Fortran Program","text":"interface Returns .true. if node to node connectivity data is initiated. private pure function is_node_nodes_initiated(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj Return Value logical(kind=LGT)","tags":"","loc":"interface/is_node_nodes_initiated.html"},{"title":"is_node_present – Fortran Program","text":"interface Returns .true. if the a global node is present inside the mesh-data private pure function is_node_present(Obj, Nptrs) result(Ans) Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj mesh data integer(kind=I4B), intent(in) :: Nptrs global node number Return Value logical(kind=LGT) Returns true if present Description Returns .true. if the a global node is present inside the mesh-data Usage fortran\n    is = Obj % isNodePresent( Nptrs )","tags":"","loc":"interface/is_node_present.html"},{"title":"local_from_global – Fortran Program","text":"interface Convert global node number to local node  number private pure function local_from_global(Obj, GlobalIndx) result(Ans) Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj mesh data integer(kind=I4B), intent(in) :: GlobalIndx (:) vec of global node numbers Return Value integer(kind=I4B),\n  ALLOCATABLE,(:) vec of local node number Description Convert global node number to local node  number Usage fortran\n    indx = obj % localNptrs( globalIndx )","tags":"","loc":"interface/local_from_global.html"},{"title":"local_from_global_scalar – Fortran Program","text":"interface Convert global node numbr to local node number private pure function local_from_global_scalar(Obj, GlobalIndx) result(Ans) Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj mesh data integer(kind=I4B), intent(in) :: GlobalIndx global node number Return Value integer(kind=I4B) local node number Description Convert global node numbr to local node number Usage fortran\n    indx = Obj % localNptrs( GlobalIndx )","tags":"","loc":"interface/local_from_global_scalar.html"},{"title":"mc_connect_facet_cell – Fortran Program","text":"interface Connect facet to cell elements private subroutine mc_connect_facet_cell(CellMeshData, CellMesh, FacetMesh) Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(inout) :: CellMeshData Mesh data of cell mesh class(Mesh_), intent(inout), TARGET :: CellMesh Mesh of  cell elements class(Mesh_), intent(inout), TARGET :: FacetMesh Mesh of facet elements Description This subroutine connects the mesh of facet elements to the mesh of\n cell elements. Usage fortran\n    call ConnectFacetToCell( CellMesh, FacetMesh, CellMeshData )","tags":"","loc":"interface/mc_connect_facet_cell.html"},{"title":"md_findelement – Fortran Program","text":"interface private function md_findelement(Obj, MeshObj, coord, nodes) result(Ans) Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj class(Mesh_), intent(in) :: MeshObj real(kind=DFP), intent(in) :: coord (:,:) real(kind=DFP), intent(in) :: nodes (:,:) Return Value real(kind=DFP)\n  (SIZE(coord,2))","tags":"","loc":"interface/md_findelement.html"},{"title":"md_quality – Fortran Program","text":"interface private function md_quality(Obj, Meshobj, Nodes, Measure) result(Ans) Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(inout) :: Obj class(Mesh_), intent(inout), TARGET :: Meshobj real(kind=DFP), intent(in) :: Nodes (:,:) integer(kind=I4B), intent(in) :: Measure Return Value real(kind=DFP),\n  ALLOCATABLE,(:)","tags":"","loc":"interface/md_quality.html"},{"title":"meshdata_1 – Fortran Program","text":"interface MeshData() function to construct mesh data private function meshdata_1(MeshObj) result(Ans) Arguments Type Intent Optional Attributes Name class(Mesh_), intent(inout) :: MeshObj Mesh object Return Value type( MeshData_ ) Meshdata object Description MeshData() function to construct mesh data Usage fortran\n    obj = meshData( MeshObj )","tags":"","loc":"interface/meshdata_1.html"},{"title":"node_elements – Fortran Program","text":"interface Returns the element numbers which are connected to the a global node private pure function node_elements(Obj, GlobalPt) result(Ans) Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj mesh data integer(kind=I4B), intent(in) :: GlobalPt global node number Return Value integer(kind=I4B),\n  ALLOCATABLE,(:) vec of element number Description Returns the element numbers which are connected to the a global node Usage fortran\n val = Obj % NodeToElements( GlobalPt )","tags":"","loc":"interface/node_elements.html"},{"title":"setSparsity – Fortran Program","text":"public interface setSparsity generic interfac for setting sparsity pattern in SparseMatrix_ . Contents Module Procedures setSparsity_1 Module Procedures private interface setSparsity_1 () This routine set the sparsity pattern in SparseMatrix_ object Arguments None","tags":"","loc":"interface/setsparsity.html"},{"title":"setSparsity_1 – Fortran Program","text":"interface This routine set the sparsity pattern in SparseMatrix_ object private subroutine setSparsity_1(Obj, MeshObj, Mat, map) Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(inout) :: Obj mesh data type(Mesh_), intent(inout) :: MeshObj mesh object type(SparseMatrix_), intent(inout) :: Mat sparsematrix object integer(kind=I4B), intent(in), optional :: map (:) Global to local node number map Description This routine set the sparsity pattern in SparseMatrix_ object Usage fortran\n    call setSparsity( Obj, MeshObj, Mat )","tags":"","loc":"interface/setsparsity_1.html"},{"title":"Constructor_1 – Fortran Program","text":"private function Constructor_1(NSD, tElements, factor) result(Ans) Function for constructing pointer to Mesh_ Usage fortran\n class( mesh_ ), pointer :: obj\n obj => mesh_pointer( NSD = 2, tELements = 10 ) end fortran Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: NSD integer(kind=I4B), intent(in) :: tElements real(kind=DFP), intent(in), optional :: factor Return Value class( Mesh_ ),\n  POINTER Contents Source Code Constructor_1 Source Code FUNCTION Constructor_1 ( NSD , tElements , factor ) RESULT ( Ans ) CLASS ( Mesh_ ), POINTER :: Ans INTEGER ( I4B ), INTENT ( IN ) :: tElements , NSD REAL ( DFP ), INTENT ( IN ), OPTIONAL :: factor ALLOCATE ( Ans ) IF ( PRESENT ( factor ) ) THEN CALL Ans % Initiate ( NSD = NSD , tElements = tElements , factor = factor ) ELSE CALL Ans % Initiate ( NSD = NSD , tElements = tElements ) END IF END FUNCTION Constructor_1","tags":"","loc":"proc/constructor_1.html"},{"title":"Constructor1 – Fortran Program","text":"interface Function for constructing Mesh_ private pure function Constructor1(NSD, tElements, factor) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: NSD spatial dimension integer(kind=I4B), intent(in) :: tElements totat number of elements in mesh real(kind=DFP), intent(in), optional :: factor Return Value type( Mesh_ ) Mesh object Description Function for constructing Mesh_ Usage fortran\nobj = Mesh( NSD = 2, tELements = 10 ) end fortran","tags":"","loc":"interface/constructor1.html"},{"title":"DeallocateData – Fortran Program","text":"public interface DeallocateData Generic subroutine for deallcating data stored in Mesh_ Contents Module Procedures Deallocate_Data Module Procedures private interface Deallocate_Data () Deallocate data stored in Mesh_ Arguments None","tags":"","loc":"interface/deallocatedata~2.html"},{"title":"Deallocate_Data – Fortran Program","text":"interface Deallocate data stored in Mesh_ private subroutine Deallocate_Data(Obj) Arguments Type Intent Optional Attributes Name class( Mesh_ ), intent(inout) :: Obj mesh object Description Deallocate data stored in Mesh_ Usage fortran\ncall deallocateData( Obj = Obj ) end fortran","tags":"","loc":"interface/deallocate_data.html"},{"title":"Display – Fortran Program","text":"public interface Display generic routine to display content of mesh Contents Module Procedures display_mesh Module Procedures private interface display_mesh () display content of Mesh_ Arguments None","tags":"","loc":"interface/display.html"},{"title":"Initiate – Fortran Program","text":"public interface Initiate Generic routine for constructing Mesh_ Contents Module Procedures allocateMeshSize Module Procedures private interface allocateMeshSize () Allocate the size of the mesh Arguments None","tags":"","loc":"interface/initiate~2.html"},{"title":"Mesh – Fortran Program","text":"public interface Mesh Generic function for constructing Mesh_ Contents Module Procedures Constructor1 Module Procedures private interface Constructor1 () Function for constructing Mesh_ Arguments None","tags":"","loc":"interface/mesh.html"},{"title":"Mesh_Pointer – Fortran Program","text":"public interface Mesh_Pointer Generic function for constructing pointer to Mesh_ Contents Module Procedures Constructor_1 Module Procedures private function Constructor_1 (NSD, tElements, factor) result(Ans) Function for constructing pointer to Mesh_ Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: NSD integer(kind=I4B), intent(in) :: tElements real(kind=DFP), intent(in), optional :: factor Return Value class( Mesh_ ),\n  POINTER","tags":"","loc":"interface/mesh_pointer.html"},{"title":"Set_element – Fortran Program","text":"interface Set an element to a mesh private subroutine Set_element(Obj, Elem, iel) Arguments Type Intent Optional Attributes Name class( Mesh_ ), intent(inout) :: Obj Mesh object class(Element_), intent(inout), TARGET :: Elem Finite element to be put in mesh integer(kind=I4B), intent(in) :: iel element number Description Seting element; total number of elements remain same\n Size of mesh should be sufficient while using this. Usage fortran\n call obj % setElement( Elem )","tags":"","loc":"interface/set_element.html"},{"title":"add_element – Fortran Program","text":"interface Add an element to mesh private subroutine add_element(Obj, Elem) Arguments Type Intent Optional Attributes Name class( Mesh_ ), intent(inout) :: Obj mesh obj class(Element_), intent(inout), TARGET :: Elem finite element to be added Description Append an element, increate total elements in mesh by one Usage fortran\n call obj % append( Elem )","tags":"","loc":"interface/add_element.html"},{"title":"allocateMeshSize – Fortran Program","text":"interface Allocate the size of the mesh private subroutine allocateMeshSize(Obj, NSD, tElements, factor) Arguments Type Intent Optional Attributes Name class( Mesh_ ), intent(inout) :: Obj mesh object integer(kind=I4B), intent(in) :: NSD spatial dimension integer(kind=I4B), intent(in) :: tElements total number of elements in mesh real(kind=DFP), intent(in), optional :: factor maxLength = factor * telements Description Allocate the size of the mesh. Generic name —> Initiate() Usage fortran\ncall obj % initiate( NSD = 2, tELements = 10 ) end fortran\n allocate the size of the mesh","tags":"","loc":"interface/allocatemeshsize.html"},{"title":"display_mesh – Fortran Program","text":"interface display content of Mesh_ private subroutine display_mesh(Obj, Msg, UnitNo) Arguments Type Intent Optional Attributes Name class( Mesh_ ), intent(inout) :: Obj mesh object character(len=*), intent(in) :: Msg message on screen integer(kind=I4B), intent(in), optional :: UnitNo unit number of ouput file Description Display content of Mesh_ Usage fortran\n    call display( obj, 'mesh', stdout )","tags":"","loc":"interface/display_mesh.html"},{"title":"getElement_Pointer – Fortran Program","text":"interface Return the pointer to an element Obj % Elem(iel) private function getElement_Pointer(Obj, iel) result(Ans) Arguments Type Intent Optional Attributes Name class( Mesh_ ), intent(in) :: Obj mesh object integer(kind=I4B), intent(in) :: iel element number Return Value class(Element_),\n  POINTER pointer to finite element Description Return the pointer to an element Obj % Elem(iel) Warning make sure iel should be less that Obj%telements Usage fortran\n class( element_ ), pointer :: elem\n elem => obj % ElementPointer( iel )","tags":"","loc":"interface/getelement_pointer.html"},{"title":"getNptrs – Fortran Program","text":"public interface getNptrs Generic subroutine to get Nptrs in MeshPointer_ Contents Module Procedures mesh_pointer_get_nptrs Module Procedures private interface mesh_pointer_get_nptrs () Returns a vec of node numbers present in a collection of MeshPointer_ Arguments None","tags":"","loc":"interface/getnptrs.html"},{"title":"get_nptrs – Fortran Program","text":"interface Returns the node numbers in mesh private subroutine get_nptrs(Obj, Nptrs) Arguments Type Intent Optional Attributes Name class( Mesh_ ), intent(inout) :: Obj mesh object integer(kind=I4B), intent(inout), ALLOCATABLE :: Nptrs (:) node numbers Description Returns the node numbers in mesh Usage fortran\n    call obj % getNptrs( Nptrs )","tags":"","loc":"interface/get_nptrs.html"},{"title":"mesh_pointer_get_nptrs – Fortran Program","text":"interface Returns a vec of node numbers present in a collection of MeshPointer_ private subroutine mesh_pointer_get_nptrs(Obj, Nptrs) Arguments Type Intent Optional Attributes Name type( MeshPointer_ ), intent(inout) :: Obj (:) Collection of pointer to Mesh_ integer(kind=I4B), intent(inout), ALLOCATABLE :: Nptrs (:) Node present in the collection of mesh Description Returns the vec of node numbers present in a collection of MeshPointer_ Usage fortran\n    call getNptrs( Obj, Nptrs )","tags":"","loc":"interface/mesh_pointer_get_nptrs.html"},{"title":"remove_element – Fortran Program","text":"interface Remove an element from the mesh private subroutine remove_element(Obj, iel, extraoption) Arguments Type Intent Optional Attributes Name class( Mesh_ ), intent(inout) :: Obj mesh object integer(kind=I4B), intent(in) :: iel element number integer(kind=I4B), intent(in) :: extraoption Description Remove an element from the mesh extraOption = 1 then Obj % elem( iel ) will be nullified and deallocated extraOption = 2 then Obj % elem( iel ) will be nullified and elements in\n mesh will be rearranged extraoption = 3 then Obj % elem( iel ) will be nullified and deallocated\n  and elements in the mesh will be rearranged Usage fortran\n call obj % removeElement( iel = iel, extraoption = 2 )","tags":"","loc":"interface/remove_element.html"},{"title":"setMaterialType_1 – Fortran Program","text":"interface Set material propertie private subroutine setMaterialType_1(Obj, MatType) Arguments Type Intent Optional Attributes Name class( Mesh_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: MatType Description set material properties of element in the mesh. Currently, this routine\n add same material property to all elements Todo - add material properties by providing MatType as a vector of material type Usage fortran\n    call Obj % setMaterialType( MatType = 1 )","tags":"","loc":"interface/setmaterialtype_1.html"},{"title":"set_total_elements – Fortran Program","text":"interface Set total elements in mesh object private subroutine set_total_elements(Obj) Arguments Type Intent Optional Attributes Name class( Mesh_ ), intent(inout) :: Obj mesh object Description Set total elements in mesh object Note this routine runs through the element array and counts element pointers\n that are associated, and return the total number of associated elements.\n Therefore, it should be called only after appending/removing an element\n from the mesh. Usage fortran\ncall obj % SetSize( ) end fortran","tags":"","loc":"interface/set_total_elements.html"},{"title":"total_elements – Fortran Program","text":"interface Returns total elements in the mesh private pure function total_elements(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( Mesh_ ), intent(in) :: Obj mesh object Return Value integer(kind=I4B) Description Returns total elements in the mesh Usage fortran\n    telem = Obj % SIZE( Obj )","tags":"","loc":"interface/total_elements.html"},{"title":"DeallocateData – Fortran Program","text":"private interface DeallocateData Generic subroutine to deallocate data stored inside MeshConnectivity_ Contents Module Procedures mc_deallocate_data Module Procedures private interface mc_deallocate_data () This subroutine deallocate the data stored in MeshConnectivity_ Arguments None","tags":"","loc":"interface/deallocatedata~3.html"},{"title":"mc_cell_of_facet – Fortran Program","text":"interface Returns cell number of given facet number private pure function mc_cell_of_facet(Obj, FacetNum) result(Ans) Arguments Type Intent Optional Attributes Name class( MeshConnectivity_ ), intent(in) :: Obj Mesh connectivity data integer(kind=I4B), intent(in) :: FacetNum Facet element number Return Value integer(kind=I4B) Cell number Description Returns cell number of given facet number if cell number is zero it means facet element is an orphan Usage fortran\n    id = obj % CellNumber( facetNum )","tags":"","loc":"interface/mc_cell_of_facet.html"},{"title":"mc_cells_of_facets – Fortran Program","text":"interface Returns cell number of given facet number private pure function mc_cells_of_facets(Obj, FacetNum) result(Ans) Arguments Type Intent Optional Attributes Name class( MeshConnectivity_ ), intent(in) :: Obj Mesh connectivity data integer(kind=I4B), intent(in) :: FacetNum (:) List of facet element numbers Return Value integer(kind=I4B)\n  (SIZE(FacetNum)) List of cell element numbers Description Returns cell number of given facet number if cell number is zero it means facet element is an orphan Usage fortran\n    id = obj % CellNumber( facetNum )","tags":"","loc":"interface/mc_cells_of_facets.html"},{"title":"mc_deallocate_data – Fortran Program","text":"interface This subroutine deallocate the data stored in MeshConnectivity_ private subroutine mc_deallocate_data(Obj) Arguments Type Intent Optional Attributes Name class( MeshConnectivity_ ), intent(inout) :: Obj Mesh connectivity object Description This subroutine deallocate the data stored in MeshConnectivity_ Usage fortran\n    call DeallocateData( Obj )","tags":"","loc":"interface/mc_deallocate_data.html"},{"title":"mc_facet_local_id_1 – Fortran Program","text":"interface Returns the local facet id of cell element private pure function mc_facet_local_id_1(Obj, FacetNum) result(Ans) Arguments Type Intent Optional Attributes Name class( MeshConnectivity_ ), intent(in) :: Obj Mesh connectivity object integer(kind=I4B), intent(in) :: FacetNum Facet element number Return Value integer(kind=I4B) Local facet ID Description Returns the local facet id of cell element which is in contact with\n facet element Usage fortran\n    id = Obj % FacetLocalID( FacetNum )","tags":"","loc":"interface/mc_facet_local_id_1.html"},{"title":"mc_facet_local_id_2 – Fortran Program","text":"interface Returns the local facet id of cell element private pure function mc_facet_local_id_2(Obj, FacetNum) result(Ans) Arguments Type Intent Optional Attributes Name class( MeshConnectivity_ ), intent(in) :: Obj Mesh connectivity data integer(kind=I4B), intent(in) :: FacetNum (:) List of facet element numbers Return Value integer(kind=I4B)\n  (SIZE(FacetNum)) List of local facet IDs Description Returns the local facet id of cell element which is in contact with\n facet element Usage fortran\n    id = Obj % FacetLocalID( FacetNum )","tags":"","loc":"interface/mc_facet_local_id_2.html"},{"title":"mc_init_cell_facet – Fortran Program","text":"interface Generate the connectivity matrix between cell and facet mesh. private subroutine mc_init_cell_facet(Obj, CellMesh, FacetMesh, CellMeshData) Arguments Type Intent Optional Attributes Name class( MeshConnectivity_ ), intent(inout) :: Obj Mesh connectivity data class(Mesh_), intent(inout) :: CellMesh Mesh of cell elements class(Mesh_), intent(inout) :: FacetMesh Mesh of facet mesh class(MeshData_), intent(inout) :: CellMeshData Mesh data for CellMesh Description This subroutine generate the connectivity matrix called Obj % CellFacet\n between cell and facet mesh. The output result will be an integer array with 2 rows First row contains the element number of CellMesh Second row contains the local facet number of cell element which\n  connects to the facet mesh element. Each column of Obj % CellFacet corresponds to an Element of FacetMesh ; total number of columns are same as total number of elem\n  in the FacetMesh if an element of FacetMesh is orphan then its corresponding entry\n  is set to zero in Obj % CellFacet matrix Usage fortran\n    call Obj % initiateFacetToCellData( Obj, CellMesh, FacetMesh, CellMeshData)","tags":"","loc":"interface/mc_init_cell_facet.html"},{"title":"mc_init_node_node – Fortran Program","text":"interface Generate the connectivity matrix between two meshes private subroutine mc_init_node_node(Obj, Mesh1, Mesh2, Node1, Node2, MeshData1, MeshData2) Arguments Type Intent Optional Attributes Name class( MeshConnectivity_ ), intent(inout) :: Obj mesh connectivity object class(Mesh_), intent(in) :: Mesh1 Mesh object class(Mesh_), intent(in) :: Mesh2 Mesh object real(kind=DFP), intent(in) :: Node1 (:,:) Nodal coordinates in Mesh1 real(kind=DFP), intent(in) :: Node2 (:,:) Nodal coordinate in Mesh2 class(MeshData_), intent(inout) :: MeshData1 Mesh data for mesh 1 class(MeshData_), intent(inout) :: MeshData2 Mesh data for mesh 2 Description This subroutine generate the connectivity matrix between two meshes The output result will be an integer array with 2 columns\n       - first column: contains the node number of Mesh1\n       - second column: contains the node number of Mesh2 which is\n       - directly connected to the node 1","tags":"","loc":"interface/mc_init_node_node.html"},{"title":"DeallocateData – Fortran Program","text":"public interface DeallocateData generic interface to deallocate data in Domain_ Contents Module Procedures deallocate_obj Module Procedures private interface deallocate_obj () Deallocate data in Domain_ object Arguments None","tags":"","loc":"interface/deallocatedata~4.html"},{"title":"Initiate – Fortran Program","text":"public interface Initiate Generic routine for initiating Domain_ object Contents Module Procedures Initiate_obj Module Procedures private interface Initiate_obj () Initiate Domain_ object Arguments None","tags":"","loc":"interface/initiate~3.html"},{"title":"Initiate_obj – Fortran Program","text":"interface Initiate Domain_ object private subroutine Initiate_obj(Obj, tOmega, tBoundary, tEdge) Arguments Type Intent Optional Attributes Name class( Domain_ ), intent(inout) :: Obj Domain integer(kind=I4B), intent(in), optional :: tOmega total number of $\\Omega$ domains integer(kind=I4B), intent(in), optional :: tBoundary total number of $\\Gamma$ domains integer(kind=I4B), intent(in), optional :: tEdge total number of line domains Description This routine allocate the memory for Domain_ obj.\n - allocate size of Obj % Omega( 1:tOmega ) - allocate Obj % Boundary( 1:tBoundary ) ,\n - allocate Obj % mdOmega( 1:tOmega ) - allocate Obj % mdBoundary( 1:tBoundary ) Usage fortran\n    call Obj % initiate( tOmega, tBoundary )","tags":"","loc":"interface/initiate_obj.html"},{"title":"deallocate_obj – Fortran Program","text":"interface Deallocate data in Domain_ object private subroutine deallocate_obj(Obj) Arguments Type Intent Optional Attributes Name class( Domain_ ), intent(inout) :: Obj Domain object Description Deallocate data stored in Domain_ object","tags":"","loc":"interface/deallocate_obj.html"},{"title":"mc_connect_facet_cell – Fortran Program","text":"interface Connect Mesh_ of FacetElement_ to Mesh_ of cell Element_ private subroutine mc_connect_facet_cell(Dom, OmegaIndx, BoundaryIndx) Arguments Type Intent Optional Attributes Name class( Domain_ ), intent(inout), TARGET :: Dom integer(kind=I4B), intent(in) :: OmegaIndx integer(kind=I4B), intent(in) :: BoundaryIndx Description This subroutine connects the mesh of facet elements to the mesh of\n cell elements User does not require to access the mesh. One can simply provide the\n index of cell mesh (i.e., dom % omega( cellIndx ) ) and index of facet mesh\n (i.e., dom % boundary( faceIndx )). This subroutine runs several\n tests and reports error if there is any. Note This subroutine is a wrapper around Mesh_ Usage fortran\n    call ConnectFacetToCell( Dom, OmegaIndx, BoundaryIndx )","tags":"","loc":"interface/mc_connect_facet_cell~2.html"},{"title":"getFEPointer – Fortran Program","text":"public function getFEPointer(Obj, Nptrs, Mat_Type, RefElem) result(Ans) Uses BaseType GlobalData Arguments Type Intent Optional Attributes Name class(Element_), intent(in) :: Obj integer(kind=I4B), intent(in) :: Nptrs (:) integer(kind=I4B), intent(in) :: Mat_Type class(ReferenceElement_), intent(inout), TARGET :: RefElem Return Value class(Element_),\n  POINTER Contents Source Code getFEPointer Source Code FUNCTION getFEPointer ( Obj , Nptrs , Mat_Type , RefElem ) RESULT ( Ans ) USE BaseType USE GlobalData ! Define internal variable CLASS ( Element_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Nptrs ( : ), Mat_Type CLASS ( ReferenceElement_ ), TARGET , INTENT ( INOUT ) :: RefElem CLASS ( Element_ ), POINTER :: Ans ! SELECT TYPE ( Obj ) TYPE IS ( Element_ ) Ans => Element_Pointer ( Nptrs , Mat_Type , RefElem ) TYPE IS ( FacetElement_ ) Ans => FacetElement_Pointer ( Nptrs , Mat_Type , RefElem ) END SELECT ! END FUNCTION getFEPointer","tags":"","loc":"proc/getfepointer.html"},{"title":"Constructor_1 – Fortran Program","text":"private function Constructor_1(Nptrs, Mat_Type, RefElem) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Nptrs (:) integer(kind=I4B), intent(in) :: Mat_Type class(ReferenceElement_), intent(inout), TARGET :: RefElem Return Value class( Element_ ),\n  POINTER Contents Source Code Constructor_1 Source Code FUNCTION Constructor_1 ( Nptrs , Mat_Type , RefElem ) RESULT ( Obj ) CLASS ( Element_ ), POINTER :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Nptrs ( : ), Mat_Type CLASS ( ReferenceElement_ ), TARGET , INTENT ( INOUT ) :: RefElem ALLOCATE ( Obj ) CALL Obj % Initiate ( Nptrs = Nptrs , Mat_Type = Mat_Type , RefElem = RefElem ) END FUNCTION Constructor_1","tags":"","loc":"proc/constructor_1~2.html"},{"title":"Constructor_2 – Fortran Program","text":"private function Constructor_2() result(Obj) Arguments None Return Value class( Element_ ),\n  POINTER Contents Source Code Constructor_2 Source Code FUNCTION Constructor_2 ( ) RESULT ( Obj ) CLASS ( Element_ ), POINTER :: Obj ALLOCATE ( Obj ) Obj % Mat_Type = - 1 Obj % Nptrs = [ - 1 ] Obj % RefElem => NULL ( ) END FUNCTION Constructor_2","tags":"","loc":"proc/constructor_2.html"},{"title":"Constructor_3 – Fortran Program","text":"private function Constructor_3(AnotherObj) result(Obj) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(inout), TARGET :: AnotherObj Return Value class( Element_ ),\n  POINTER Contents Source Code Constructor_3 Source Code FUNCTION Constructor_3 ( AnotherObj ) RESULT ( Obj ) CLASS ( Element_ ), POINTER :: Obj CLASS ( Element_ ), TARGET , INTENT ( INOUT ) :: AnotherObj ALLOCATE ( Obj ) CALL Obj % Initiate ( AnotherObj ) END FUNCTION Constructor_3","tags":"","loc":"proc/constructor_3.html"},{"title":"Constructor1 – Fortran Program","text":"interface private function Constructor1(Nptrs, Mat_Type, RefElem) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Nptrs (:) integer(kind=I4B), intent(in) :: Mat_Type class(ReferenceElement_), intent(inout), TARGET :: RefElem Return Value type( Element_ )","tags":"","loc":"interface/constructor1~3.html"},{"title":"Constructor2 – Fortran Program","text":"interface private function Constructor2() result(Obj) Arguments None Return Value type( Element_ )","tags":"","loc":"interface/constructor2.html"},{"title":"Constructor3 – Fortran Program","text":"interface private function Constructor3(AnotherObj) result(Obj) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(inout), TARGET :: AnotherObj Return Value type( Element_ )","tags":"","loc":"interface/constructor3~2.html"},{"title":"DeallocateData – Fortran Program","text":"public interface DeallocateData Contents Module Procedures Deallocate_Data Module Procedures private interface Deallocate_Data () Arguments None","tags":"","loc":"interface/deallocatedata~5.html"},{"title":"Deallocate_Data – Fortran Program","text":"interface private subroutine Deallocate_Data(Obj) Arguments Type Intent Optional Attributes Name type( Element_ ), intent(inout) :: Obj","tags":"","loc":"interface/deallocate_data~3.html"},{"title":"Display – Fortran Program","text":"public interface Display Contents Module Procedures s_display_Obj Module Procedures private interface s_display_Obj () Arguments None","tags":"","loc":"interface/display~2.html"},{"title":"Element – Fortran Program","text":"public interface Element Contents Module Procedures Constructor1 Constructor2 Constructor3 Module Procedures private interface Constructor1 () Arguments None private interface Constructor2 () Arguments None private interface Constructor3 () Arguments None","tags":"","loc":"interface/element.html"},{"title":"Element_Pointer – Fortran Program","text":"public interface Element_Pointer Contents Module Procedures Constructor_1 Constructor_2 Constructor_3 Module Procedures private function Constructor_1 (Nptrs, Mat_Type, RefElem) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Nptrs (:) integer(kind=I4B), intent(in) :: Mat_Type class(ReferenceElement_), intent(inout), TARGET :: RefElem Return Value class( Element_ ),\n  POINTER private function Constructor_2 () result(Obj) Arguments None Return Value class( Element_ ),\n  POINTER private function Constructor_3 (AnotherObj) result(Obj) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(inout), TARGET :: AnotherObj Return Value class( Element_ ),\n  POINTER","tags":"","loc":"interface/element_pointer.html"},{"title":"FreePointerToCell – Fortran Program","text":"interface private subroutine FreePointerToCell(Obj) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(inout) :: Obj","tags":"","loc":"interface/freepointertocell.html"},{"title":"Initiate – Fortran Program","text":"public interface Initiate Contents Module Procedures s_initiate_obj Module Procedures private interface s_Initiate_obj () Arguments None","tags":"","loc":"interface/initiate~4.html"},{"title":"SetPointerToCell – Fortran Program","text":"interface private subroutine SetPointerToCell(Obj, CellObj) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(inout) :: Obj class( Element_ ), intent(inout), TARGET :: CellObj","tags":"","loc":"interface/setpointertocell.html"},{"title":"getCellNptrs – Fortran Program","text":"interface private pure function getCellNptrs(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(in) :: Obj Return Value integer(kind=I4B),\n  ALLOCATABLE,(:)","tags":"","loc":"interface/getcellnptrs.html"},{"title":"getFacetLocalID – Fortran Program","text":"interface private pure function getFacetLocalID(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(in) :: Obj Return Value integer(kind=I4B)","tags":"","loc":"interface/getfacetlocalid.html"},{"title":"getFacetLocalNptrs – Fortran Program","text":"interface private pure function getFacetLocalNptrs(Obj) result(Nptrs) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(in) :: Obj Return Value integer(kind=I4B),\n  ALLOCATABLE,(:)","tags":"","loc":"interface/getfacetlocalnptrs.html"},{"title":"getPointerToCell – Fortran Program","text":"interface private function getPointerToCell(Obj) result(CellObj) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(in), TARGET :: Obj Return Value class( Element_ ),\n  POINTER","tags":"","loc":"interface/getpointertocell.html"},{"title":"get_elemsd_H1_Lagrange – Fortran Program","text":"interface private subroutine get_elemsd_H1_Lagrange(Obj, ElemSD, Quad, xIJ, ContinuityType, InterpolType) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(inout) :: Obj class(ElemShapeData_), intent(inout) :: ElemSD type(QuadraturePoint_), intent(in) :: Quad real(kind=DFP), intent(in) :: xIJ (:,:) type(H1_), intent(in) :: ContinuityType type(LagrangeInterpolation_), intent(in) :: InterpolType","tags":"","loc":"interface/get_elemsd_h1_lagrange.html"},{"title":"m_Initiate_obj – Fortran Program","text":"interface private subroutine m_Initiate_obj(Obj, Nptrs, Mat_Type, RefElem) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Nptrs (:) integer(kind=I4B), intent(in) :: Mat_Type class(ReferenceElement_), intent(inout), TARGET :: RefElem","tags":"","loc":"interface/m_initiate_obj.html"},{"title":"m_display_Obj – Fortran Program","text":"interface private subroutine m_display_Obj(Obj, Msg, UnitNo, FullDisp) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(in) :: Obj character(len=*), intent(in) :: Msg integer(kind=I4B), intent(in), optional :: UnitNo logical(kind=LGT), intent(in), optional :: FullDisp","tags":"","loc":"interface/m_display_obj.html"},{"title":"m_getNptrs – Fortran Program","text":"interface private pure function m_getNptrs(Obj) result(Nptrs) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(in) :: Obj Return Value integer(kind=I4B),\n  ALLOCATABLE,(:)","tags":"","loc":"interface/m_getnptrs.html"},{"title":"m_initiate_from_obj – Fortran Program","text":"interface private subroutine m_initiate_from_obj(Obj, AnotherObj) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(inout) :: Obj class( Element_ ), intent(inout), TARGET :: AnotherObj","tags":"","loc":"interface/m_initiate_from_obj.html"},{"title":"m_isBoundaryElement – Fortran Program","text":"interface private pure function m_isBoundaryElement(Obj, NSD) result(Ans) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: NSD Return Value logical(kind=LGT)","tags":"","loc":"interface/m_isboundaryelement.html"},{"title":"m_setNptrs – Fortran Program","text":"interface private subroutine m_setNptrs(Obj, Nptrs) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Nptrs (:)","tags":"","loc":"interface/m_setnptrs.html"},{"title":"s_Initiate_obj – Fortran Program","text":"interface private subroutine s_Initiate_obj(Obj, Nptrs, Mat_Type, RefElem) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Nptrs (:) integer(kind=I4B), intent(in) :: Mat_Type class(ReferenceElement_), intent(inout), TARGET :: RefElem","tags":"","loc":"interface/s_initiate_obj.html"},{"title":"s_display_Obj – Fortran Program","text":"interface private subroutine s_display_Obj(Obj, Msg, UnitNo, FullDisp) Arguments Type Intent Optional Attributes Name type( Element_ ), intent(in) :: Obj character(len=*), intent(in) :: Msg integer(kind=I4B), intent(in), optional :: UnitNo logical(kind=LGT), intent(in), optional :: FullDisp","tags":"","loc":"interface/s_display_obj.html"},{"title":"setFacetLocalID – Fortran Program","text":"interface private subroutine setFacetLocalID(Obj, Id) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Id","tags":"","loc":"interface/setfacetlocalid.html"},{"title":"setMaterialType_1 – Fortran Program","text":"interface private subroutine setMaterialType_1(Obj, MatType) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: MatType","tags":"","loc":"interface/setmaterialtype_1~2.html"},{"title":"Constructor_1 – Fortran Program","text":"private function Constructor_1(Nptrs, Mat_Type, RefElem) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Nptrs (:) integer(kind=I4B), intent(in) :: Mat_Type class(ReferenceElement_), intent(inout), TARGET :: RefElem Return Value class( FacetElement_ ),\n  POINTER Contents Source Code Constructor_1 Source Code FUNCTION Constructor_1 ( Nptrs , Mat_Type , RefElem ) RESULT ( Obj ) CLASS ( FacetElement_ ), POINTER :: Obj INTEGER ( I4B ), INTENT ( IN ) :: Nptrs ( : ), Mat_Type CLASS ( ReferenceElement_ ), TARGET , INTENT ( INOUT ) :: RefElem ALLOCATE ( Obj ) CALL Obj % Initiate ( Nptrs = Nptrs , Mat_Type = Mat_Type , RefElem = RefElem ) END FUNCTION Constructor_1","tags":"","loc":"proc/constructor_1~3.html"},{"title":"Constructor_2 – Fortran Program","text":"private function Constructor_2() result(Obj) Arguments None Return Value class( FacetElement_ ),\n  POINTER Contents Source Code Constructor_2 Source Code FUNCTION Constructor_2 ( ) RESULT ( Obj ) CLASS ( FacetElement_ ), POINTER :: Obj ALLOCATE ( Obj ) Obj % Mat_Type = - 1 Obj % Nptrs = [ - 1 ] Obj % RefElem => NULL ( ) END FUNCTION Constructor_2","tags":"","loc":"proc/constructor_2~2.html"},{"title":"Constructor_3 – Fortran Program","text":"private function Constructor_3(AnotherObj) result(Obj) Arguments Type Intent Optional Attributes Name class( FacetElement_ ), intent(inout), TARGET :: AnotherObj Return Value class( FacetElement_ ),\n  POINTER Contents Source Code Constructor_3 Source Code FUNCTION Constructor_3 ( AnotherObj ) RESULT ( Obj ) CLASS ( FacetElement_ ), POINTER :: Obj CLASS ( FacetElement_ ), TARGET , INTENT ( INOUT ) :: AnotherObj ALLOCATE ( Obj ) CALL Obj % Initiate ( AnotherObj ) END FUNCTION Constructor_3","tags":"","loc":"proc/constructor_3~2.html"},{"title":"Constructor1 – Fortran Program","text":"interface private function Constructor1(Nptrs, Mat_Type, RefElem) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Nptrs (:) integer(kind=I4B), intent(in) :: Mat_Type class(ReferenceElement_), intent(inout), TARGET :: RefElem Return Value type( FacetElement_ )","tags":"","loc":"interface/constructor1~4.html"},{"title":"Constructor2 – Fortran Program","text":"interface private function Constructor2() result(Obj) Arguments None Return Value type( FacetElement_ )","tags":"","loc":"interface/constructor2~2.html"},{"title":"Constructor3 – Fortran Program","text":"interface private function Constructor3(AnotherObj) result(Obj) Arguments Type Intent Optional Attributes Name class(Element_), intent(inout), TARGET :: AnotherObj Return Value type( FacetElement_ )","tags":"","loc":"interface/constructor3~3.html"},{"title":"DeallocateData – Fortran Program","text":"public interface DeallocateData Contents Module Procedures Deallocate_Data Module Procedures private interface Deallocate_Data () Arguments None","tags":"","loc":"interface/deallocatedata~6.html"},{"title":"Deallocate_Data – Fortran Program","text":"interface private subroutine Deallocate_Data(Obj) Arguments Type Intent Optional Attributes Name type( FacetElement_ ), intent(inout) :: Obj","tags":"","loc":"interface/deallocate_data~4.html"},{"title":"Display – Fortran Program","text":"public interface Display Contents Module Procedures s_display_Obj Module Procedures private interface s_display_Obj () Arguments None","tags":"","loc":"interface/display~3.html"},{"title":"FacetElement – Fortran Program","text":"public interface FacetElement Contents Module Procedures Constructor1 Constructor2 Constructor3 Module Procedures private interface Constructor1 () Arguments None private interface Constructor2 () Arguments None private interface Constructor3 () Arguments None","tags":"","loc":"interface/facetelement.html"},{"title":"FacetElement_Pointer – Fortran Program","text":"public interface FacetElement_Pointer Contents Module Procedures Constructor_1 Constructor_2 Constructor_3 Module Procedures private function Constructor_1 (Nptrs, Mat_Type, RefElem) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Nptrs (:) integer(kind=I4B), intent(in) :: Mat_Type class(ReferenceElement_), intent(inout), TARGET :: RefElem Return Value class( FacetElement_ ),\n  POINTER private function Constructor_2 () result(Obj) Arguments None Return Value class( FacetElement_ ),\n  POINTER private function Constructor_3 (AnotherObj) result(Obj) Arguments Type Intent Optional Attributes Name class( FacetElement_ ), intent(inout), TARGET :: AnotherObj Return Value class( FacetElement_ ),\n  POINTER","tags":"","loc":"interface/facetelement_pointer.html"},{"title":"FreePointerToCell – Fortran Program","text":"interface private subroutine FreePointerToCell(Obj) Arguments Type Intent Optional Attributes Name class( FacetElement_ ), intent(inout) :: Obj","tags":"","loc":"interface/freepointertocell~2.html"},{"title":"SetPointerToCell – Fortran Program","text":"interface private subroutine SetPointerToCell(Obj, CellObj) Arguments Type Intent Optional Attributes Name class( FacetElement_ ), intent(inout) :: Obj class(Element_), intent(inout), TARGET :: CellObj","tags":"","loc":"interface/setpointertocell~2.html"},{"title":"getCellNptrs – Fortran Program","text":"interface private pure function getCellNptrs(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( FacetElement_ ), intent(in) :: Obj Return Value integer(kind=I4B),\n  ALLOCATABLE,(:)","tags":"","loc":"interface/getcellnptrs~2.html"},{"title":"getFacetLocalID – Fortran Program","text":"interface private pure function getFacetLocalID(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( FacetElement_ ), intent(in) :: Obj Return Value integer(kind=I4B)","tags":"","loc":"interface/getfacetlocalid~2.html"},{"title":"getFacetLocalNptrs – Fortran Program","text":"interface private pure function getFacetLocalNptrs(Obj) result(Nptrs) Arguments Type Intent Optional Attributes Name class( FacetElement_ ), intent(in) :: Obj Return Value integer(kind=I4B),\n  ALLOCATABLE,(:)","tags":"","loc":"interface/getfacetlocalnptrs~2.html"},{"title":"getPointerToCell – Fortran Program","text":"interface private function getPointerToCell(Obj) result(CellObj) Arguments Type Intent Optional Attributes Name class( FacetElement_ ), intent(in), TARGET :: Obj Return Value class(Element_),\n  POINTER","tags":"","loc":"interface/getpointertocell~2.html"},{"title":"get_elemsd_H1_Lagrange – Fortran Program","text":"interface private subroutine get_elemsd_H1_Lagrange(Obj, ElemSD, Quad, xIJ, ContinuityType, InterpolType) Arguments Type Intent Optional Attributes Name class( FacetElement_ ), intent(inout) :: Obj class(ElemShapeData_), intent(inout) :: ElemSD type(QuadraturePoint_), intent(in) :: Quad real(kind=DFP), intent(in) :: xIJ (:,:) type(H1_), intent(in) :: ContinuityType type(LagrangeInterpolation_), intent(in) :: InterpolType","tags":"","loc":"interface/get_elemsd_h1_lagrange~2.html"},{"title":"m_display_Obj – Fortran Program","text":"interface private subroutine m_display_Obj(Obj, Msg, UnitNo, FullDisp) Arguments Type Intent Optional Attributes Name class( FacetElement_ ), intent(in) :: Obj character(len=*), intent(in) :: Msg integer(kind=I4B), intent(in), optional :: UnitNo logical(kind=LGT), intent(in), optional :: FullDisp","tags":"","loc":"interface/m_display_obj~2.html"},{"title":"s_display_Obj – Fortran Program","text":"interface private subroutine s_display_Obj(Obj, Msg, UnitNo, FullDisp) Arguments Type Intent Optional Attributes Name type( FacetElement_ ), intent(in) :: Obj character(len=*), intent(in) :: Msg integer(kind=I4B), intent(in), optional :: UnitNo logical(kind=LGT), intent(in), optional :: FullDisp","tags":"","loc":"interface/s_display_obj~2.html"},{"title":"setFacetLocalID – Fortran Program","text":"interface private subroutine setFacetLocalID(Obj, Id) Arguments Type Intent Optional Attributes Name class( FacetElement_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Id","tags":"","loc":"interface/setfacetlocalid~2.html"},{"title":"DeallocateData – Fortran Program","text":"public interface DeallocateData Contents Module Procedures vtk_final Module Procedures private interface vtk_final () This subroutine closes the opened vtk file Arguments None","tags":"","loc":"interface/deallocatedata~7.html"},{"title":"Display – Fortran Program","text":"public interface Display Contents Module Procedures vtk_display Module Procedures private interface vtk_display () Arguments None","tags":"","loc":"interface/display~4.html"},{"title":"vtk_display – Fortran Program","text":"interface private subroutine vtk_display(obj, msg, unitno) Arguments Type Intent Optional Attributes Name class( vtk_ ), intent(in) :: obj character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitno","tags":"","loc":"interface/vtk_display.html"},{"title":"vtk_final – Fortran Program","text":"interface This subroutine closes the opened vtk file private subroutine vtk_final(obj) Arguments Type Intent Optional Attributes Name class( vtk_ ), intent(inout) :: obj Description This subroutine close the open vtk file","tags":"","loc":"interface/vtk_final.html"},{"title":"vtk_init – Fortran Program","text":"interface This subroutine initiate the vtk object private subroutine vtk_init(obj, path, filename, extension, fmt, meshTopology, indx, nx1, nx2, ny1, ny2, nz1, nz2) Arguments Type Intent Optional Attributes Name class( vtk_ ), intent(inout) :: obj vtk_ filename object character(len=*), intent(in) :: path path of the filename to be created character(len=*), intent(in) :: filename name of the file to be created character(len=*), intent(in) :: extension extension of the file .vtu character(len=*), intent(in) :: fmt storage format ascii, binary_append, binary character(len=*), intent(in) :: meshTopology mesh topology UnstructuredGrid integer(kind=I4B), intent(in) :: indx (:) its(1) = time-step its(2) = iteration number, if present integer(kind=I4B), intent(in), optional :: nx1 for structured grid only integer(kind=I4B), intent(in), optional :: nx2 for structured grid only integer(kind=I4B), intent(in), optional :: ny1 for structured grid only integer(kind=I4B), intent(in), optional :: ny2 for structured grid only integer(kind=I4B), intent(in), optional :: nz1 for structured grid only integer(kind=I4B), intent(in), optional :: nz2 for structured grid only Description This subroutine initate the vtk file object","tags":"","loc":"interface/vtk_init.html"},{"title":"vtk_start_write_elem_data – Fortran Program","text":"interface private subroutine vtk_start_write_elem_data(obj) Arguments Type Intent Optional Attributes Name class( vtk_ ), intent(inout) :: obj","tags":"","loc":"interface/vtk_start_write_elem_data.html"},{"title":"vtk_start_write_geo – Fortran Program","text":"interface Should be called before vtk_ call private subroutine vtk_start_write_geo(obj) Arguments Type Intent Optional Attributes Name class( vtk_ ), intent(inout) :: obj Description This subroutine should be called before start writing the geometry\n in the <piece> tag This subroutine indicates that we are going to write the mesh information","tags":"","loc":"interface/vtk_start_write_geo.html"},{"title":"vtk_start_write_node_data – Fortran Program","text":"interface private subroutine vtk_start_write_node_data(obj) Arguments Type Intent Optional Attributes Name class( vtk_ ), intent(inout) :: obj","tags":"","loc":"interface/vtk_start_write_node_data.html"},{"title":"vtk_stop_write_elem_data – Fortran Program","text":"interface private subroutine vtk_stop_write_elem_data(obj) Arguments Type Intent Optional Attributes Name class( vtk_ ), intent(inout) :: obj","tags":"","loc":"interface/vtk_stop_write_elem_data.html"},{"title":"vtk_stop_write_geo – Fortran Program","text":"interface Should be called before vtk_ call private subroutine vtk_stop_write_geo(obj) Arguments Type Intent Optional Attributes Name class( vtk_ ), intent(inout) :: obj Description This subroutine should be called after we are done writing the mesh\n information, point data and cell data. This subroutine will write </piece> tag","tags":"","loc":"interface/vtk_stop_write_geo.html"},{"title":"vtk_stop_write_node_data – Fortran Program","text":"interface private subroutine vtk_stop_write_node_data(obj) Arguments Type Intent Optional Attributes Name class( vtk_ ), intent(inout) :: obj","tags":"","loc":"interface/vtk_stop_write_node_data.html"},{"title":"vtk_write_cell_data_1 – Fortran Program","text":"interface This subroutine writes the cell data information in a vtk file format private subroutine vtk_write_cell_data_1(obj, val, name) Arguments Type Intent Optional Attributes Name class( vtk_ ), intent(inout) :: obj real(kind=DFP), intent(in) :: val (:) size(val) should be equal to totol number of cell character(len=*), intent(in) :: name Description This subroutine writes the cell data (single scalars) into a vtk file","tags":"","loc":"interface/vtk_write_cell_data_1.html"},{"title":"vtk_write_cell_data_2 – Fortran Program","text":"interface This subroutine writes the cell data information in a vtk file format private subroutine vtk_write_cell_data_2(obj, val, name) Arguments Type Intent Optional Attributes Name class( vtk_ ), intent(inout) :: obj real(kind=DFP), intent(in) :: val (:,:) size(val,2) should be equal to totol number of cell\n size(val,1) number of components character(len=*), intent(in) :: name Description This subroutine writes the cell data (single vector) into a vtk file","tags":"","loc":"interface/vtk_write_cell_data_2.html"},{"title":"vtk_write_mesh_data_1 – Fortran Program","text":"interface This subroutine writes the mesh data information in the private subroutine vtk_write_mesh_data_1(obj, meshobj, mdobj, nodes) Arguments Type Intent Optional Attributes Name class( vtk_ ), intent(inout) :: obj vtk_ file class(Mesh_), intent(inout), TARGET :: meshobj Mesh_ instance class(MeshData_), intent(inout) :: mdobj MeshData_ instance real(kind=DFP), intent(in) :: nodes (:,:) Nodal coordinates in xij format Description This subroutine writes the information of the mesh in vtkfile\n In this interface use must provide the MeshData_ object. In the vtk file local node numbers are written Only those points (coords) are written which are included in meshobj Note that nodes can represent a super set of nodes; nodes present in\n mesh are subset of nodes","tags":"","loc":"interface/vtk_write_mesh_data_1.html"},{"title":"vtk_write_mesh_data_2 – Fortran Program","text":"interface This subroutine writes the mesh data information in the private subroutine vtk_write_mesh_data_2(obj, meshobj, nodes) Arguments Type Intent Optional Attributes Name class( vtk_ ), intent(inout) :: obj vtk_ file class(Mesh_), intent(inout), TARGET :: meshobj Mesh_ instance real(kind=DFP), intent(in) :: nodes (:,:) Nodal coordinates in xij format Description This subroutine writes the information of the mesh in vtkfile\n This subroutine should be used carefully\n We advise you to avoide using this subroutine as much as possible","tags":"","loc":"interface/vtk_write_mesh_data_2.html"},{"title":"vtk_write_mesh_data_3 – Fortran Program","text":"interface This subroutine writes the mesh data information in the private subroutine vtk_write_mesh_data_3(obj, meshobj, nodes, tag, local2global, map, lb, ub) Arguments Type Intent Optional Attributes Name class( vtk_ ), intent(inout) :: obj vtk_ file class(MeshPointer_), intent(inout), TARGET :: meshobj (:) Mesh_ instance real(kind=DFP), intent(in) :: nodes (:,:) Nodal coordinates in xij format integer(kind=I4B), intent(in) :: tag (:) integer(kind=I4B), intent(in) :: local2global (:) integer(kind=I4B), intent(in) :: map (lb:ub) integer(kind=I4B), intent(in) :: lb integer(kind=I4B), intent(in) :: ub Description This subroutine writes the information of the mesh in vtkfile\n In this interface use must provide the MeshData_ object. In the vtk file local node numbers are written Only those points (coords) are written which are included in meshobj Note that nodes can represent a super set of nodes; nodes present in\n mesh are subset of nodes","tags":"","loc":"interface/vtk_write_mesh_data_3.html"},{"title":"vtk_write_node_data_1 – Fortran Program","text":"interface This subroutine writes the node data information in a vtk file format private subroutine vtk_write_node_data_1(obj, x, dofobj, name, prefix) Arguments Type Intent Optional Attributes Name class( vtk_ ), intent(inout) :: obj real(kind=DFP), intent(in) :: x (:) type(DOF_), intent(in) :: dofobj character(len=1), intent(in) :: name character(len=*), intent(in) :: prefix It is the name of a DOF present inside dofobj; we will find this name\n and write data corresponding to that physical name Description This subroutine writes the nodal values of a variable x into vtk file name is the name of physical variable whose dof will be printed The subroutine will decided the nature of physical variable and\n and write in vtk file accordingly The subroutine search for this name in DOF_ and if this name is\n is not present the subroutine writes nothing","tags":"","loc":"interface/vtk_write_node_data_1.html"},{"title":"vtk_write_node_data_2 – Fortran Program","text":"interface This subroutine writes the node data information in a vtk file format private subroutine vtk_write_node_data_2(obj, x, dofobj, prefix) Arguments Type Intent Optional Attributes Name class( vtk_ ), intent(inout) :: obj real(kind=DFP), intent(in) :: x (:) type(DOF_), intent(in) :: dofobj character(len=*), intent(in), optional :: prefix Description This subroutine writes the nodal values of a variable x into vtk file It will write all the physical variables in vtk file It calls vtk_write_node_data_1 subroutine internally","tags":"","loc":"interface/vtk_write_node_data_2.html"},{"title":"DeallocateData – Fortran Program","text":"public interface DeallocateData genenric interface for deallocating data in QuadratureVariables_ Contents Module Procedures elem_var_deallocate_data Module Procedures private interface elem_var_deallocate_data () Deallocat data stored inside QuadratureVariables_ object Arguments None","tags":"","loc":"interface/deallocatedata~8.html"},{"title":"Display – Fortran Program","text":"public interface Display Generic interaface to display content of QuadratureVariables_ Contents Module Procedures elem_var_disp Module Procedures private interface elem_var_disp () Display the content of QuadratureVariables_ Arguments None","tags":"","loc":"interface/display~5.html"},{"title":"Initiate – Fortran Program","text":"public interface Initiate Generic method to initiate QuadratureVariables_ Contents Module Procedures elem_var_initiate Module Procedures private interface elem_var_initiate () Subroutine that initiate QuadratureVariables_ object Arguments None","tags":"","loc":"interface/initiate~5.html"},{"title":"elem_var_add_val – Fortran Program","text":"interface Subroutine that adds values in QuadratureVariables_ object private subroutine elem_var_add_val(Obj, ipoint, elemnum, Scale, Val, is, ie) Arguments Type Intent Optional Attributes Name class( QuadratureVariables_ ), intent(inout) :: Obj Instance of QuadratureVariables_ integer(kind=I4B), intent(in) :: ipoint Quadrature point number integer(kind=I4B), intent(in) :: elemnum It represents id of element or material depending on storage type real(kind=DFP), intent(in) :: Scale Scaling used for Values real(kind=DFP), intent(in) :: Val (:) Values integer(kind=I4B), intent(in), optional :: is is starting index integer(kind=I4B), intent(in), optional :: ie ie ending index Description This subroutine adds values of Obj % Val( :, ipoint, icol )","tags":"","loc":"interface/elem_var_add_val.html"},{"title":"elem_var_deallocate_data – Fortran Program","text":"interface Deallocat data stored inside QuadratureVariables_ object private subroutine elem_var_deallocate_data(Obj) Arguments Type Intent Optional Attributes Name class( QuadratureVariables_ ), intent(inout) :: Obj","tags":"","loc":"interface/elem_var_deallocate_data.html"},{"title":"elem_var_disp – Fortran Program","text":"interface Display the content of QuadratureVariables_ private subroutine elem_var_disp(Obj, msg, unitno) Arguments Type Intent Optional Attributes Name class( QuadratureVariables_ ), intent(in) :: Obj character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitno","tags":"","loc":"interface/elem_var_disp.html"},{"title":"elem_var_get_value – Fortran Program","text":"interface Return values stored inside QuadratureVariables_ private pure function elem_var_get_value(Obj, elemnum) result(Ans) Arguments Type Intent Optional Attributes Name class( QuadratureVariables_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: elemnum Element number or material number Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:) Description This subroutine returns Obj % Val(:,:,elemnum)","tags":"","loc":"interface/elem_var_get_value.html"},{"title":"elem_var_initiate – Fortran Program","text":"interface Subroutine that initiate QuadratureVariables_ object private subroutine elem_var_initiate(Obj, tprop, tpoint, telem, names) Arguments Type Intent Optional Attributes Name class( QuadratureVariables_ ), intent(inout) :: Obj Instance integer(kind=I4B), intent(in) :: tprop Total number of properties integer(kind=I4B), intent(in) :: tpoint Total number of quadrature points integer(kind=I4B), intent(in) :: telem Total number of columns type(String), intent(in), optional :: names (:) Names of variables Description This subroutine initiates QuadratureVariables_ object\n - If colID=M then object stores material properties\n - In above case tpoint is not considered and set to 1 internally\n - If names are present then size( names ) == tprop - If names are not present then variables will be named as V1, V2,...","tags":"","loc":"interface/elem_var_initiate.html"},{"title":"elem_var_set_value – Fortran Program","text":"interface Subroutine that sets values in QuadratureVariables_ object private subroutine elem_var_set_value(Obj, ipoint, elemnum, Val, is, ie) Arguments Type Intent Optional Attributes Name class( QuadratureVariables_ ), intent(inout) :: Obj Instance of QuadratureVariables_ integer(kind=I4B), intent(in) :: ipoint Quadrature point number integer(kind=I4B), intent(in) :: elemnum element number real(kind=DFP), intent(in) :: Val (:) Values integer(kind=I4B), intent(in), optional :: is is starting index integer(kind=I4B), intent(in), optional :: ie ie ending index Description This subroutine set values of Obj % Val( :, ipoint, icol ) - Obj % Val( i_s:i_e, ipoint, icol) = Val( : )","tags":"","loc":"interface/elem_var_set_value.html"},{"title":"gmsh_clear – Fortran Program","text":"private function gmsh_clear(Obj) result(Ans) This function will clear all model and option and create an blank model Arguments Type Intent Optional Attributes Name class( gmsh_ ), intent(inout) :: Obj Return Value integer(kind=I4B) Contents Source Code gmsh_clear Source Code FUNCTION gmsh_clear ( Obj ) RESULT ( Ans ) CLASS ( gmsh_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ) :: Ans CALL EqualLine ( ) CALL Display ( \"     gmsh_Class@Methods.f90\" ) CALL Display ( \"        gmsh_clear()\" ) CALL Display ( \"        cleanup done\" ) CALL EqualLine ( ) IF ( ASSOCIATED ( Obj % model ) ) DEALLOCATE ( Obj % model ) Obj % model => NULL ( ) END FUNCTION gmsh_clear","tags":"","loc":"proc/gmsh_clear.html"},{"title":"gmsh_final – Fortran Program","text":"private function gmsh_final(Obj) result(Ans) This function will stop the gmsh engine Usage fortran\n    ierr = obj % finalize() Arguments Type Intent Optional Attributes Name class( gmsh_ ), intent(inout) :: Obj Return Value integer(kind=I4B) Contents Source Code gmsh_final Source Code FUNCTION gmsh_final ( Obj ) RESULT ( Ans ) CLASS ( gmsh_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ) :: Ans CALL Display ( \"gmsh:: Deallocating gmsh%modelc\" ) IF ( ASSOCIATED ( obj % model ) ) DEALLOCATE ( obj % model ) obj % model => null () Ans = 0 Obj % NSD = 0 END FUNCTION gmsh_final","tags":"","loc":"proc/gmsh_final.html"},{"title":"gmsh_init – Fortran Program","text":"private function gmsh_init(Obj, NSD) result(Ans) This function will start the gmsh engine\n It allocates obj % model Usage fortran\n    ierr = obj % initialize( NSD ) Arguments Type Intent Optional Attributes Name class( gmsh_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: NSD Return Value integer(kind=I4B) Contents Source Code gmsh_init Source Code FUNCTION gmsh_init ( Obj , NSD ) RESULT ( Ans ) CLASS ( gmsh_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: NSD INTEGER ( I4B ) :: Ans CALL Display ( \"gmsh:: Initiating gmsh\" ) IF ( ASSOCIATED ( Obj % model ) ) DEALLOCATE ( Obj % model ) ALLOCATE ( obj % model ) ans = 0 Obj % NSD = NSD END FUNCTION gmsh_init","tags":"","loc":"proc/gmsh_init.html"},{"title":"gmsh_merge – Fortran Program","text":"private function gmsh_merge(Obj, P, F, E) result(Ans) This function will open a file and read its content\n Based upon the extension of the file it can take different actions\n IF the file represents a model file then it will merge the content to the\n current model Arguments Type Intent Optional Attributes Name class( gmsh_ ), intent(inout) :: Obj character(len=*), intent(in) :: P Path of file character(len=*), intent(in) :: F File name character(len=*), intent(in) :: E Extension Return Value integer(kind=I4B) Contents Source Code gmsh_merge Source Code FUNCTION gmsh_merge ( Obj , P , F , E ) RESULT ( Ans ) CLASS ( gmsh_ ), INTENT ( INOUT ) :: Obj CHARACTER ( LEN = * ), INTENT ( IN ) :: P !! Path of file CHARACTER ( LEN = * ), INTENT ( IN ) :: F !! File name CHARACTER ( LEN = * ), INTENT ( IN ) :: E !! Extension INTEGER ( I4B ) :: Ans ! main program CALL EqualLine ( ) CALL Display ( \"ERROR:: gmsh_Class@Methods.f90\" ) CALL Display ( \"        gmsh_merge()\" ) CALL Display ( \"        Currently not supported\" ) CALL EqualLine ( ) END FUNCTION gmsh_merge","tags":"","loc":"proc/gmsh_merge.html"},{"title":"gmsh_open – Fortran Program","text":"private function gmsh_open(Obj, P, F, E) result(Ans) This function will open a file and read its content\n Based upon the extension of the file it can take different actions\n If file represents a model file then a new model will be created Arguments Type Intent Optional Attributes Name class( gmsh_ ), intent(inout) :: Obj character(len=*), intent(in) :: P Path of file character(len=*), intent(in) :: F File name character(len=*), intent(in) :: E Extension Return Value integer(kind=I4B) Contents Source Code gmsh_open Source Code FUNCTION gmsh_open ( Obj , P , F , E ) RESULT ( Ans ) CLASS ( gmsh_ ), INTENT ( INOUT ) :: Obj CHARACTER ( LEN = * ), INTENT ( IN ) :: P !! Path of file CHARACTER ( LEN = * ), INTENT ( IN ) :: F !! File name CHARACTER ( LEN = * ), INTENT ( IN ) :: E !! Extension INTEGER ( I4B ) :: Ans ! main program Ans = 0 IF ( trim ( E ) . EQ . \".msh\" ) THEN ! we need to create a model in this case IF ( . NOT . ASSOCIATED ( Obj % model ) ) THEN CALL Display ( \"gmsh::  allocating obj % model\" ) ALLOCATE ( Obj % model ) END IF IF ( . NOT . ASSOCIATED ( Obj % model % mesh ) ) THEN CALL Display ( \"gmsh:: allocating obj % model % mesh\" ) ALLOCATE ( Obj % model % mesh ) ELSE CALL Display ( \"WARNING:: gmsh_Class@Methods.f90\" ) CALL Display ( \"        gmsh_open()\" ) CALL Display ( \"        gmh%model%mesh is associated\" ) CALL Display ( \"           calling deallocateData()\" ) CALL Display ( \"           buffer is untouched()\" ) CALL Obj % model % mesh % Finalize ( ) END IF CALL Display ( \"gmsh:: making obj % model % mesh object\" ) CALL Obj % model % mesh % initiate ( P , F , E , Obj % NSD ) ELSE IF ( trim ( E ) . EQ . \".geo\" ) THEN CALL Display ( \"ERROR:: gmsh_Class@Methods.f90\" ) CALL Display ( \"        gmsh_open()\" ) CALL Display ( \"        Currently .geo file cannot be loaded\" ) STOP END IF END FUNCTION gmsh_open","tags":"","loc":"proc/gmsh_open.html"},{"title":"gmsh_write – Fortran Program","text":"private function gmsh_write(Obj, P, F, E) result(Ans) This function will write the data in a file depending upon the extension\n of the file Arguments Type Intent Optional Attributes Name class( gmsh_ ), intent(inout) :: Obj character(len=*), intent(in) :: P Path of file character(len=*), intent(in) :: F File name character(len=*), intent(in) :: E Extension Return Value integer(kind=I4B) Contents Source Code gmsh_write Source Code FUNCTION gmsh_write ( Obj , P , F , E ) RESULT ( Ans ) CLASS ( gmsh_ ), INTENT ( INOUT ) :: Obj CHARACTER ( LEN = * ), INTENT ( IN ) :: P !! Path of file CHARACTER ( LEN = * ), INTENT ( IN ) :: F !! File name CHARACTER ( LEN = * ), INTENT ( IN ) :: E !! Extension INTEGER ( I4B ) :: Ans ! Internal variables TYPE ( File_ ) :: aFile IF ( . NOT . ASSOCIATED ( Obj % model ) ) THEN CALL Display ( \"ERROR:: gmsh_Class@Methods.f90\" ) CALL Display ( \"        gmsh_write()\" ) CALL Display ( \"        obj % model is not allocated/added\" ) STOP END IF IF ( trim ( E ) . EQ . \".msh\" ) THEN CALL Display ( \"gmsh:: opening a file to write .geo file\" ) CALL OpenFileToWrite ( aFile , P , F , \".geo\" ) CALL Display ( \"gmsh:: calling gmsh%model%write()\" ) Ans = obj % model % write ( aFile % UnitNo ) WRITE ( aFile % UnitNo , \"(A)\" ) 'Save \"' // trim ( P ) // trim ( F ) & & // trim ( E ) // '\" ;' WRITE ( aFile % UnitNo , \"(A)\" ) \"Exit; \" CALL CloseFile ( aFile ) CALL ExecuteCommand ( 'gmsh \"' // trim ( P ) // trim ( F ) // \".geo\" // '\"' , & & \"gmsh_Class.f90>>gmsh_write()\" ) ELSE IF ( trim ( E ) . EQ . \".geo\" ) THEN CALL Display ( \"gmsh:: opening a file to write .geo file\" ) CALL OpenFileToWrite ( aFile , P , F , E ) CALL Display ( \"gmsh:: calling gmsh%model%write()\" ) Ans = obj % model % write ( aFile % UnitNo ) CALL CloseFile ( aFile ) ELSE CALL Display ( \"ERROR:: gmsh_Class@Methods.f90\" ) CALL Display ( \"        gmsh_write()\" ) CALL Display ( \"        Unknown file extension\" ) STOP END IF END FUNCTION gmsh_write","tags":"","loc":"proc/gmsh_write.html"},{"title":"gmsh_from_gmsh – Fortran Program","text":"interface This function generate a gmsh model from the mesh data stored inside private function gmsh_from_gmsh(Obj, gmsh, Nodes) result(Ans) Arguments Type Intent Optional Attributes Name class( gmsh_ ), intent(inout), TARGET :: Obj Old gmsh class( gmsh_ ), intent(inout), TARGET :: gmsh new gmsh real(kind=DFP), intent(in) :: Nodes (:,:) nodes Return Value integer(kind=I4B) Description This function generates a gmsh model by reading mesh data stored inside gmsh_ object.","tags":"","loc":"interface/gmsh_from_gmsh.html"},{"title":"gmsh_mesh_constructor_1 – Fortran Program","text":"private function gmsh_mesh_constructor_1(Path, FileName, Extension, NSD) result(Obj) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: Path character(len=*), intent(in) :: FileName character(len=*), intent(in), optional :: Extension integer(kind=I4B), intent(in) :: NSD Return Value class( gmshMesh_ ),\n  POINTER Contents Source Code gmsh_mesh_constructor_1 Source Code FUNCTION gmsh_mesh_constructor_1 ( Path , FileName , Extension , NSD ) RESULT ( Obj ) ! Define intent of dummy variables CLASS ( gmshMesh_ ), POINTER :: Obj CHARACTER ( LEN = * ), INTENT ( IN ) :: FileName CHARACTER ( LEN = * ), INTENT ( IN ), OPTIONAL :: Extension , Path INTEGER ( I4B ), INTENT ( IN ) :: NSD ALLOCATE ( Obj ) CALL Obj % Initiate ( Path , FileName , Extension , NSD ) END FUNCTION gmsh_mesh_constructor_1","tags":"","loc":"proc/gmsh_mesh_constructor_1.html"},{"title":"DeallocateData – Fortran Program","text":"public interface DeallocateData Contents Module Procedures gmsh_mesh_deallocatedata Module Procedures private interface gmsh_mesh_deallocatedata () This will deallocate data Arguments None","tags":"","loc":"interface/deallocatedata~9.html"},{"title":"Display – Fortran Program","text":"public interface Display Contents Module Procedures gmsh_mesh_display Module Procedures private interface gmsh_mesh_display () This subroutine display the content of gmshmesh object Arguments None","tags":"","loc":"interface/display~6.html"},{"title":"Initiate – Fortran Program","text":"public interface Initiate Contents Module Procedures gmsh_mesh_initiate Module Procedures private interface gmsh_mesh_initiate () This subroutine generates the gmshMesh_ object Arguments None","tags":"","loc":"interface/initiate~6.html"},{"title":"dom_init_from_gmshMesh – Fortran Program","text":"interface This subroutine initiate Domain_ by reading gmshMesh file private subroutine dom_init_from_gmshMesh(mshobj, obj, facetmesh) Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: mshobj class(Domain_), intent(inout) :: obj type(String), intent(in), optional :: facetmesh (:,:) Description This subroutine initiate Domain_ by reading gmshMesh file\n This is a high level routine It gets all informatio from gmshMesh_ and allocate obj %  omega and obj  % boundary","tags":"","loc":"interface/dom_init_from_gmshmesh.html"},{"title":"gmshMesh – Fortran Program","text":"public interface gmshMesh Contents Module Procedures gmsh_mesh_constuctor1 Module Procedures private interface gmsh_mesh_constuctor1 () This function will create the gmshMesh_ object Arguments None","tags":"","loc":"interface/gmshmesh.html"},{"title":"gmsh_mesh_Pointer – Fortran Program","text":"public interface gmsh_mesh_Pointer Contents Module Procedures gmsh_mesh_constructor_1 Module Procedures private function gmsh_mesh_constructor_1 (Path, FileName, Extension, NSD) result(Obj) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: Path character(len=*), intent(in) :: FileName character(len=*), intent(in), optional :: Extension integer(kind=I4B), intent(in) :: NSD Return Value class( gmshMesh_ ),\n  POINTER","tags":"","loc":"interface/gmsh_mesh_pointer.html"},{"title":"gmsh_mesh_constuctor1 – Fortran Program","text":"interface This function will create the gmshMesh_ object private function gmsh_mesh_constuctor1(Path, FileName, Extension, NSD) result(Ans) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Path character(len=*), intent(in) :: FileName character(len=*), intent(in) :: Extension integer(kind=I4B), intent(in) :: NSD Return Value type( gmshMesh_ ) Description This function will create the gmshMesh_ object","tags":"","loc":"interface/gmsh_mesh_constuctor1.html"},{"title":"gmsh_mesh_deallocatedata – Fortran Program","text":"interface This will deallocate data private subroutine gmsh_mesh_deallocatedata(obj) Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(inout) :: obj Description This subroutine deallocate data","tags":"","loc":"interface/gmsh_mesh_deallocatedata.html"},{"title":"gmsh_mesh_display – Fortran Program","text":"interface This subroutine display the content of gmshmesh object private subroutine gmsh_mesh_display(obj, msg, UnitNo) Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: obj character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: UnitNo Description This subroutine display the content of obj","tags":"","loc":"interface/gmsh_mesh_display.html"},{"title":"gmsh_mesh_getelements_1 – Fortran Program","text":"interface This subroutine returns a mesh of elements; private subroutine gmsh_mesh_getelements_1(obj, MeshObj, FEObj) Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: obj class(Mesh_), intent(inout), TARGET :: MeshObj class(Element_), intent(in) :: FEObj Description This subroutine returns a single Mesh_ object containing all elements","tags":"","loc":"interface/gmsh_mesh_getelements_1.html"},{"title":"gmsh_mesh_getelements_2 – Fortran Program","text":"interface This subroutine builds a mesh of elements with same co-dimensions private subroutine gmsh_mesh_getelements_2(obj, MeshObj, XiDim, FEObj, Offset) Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: obj class(Mesh_), intent(inout), TARGET :: MeshObj integer(kind=I4B), intent(in) :: XiDim class(Element_), intent(in) :: FEObj integer(kind=I4B), intent(in), optional :: Offset Description This subroutine builds a mesh of elements with same co-dimensions For Xidim=nsd it returns all cell elements For Xidim=nsd-1 it returns all facet elements For Xidim=nsd-2 it returns all line elements For Xidim=nsd-3 it returns all the point elements Note If offset is present then MeshObj should be allocated, in that case\n first element will be placed at MeshObj % elem( offset + 1 ) . Therefore,\n there should be sufficient space in MeshObj to accomodate all new\n coming elements","tags":"","loc":"interface/gmsh_mesh_getelements_2.html"},{"title":"gmsh_mesh_getelements_2c – Fortran Program","text":"interface This subroutine build a Mesh_ in Domain_ by using gmshMesh_ private subroutine gmsh_mesh_getelements_2c(Obj, Dom, indx, XiDim, FEObj, Offset) Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: Obj class(Domain_), intent(inout), TARGET :: Dom integer(kind=I4B), intent(in) :: indx integer(kind=I4B), intent(in) :: XiDim class(Element_), intent(in) :: FEObj integer(kind=I4B), intent(in), optional :: Offset Description This subroutine builds a mesh of elements with same co-dimensions For Xidim=nsd it returns all cell elements For Xidim=nsd-1 it returns all facet elements For Xidim=nsd-2 it returns all line elements For Xidim=nsd-3 it returns all the point elements If offset is present then MeshObj should be allocated, in that case\n first element will be placed at MeshObj % elem( offset + 1 ) . Therefore,\n there should be sufficient space in MeshObj to accomodate all new\n coming elements Note that this is just a wrapper for a method defined in\n [[gmshMesh_::getelements]]","tags":"","loc":"interface/gmsh_mesh_getelements_2c.html"},{"title":"gmsh_mesh_getelements_3 – Fortran Program","text":"interface This subroutine returns the mesh of elements private subroutine gmsh_mesh_getelements_3(obj, MeshObj, XiDim, Tag, FEObj, Offset) Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: obj class(Mesh_), intent(inout), TARGET :: MeshObj integer(kind=I4B), intent(in) :: XiDim integer(kind=I4B), intent(in) :: Tag (:) class(Element_), intent(in) :: FEObj integer(kind=I4B), intent(in), optional :: Offset Description This subroutine returns the mesh of elements; it applies two levels of\n filter For Xidim=nsd it returns all cell elements For Xidim=nsd-1 it returns all facet elements For Xidim=nsd-2 it returns all line elements For Xidim=nsd-3 it returns all the point elements Note If offset is present then MeshObj should be allocated, in that case\n first element will be placed at MeshObj % elem( offset + 1 ) . Therefore,\n there should be sufficient space in MeshObj to accomodate all new\n coming elements","tags":"","loc":"interface/gmsh_mesh_getelements_3.html"},{"title":"gmsh_mesh_getelements_3c – Fortran Program","text":"interface This subroutine build a Mesh_ in Domain_ by using gmshMesh_ private subroutine gmsh_mesh_getelements_3c(Obj, Dom, Indx, XiDim, Tag, FEObj, Offset) Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: Obj class(Domain_), intent(inout), TARGET :: Dom integer(kind=I4B), intent(in) :: Indx integer(kind=I4B), intent(in) :: XiDim integer(kind=I4B), intent(in) :: Tag (:) class(Element_), intent(in) :: FEObj integer(kind=I4B), intent(in), optional :: Offset Description This subroutine returns the mesh of elements; it applies two levels of\n filter For Xidim=nsd it returns all cell elements For Xidim=nsd-1 it returns all facet elements For Xidim=nsd-2 it returns all line elements For Xidim=nsd-3 it returns all the point elements Note If offset is present then MeshObj should be allocated, in that case\n first element will be placed at MeshObj % elem( offset + 1 ) . Therefore,\n there should be sufficient space in MeshObj to accomodate all new\n coming elements Note that this is just a wrapper for a method defined in\n [[gmshMesh_::getelements]]","tags":"","loc":"interface/gmsh_mesh_getelements_3c.html"},{"title":"gmsh_mesh_getelements_4 – Fortran Program","text":"interface This subroutine returns the mesh of elements private subroutine gmsh_mesh_getelements_4(obj, MeshObj, XiDim, TagNames, FEObj, Offset) Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: obj class(Mesh_), intent(inout), TARGET :: MeshObj integer(kind=I4B), intent(in) :: XiDim type(String), intent(in) :: TagNames (:) class(Element_), intent(in) :: FEObj integer(kind=I4B), intent(in), optional :: Offset Description This subroutine returns the mesh of elements; it applies two levels of\n filter For Xidim=nsd it returns all cell elements For Xidim=nsd-1 it returns all facet elements For Xidim=nsd-2 it returns all line elements For Xidim=nsd-3 it returns all the point elements Note If offset is present then MeshObj should be allocated, in that case\n first element will be placed at MeshObj % elem( offset + 1 ) . Therefore,\n there should be sufficient space in MeshObj to accomodate all new\n coming elements","tags":"","loc":"interface/gmsh_mesh_getelements_4.html"},{"title":"gmsh_mesh_getelements_4c – Fortran Program","text":"interface This subroutine build a Mesh_ in Domain_ by using gmshMesh_ private subroutine gmsh_mesh_getelements_4c(Obj, Dom, Indx, XiDim, TagNames, FEObj, Offset) Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: Obj class(Domain_), intent(inout), TARGET :: Dom integer(kind=I4B), intent(in) :: Indx integer(kind=I4B), intent(in) :: XiDim type(String), intent(in) :: TagNames (:) class(Element_), intent(in) :: FEObj integer(kind=I4B), intent(in), optional :: Offset Description This subroutine returns the mesh of elements; it applies two levels of\n filter For Xidim=nsd it returns all cell elements For Xidim=nsd-1 it returns all facet elements For Xidim=nsd-2 it returns all line elements For Xidim=nsd-3 it returns all the point elements Note If offset is present then MeshObj should be allocated, in that case\n first element will be placed at MeshObj % elem( offset + 1 ) . Therefore,\n there should be sufficient space in MeshObj to accomodate all new\n coming elements Note that this is just a wrapper for a method defined in\n [[gmshMesh_::getelements]]","tags":"","loc":"interface/gmsh_mesh_getelements_4c.html"},{"title":"gmsh_mesh_getnodes_array – Fortran Program","text":"interface This subroutine retunr the nodal coordinates private subroutine gmsh_mesh_getnodes_array(obj, Nodes) Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: obj real(kind=DFP), intent(inout), ALLOCATABLE :: Nodes (:,:) Description This subroutine returns the nodal coordinates","tags":"","loc":"interface/gmsh_mesh_getnodes_array.html"},{"title":"gmsh_mesh_getnodes_file – Fortran Program","text":"interface This subroutine retunr the nodal coordinates private subroutine gmsh_mesh_getnodes_file(obj, UnitNo, Str, EndStr) Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: obj integer(kind=I4B), intent(in), optional :: UnitNo character(len=*), intent(in), optional :: Str character(len=*), intent(in), optional :: EndStr Description This subroutine returns the nodal coordinates","tags":"","loc":"interface/gmsh_mesh_getnodes_file.html"},{"title":"gmsh_mesh_initiate – Fortran Program","text":"interface This subroutine generates the gmshMesh_ object private subroutine gmsh_mesh_initiate(obj, Path, FileName, Extension, NSD) Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(inout) :: obj character(len=*), intent(in) :: Path character(len=*), intent(in) :: FileName character(len=*), intent(in) :: Extension integer(kind=I4B), intent(in) :: NSD Description This subroutine reads the .msh file and creates the object","tags":"","loc":"interface/gmsh_mesh_initiate.html"},{"title":"gmsh_mesh_telements_1 – Fortran Program","text":"interface This function returns the total element in the mesh private pure function gmsh_mesh_telements_1(obj) result(Ans) Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: obj Return Value integer(kind=I4B) Description This function returns the total element in the mesh","tags":"","loc":"interface/gmsh_mesh_telements_1.html"},{"title":"gmsh_mesh_telements_2 – Fortran Program","text":"interface This function returns the total element in the mesh private pure function gmsh_mesh_telements_2(obj, XiDim) result(Ans) Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: obj integer(kind=I4B), intent(in) :: XiDim Return Value integer(kind=I4B) Description This function returns the total element in the mesh\n Xidim is a codimension based filter\n Xidim=0 => Point\n Xidim=1 => Curve\n Xidim=2 => Surface\n Xidim=3 => Volume","tags":"","loc":"interface/gmsh_mesh_telements_2.html"},{"title":"gmsh_mesh_telements_3 – Fortran Program","text":"interface This function returns the total element in the mesh private pure function gmsh_mesh_telements_3(obj, XiDim, Tag) result(Ans) Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: obj integer(kind=I4B), intent(in) :: XiDim integer(kind=I4B), intent(in) :: Tag (:) Return Value integer(kind=I4B) Description This function returns the total element in the mesh\n We can filter elements based on Xidim and tag","tags":"","loc":"interface/gmsh_mesh_telements_3.html"},{"title":"gmsh_mesh_totalnodes – Fortran Program","text":"interface This function will return the total number of nodes in mesh private pure function gmsh_mesh_totalnodes(obj) result(Ans) Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: obj Return Value integer(kind=I4B) Description This function will return the total number of nodes in mesh","tags":"","loc":"interface/gmsh_mesh_totalnodes.html"},{"title":"gmsh_mesh_write_mesh – Fortran Program","text":"interface private subroutine gmsh_mesh_write_mesh(obj, Path, FileName, Extension, Nodes) Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: obj character(len=*), intent(in) :: Path character(len=*), intent(in) :: FileName character(len=*), intent(in) :: Extension real(kind=DFP), intent(in) :: Nodes (:,:)","tags":"","loc":"interface/gmsh_mesh_write_mesh.html"},{"title":"gmsh_mesh_write_nodedata_1 – Fortran Program","text":"interface This subroutine writes the node data information in a msh file format private subroutine gmsh_mesh_write_nodedata_1(obj, x, dofobj, name, indx, local_nptrs, nodes) Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: obj real(kind=DFP), intent(in) :: x (:) type(DOF_), intent(in) :: dofobj character(len=1), intent(in) :: name integer(kind=I4B), intent(in) :: indx (:) integer(kind=I4B), intent(in) :: local_nptrs (:) real(kind=DFP), intent(in), optional :: nodes (:,:) Description This subroutine writes the nodal values of a variable x into msh file name is the name of physical variable whose dof will be printed The subroutine will decided the nature of physical variable and\n and write in msh file accordingly The subroutine search for this name in DOF_ and if this name is\n is not present the subroutine writes nothing","tags":"","loc":"interface/gmsh_mesh_write_nodedata_1.html"},{"title":"gmsh_mesh_write_nodedata_2 – Fortran Program","text":"interface This subroutine writes the node data information in a gmshMesh file format private subroutine gmsh_mesh_write_nodedata_2(obj, x, dofobj, indx, local_nptrs, nodes) Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: obj real(kind=DFP), intent(in) :: x (:) type(DOF_), intent(in) :: dofobj integer(kind=I4B), intent(in) :: indx (:) integer(kind=I4B), intent(in) :: local_nptrs (:) real(kind=DFP), intent(in), optional :: nodes (:,:) Description This subroutine writes the nodal values of a variable x into gmshMesh file It will write all the physical variables in vtk file It calls gmsh_mesh_write_nodedata_2 subroutine internally","tags":"","loc":"interface/gmsh_mesh_write_nodedata_2.html"},{"title":"mesh_generate – Fortran Program","text":"interface This will add mesh generation command to .geo file private function mesh_generate(Obj, dim) result(Ans) Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: dim Return Value integer(kind=I4B) Description This will add mesh generation command to .geo file","tags":"","loc":"interface/mesh_generate.html"},{"title":"mesh_write – Fortran Program","text":"interface This function will dump the buffer content in to a file private function mesh_write(Obj, UnitNo) result(Ans) Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: UnitNo Return Value integer(kind=I4B) Description This function will dump the buffer content in to a file","tags":"","loc":"interface/mesh_write.html"},{"title":"BSpline_encode – Fortran Program","text":"private function BSpline_encode(obj) result(ans) Arguments Type Intent Optional Attributes Name class( gmshBSpline_ ), intent(in) :: obj Return Value type(String) Contents Source Code BSpline_encode Source Code FUNCTION BSpline_encode ( Obj ) RESULT ( Ans ) CLASS ( gmshBSpline_ ), INTENT ( IN ) :: obj TYPE ( String ) :: ans ! internal variables INTEGER ( I4B ) :: ii , n TYPE ( String ), ALLOCATABLE :: s ( : ) n = SIZE ( obj % pointTags ) ALLOCATE ( s ( n ) ) DO ii = 1 , n s ( ii ) = trim ( str ( obj % pointTags ( ii ), no_sign = . true . ) ) END DO ans = ans % join ( s , sep = \", \" ) ans = & & \"BSpline( \" // & & trim ( str ( obj % uid , no_sign = . true . ) ) // & & \" ) = { \" // & & trim ( ans ) // & & \" };\" END FUNCTION BSpline_encode","tags":"","loc":"proc/bspline_encode.html"},{"title":"Bezier_encode – Fortran Program","text":"private function Bezier_encode(obj) result(ans) Arguments Type Intent Optional Attributes Name class( gmshBezier_ ), intent(in) :: obj Return Value type(String) Contents Source Code Bezier_encode Source Code FUNCTION Bezier_encode ( Obj ) RESULT ( Ans ) CLASS ( gmshBezier_ ), INTENT ( IN ) :: obj TYPE ( String ) :: ans ! internal variables INTEGER ( I4B ) :: ii , n TYPE ( String ), ALLOCATABLE :: s ( : ) n = SIZE ( obj % pointTags ) ALLOCATE ( s ( n ) ) DO ii = 1 , n s ( ii ) = trim ( str ( obj % pointTags ( ii ), no_sign = . true . ) ) END DO ans = ans % join ( s , sep = \", \" ) ans = & & \"Bezier( \" // & & trim ( str ( obj % uid , no_sign = . true . ) ) // & & \" ) = { \" // & & trim ( ans ) // & & \" };\" END FUNCTION Bezier_encode","tags":"","loc":"proc/bezier_encode.html"},{"title":"Circle_encode – Fortran Program","text":"private function Circle_encode(obj) result(ans) Arguments Type Intent Optional Attributes Name class( gmshCircle_ ), intent(in) :: obj Return Value type(String) Contents Source Code Circle_encode Source Code FUNCTION Circle_encode ( Obj ) RESULT ( Ans ) CLASS ( gmshCircle_ ), INTENT ( IN ) :: obj TYPE ( String ) :: ans ans = & & \"Circle( \" // & & trim ( str ( obj % uid , no_sign = . true . ) ) // & & \" ) = { \" // & & trim ( str ( obj % startTag , no_sign = . true . ) ) // & & \", \" // & & trim ( str ( obj % centerTag , no_sign = . true . ) ) // & & \", \" // & & trim ( str ( obj % endTag , no_sign = . true . ) ) // & & \" };\" END FUNCTION Circle_encode","tags":"","loc":"proc/circle_encode.html"},{"title":"CompoundBSpline_encode – Fortran Program","text":"private function CompoundBSpline_encode(obj) result(ans) Arguments Type Intent Optional Attributes Name class( gmshCompoundBSpline_ ), intent(in) :: obj Return Value type(String) Contents Source Code CompoundBSpline_encode Source Code FUNCTION CompoundBSpline_encode ( Obj ) RESULT ( Ans ) CLASS ( gmshCompoundBSpline_ ), INTENT ( IN ) :: obj TYPE ( String ) :: ans ! internal variables INTEGER ( I4B ) :: ii , n TYPE ( String ), ALLOCATABLE :: s ( : ) n = SIZE ( obj % curveTags ) ALLOCATE ( s ( n ) ) DO ii = 1 , n s ( ii ) = trim ( str ( obj % curveTags ( ii ), no_sign = . true . ) ) END DO ans = ans % join ( s , sep = \", \" ) ans = & & \"Compound BSpline( \" // & & trim ( str ( obj % uid , no_sign = . true . ) ) // & & \" ) = { \" // & & trim ( ans ) // & & \" } Using \" // & & trim ( str ( obj % numIntervals , no_sign = . true . ) ) // & & \";\" END FUNCTION CompoundBSpline_encode","tags":"","loc":"proc/compoundbspline_encode.html"},{"title":"CompoundSpline_encode – Fortran Program","text":"private function CompoundSpline_encode(obj) result(ans) Arguments Type Intent Optional Attributes Name class( gmshCompoundSpline_ ), intent(in) :: obj Return Value type(String) Contents Source Code CompoundSpline_encode Source Code FUNCTION CompoundSpline_encode ( Obj ) RESULT ( Ans ) CLASS ( gmshCompoundSpline_ ), INTENT ( IN ) :: obj TYPE ( String ) :: ans ! internal variables INTEGER ( I4B ) :: ii , n TYPE ( String ), ALLOCATABLE :: s ( : ) n = SIZE ( obj % curveTags ) ALLOCATE ( s ( n ) ) DO ii = 1 , n s ( ii ) = trim ( str ( obj % curveTags ( ii ), no_sign = . true . ) ) END DO ans = ans % join ( s , sep = \", \" ) ans = & & \"Compound Spline( \" // & & trim ( str ( obj % uid , no_sign = . true . ) ) // & & \" ) = { \" // & & trim ( ans ) // & & \" } Using \" // & & trim ( str ( obj % numIntervals , no_sign = . true . ) ) // & & \";\" END FUNCTION CompoundSpline_encode","tags":"","loc":"proc/compoundspline_encode.html"},{"title":"CurveLoop_encode – Fortran Program","text":"private function CurveLoop_encode(obj) result(ans) Arguments Type Intent Optional Attributes Name class( gmshCurveLoop_ ), intent(in) :: obj Return Value type(String) Contents Source Code CurveLoop_encode Source Code FUNCTION CurveLoop_encode ( Obj ) RESULT ( Ans ) CLASS ( gmshCurveLoop_ ), INTENT ( IN ) :: obj TYPE ( String ) :: ans ! internal variables INTEGER ( I4B ) :: ii , n TYPE ( String ), ALLOCATABLE :: s ( : ) n = SIZE ( obj % curveTags ) ALLOCATE ( s ( n ) ) DO ii = 1 , n s ( ii ) = trim ( str ( obj % curveTags ( ii ) ) ) END DO ans = ans % join ( s , sep = \", \" ) ans = & & \"Curve Loop( \" // & & trim ( str ( obj % uid , no_sign = . true . ) ) // & & \" ) = { \" // & & trim ( ans ) // & & \" };\" END FUNCTION CurveLoop_encode","tags":"","loc":"proc/curveloop_encode.html"},{"title":"Ellipse_encode – Fortran Program","text":"private function Ellipse_encode(obj) result(ans) Arguments Type Intent Optional Attributes Name class( gmshEllipse_ ), intent(in) :: obj Return Value type(String) Contents Source Code Ellipse_encode Source Code FUNCTION Ellipse_encode ( Obj ) RESULT ( Ans ) CLASS ( gmshEllipse_ ), INTENT ( IN ) :: obj TYPE ( String ) :: ans ans = & & \"Ellipse( \" // & & trim ( str ( obj % uid , no_sign = . true . ) ) // & & \" ) = { \" // & & trim ( str ( obj % startTag , no_sign = . true . ) ) // & & \", \" // & & trim ( str ( obj % centerTag , no_sign = . true . ) ) // & & \", \" // & & trim ( str ( obj % majorTag , no_sign = . true . ) ) // & & \", \" // & & trim ( str ( obj % endTag , no_sign = . true . ) ) // & & \" };\" END FUNCTION Ellipse_encode","tags":"","loc":"proc/ellipse_encode.html"},{"title":"Spline_encode – Fortran Program","text":"private function Spline_encode(obj) result(ans) Arguments Type Intent Optional Attributes Name class( gmshSpline_ ), intent(in) :: obj Return Value type(String) Contents Source Code Spline_encode Source Code FUNCTION Spline_encode ( Obj ) RESULT ( Ans ) CLASS ( gmshSpline_ ), INTENT ( IN ) :: obj TYPE ( String ) :: ans ! internal variables INTEGER ( I4B ) :: ii , n TYPE ( String ), ALLOCATABLE :: s ( : ) n = SIZE ( obj % pointTags ) ALLOCATE ( s ( n ) ) DO ii = 1 , n s ( ii ) = trim ( str ( obj % pointTags ( ii ), no_sign = . true . ) ) END DO ans = ans % join ( s , sep = \", \" ) ans = & & \"Spline( \" // & & trim ( str ( obj % uid , no_sign = . true . ) ) // & & \" ) = { \" // & & trim ( ans ) // & & \" };\" END FUNCTION Spline_encode","tags":"","loc":"proc/spline_encode.html"},{"title":"gmshBSpline_Pointer – Fortran Program","text":"public function gmshBSpline_Pointer(pointTags, uid) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: pointTags (:) integer(kind=I4B), intent(in) :: uid Return Value class( gmshBSpline_ ),\n  POINTER Contents Source Code gmshBSpline_Pointer Source Code FUNCTION gmshBSpline_Pointer ( pointTags , uid ) RESULT ( Ans ) INTEGER ( I4B ), INTENT ( IN ) :: uid , pointTags ( : ) CLASS ( gmshBSpline_ ), POINTER :: Ans ALLOCATE ( Ans ) Ans % pointTags = pointTags Ans % uid = uid Ans % dim = 1 END FUNCTION gmshBSpline_Pointer","tags":"","loc":"proc/gmshbspline_pointer.html"},{"title":"gmshBezier_Pointer – Fortran Program","text":"public function gmshBezier_Pointer(pointTags, uid) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: pointTags (:) integer(kind=I4B), intent(in) :: uid Return Value class( gmshBezier_ ),\n  POINTER Contents Source Code gmshBezier_Pointer Source Code FUNCTION gmshBezier_Pointer ( pointTags , uid ) RESULT ( Ans ) INTEGER ( I4B ), INTENT ( IN ) :: uid , pointTags ( : ) CLASS ( gmshBezier_ ), POINTER :: Ans ALLOCATE ( Ans ) Ans % pointTags = pointTags Ans % uid = uid Ans % dim = 1 END FUNCTION gmshBezier_Pointer","tags":"","loc":"proc/gmshbezier_pointer.html"},{"title":"gmshCircle_Pointer – Fortran Program","text":"public function gmshCircle_Pointer(startTag, centerTag, endTag, uid, nx, ny, nz) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: startTag integer(kind=I4B), intent(in) :: centerTag integer(kind=I4B), intent(in) :: endTag integer(kind=I4B), intent(in) :: uid real(kind=DFP), intent(in) :: nx real(kind=DFP), intent(in) :: ny real(kind=DFP), intent(in) :: nz Return Value class( gmshCircle_ ),\n  POINTER Contents Source Code gmshCircle_Pointer Source Code FUNCTION gmshCircle_Pointer ( startTag , centerTag , endTag , uid , nx , ny , nz ) & & RESULT ( Ans ) INTEGER ( I4B ), INTENT ( IN ) :: startTag , endTag , centerTag , uid REAL ( DFP ), INTENT ( IN ) :: nx , ny , nz CLASS ( gmshCircle_ ), POINTER :: Ans ALLOCATE ( Ans ) Ans % startTag = startTag Ans % endTag = endTag Ans % centerTag = centerTag Ans % nx = nx Ans % ny = ny Ans % nz = nz Ans % uid = uid Ans % dim = 1 END FUNCTION gmshCircle_Pointer","tags":"","loc":"proc/gmshcircle_pointer.html"},{"title":"gmshCompoundBSpline_Pointer – Fortran Program","text":"public function gmshCompoundBSpline_Pointer(curveTags, uid, numIntervals) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: curveTags (:) integer(kind=I4B), intent(in) :: uid integer(kind=I4B), intent(in) :: numIntervals Return Value class( gmshCompoundBSpline_ ),\n  POINTER Contents Source Code gmshCompoundBSpline_Pointer Source Code FUNCTION gmshCompoundBSpline_Pointer ( curveTags , uid , numIntervals ) & & RESULT ( Ans ) INTEGER ( I4B ), INTENT ( IN ) :: uid , curveTags ( : ), numIntervals CLASS ( gmshCompoundBSpline_ ), POINTER :: Ans ALLOCATE ( Ans ) Ans % curveTags = curveTags Ans % numIntervals = numIntervals Ans % uid = uid Ans % dim = 1 END FUNCTION gmshCompoundBSpline_Pointer","tags":"","loc":"proc/gmshcompoundbspline_pointer.html"},{"title":"gmshCompoundSpline_Pointer – Fortran Program","text":"public function gmshCompoundSpline_Pointer(curveTags, uid, numIntervals) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: curveTags (:) integer(kind=I4B), intent(in) :: uid integer(kind=I4B), intent(in) :: numIntervals Return Value class( gmshCompoundSpline_ ),\n  POINTER Contents Source Code gmshCompoundSpline_Pointer Source Code FUNCTION gmshCompoundSpline_Pointer ( curveTags , uid , numIntervals ) & & RESULT ( Ans ) INTEGER ( I4B ), INTENT ( IN ) :: uid , curveTags ( : ), numIntervals CLASS ( gmshCompoundSpline_ ), POINTER :: Ans ALLOCATE ( Ans ) Ans % curveTags = curveTags Ans % numIntervals = numIntervals Ans % uid = uid Ans % dim = 1 END FUNCTION gmshCompoundSpline_Pointer","tags":"","loc":"proc/gmshcompoundspline_pointer.html"},{"title":"gmshCurveLoop_Pointer – Fortran Program","text":"public function gmshCurveLoop_Pointer(curveTags, uid) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: curveTags (:) integer(kind=I4B), intent(in) :: uid Return Value class( gmshCurveLoop_ ),\n  POINTER Contents Source Code gmshCurveLoop_Pointer Source Code FUNCTION gmshCurveLoop_Pointer ( curveTags , uid ) RESULT ( Ans ) INTEGER ( I4B ), INTENT ( IN ) :: uid , curveTags ( : ) CLASS ( gmshCurveLoop_ ), POINTER :: Ans ALLOCATE ( Ans ) Ans % curveTags = curveTags Ans % uid = uid Ans % dim = 1 END FUNCTION gmshCurveLoop_Pointer","tags":"","loc":"proc/gmshcurveloop_pointer.html"},{"title":"gmshEllipse_Pointer – Fortran Program","text":"public function gmshEllipse_Pointer(startTag, centerTag, majorTag, endTag, uid, nx, ny, nz) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: startTag integer(kind=I4B), intent(in) :: centerTag integer(kind=I4B), intent(in) :: majorTag integer(kind=I4B), intent(in) :: endTag integer(kind=I4B), intent(in) :: uid real(kind=DFP), intent(in) :: nx real(kind=DFP), intent(in) :: ny real(kind=DFP), intent(in) :: nz Return Value class( gmshEllipse_ ),\n  POINTER Contents Source Code gmshEllipse_Pointer Source Code FUNCTION gmshEllipse_Pointer ( startTag , centerTag , majorTag , endTag , uid , & & nx , ny , nz ) RESULT ( Ans ) INTEGER ( I4B ), INTENT ( IN ) :: startTag , endTag , centerTag , majorTag , uid REAL ( DFP ), INTENT ( IN ) :: nx , ny , nz CLASS ( gmshEllipse_ ), POINTER :: Ans ALLOCATE ( Ans ) Ans % startTag = startTag Ans % endTag = endTag Ans % majorTag = majorTag Ans % centerTag = centerTag Ans % nx = nx Ans % ny = ny Ans % nz = nz Ans % uid = uid Ans % dim = 1 END FUNCTION gmshEllipse_Pointer","tags":"","loc":"proc/gmshellipse_pointer.html"},{"title":"gmshLine_Pointer – Fortran Program","text":"public function gmshLine_Pointer(startTag, endTag, uid) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: startTag integer(kind=I4B), intent(in) :: endTag integer(kind=I4B), intent(in) :: uid Return Value class( gmshLine_ ),\n  POINTER Contents Source Code gmshLine_Pointer Source Code FUNCTION gmshLine_Pointer ( startTag , endTag , uid ) RESULT ( Ans ) INTEGER ( I4B ), INTENT ( IN ) :: startTag , endTag , uid CLASS ( gmshLine_ ), POINTER :: Ans ALLOCATE ( Ans ) Ans % startTag = startTag Ans % endTag = endTag Ans % uid = uid Ans % dim = 1 END FUNCTION gmshLine_Pointer","tags":"","loc":"proc/gmshline_pointer.html"},{"title":"gmshSpline_Pointer – Fortran Program","text":"public function gmshSpline_Pointer(pointTags, uid) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: pointTags (:) integer(kind=I4B), intent(in) :: uid Return Value class( gmshSpline_ ),\n  POINTER Contents Source Code gmshSpline_Pointer Source Code FUNCTION gmshSpline_Pointer ( pointTags , uid ) RESULT ( Ans ) INTEGER ( I4B ), INTENT ( IN ) :: uid , pointTags ( : ) CLASS ( gmshSpline_ ), POINTER :: Ans ALLOCATE ( Ans ) Ans % pointTags = pointTags Ans % uid = uid Ans % dim = 1 END FUNCTION gmshSpline_Pointer","tags":"","loc":"proc/gmshspline_pointer.html"},{"title":"line_encode – Fortran Program","text":"private function line_encode(obj) result(ans) Arguments Type Intent Optional Attributes Name class( gmshLine_ ), intent(in) :: obj Return Value type(String) Contents Source Code line_encode Source Code FUNCTION line_encode ( Obj ) RESULT ( Ans ) CLASS ( gmshLine_ ), INTENT ( IN ) :: obj TYPE ( String ) :: ans ans = & & \"Line( \" // & & trim ( str ( obj % uid , no_sign = . true . ) ) // & & \" ) = { \" // & & trim ( str ( obj % startTag , no_sign = . true . ) ) // & & \", \" // & & trim ( str ( obj % endTag , no_sign = . true . ) ) // & & \" };\" END FUNCTION line_encode","tags":"","loc":"proc/line_encode.html"},{"title":"Volume_encode – Fortran Program","text":"private function Volume_encode(obj) result(ans) Arguments Type Intent Optional Attributes Name class( gmshVolume_ ), intent(in) :: obj Return Value type(String) Contents Source Code Volume_encode Source Code FUNCTION Volume_encode ( Obj ) RESULT ( Ans ) CLASS ( gmshVolume_ ), INTENT ( IN ) :: obj TYPE ( String ) :: ans ! internal variables INTEGER ( I4B ) :: ii , n TYPE ( String ), ALLOCATABLE :: s ( : ) n = SIZE ( obj % shellTags ) ALLOCATE ( s ( n ) ) DO ii = 1 , n s ( ii ) = trim ( str ( obj % shellTags ( ii ), no_sign = . true . )) END DO ans = ans % join ( s , sep = \", \" ) ans = & & \"Volume( \" // & & trim ( str ( obj % uid , no_sign = . true . ) ) // & & \" ) = { \" // & & trim ( ans ) // & & \" };\" END FUNCTION Volume_encode","tags":"","loc":"proc/volume_encode.html"},{"title":"gmshVolume_Pointer – Fortran Program","text":"public function gmshVolume_Pointer(shellTags, uid) result(Ans) Add a volume (a region) defined by one or more shells shellTags.\n The first surface loop defines the exterior boundary; additional surface\n loop define holes. If tag is positive, set the tag explicitly; otherwise a\n  new tag is selected automatically. Return the tag of the volume. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: shellTags (:) integer(kind=I4B), intent(in) :: uid Return Value class( gmshVolume_ ),\n  POINTER Contents Source Code gmshVolume_Pointer Source Code FUNCTION gmshVolume_Pointer ( shellTags , uid ) RESULT ( Ans ) INTEGER ( I4B ), INTENT ( IN ) :: shellTags ( : ) INTEGER ( I4B ), INTENT ( IN ) :: uid CLASS ( gmshVolume_ ), POINTER :: Ans ALLOCATE ( Ans ) Ans % shellTags = shellTags Ans % uid = uid Ans % dim = 3 END FUNCTION gmshVolume_Pointer","tags":"","loc":"proc/gmshvolume_pointer.html"},{"title":"PlaneSurface_encode – Fortran Program","text":"private function PlaneSurface_encode(obj) result(ans) Arguments Type Intent Optional Attributes Name class( gmshPlaneSurface_ ), intent(in) :: obj Return Value type(String) Contents Source Code PlaneSurface_encode Source Code FUNCTION PlaneSurface_encode ( Obj ) RESULT ( Ans ) CLASS ( gmshPlaneSurface_ ), INTENT ( IN ) :: obj TYPE ( String ) :: ans ! internal variables INTEGER ( I4B ) :: ii , n TYPE ( String ), ALLOCATABLE :: s ( : ) n = SIZE ( obj % wireTags ) ALLOCATE ( s ( n ) ) DO ii = 1 , n s ( ii ) = trim ( str ( obj % wireTags ( ii ), no_sign = . true . ) ) END DO ans = ans % join ( s , sep = \", \" ) ans = & & \"Plane Surface( \" // & & trim ( str ( obj % uid , no_sign = . true . ) ) // & & \" ) = { \" // & & trim ( ans ) // & & \" }; \" END FUNCTION PlaneSurface_encode","tags":"","loc":"proc/planesurface_encode.html"},{"title":"SurfaceLoop_encode – Fortran Program","text":"private function SurfaceLoop_encode(obj) result(ans) Arguments Type Intent Optional Attributes Name class( gmshSurfaceLoop_ ), intent(in) :: obj Return Value type(String) Contents Source Code SurfaceLoop_encode Source Code FUNCTION SurfaceLoop_encode ( Obj ) RESULT ( Ans ) CLASS ( gmshSurfaceLoop_ ), INTENT ( IN ) :: obj TYPE ( String ) :: ans ! internal variables INTEGER ( I4B ) :: ii , n TYPE ( String ), ALLOCATABLE :: s ( : ) n = SIZE ( obj % wireTags ) ALLOCATE ( s ( n ) ) DO ii = 1 , n s ( ii ) = trim ( str ( obj % wireTags ( ii ) )) END DO ans = ans % join ( s , sep = \", \" ) ans = & & \"Surface Loop( \" // & & trim ( str ( obj % uid , no_sign = . true . ) ) // & & \" ) = { \" // & & trim ( ans ) // & & \" }; \" END FUNCTION SurfaceLoop_encode","tags":"","loc":"proc/surfaceloop_encode.html"},{"title":"Surface_encode – Fortran Program","text":"private function Surface_encode(obj) result(ans) Arguments Type Intent Optional Attributes Name class( gmshSurface_ ), intent(in) :: obj Return Value type(String) Contents Source Code Surface_encode Source Code FUNCTION Surface_encode ( Obj ) RESULT ( Ans ) CLASS ( gmshSurface_ ), INTENT ( IN ) :: obj TYPE ( String ) :: ans ! internal variables INTEGER ( I4B ) :: ii , n TYPE ( String ), ALLOCATABLE :: s ( : ) n = SIZE ( obj % wireTags ) ALLOCATE ( s ( n ) ) DO ii = 1 , n s ( ii ) = trim ( str ( obj % wireTags ( ii ), no_sign = . true . ) ) END DO ans = ans % join ( s , sep = \", \" ) ans = & & \"Surface( \" // & & trim ( str ( obj % uid , no_sign = . true . ) ) // & & \" ) = { \" // & & trim ( ans ) // & & \" }\" IF ( obj % sphereCenterTag . LT . 0 ) THEN ans = trim ( ans ) // \";\" ELSE ans = trim ( ans ) & & // \" In Sphere \" & & // str ( obj % sphereCenterTag , no_sign = . true . ) & & // \";\" END IF END FUNCTION Surface_encode","tags":"","loc":"proc/surface_encode.html"},{"title":"gmshPlaneSurface_Pointer – Fortran Program","text":"public function gmshPlaneSurface_Pointer(wireTags, uid) result(Ans) Reference\n Creates a plane surface. The expression inside the parentheses is the plane\n surface’s tag; the expression-list on the right hand side should contain\n the tags of all the curve loops defining the surface. The first curve loop\n defines the exterior boundary of the surface; all other curve loops define\n holes in the surface. A curve loop defining a hole should not have any\n curves in common with the exterior curve loop (in which case it is not a\n hole, and the two surfaces should be defined separately). Likewise, a\n curve loop defining a hole should not have any curves in common with\n another curve loop defining a hole in the same surface (in which case the\n two curve loops should be combined). Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: wireTags (:) integer(kind=I4B), intent(in) :: uid Return Value class( gmshPlaneSurface_ ),\n  POINTER Contents Source Code gmshPlaneSurface_Pointer Source Code FUNCTION gmshPlaneSurface_Pointer ( wireTags , uid ) RESULT ( Ans ) INTEGER ( I4B ), INTENT ( IN ) :: wireTags ( : ), uid CLASS ( gmshPlaneSurface_ ), POINTER :: Ans ALLOCATE ( Ans ) Ans % wireTags = wireTags Ans % uid = uid Ans % dim = 2 END FUNCTION gmshPlaneSurface_Pointer","tags":"","loc":"proc/gmshplanesurface_pointer.html"},{"title":"gmshSurfaceLoop_Pointer – Fortran Program","text":"public function gmshSurfaceLoop_Pointer(wireTags, uid) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: wireTags (:) integer(kind=I4B), intent(in) :: uid Return Value class( gmshSurfaceLoop_ ),\n  POINTER Contents Source Code gmshSurfaceLoop_Pointer Source Code FUNCTION gmshSurfaceLoop_Pointer ( wireTags , uid ) RESULT ( Ans ) INTEGER ( I4B ), INTENT ( IN ) :: wireTags ( : ), uid CLASS ( gmshSurfaceLoop_ ), POINTER :: Ans ALLOCATE ( Ans ) Ans % wireTags = wireTags Ans % uid = uid Ans % dim = 2 END FUNCTION gmshSurfaceLoop_Pointer","tags":"","loc":"proc/gmshsurfaceloop_pointer.html"},{"title":"gmshSurface_Pointer – Fortran Program","text":"public function gmshSurface_Pointer(wireTags, uid, sphereCenterTag) result(Ans) Creates a surface filling. With the built-in kernel, the first curve\n loop should be composed of either three or four curves.\n With the built-in kernel, the optional In Sphere argument forces\n the surface to be a spherical patch (the extra parameter gives the\n tag of the center of the sphere). Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: wireTags (:) integer(kind=I4B), intent(in) :: uid integer(kind=I4B), intent(in) :: sphereCenterTag Return Value class( gmshSurface_ ),\n  POINTER Contents Source Code gmshSurface_Pointer Source Code FUNCTION gmshSurface_Pointer ( wireTags , uid , sphereCenterTag ) RESULT ( Ans ) INTEGER ( I4B ), INTENT ( IN ) :: wireTags ( : ) INTEGER ( I4B ), INTENT ( IN ) :: uid INTEGER ( I4B ), INTENT ( IN ) :: sphereCenterTag CLASS ( gmshSurface_ ), POINTER :: Ans ALLOCATE ( Ans ) Ans % wireTags = wireTags Ans % sphereCenterTag = sphereCenterTag Ans % uid = uid Ans % dim = 2 END FUNCTION gmshSurface_Pointer","tags":"","loc":"proc/gmshsurface_pointer.html"},{"title":"constructor_1 – Fortran Program","text":"private function constructor_1(x, y, z, lc, uid) result(Ans) This function gmshPoint_Pointer returns pointer to gmshPoint_ Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: x real(kind=DFP), intent(in) :: y real(kind=DFP), intent(in) :: z real(kind=DFP), intent(in) :: lc integer(kind=I4B), intent(in) :: uid Return Value class( gmshPoint_ ),\n  POINTER Contents Source Code constructor_1 Source Code FUNCTION constructor_1 ( x , y , z , lc , uid ) RESULT ( Ans ) REAL ( DFP ), INTENT ( IN ) :: x , y , z , lc INTEGER ( I4B ), INTENT ( IN ) :: uid CLASS ( gmshPoint_ ), POINTER :: Ans ALLOCATE ( Ans ) Ans % x = x Ans % y = y Ans % z = z Ans % lc = lc Ans % uid = uid Ans % dim = 0 END FUNCTION constructor_1","tags":"","loc":"proc/constructor_1.html"},{"title":"point_encode – Fortran Program","text":"private function point_encode(obj) result(ans) This function encode the information stored in gmshPoint_ in a string\n data type and return it for printing Arguments Type Intent Optional Attributes Name class( gmshPoint_ ), intent(in) :: obj Return Value type(String) Contents Source Code point_encode Source Code FUNCTION point_encode ( Obj ) RESULT ( Ans ) CLASS ( gmshPoint_ ), INTENT ( IN ) :: obj TYPE ( String ) :: ans IF ( obj % lc . GT . 0.0_DFP ) THEN ans = & & \"Point( \" // & & trim ( str ( obj % uid , no_sign = . true . ) ) // & & \" ) = { \" // & & trim ( str ( obj % x ) ) // & & \", \" // & & trim ( str ( obj % y ) ) // & & \", \" // & & trim ( str ( obj % z ) ) // & & \", \" // & & trim ( str ( obj % lc ) ) // & & \" };\" ELSE ans = & & \"Point( \" // & & trim ( str ( obj % uid , no_sign = . true . ) ) // & & \" ) = { \" // & & trim ( str ( obj % x ) ) // & & \", \" // & & trim ( str ( obj % y ) ) // & & \", \" // & & trim ( str ( obj % z ) ) // & & \" };\" END IF END FUNCTION point_encode","tags":"","loc":"proc/point_encode.html"},{"title":"gmshPoint_Pointer – Fortran Program","text":"public interface gmshPoint_Pointer Contents Module Procedures constructor_1 Module Procedures private function constructor_1 (x, y, z, lc, uid) result(Ans) This function gmshPoint_Pointer returns pointer to gmshPoint_ Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: x real(kind=DFP), intent(in) :: y real(kind=DFP), intent(in) :: z real(kind=DFP), intent(in) :: lc integer(kind=I4B), intent(in) :: uid Return Value class( gmshPoint_ ),\n  POINTER","tags":"","loc":"interface/gmshpoint_pointer.html"},{"title":"geoMesh_setAlgorithm – Fortran Program","text":"private function geoMesh_setAlgorithm(Obj, dim, tag, val) result(Ans) Set the meshing algorithm on the model entity of dimension dim and tag tag.\n Currently only supported for dim == 2. Arguments Type Intent Optional Attributes Name class( gmshGeoMesh_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: dim integer(kind=I4B), intent(in) :: tag integer(kind=I4B), intent(in) :: val Return Value integer(kind=I4B) Contents Source Code geoMesh_setAlgorithm Source Code FUNCTION geoMesh_setAlgorithm ( Obj , dim , tag , val ) RESULT ( Ans ) CLASS ( gmshGeoMesh_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: dim INTEGER ( I4B ), INTENT ( IN ) :: tag INTEGER ( I4B ), INTENT ( IN ) :: val INTEGER ( I4B ) :: Ans END FUNCTION geoMesh_setAlgorithm","tags":"","loc":"proc/geomesh_setalgorithm.html"},{"title":"geoMesh_setRecombine – Fortran Program","text":"private function geoMesh_setRecombine(Obj, dim, tag, angle) result(Ans) Set a recombination meshing constraint on the model entity of dimension\n dim and tag tag. Currently only entities of dimension 2\n (to recombine triangles into quadrangles) are supporte Arguments Type Intent Optional Attributes Name class( gmshGeoMesh_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: dim integer(kind=I4B), intent(in) :: tag real(kind=DFP), intent(in), optional :: angle Return Value integer(kind=I4B) Contents Source Code geoMesh_setRecombine Source Code FUNCTION geoMesh_setRecombine ( Obj , dim , tag , angle ) RESULT ( Ans ) CLASS ( gmshGeoMesh_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: dim INTEGER ( I4B ), INTENT ( IN ) :: tag REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: angle INTEGER ( I4B ) :: Ans END FUNCTION geoMesh_setRecombine","tags":"","loc":"proc/geomesh_setrecombine.html"},{"title":"geoMesh_setReverse – Fortran Program","text":"private function geoMesh_setReverse(Obj, dim, tag, val) result(Ans) Set a smoothing meshing constraint on the model entity of dimension dim\n and tag tag. val iterations of a Laplace smoother are applied. Arguments Type Intent Optional Attributes Name class( gmshGeoMesh_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: dim integer(kind=I4B), intent(in) :: tag logical(kind=LGT), intent(in) :: val Return Value integer(kind=I4B) Contents Source Code geoMesh_setReverse Source Code FUNCTION geoMesh_setReverse ( Obj , dim , tag , val ) RESULT ( Ans ) CLASS ( gmshGeoMesh_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: dim INTEGER ( I4B ), INTENT ( IN ) :: tag LOGICAL ( LGT ), INTENT ( IN ) :: val INTEGER ( I4B ) :: Ans END FUNCTION geoMesh_setReverse","tags":"","loc":"proc/geomesh_setreverse.html"},{"title":"geoMesh_setSize – Fortran Program","text":"private function geoMesh_setSize(Obj, dim, tags, meshsize) result(Ans) Set a mesh size constraint on the model entities dimTags. Currently only\n entities of dimension 0 (points) are handled. Arguments Type Intent Optional Attributes Name class( gmshGeoMesh_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: dim integer(kind=I4B), intent(in) :: tags (:) real(kind=DFP), intent(in) :: meshsize Return Value integer(kind=I4B) Contents Source Code geoMesh_setSize Source Code FUNCTION geoMesh_setSize ( Obj , dim , tags , meshsize ) RESULT ( Ans ) CLASS ( gmshGeoMesh_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: dim INTEGER ( I4B ), INTENT ( IN ) :: tags ( : ) REAL ( DFP ), INTENT ( IN ) :: meshsize INTEGER ( I4B ) :: Ans ! internal variables INTEGER ( I4B ) :: ii , n TYPE ( String ), ALLOCATABLE :: s ( : ) TYPE ( String ) :: ss IF ( dim . NE . 0 ) THEN CALL Display ( \"ERROR:: gmshGeoMesh_Class.f90\" ) CALL Display ( \"          geoMesh_setSize()\" ) CALL Display ( \"          only dim = 0, supported currently\" ) END IF CALL Display ( \"      gmsh%model%geo%mesh%setSize()\" ) Ans = 0 n = SIZE ( tags ) ALLOCATE ( s ( n ) ) DO ii = 1 , n s ( ii ) = trim ( str ( tags ( ii ), no_sign = . true . ) ) END DO ss = ss % join ( s , sep = \", \" ) ss = & & \"Characteristic Length { \" // & & trim ( ss ) // & & \" } =  \" // & & trim ( str ( meshsize ) ) // & & \" ;\" IF ( . NOT . ASSOCIATED ( Obj % buffer ) ) THEN ALLOCATE ( Obj % buffer ) END IF CALL APPEND ( Obj % buffer , ss ) DEALLOCATE ( s ) END FUNCTION geoMesh_setSize","tags":"","loc":"proc/geomesh_setsize.html"},{"title":"geoMesh_setSizeFromBoundary – Fortran Program","text":"private function geoMesh_setSizeFromBoundary(Obj, dim, tag, val) result(Ans) Force the mesh size to be extended from the boundary, or not, for the model\n entity of dimension dim and tag tag. Currently only supported for dim == 2. Arguments Type Intent Optional Attributes Name class( gmshGeoMesh_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: dim integer(kind=I4B), intent(in) :: tag integer(kind=I4B), intent(in) :: val Return Value integer(kind=I4B) Contents Source Code geoMesh_setSizeFromBoundary Source Code FUNCTION geoMesh_setSizeFromBoundary ( Obj , dim , tag , val ) RESULT ( Ans ) CLASS ( gmshGeoMesh_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: dim INTEGER ( I4B ), INTENT ( IN ) :: tag INTEGER ( I4B ), INTENT ( IN ) :: val INTEGER ( I4B ) :: Ans END FUNCTION geoMesh_setSizeFromBoundary","tags":"","loc":"proc/geomesh_setsizefromboundary.html"},{"title":"geoMesh_setSmoothing – Fortran Program","text":"private function geoMesh_setSmoothing(Obj, dim, tag, val) result(Ans) Set a smoothing meshing constraint on the model entity of dimension dim\n and tag tag. val iterations of a Laplace smoother are applied. Arguments Type Intent Optional Attributes Name class( gmshGeoMesh_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: dim integer(kind=I4B), intent(in) :: tag integer(kind=I4B), intent(in), optional :: val Return Value integer(kind=I4B) Contents Source Code geoMesh_setSmoothing Source Code FUNCTION geoMesh_setSmoothing ( Obj , dim , tag , val ) RESULT ( Ans ) CLASS ( gmshGeoMesh_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: dim INTEGER ( I4B ), INTENT ( IN ) :: tag INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: val INTEGER ( I4B ) :: Ans END FUNCTION geoMesh_setSmoothing","tags":"","loc":"proc/geomesh_setsmoothing.html"},{"title":"geoMesh_setTransfiniteCurve – Fortran Program","text":"private function geoMesh_setTransfiniteCurve(Obj, tag, nPoints, meshType, coef) result(Ans) Set a transfinite meshing constraint on the curve tag, with numNodes nodes\n distributed according to meshType and coef. Currently supported types\n are “Progres- sion” (geometrical progression with power coef) and “Bump”\n (refinement toward both extremities of the curve). Arguments Type Intent Optional Attributes Name class( gmshGeoMesh_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: tag integer(kind=I4B), intent(in) :: nPoints character(len=*), intent(in) :: meshType integer(kind=I4B), intent(in), optional :: coef Return Value integer(kind=I4B) Contents Source Code geoMesh_setTransfiniteCurve Source Code FUNCTION geoMesh_setTransfiniteCurve ( Obj , tag , nPoints , meshType , & & coef ) RESULT ( Ans ) CLASS ( gmshGeoMesh_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: tag INTEGER ( I4B ), INTENT ( IN ) :: nPoints CHARACTER ( LEN = * ), INTENT ( IN ) :: meshType INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: coef INTEGER ( I4B ) :: Ans END FUNCTION geoMesh_setTransfiniteCurve","tags":"","loc":"proc/geomesh_settransfinitecurve.html"},{"title":"geoMesh_setTransfiniteSurface – Fortran Program","text":"private function geoMesh_setTransfiniteSurface(Obj, tag, arrangement, cornerTags) result(Ans) Set a transfinite meshing constraint on the surface tag. arrangement\n describes the arrangement of the triangles when the surface is not\n flagged as recombined: cur- rently supported values are “Left”, “Right”,\n “AlternateLeft” and “AlternateRight”. cornerTags can be used to specify\n the (3 or 4) corners of the transfinite interpola- tion explicitly;\n specifying the corners explicitly is mandatory if the surface has more\n that 3 or 4 points on its boundary. Arguments Type Intent Optional Attributes Name class( gmshGeoMesh_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: tag character(len=*), intent(in) :: arrangement integer(kind=I4B), intent(in) :: cornerTags (:) Return Value integer(kind=I4B) Contents Source Code geoMesh_setTransfiniteSurface Source Code FUNCTION geoMesh_setTransfiniteSurface ( Obj , tag , arrangement , & & cornerTags ) RESULT ( Ans ) CLASS ( gmshGeoMesh_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: tag CHARACTER ( LEN = * ), INTENT ( IN ) :: arrangement INTEGER ( I4B ), INTENT ( IN ) :: cornerTags ( : ) INTEGER ( I4B ) :: Ans END FUNCTION geoMesh_setTransfiniteSurface","tags":"","loc":"proc/geomesh_settransfinitesurface.html"},{"title":"geoMesh_setTransfiniteVolume – Fortran Program","text":"private function geoMesh_setTransfiniteVolume(Obj, tag, cornerTags) result(Ans) Set a transfinite meshing constraint on the surface tag. arrangement\n describes the arrangement of the triangles when the surface is not\n flagged as recombined: cur- rently supported values are “Left”, “Right”,\n “AlternateLeft” and “AlternateRight”. cornerTags can be used to specify\n the (3 or 4) corners of the transfinite interpola- tion explicitly;\n specifying the corners explicitly is mandatory if the surface has more\n that 3 or 4 points on its boundary. Arguments Type Intent Optional Attributes Name class( gmshGeoMesh_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: tag integer(kind=I4B), intent(in), optional :: cornerTags (:) Return Value integer(kind=I4B) Contents Source Code geoMesh_setTransfiniteVolume Source Code FUNCTION geoMesh_setTransfiniteVolume ( Obj , tag , & & cornerTags ) RESULT ( Ans ) CLASS ( gmshGeoMesh_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: tag INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: cornerTags ( : ) INTEGER ( I4B ) :: Ans END FUNCTION geoMesh_setTransfiniteVolume","tags":"","loc":"proc/geomesh_settransfinitevolume.html"},{"title":"geoMesh_write – Fortran Program","text":"private function geoMesh_write(Obj, UnitNo) result(Ans) Arguments Type Intent Optional Attributes Name class( gmshGeoMesh_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: UnitNo Return Value integer(kind=I4B) Contents Source Code geoMesh_write Source Code FUNCTION geoMesh_write ( Obj , UnitNo ) RESULT ( Ans ) CLASS ( gmshGeoMesh_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: UnitNo INTEGER ( I4B ) :: Ans INTEGER ( I4B ) :: ii IF ( ASSOCIATED ( Obj % buffer ) ) THEN DO ii = 1 , Obj % buffer % tLine WRITE ( UnitNo , \"(DT)\" ) Obj % buffer % Line ( ii ) % Ptr END DO END IF END FUNCTION geoMesh_write","tags":"","loc":"proc/geomesh_write.html"},{"title":"geo_add_BSpline – Fortran Program","text":"private function geo_add_BSpline(Obj, pointTags, uid) result(ans) Arguments Type Intent Optional Attributes Name class( gmshGeo_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: pointTags (:) integer(kind=I4B), intent(in) :: uid Return Value integer(kind=I4B) Contents Source Code geo_add_BSpline Source Code FUNCTION geo_add_BSpline ( Obj , pointTags , uid ) RESULT ( Ans ) CLASS ( gmshGeo_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: pointTags ( : ), uid INTEGER ( I4B ) :: ans ! Internal variables INTEGER ( I4B ) :: ip , n ! check IF ( . NOT . ALLOCATED ( obj % point ) ) THEN CALL Display ( \"ERROR: gmshGeo_Class.f90\" ) CALL Display ( \"       geo_add_BSpline()\" ) CALL Display ( \"       points are not allocated\" ) STOP END IF #include \"./addcurve.inc\" IF ( uid . GT . 0 ) THEN obj % curve ( ip ) % ptr => gmshBSpline_Pointer ( pointTags , uid ) Ans = 0 ELSE obj % curve ( ip ) % ptr => gmshBSpline_Pointer ( pointTags , ip ) Ans = ip END IF ! append to buffer ! WRITE( obj % buffer % unitno, \"(DT)\" ) obj%curve(ip)%ptr%encodedStr( ) ! CALL Display( \"    adding BSpline in gmsh%model%geo%buffer\") CALL APPEND ( obj % buffer , obj % curve ( ip )% ptr % encodedStr ( ) ) END FUNCTION geo_add_BSpline","tags":"","loc":"proc/geo_add_bspline.html"},{"title":"geo_add_Bezier – Fortran Program","text":"private function geo_add_Bezier(Obj, pointTags, uid) result(ans) Arguments Type Intent Optional Attributes Name class( gmshGeo_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: pointTags (:) integer(kind=I4B), intent(in) :: uid Return Value integer(kind=I4B) Contents Source Code geo_add_Bezier Source Code FUNCTION geo_add_Bezier ( Obj , pointTags , uid ) RESULT ( Ans ) CLASS ( gmshGeo_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: pointTags ( : ), uid INTEGER ( I4B ) :: ans ! Internal variables INTEGER ( I4B ) :: ip , n ! check IF ( . NOT . ALLOCATED ( obj % point ) ) THEN CALL Display ( \"ERROR: gmshGeo_Class.f90\" ) CALL Display ( \"       geo_add_Bezier()\" ) CALL Display ( \"       points are not allocated\" ) STOP END IF #include \"./addcurve.inc\" IF ( uid . GT . 0 ) THEN obj % curve ( ip ) % ptr => gmshBezier_Pointer ( pointTags , uid ) Ans = 0 ELSE obj % curve ( ip ) % ptr => gmshBezier_Pointer ( pointTags , ip ) Ans = ip END IF ! append to buffer ! WRITE( obj % buffer % unitno, \"(DT)\" ) obj%curve(ip)%ptr%encodedStr( ) ! CALL Display( \"    adding Bezier in gmsh%model%geo%buffer\") CALL APPEND ( obj % buffer , obj % curve ( ip )% ptr % encodedStr ( ) ) END FUNCTION geo_add_Bezier","tags":"","loc":"proc/geo_add_bezier.html"},{"title":"geo_add_CompoundBSpline – Fortran Program","text":"private function geo_add_CompoundBSpline(Obj, curveTags, uid, numIntervals) result(ans) Arguments Type Intent Optional Attributes Name class( gmshGeo_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: curveTags (:) integer(kind=I4B), intent(in) :: uid integer(kind=I4B), optional :: numIntervals Return Value integer(kind=I4B) Contents Source Code geo_add_CompoundBSpline Source Code FUNCTION geo_add_CompoundBSpline ( Obj , curveTags , uid , numIntervals ) & & RESULT ( Ans ) CLASS ( gmshGeo_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: curveTags ( : ), uid INTEGER ( I4B ), OPTIONAL :: numIntervals INTEGER ( I4B ) :: ans ! Internal variables INTEGER ( I4B ) :: ip , n , nI IF ( PRESENT ( numIntervals ) ) THEN nI = numIntervals ELSE nI = 5 END IF ! check IF ( . NOT . ALLOCATED ( obj % point ) ) THEN CALL Display ( \"ERROR: gmshGeo_Class.f90\" ) CALL Display ( \"       geo_add_CompoundBSpline()\" ) CALL Display ( \"       points are not allocated\" ) STOP END IF #include \"./addcurve.inc\" IF ( uid . GT . 0 ) THEN obj % curve ( ip ) % ptr => gmshCompoundBSpline_Pointer ( curveTags , & & uid , nI ) Ans = 0 ELSE obj % curve ( ip ) % ptr => gmshCompoundBSpline_Pointer ( curveTags , & & ip , nI ) Ans = ip END IF ! append to buffer ! WRITE( obj % buffer % unitno, \"(DT)\" ) obj%curve(ip)%ptr%encodedStr( ) ! CALL Display( \"    adding CompoundBSpline in gmsh%model%geo%buffer\") CALL APPEND ( obj % buffer , obj % curve ( ip )% ptr % encodedStr ( ) ) END FUNCTION geo_add_CompoundBSpline","tags":"","loc":"proc/geo_add_compoundbspline.html"},{"title":"geo_add_CompoundSpline – Fortran Program","text":"private function geo_add_CompoundSpline(Obj, curveTags, uid, numIntervals) result(ans) Arguments Type Intent Optional Attributes Name class( gmshGeo_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: curveTags (:) integer(kind=I4B), intent(in) :: uid integer(kind=I4B), optional :: numIntervals Return Value integer(kind=I4B) Contents Source Code geo_add_CompoundSpline Source Code FUNCTION geo_add_CompoundSpline ( Obj , curveTags , uid , numIntervals ) & & RESULT ( Ans ) CLASS ( gmshGeo_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: curveTags ( : ), uid INTEGER ( I4B ), OPTIONAL :: numIntervals INTEGER ( I4B ) :: ans ! Internal variables INTEGER ( I4B ) :: ip , n , nI IF ( PRESENT ( numIntervals ) ) THEN nI = numIntervals ELSE nI = 5 END IF ! check IF ( . NOT . ALLOCATED ( obj % point ) ) THEN CALL Display ( \"ERROR: gmshGeo_Class.f90\" ) CALL Display ( \"       geo_add_CompoundSpline()\" ) CALL Display ( \"       points are not allocated\" ) STOP END IF #include \"./addcurve.inc\" IF ( uid . GT . 0 ) THEN obj % curve ( ip ) % ptr => gmshCompoundSpline_Pointer ( curveTags , & & uid , nI ) Ans = 0 ELSE obj % curve ( ip ) % ptr => gmshCompoundSpline_Pointer ( curveTags , & & ip , nI ) Ans = ip END IF ! append to buffer ! WRITE( obj % buffer % unitno, \"(DT)\" ) obj%curve(ip)%ptr%encodedStr( ) ! CALL Display( \"    adding CompoundSpline in gmsh%model%geo%buffer\") CALL APPEND ( obj % buffer , obj % curve ( ip )% ptr % encodedStr ( ) ) END FUNCTION geo_add_CompoundSpline","tags":"","loc":"proc/geo_add_compoundspline.html"},{"title":"geo_add_CurveLoop – Fortran Program","text":"private function geo_add_CurveLoop(Obj, curveTags, uid) result(ans) Arguments Type Intent Optional Attributes Name class( gmshGeo_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: curveTags (:) integer(kind=I4B), intent(in) :: uid Return Value integer(kind=I4B) Contents Source Code geo_add_CurveLoop Source Code FUNCTION geo_add_CurveLoop ( Obj , curveTags , uid ) & & RESULT ( Ans ) CLASS ( gmshGeo_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: curveTags ( : ), uid INTEGER ( I4B ) :: ans ! Internal variables INTEGER ( I4B ) :: ip , n ! check IF ( . NOT . ALLOCATED ( obj % point ) ) THEN CALL Display ( \"ERROR: gmshGeo_Class.f90\" ) CALL Display ( \"       geo_add_CurveLoop()\" ) CALL Display ( \"       points are not allocated\" ) STOP END IF ! check IF ( . NOT . ALLOCATED ( obj % curve ) ) THEN CALL Display ( \"ERROR: gmshGeo_Class.f90\" ) CALL Display ( \"       geo_add_CurveLoop()\" ) CALL Display ( \"       curve are not allocated\" ) STOP END IF #include \"./addcurveloop.inc\" IF ( uid . GT . 0 ) THEN obj % curveloop ( ip ) % ptr => gmshCurveLoop_Pointer ( curveTags , uid ) Ans = 0 ELSE obj % curveloop ( ip ) % ptr => gmshCurveLoop_Pointer ( curveTags , ip ) Ans = ip END IF ! append to buffer ! WRITE( obj % buffer % unitno, \"(DT)\" ) obj%CurveLoop(ip)%ptr%encodedStr( ) ! CALL Display( \"    adding Curveloop in gmsh%model%geo%buffer\") CALL APPEND ( obj % buffer , obj % CurveLoop ( ip )% ptr % encodedStr ( ) ) END FUNCTION geo_add_CurveLoop","tags":"","loc":"proc/geo_add_curveloop.html"},{"title":"geo_add_Ellipse – Fortran Program","text":"private function geo_add_Ellipse(Obj, startTag, centerTag, majorTag, endTag, uid, nx, ny, nz) result(ans) Arguments Type Intent Optional Attributes Name class( gmshGeo_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: startTag integer(kind=I4B), intent(in) :: centerTag integer(kind=I4B), intent(in) :: majorTag integer(kind=I4B), intent(in) :: endTag integer(kind=I4B), intent(in) :: uid real(kind=DFP), optional :: nx real(kind=DFP), optional :: ny real(kind=DFP), optional :: nz Return Value integer(kind=I4B) Contents Source Code geo_add_Ellipse Source Code FUNCTION geo_add_Ellipse ( Obj , startTag , centerTag , majorTag , endTag , uid , & & nx , ny , nz ) RESULT ( Ans ) CLASS ( gmshGeo_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: startTag , endTag , centerTag , majorTag , uid REAL ( DFP ), OPTIONAL :: nx , ny , nz INTEGER ( I4B ) :: ans ! Internal variables INTEGER ( I4B ) :: ip , n REAL ( DFP ) :: rval ( 3 ) ! check IF ( . NOT . ALLOCATED ( obj % point ) ) THEN CALL Display ( \"ERROR: gmshGeo_Class.f90\" ) CALL Display ( \"       geo_add_Ellipse()\" ) CALL Display ( \"       points are not allocated\" ) STOP END IF #include \"./addcurve.inc\" rval = 0.0 IF ( PRESENT ( nx ) ) rval ( 1 ) = nx IF ( PRESENT ( ny ) ) rval ( 2 ) = ny IF ( PRESENT ( ny ) ) rval ( 3 ) = nz IF ( uid . GT . 0 ) THEN obj % curve ( ip ) % ptr => gmshEllipse_Pointer ( startTag , & & centerTag , majorTag , endTag , uid , rval ( 1 ), rval ( 2 ), rval ( 3 ) ) Ans = 0 ELSE obj % curve ( ip ) % ptr => gmshEllipse_Pointer ( startTag , & & centerTag , majorTag , endTag , ip , rval ( 1 ), rval ( 2 ), rval ( 3 ) ) Ans = ip END IF ! append to buffer ! CALL Display( \"    adding Ellipse in gmsh%model%geo%buffer\") CALL APPEND ( obj % buffer , obj % curve ( ip )% ptr % encodedStr ( ) ) END FUNCTION geo_add_Ellipse","tags":"","loc":"proc/geo_add_ellipse.html"},{"title":"geo_add_PlaneSurface – Fortran Program","text":"private function geo_add_PlaneSurface(Obj, wireTags, uid) result(ans) Arguments Type Intent Optional Attributes Name class( gmshGeo_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: wireTags (:) integer(kind=I4B), intent(in) :: uid Return Value integer(kind=I4B) Contents Source Code geo_add_PlaneSurface Source Code FUNCTION geo_add_PlaneSurface ( Obj , wireTags , uid ) & & RESULT ( Ans ) CLASS ( gmshGeo_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: wireTags ( : ), uid INTEGER ( I4B ) :: ans ! Internal variables INTEGER ( I4B ) :: ip , n ! check IF ( . NOT . ALLOCATED ( obj % point ) ) THEN CALL Display ( \"ERROR: gmshGeo_Class.f90\" ) CALL Display ( \"       geo_add_PlaneSurface()\" ) CALL Display ( \"       points are not allocated\" ) STOP END IF ! check IF ( . NOT . ALLOCATED ( obj % curve ) ) THEN CALL Display ( \"ERROR: gmshGeo_Class.f90\" ) CALL Display ( \"       geo_add_PlaneSurface()\" ) CALL Display ( \"       curve are not allocated\" ) STOP END IF ! check IF ( . NOT . ALLOCATED ( obj % CurveLoop ) ) THEN CALL Display ( \"ERROR: gmshGeo_Class.f90\" ) CALL Display ( \"       geo_add_PlaneSurface()\" ) CALL Display ( \"       CurveLoop are not allocated\" ) STOP END IF #include \"./addsurface.inc\" IF ( uid . GT . 0 ) THEN obj % surface ( ip ) % ptr => gmshPlaneSurface_Pointer ( wireTags , uid ) Ans = 0 ELSE obj % surface ( ip ) % ptr => gmshPlaneSurface_Pointer ( wireTags , ip ) Ans = ip END IF ! append to buffer ! WRITE( obj % buffer % unitno, \"(DT)\" ) obj%surface(ip)%ptr%encodedStr( ) ! CALL Display( \"    adding PlaneSurface in gmsh%model%geo%buffer\") CALL APPEND ( obj % buffer , obj % surface ( ip )% ptr % encodedStr ( ) ) END FUNCTION geo_add_PlaneSurface","tags":"","loc":"proc/geo_add_planesurface.html"},{"title":"geo_add_Spline – Fortran Program","text":"private function geo_add_Spline(Obj, pointTags, uid) result(ans) Arguments Type Intent Optional Attributes Name class( gmshGeo_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: pointTags (:) integer(kind=I4B), intent(in) :: uid Return Value integer(kind=I4B) Contents Source Code geo_add_Spline Source Code FUNCTION geo_add_Spline ( Obj , pointTags , uid ) RESULT ( Ans ) CLASS ( gmshGeo_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: pointTags ( : ), uid INTEGER ( I4B ) :: ans ! Internal variables INTEGER ( I4B ) :: ip , n ! check IF ( . NOT . ALLOCATED ( obj % point ) ) THEN CALL Display ( \"ERROR: gmshGeo_Class.f90\" ) CALL Display ( \"       geo_add_Spline()\" ) CALL Display ( \"       points are not allocated\" ) STOP END IF #include \"./addcurve.inc\" IF ( uid . GT . 0 ) THEN obj % curve ( ip ) % ptr => gmshSpline_Pointer ( pointTags , uid ) Ans = 0 ELSE obj % curve ( ip ) % ptr => gmshSpline_Pointer ( pointTags , ip ) Ans = ip END IF ! append to buffer ! WRITE( obj % buffer % unitno, \"(DT)\" ) obj%curve(ip)%ptr%encodedStr( ) ! CALL Display( \"    adding Spline in gmsh%model%geo%buffer\") CALL APPEND ( obj % buffer , obj % curve ( ip )% ptr % encodedStr ( ) ) END FUNCTION geo_add_Spline","tags":"","loc":"proc/geo_add_spline.html"},{"title":"geo_add_SurfaceFilling – Fortran Program","text":"private function geo_add_SurfaceFilling(Obj, wireTags, uid, sphereCenterTag) result(ans) Add a surface filling the curve loops in wireTags.\n Currently only a single curve loop is supported; this curve loop should be\n composed by 3 or 4 curves only. If tag is positive, set the tag explicitly;\n otherwise a new tag is selected automatically. Return the tag of the surface. Arguments Type Intent Optional Attributes Name class( gmshGeo_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: wireTags (:) integer(kind=I4B), intent(in) :: uid integer(kind=I4B), intent(in), optional :: sphereCenterTag Return Value integer(kind=I4B) Contents Source Code geo_add_SurfaceFilling Source Code FUNCTION geo_add_SurfaceFilling ( Obj , wireTags , uid , sphereCenterTag ) & & RESULT ( Ans ) CLASS ( gmshGeo_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: wireTags ( : ), uid INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: sphereCenterTag INTEGER ( I4B ) :: ans ! Internal variables INTEGER ( I4B ) :: ip , n , sct IF ( PRESENT ( sphereCenterTag ) ) THEN sct = sphereCenterTag ELSE sct = - 1 END IF ! check IF ( . NOT . ALLOCATED ( obj % point ) ) THEN CALL Display ( \"ERROR: gmshGeo_Class.f90\" ) CALL Display ( \"       geo_add_SurfaceFilling()\" ) CALL Display ( \"       points are not allocated\" ) STOP END IF ! check IF ( . NOT . ALLOCATED ( obj % curve ) ) THEN CALL Display ( \"ERROR: gmshGeo_Class.f90\" ) CALL Display ( \"       geo_add_SurfaceFilling()\" ) CALL Display ( \"       curve are not allocated\" ) STOP END IF ! check IF ( . NOT . ALLOCATED ( obj % CurveLoop ) ) THEN CALL Display ( \"ERROR: gmshGeo_Class.f90\" ) CALL Display ( \"       geo_add_SurfaceFilling()\" ) CALL Display ( \"       CurveLoop are not allocated\" ) STOP END IF #include \"./addsurface.inc\" IF ( uid . GT . 0 ) THEN obj % surface ( ip ) % ptr => gmshSurface_Pointer ( wireTags , uid , sct ) Ans = 0 ELSE obj % surface ( ip ) % ptr => gmshSurface_Pointer ( wireTags , ip , sct ) Ans = ip END IF ! append to buffer ! WRITE( obj % buffer % unitno, \"(DT)\" ) obj%surface(ip)%ptr%encodedStr( ) ! CALL Display( \"    adding Surface in gmsh%model%geo%buffer\") CALL APPEND ( obj % buffer , obj % surface ( ip )% ptr % encodedStr ( ) ) END FUNCTION geo_add_SurfaceFilling","tags":"","loc":"proc/geo_add_surfacefilling.html"},{"title":"geo_add_SurfaceLoop – Fortran Program","text":"private function geo_add_SurfaceLoop(Obj, surfaceTags, uid) result(ans) Arguments Type Intent Optional Attributes Name class( gmshGeo_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: surfaceTags (:) integer(kind=I4B), intent(in) :: uid Return Value integer(kind=I4B) Contents Source Code geo_add_SurfaceLoop Source Code FUNCTION geo_add_SurfaceLoop ( Obj , surfaceTags , uid ) & & RESULT ( Ans ) CLASS ( gmshGeo_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: surfaceTags ( : ), uid INTEGER ( I4B ) :: ans ! Internal variables INTEGER ( I4B ) :: ip , n ! check IF ( . NOT . ALLOCATED ( obj % point ) ) THEN CALL Display ( \"ERROR: gmshGeo_Class.f90\" ) CALL Display ( \"       geo_add_SurfaceLoop()\" ) CALL Display ( \"       points are not allocated\" ) STOP END IF ! check IF ( . NOT . ALLOCATED ( obj % curve ) ) THEN CALL Display ( \"ERROR: gmshGeo_Class.f90\" ) CALL Display ( \"       geo_add_SurfaceLoop()\" ) CALL Display ( \"       curve are not allocated\" ) STOP END IF ! check IF ( . NOT . ALLOCATED ( obj % surface ) ) THEN CALL Display ( \"ERROR: gmshGeo_Class.f90\" ) CALL Display ( \"       geo_add_SurfaceLoop()\" ) CALL Display ( \"       surfaces are not allocated\" ) STOP END IF #include \"./addsurfaceloop.inc\" IF ( uid . GT . 0 ) THEN obj % Surfaceloop ( ip ) % ptr => gmshSurfaceLoop_Pointer ( surfaceTags , uid ) Ans = 0 ELSE obj % Surfaceloop ( ip ) % ptr => gmshSurfaceLoop_Pointer ( surfaceTags , ip ) Ans = ip END IF ! append to buffer ! WRITE( obj % buffer % unitno, \"(DT)\" ) obj%SurfaceLoop(ip)%ptr%encodedStr( ) ! CALL Display( \"    adding SurfaceLoop in gmsh%model%geo%buffer\") CALL APPEND ( obj % buffer , obj % SurfaceLoop ( ip )% ptr % encodedStr ( ) ) END FUNCTION geo_add_SurfaceLoop","tags":"","loc":"proc/geo_add_surfaceloop.html"},{"title":"geo_add_Volume – Fortran Program","text":"private function geo_add_Volume(Obj, shellTags, uid) result(ans) Arguments Type Intent Optional Attributes Name class( gmshGeo_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: shellTags (:) integer(kind=I4B), intent(in) :: uid Return Value integer(kind=I4B) Contents Source Code geo_add_Volume Source Code FUNCTION geo_add_Volume ( Obj , shellTags , uid ) & & RESULT ( Ans ) CLASS ( gmshGeo_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: shellTags ( : ), uid INTEGER ( I4B ) :: ans ! Internal variables INTEGER ( I4B ) :: ip , n ! check IF ( . NOT . ALLOCATED ( obj % point ) ) THEN CALL Display ( \"ERROR: gmshGeo_Class.f90\" ) CALL Display ( \"       geo_add_Volume()\" ) CALL Display ( \"       points are not allocated\" ) STOP END IF ! check IF ( . NOT . ALLOCATED ( obj % curve ) ) THEN CALL Display ( \"ERROR: gmshGeo_Class.f90\" ) CALL Display ( \"       geo_add_Volume()\" ) CALL Display ( \"       curve are not allocated\" ) STOP END IF ! check IF ( . NOT . ALLOCATED ( obj % surface ) ) THEN CALL Display ( \"ERROR: gmshGeo_Class.f90\" ) CALL Display ( \"       geo_add_Volume()\" ) CALL Display ( \"       surfaces are not allocated\" ) STOP END IF ! check IF ( . NOT . ALLOCATED ( obj % Surfaceloop ) ) THEN CALL Display ( \"ERROR: gmshGeo_Class.f90\" ) CALL Display ( \"       geo_add_Volume()\" ) CALL Display ( \"       surfaceLoop are not allocated\" ) STOP END IF #include \"./addvolume.inc\" IF ( uid . GT . 0 ) THEN obj % Volume ( ip ) % ptr => gmshVolume_Pointer ( shellTags , uid ) Ans = 0 ELSE obj % Volume ( ip ) % ptr => gmshVolume_Pointer ( shellTags , ip ) Ans = ip END IF ! append to buffer ! CALL Display( \"    adding Volume in gmsh%model%geo%buffer\") CALL APPEND ( obj % buffer , obj % Volume ( ip )% ptr % encodedStr ( ) ) END FUNCTION geo_add_Volume","tags":"","loc":"proc/geo_add_volume.html"},{"title":"geo_add_circle – Fortran Program","text":"private function geo_add_circle(Obj, startTag, centerTag, endTag, uid, nx, ny, nz) result(ans) Arguments Type Intent Optional Attributes Name class( gmshGeo_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: startTag integer(kind=I4B), intent(in) :: centerTag integer(kind=I4B), intent(in) :: endTag integer(kind=I4B), intent(in) :: uid real(kind=DFP), optional :: nx real(kind=DFP), optional :: ny real(kind=DFP), optional :: nz Return Value integer(kind=I4B) Contents Source Code geo_add_circle Source Code FUNCTION geo_add_circle ( Obj , startTag , centerTag , endTag , uid , & & nx , ny , nz ) RESULT ( Ans ) CLASS ( gmshGeo_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: startTag , endTag , centerTag , uid REAL ( DFP ), OPTIONAL :: nx , ny , nz INTEGER ( I4B ) :: ans ! Internal variables INTEGER ( I4B ) :: ip , n REAL ( DFP ) :: rval ( 3 ) ! check IF ( . NOT . ALLOCATED ( obj % point ) ) THEN CALL Display ( \"ERROR: gmshGeo_Class.f90\" ) CALL Display ( \"       geo_add_line()\" ) CALL Display ( \"       points are not allocated\" ) STOP END IF #include \"./addcurve.inc\" rval = 0.0 IF ( PRESENT ( nx ) ) rval ( 1 ) = nx IF ( PRESENT ( ny ) ) rval ( 2 ) = ny IF ( PRESENT ( ny ) ) rval ( 3 ) = nz IF ( uid . GT . 0 ) THEN obj % curve ( ip ) % ptr => gmshCircle_Pointer ( startTag , & & centerTag , endTag , uid , rval ( 1 ), rval ( 2 ), rval ( 3 ) ) Ans = 0 ELSE obj % curve ( ip ) % ptr => gmshCircle_Pointer ( startTag , & & centerTag , endTag , ip , rval ( 1 ), rval ( 2 ), rval ( 3 ) ) Ans = ip END IF ! append to buffer ! CALL Display( \"    adding Circle in gmsh%model%geo%buffer\") CALL APPEND ( obj % buffer , obj % curve ( ip )% ptr % encodedStr ( ) ) END FUNCTION geo_add_circle","tags":"","loc":"proc/geo_add_circle.html"},{"title":"geo_add_line – Fortran Program","text":"private function geo_add_line(Obj, startTag, endTag, uid) result(ans) Arguments Type Intent Optional Attributes Name class( gmshGeo_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: startTag integer(kind=I4B), intent(in) :: endTag integer(kind=I4B), intent(in) :: uid Return Value integer(kind=I4B) Contents Source Code geo_add_line Source Code FUNCTION geo_add_line ( Obj , startTag , endTag , uid ) RESULT ( Ans ) CLASS ( gmshGeo_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: startTag , endTag , uid INTEGER ( I4B ) :: ans ! Internal variables INTEGER ( I4B ) :: ip , n ! check IF ( . NOT . ALLOCATED ( obj % point ) ) THEN CALL Display ( \"ERROR: gmshGeo_Class.f90\" ) CALL Display ( \"       geo_add_line()\" ) CALL Display ( \"       points are not allocated\" ) STOP END IF #include \"./addcurve.inc\" IF ( uid . GT . 0 ) THEN obj % curve ( ip ) % ptr => gmshLine_Pointer ( startTag , endTag , uid ) Ans = 0 ELSE obj % curve ( ip ) % ptr => gmshLine_Pointer ( startTag , endTag , ip ) Ans = ip END IF ! append to buffer ! WRITE( obj % buffer % unitno, \"(DT)\" ) obj%curve(ip)%ptr%encodedStr( ) ! CALL Display( \"    adding Line in gmsh%model%geo%buffer\") CALL APPEND ( obj % buffer , obj % curve ( ip )% ptr % encodedStr ( ) ) END FUNCTION geo_add_line","tags":"","loc":"proc/geo_add_line.html"},{"title":"geo_add_point – Fortran Program","text":"private function geo_add_point(Obj, x, y, z, lc, uid) result(ans) Arguments Type Intent Optional Attributes Name class( gmshGeo_ ), intent(inout) :: Obj real(kind=DFP), intent(in) :: x real(kind=DFP), intent(in) :: y real(kind=DFP), intent(in) :: z real(kind=DFP), intent(in) :: lc integer(kind=I4B), intent(in) :: uid Return Value integer(kind=I4B) Contents Source Code geo_add_point Source Code FUNCTION geo_add_point ( Obj , x , y , z , lc , uid ) RESULT ( Ans ) CLASS ( gmshGeo_ ), INTENT ( INOUT ) :: Obj REAL ( DFP ), INTENT ( IN ) :: x , y , z , lc INTEGER ( I4B ), INTENT ( IN ) :: uid INTEGER ( I4B ) :: ans ! Internal variables INTEGER ( I4B ) :: ip , n ! main code IF ( ALLOCATED ( obj % point ) ) THEN n = SIZE ( obj % point ) ! we will expand the point now to accomodate one IF ( n . EQ . obj % tPoints ) THEN BLOCK TYPE ( gmshPointPointer_ ) :: temp ( n ) INTEGER ( I4B ) :: ii DO ii = 1 , n temp ( ii ) % ptr => obj % point ( ii ) % ptr obj % point ( ii ) % ptr => NULL ( ) END DO DEALLOCATE ( obj % point ) ALLOCATE ( obj % point ( 2 * ( n + 1 ) ) ) obj % tPoints = n + 1 ip = n + 1 ! copy back DO ii = 1 , n obj % point ( ii ) % ptr => temp ( ii ) % ptr temp ( ii ) % ptr => NULL ( ) END DO END  BLOCK ELSE ! enough size is there obj % tPoints = obj % tPoints + 1 ip = obj % tPoints END IF ELSE ALLOCATE ( obj % point ( def_max_point ) ) obj % tPoints = 1 ip = 1 END IF IF ( uid . GT . 0 ) THEN obj % point ( ip ) % ptr => gmshPoint_Pointer ( x , y , z , lc , uid ) Ans = 0 ELSE obj % point ( ip ) % ptr => gmshPoint_Pointer ( x , y , z , lc , ip ) Ans = ip END IF ! append to buffer ! WRITE( obj % buffer % unitno, \"(DT)\" ) obj%point(ip)%ptr % encodedStr( ) ! CALL Display( \"    adding Point in gmsh%model%geo%buffer\") CALL APPEND ( obj % buffer , obj % point ( ip )% ptr % encodedStr ( ) ) END FUNCTION geo_add_point","tags":"","loc":"proc/geo_add_point.html"},{"title":"geo_write – Fortran Program","text":"private function geo_write(Obj, UnitNo) result(Ans) Arguments Type Intent Optional Attributes Name class( gmshGeo_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: UnitNo Return Value integer(kind=I4B) Contents Source Code geo_write Source Code FUNCTION geo_write ( Obj , UnitNo ) RESULT ( Ans ) CLASS ( gmshGeo_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: UnitNo INTEGER ( I4B ) :: Ans ! Internal variables INTEGER ( I4B ) :: ii IF ( . NOT . ASSOCIATED ( Obj % buffer ) ) THEN CALL Display ( \"ERROR:: gmshGeo_Class.f90\" ) CALL Display ( \"        geo_write()\" ) CALL Display ( \"        Obj % buffer is not associated \" ) STOP END IF IF ( Obj % buffer % tLine . EQ . 0 ) THEN CALL Display ( \"ERROR:: gmshGeo_Class.f90\" ) CALL Display ( \"        geo_write()\" ) CALL Display ( \"        Obj % buffer is empty\" ) STOP END IF DO ii = 1 , Obj % buffer % tLine IF ( ASSOCIATED ( Obj % buffer % Line ( ii ) % ptr ) ) THEN ! CALL Display( \"gmsh%model%geo:: writing gmsh%model%geo%buffer(\" & !   & // trim( str( ii ) ) // \" )\" ) WRITE ( UnitNo , \"(DT)\" ) Obj % buffer % Line ( ii ) % ptr END IF END DO WRITE ( UnitNo , \"(A)\" ) \"Coherence;\" END FUNCTION geo_write","tags":"","loc":"proc/geo_write.html"},{"title":"DeallocateData – Fortran Program","text":"public interface DeallocateData Contents Module Procedures fmt_deallocatedata Module Procedures private interface fmt_deallocatedata () This subroutine clears the content of mshFormat_ Arguments None","tags":"","loc":"interface/deallocatedata~10.html"},{"title":"Display – Fortran Program","text":"public interface Display Contents Module Procedures fmt_display Module Procedures private interface fmt_display () This subroutine display the content of mshFormat_ Arguments None","tags":"","loc":"interface/display~7.html"},{"title":"fmt_deallocatedata – Fortran Program","text":"interface This subroutine clears the content of mshFormat_ private subroutine fmt_deallocatedata(Obj) Arguments Type Intent Optional Attributes Name class( mshFormat_ ), intent(inout) :: Obj Description This subroutine clears the content of mshFormat_","tags":"","loc":"interface/fmt_deallocatedata.html"},{"title":"fmt_display – Fortran Program","text":"interface This subroutine display the content of mshFormat_ private subroutine fmt_display(Obj, Msg, UnitNo) Arguments Type Intent Optional Attributes Name class( mshFormat_ ), intent(in) :: Obj character(len=*), intent(in) :: Msg integer(kind=I4B), intent(in), optional :: UnitNo","tags":"","loc":"interface/fmt_display.html"},{"title":"fmt_goto – Fortran Program","text":"interface This subroutine search the mesh format tag in the mesh file private subroutine fmt_goto(Obj, mshFile, ierr) Arguments Type Intent Optional Attributes Name class( mshFormat_ ), intent(in) :: Obj type(File_), intent(inout) :: mshFile logical(kind=LGT), intent(inout) :: ierr Description This subroutine search the mesh format tag in the mesh file","tags":"","loc":"interface/fmt_goto.html"},{"title":"fmt_read_file – Fortran Program","text":"interface This subroutine reads format from .msh file private subroutine fmt_read_file(Obj, mshFile, ierr) Arguments Type Intent Optional Attributes Name class( mshFormat_ ), intent(inout) :: Obj type(File_), intent(inout) :: mshFile logical(kind=LGT), intent(inout) :: ierr Description This subroutine reads mesh format from .mshfile","tags":"","loc":"interface/fmt_read_file.html"},{"title":"fmt_write_file – Fortran Program","text":"interface This subroutine writes mesh format to a .msh file private subroutine fmt_write_file(Obj, mshFile, Str, EndStr) Arguments Type Intent Optional Attributes Name class( mshFormat_ ), intent(inout) :: Obj type(File_), intent(inout) :: mshFile character(len=*), intent(in), optional :: Str character(len=*), intent(in), optional :: EndStr Description This subroutine writes mesh format to a .msh file","tags":"","loc":"interface/fmt_write_file.html"},{"title":"DeallocateData – Fortran Program","text":"public interface DeallocateData Contents Module Procedures el_deallocatedata Module Procedures private interface el_deallocatedata () Arguments None","tags":"","loc":"interface/deallocatedata~11.html"},{"title":"Display – Fortran Program","text":"public interface Display Contents Module Procedures el_display Module Procedures private interface el_display () Arguments None","tags":"","loc":"interface/display~8.html"},{"title":"el_deallocatedata – Fortran Program","text":"interface private subroutine el_deallocatedata(Obj) Arguments Type Intent Optional Attributes Name class( mshElements_ ), intent(inout) :: Obj Description This subroutine deallocates the data from obj","tags":"","loc":"interface/el_deallocatedata.html"},{"title":"el_display – Fortran Program","text":"interface private subroutine el_display(Obj, Msg, UnitNo) Arguments Type Intent Optional Attributes Name class( mshElements_ ), intent(in) :: Obj character(len=*), intent(in) :: Msg integer(kind=I4B), intent(in), optional :: UnitNo Description This data displays the content of mshElements_","tags":"","loc":"interface/el_display.html"},{"title":"el_goto – Fortran Program","text":"interface This subroutine go the location of element in mesh file private subroutine el_goto(Obj, mshFile, ierr) Arguments Type Intent Optional Attributes Name class( mshElements_ ), intent(in) :: Obj type(File_), intent(inout) :: mshFile logical(kind=LGT), intent(inout) :: ierr Description This subroutine go the location of element in mesh file","tags":"","loc":"interface/el_goto.html"},{"title":"el_read_elem_line – Fortran Program","text":"interface private subroutine el_read_elem_line(Obj, ElemNum, ElemType, PhysicalId, GeometryId, MeshPartitionTags, Nptrs, mshFile) Arguments Type Intent Optional Attributes Name class( mshElements_ ), intent(inout) :: Obj integer(kind=I4B), intent(inout), optional :: ElemNum integer(kind=I4B), intent(inout), optional :: ElemType integer(kind=I4B), intent(inout), optional :: PhysicalId integer(kind=I4B), intent(inout), optional :: GeometryId integer(kind=I4B), intent(inout), optional ALLOCATABLE :: MeshPartitionTags (:) integer(kind=I4B), intent(inout), optional ALLOCATABLE :: Nptrs (:) type(File_), intent(inout) :: mshFile","tags":"","loc":"interface/el_read_elem_line.html"},{"title":"el_read_file – Fortran Program","text":"interface private subroutine el_read_file(Obj, mshFile, mshFormat, ierr) Arguments Type Intent Optional Attributes Name class( mshElements_ ), intent(inout) :: Obj type(File_), intent(inout) :: mshFile type(mshFormat_), intent(inout) :: mshFormat logical(kind=LGT), intent(inout) :: ierr Description This subroutine reads data from a file","tags":"","loc":"interface/el_read_file.html"},{"title":"el_telements_1 – Fortran Program","text":"interface private pure function el_telements_1(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( mshElements_ ), intent(in) :: Obj Return Value integer(kind=I4B) Description This function returns total number of elements","tags":"","loc":"interface/el_telements_1.html"},{"title":"el_write_file – Fortran Program","text":"interface private subroutine el_write_file(Obj, mshFile, mshFormat, Str, EndStr) Arguments Type Intent Optional Attributes Name class( mshElements_ ), intent(inout) :: Obj type(File_), intent(inout) :: mshFile type(mshFormat_), intent(inout) :: mshFormat character(len=*), intent(in), optional :: Str character(len=*), intent(in), optional :: EndStr Description This subroutine writes the data to a file","tags":"","loc":"interface/el_write_file.html"},{"title":"DeallocateData – Fortran Program","text":"public interface DeallocateData Contents Module Procedures pn_deallocatedata Module Procedures private interface pn_deallocatedata () This subroutine deallocates the data stored in mshPhysicalNames_ Arguments None","tags":"","loc":"interface/deallocatedata~12.html"},{"title":"Display – Fortran Program","text":"public interface Display Contents Module Procedures pn_display Module Procedures private interface pn_display () This subroutine displays the content of mshPhysicalNames_ Arguments None","tags":"","loc":"interface/display~9.html"},{"title":"pn_Curve_names – Fortran Program","text":"interface This function returns the names of physical curves private pure function pn_Curve_names(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj Return Value type(String),\n  ALLOCATABLE,(:) Description This subroutine returns the names of physical curves","tags":"","loc":"interface/pn_curve_names.html"},{"title":"pn_Curve_tags – Fortran Program","text":"interface This function returns the physical tags of all physical curves private pure function pn_Curve_tags(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj Return Value integer(kind=I4B),\n  ALLOCATABLE,(:) Description This function returns the physical tags of all physical curves","tags":"","loc":"interface/pn_curve_tags.html"},{"title":"pn_Point_tags – Fortran Program","text":"interface This function returns the physical tags of all physical points private pure function pn_Point_tags(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj Return Value integer(kind=I4B),\n  ALLOCATABLE,(:) Description This function returns the physical tags of all physical points","tags":"","loc":"interface/pn_point_tags.html"},{"title":"pn_Surface_names – Fortran Program","text":"interface This function returns the names of physical surfaces private pure function pn_Surface_names(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj Return Value type(String),\n  ALLOCATABLE,(:) Description This subroutine returns the names of physical surfaces","tags":"","loc":"interface/pn_surface_names.html"},{"title":"pn_Surface_tags – Fortran Program","text":"interface This function returns the physical tags of all physical surfaces private pure function pn_Surface_tags(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj Return Value integer(kind=I4B),\n  ALLOCATABLE,(:) Description This function returns the physical tags of all physical surfaces","tags":"","loc":"interface/pn_surface_tags.html"},{"title":"pn_Volume_names – Fortran Program","text":"interface This function returns the names of physical volumes private pure function pn_Volume_names(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj Return Value type(String),\n  ALLOCATABLE,(:) Description This subroutine returns the names of physical volumes","tags":"","loc":"interface/pn_volume_names.html"},{"title":"pn_Volume_tags – Fortran Program","text":"interface This function returns the physical tags of all physical volumes private pure function pn_Volume_tags(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj Return Value integer(kind=I4B),\n  ALLOCATABLE,(:) Description This function returns the physical tags of all physical volumes","tags":"","loc":"interface/pn_volume_tags.html"},{"title":"pn_deallocatedata – Fortran Program","text":"interface This subroutine deallocates the data stored in mshPhysicalNames_ private subroutine pn_deallocatedata(Obj) Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(inout) :: Obj Description This subroutine deallocates the data stored in mshPhysicalNames_","tags":"","loc":"interface/pn_deallocatedata.html"},{"title":"pn_display – Fortran Program","text":"interface This subroutine displays the content of mshPhysicalNames_ private subroutine pn_display(Obj, Msg, UnitNo) Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj character(len=*), intent(in) :: Msg integer(kind=I4B), intent(in), optional :: UnitNo Description This subroutine displays the content of mshPhysicalNames_","tags":"","loc":"interface/pn_display.html"},{"title":"pn_get_size – Fortran Program","text":"interface This function returns total number of physical entities private pure function pn_get_size(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj Return Value integer(kind=I4B) Description This function returns total number of physical entities","tags":"","loc":"interface/pn_get_size.html"},{"title":"pn_goto – Fortran Program","text":"interface This suboutine find the tag for Physical groups in mesh private subroutine pn_goto(Obj, mshFile, ierr) Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj type(File_), intent(inout) :: mshFile logical(kind=LGT), intent(inout) :: ierr Description This suboutine find the tag for Physical groups in mesh","tags":"","loc":"interface/pn_goto.html"},{"title":"pn_index_Curve – Fortran Program","text":"interface This function return the index of physical Curve from its physical id private pure function pn_index_Curve(Obj, Tag) result(Ans) Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Tag Return Value integer(kind=I4B) Description This function returns the index of physical Curve from its physical id","tags":"","loc":"interface/pn_index_curve.html"},{"title":"pn_index_Curve_2 – Fortran Program","text":"interface This function return the index of physical Curve from its physical id private pure function pn_index_Curve_2(Obj, Tag) result(Ans) Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Tag (:) Return Value integer(kind=I4B)\n  (SIZE(Tag)) Description This function returns the index of physical Curve from its physical id","tags":"","loc":"interface/pn_index_curve_2.html"},{"title":"pn_index_Surface – Fortran Program","text":"interface This function return the index of physical Surface from its physical id private pure function pn_index_Surface(Obj, Tag) result(Ans) Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Tag Return Value integer(kind=I4B) Description This function returns the index of physical Surface from its physical id","tags":"","loc":"interface/pn_index_surface.html"},{"title":"pn_index_Surface_2 – Fortran Program","text":"interface private pure function pn_index_Surface_2(Obj, Tag) result(Ans) Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Tag (:) Return Value integer(kind=I4B)\n  (SIZE(Tag))","tags":"","loc":"interface/pn_index_surface_2.html"},{"title":"pn_index_Volume – Fortran Program","text":"interface This function return the index of physical Volume from its physical id private pure function pn_index_Volume(Obj, Tag) result(Ans) Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Tag Return Value integer(kind=I4B) Description This function returns the index of physical Volume from its physical id","tags":"","loc":"interface/pn_index_volume.html"},{"title":"pn_index_Volume_2 – Fortran Program","text":"interface This function return the index of physical Volume from its physical id private pure function pn_index_Volume_2(Obj, Tag) result(Ans) Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Tag (:) Return Value integer(kind=I4B)\n  (SIZE(Tag)) Description This function returns the index of physical Volume from its physical id","tags":"","loc":"interface/pn_index_volume_2.html"},{"title":"pn_index_a – Fortran Program","text":"interface This function returns index of a given physical name private pure function pn_index_a(Obj, Name) result(Ans) Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj character(len=*), intent(in) :: Name Return Value integer(kind=I4B) Description This function returns index of a given physical name","tags":"","loc":"interface/pn_index_a.html"},{"title":"pn_index_b – Fortran Program","text":"interface private pure function pn_index_b(Obj, Name) result(Ans) Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj type(String), intent(in) :: Name (:) Return Value integer(kind=I4B)\n  (SIZE(Name))","tags":"","loc":"interface/pn_index_b.html"},{"title":"pn_index_c – Fortran Program","text":"interface This function returns index of a given physical name private pure function pn_index_c(Obj, XiDimTag) result(Ans) Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: XiDimTag (2) Return Value integer(kind=I4B) Description This function returns index of a given physical name XiDimTag( 1 ) denotes the XiDImension of physical entity 0 => point 1 => line 2 => surface 3 => volume XiDimTag( 2 ) denotes the Physical Tag of physical entity","tags":"","loc":"interface/pn_index_c.html"},{"title":"pn_index_d – Fortran Program","text":"interface This function returns index of a given physical name private pure function pn_index_d(Obj, XiDimTag) result(Ans) Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: XiDimTag Return Value integer(kind=I4B),\n  ALLOCATABLE,(:) Description This function returns index of a given physical name XiDim denotes the XiDImension of physical entity XiDim = 0 => returns indices of points XiDim = 1 => returns indices of lines XiDim = 2 => returns indices of surfaces XiDim = 3 => returns indices of volumes","tags":"","loc":"interface/pn_index_d.html"},{"title":"pn_index_point – Fortran Program","text":"interface private pure function pn_index_point(Obj, Tag) result(Ans) Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Tag Return Value integer(kind=I4B)","tags":"","loc":"interface/pn_index_point.html"},{"title":"pn_index_point_2 – Fortran Program","text":"interface private pure function pn_index_point_2(Obj, Tag) result(Ans) Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Tag (:) Return Value integer(kind=I4B)\n  (SIZE(Tag))","tags":"","loc":"interface/pn_index_point_2.html"},{"title":"pn_output_file – Fortran Program","text":"interface This function retunrns the name of output file private pure function pn_output_file(Obj, mshFile, indx) result(Ans) Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj type(File_), intent(in) :: mshFile integer(kind=I4B), intent(in) :: indx Return Value type(String)","tags":"","loc":"interface/pn_output_file.html"},{"title":"pn_point_names – Fortran Program","text":"interface This function returns the names of physical poins private pure function pn_point_names(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj Return Value type(String),\n  ALLOCATABLE,(:) Description This subroutine returns the names of physical points","tags":"","loc":"interface/pn_point_names.html"},{"title":"pn_read_file – Fortran Program","text":"interface This subroutine reads physical groupds info from mesh file private subroutine pn_read_file(Obj, mshFile, ierr) Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(inout) :: Obj type(File_), intent(inout) :: mshFile logical(kind=LGT), intent(inout) :: ierr Description This subroutine reads physical groupds info from mesh file","tags":"","loc":"interface/pn_read_file.html"},{"title":"pn_size_Curve – Fortran Program","text":"interface This function returns total number of physical curves private pure function pn_size_Curve(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj Return Value integer(kind=I4B) Description This function returns total number of physical curves","tags":"","loc":"interface/pn_size_curve.html"},{"title":"pn_size_Surface – Fortran Program","text":"interface This function returns total number of physical surfaces private pure function pn_size_Surface(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj Return Value integer(kind=I4B) Description This function returns total number of physical surfaces","tags":"","loc":"interface/pn_size_surface.html"},{"title":"pn_size_Volume – Fortran Program","text":"interface This function returns total number of physical volumes private pure function pn_size_Volume(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj Return Value integer(kind=I4B) Description This function returns total number of physical volumes","tags":"","loc":"interface/pn_size_volume.html"},{"title":"pn_size_point – Fortran Program","text":"interface This function returns total number of physical points private pure function pn_size_point(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj Return Value integer(kind=I4B) Description This function returns total number of physical points","tags":"","loc":"interface/pn_size_point.html"},{"title":"pn_who_am_i – Fortran Program","text":"interface private pure function pn_who_am_i(Obj, I) result(Ans) Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: I Return Value type(String)","tags":"","loc":"interface/pn_who_am_i.html"},{"title":"pn_write_file – Fortran Program","text":"interface This subroutine writes physical groupds info in mesh file private subroutine pn_write_file(Obj, mshFile, Str, EndStr) Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(inout) :: Obj type(File_), intent(inout) :: mshFile character(len=*), intent(in), optional :: Str character(len=*), intent(in), optional :: EndStr Description This subroutine writes physical groupds info in mesh file","tags":"","loc":"interface/pn_write_file.html"},{"title":"DeallocateData – Fortran Program","text":"public interface DeallocateData Contents Module Procedures ent_deallocatedata Module Procedures private interface ent_deallocatedata () This subroutine deallocate the data from mshEntity_ Arguments None","tags":"","loc":"interface/deallocatedata~13.html"},{"title":"Display – Fortran Program","text":"public interface Display Contents Module Procedures ent_display Module Procedures private interface ent_display () Arguments None","tags":"","loc":"interface/display~10.html"},{"title":"ent_deallocatedata – Fortran Program","text":"interface This subroutine deallocate the data from mshEntity_ private subroutine ent_deallocatedata(Obj) Arguments Type Intent Optional Attributes Name class( mshEntity_ ), intent(inout) :: Obj Description This subroutine deallocate the data from mshEntity_","tags":"","loc":"interface/ent_deallocatedata.html"},{"title":"ent_display – Fortran Program","text":"interface private subroutine ent_display(Obj, Msg, UnitNo) Arguments Type Intent Optional Attributes Name class( mshEntity_ ), intent(in) :: Obj character(len=*), intent(in) :: Msg integer(kind=I4B), intent(in), optional :: UnitNo Description This subroutine writes the content of mshEntity_","tags":"","loc":"interface/ent_display.html"},{"title":"ent_getIndex_a – Fortran Program","text":"interface This function finds the index of a tag/uid in list of entities private pure function ent_getIndex_a(mshEntities, Uid) result(Ans) Arguments Type Intent Optional Attributes Name type( mshEntity_ ), intent(in) :: mshEntities (:) integer(kind=I4B), intent(in) :: Uid Return Value integer(kind=I4B) Description This function finds the index of a tag/uid in the list of entities","tags":"","loc":"interface/ent_getindex_a.html"},{"title":"ent_goto – Fortran Program","text":"interface This subroutine finds the tag in the mesh file private subroutine ent_goto(Obj, mshFile, ierr) Arguments Type Intent Optional Attributes Name class( mshEntity_ ), intent(in) :: Obj type(File_), intent(inout) :: mshFile logical(kind=LGT), intent(inout) :: ierr","tags":"","loc":"interface/ent_goto.html"},{"title":"ent_read_Curve – Fortran Program","text":"interface This subroutine reads the entry for curve entity private subroutine ent_read_Curve(Obj, mshFile, readTag, ierr) Arguments Type Intent Optional Attributes Name class( mshEntity_ ), intent(inout) :: Obj type(File_), intent(inout) :: mshFile logical(kind=LGT), intent(in) :: readTag logical(kind=LGT), intent(inout) :: ierr Description This subroutine reads the entry for curve entity","tags":"","loc":"interface/ent_read_curve.html"},{"title":"ent_read_Surface – Fortran Program","text":"interface This subroutine reads the entry for surface entity private subroutine ent_read_Surface(Obj, mshFile, readTag, ierr) Arguments Type Intent Optional Attributes Name class( mshEntity_ ), intent(inout) :: Obj type(File_), intent(inout) :: mshFile logical(kind=LGT), intent(in) :: readTag logical(kind=LGT), intent(inout) :: ierr Description This subroutine reads the entry for surface entity","tags":"","loc":"interface/ent_read_surface.html"},{"title":"ent_read_Volume – Fortran Program","text":"interface This subroutine reads the entry for volume entity private subroutine ent_read_Volume(Obj, mshFile, readTag, ierr) Arguments Type Intent Optional Attributes Name class( mshEntity_ ), intent(inout) :: Obj type(File_), intent(inout) :: mshFile logical(kind=LGT), intent(in) :: readTag logical(kind=LGT), intent(inout) :: ierr Description This subroutine reads the entry for volume entity","tags":"","loc":"interface/ent_read_volume.html"},{"title":"ent_read_point – Fortran Program","text":"interface This subroutine reads the entry for point entity private subroutine ent_read_point(Obj, mshFile, readTag, ierr) Arguments Type Intent Optional Attributes Name class( mshEntity_ ), intent(inout) :: Obj type(File_), intent(inout) :: mshFile logical(kind=LGT), intent(in) :: readTag logical(kind=LGT), intent(inout) :: ierr Description This subroutine reads the entry for point entity","tags":"","loc":"interface/ent_read_point.html"},{"title":"ent_tBoundingtag – Fortran Program","text":"interface This function returns the total number of bounding tags in entity private pure function ent_tBoundingtag(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( mshEntity_ ), intent(in) :: Obj Return Value integer(kind=I4B) Description This function returns the total number of bounding tags in entity","tags":"","loc":"interface/ent_tboundingtag.html"},{"title":"ent_telements – Fortran Program","text":"interface This function returns the total number of elements in entity private pure function ent_telements(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( mshEntity_ ), intent(in) :: Obj Return Value integer(kind=I4B) Description This function returns the total number of elements in entity","tags":"","loc":"interface/ent_telements.html"},{"title":"ent_tphysicaltag – Fortran Program","text":"interface This function returns the total number of physical tags in entity private pure function ent_tphysicaltag(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( mshEntity_ ), intent(in) :: Obj Return Value integer(kind=I4B) Description This function returns the total number of physical tags in entity","tags":"","loc":"interface/ent_tphysicaltag.html"},{"title":"ent_write_file – Fortran Program","text":"interface This subroutine write the data to a file private subroutine ent_write_file(Obj, mshFile, Str, EndStr) Arguments Type Intent Optional Attributes Name class( mshEntity_ ), intent(inout) :: Obj type(File_), intent(inout) :: mshFile character(len=*), intent(in), optional :: Str character(len=*), intent(in), optional :: EndStr Description This subroutine write the data to a file","tags":"","loc":"interface/ent_write_file.html"},{"title":"getIndex – Fortran Program","text":"public interface getIndex Contents Module Procedures ent_getIndex_a Module Procedures private interface ent_getIndex_a () This function finds the index of a tag/uid in list of entities Arguments None","tags":"","loc":"interface/getindex.html"},{"title":"DeallocateData – Fortran Program","text":"public interface DeallocateData Contents Module Procedures n_deallocatedata Module Procedures private interface n_deallocatedata () This subroutine deallocate the data form the instance Arguments None","tags":"","loc":"interface/deallocatedata~14.html"},{"title":"Display – Fortran Program","text":"public interface Display Contents Module Procedures n_display Module Procedures private interface n_display () This subroutine display contents of mshNodes_ Arguments None","tags":"","loc":"interface/display~11.html"},{"title":"n_deallocatedata – Fortran Program","text":"interface This subroutine deallocate the data form the instance private subroutine n_deallocatedata(Obj) Arguments Type Intent Optional Attributes Name class( mshNodes_ ), intent(inout) :: Obj Description This subroutine deallocate the data from instance","tags":"","loc":"interface/n_deallocatedata.html"},{"title":"n_display – Fortran Program","text":"interface This subroutine display contents of mshNodes_ private subroutine n_display(Obj, Msg, UnitNo) Arguments Type Intent Optional Attributes Name class( mshNodes_ ), intent(in) :: Obj character(len=*), intent(in) :: Msg integer(kind=I4B), intent(in), optional :: UnitNo Description This subroutine displays content of mshNodes_","tags":"","loc":"interface/n_display.html"},{"title":"n_goto – Fortran Program","text":"interface This subroutine go to the position where nodes are defined private subroutine n_goto(Obj, mshFile, ierr) Arguments Type Intent Optional Attributes Name class( mshNodes_ ), intent(in) :: Obj type(File_), intent(inout) :: mshFile logical(kind=LGT), intent(inout) :: ierr Description This subroutine go to the position where nodes are defined","tags":"","loc":"interface/n_goto.html"},{"title":"n_read_file – Fortran Program","text":"interface This subroutine read data from mesh file private subroutine n_read_file(Obj, mshFile, mshFormat, ierr) Arguments Type Intent Optional Attributes Name class( mshNodes_ ), intent(inout) :: Obj type(File_), intent(inout) :: mshFile type(mshFormat_), intent(inout) :: mshFormat logical(kind=LGT), intent(inout) :: ierr Description This subroutine read data from mesh file","tags":"","loc":"interface/n_read_file.html"},{"title":"n_write_file – Fortran Program","text":"interface This subroutine write data to a file private subroutine n_write_file(Obj, mshFile, mshFormat, Str, EndStr) Arguments Type Intent Optional Attributes Name class( mshNodes_ ), intent(inout) :: Obj type(File_), intent(inout) :: mshFile type(mshFormat_), intent(inout) :: mshFormat character(len=*), intent(in), optional :: Str character(len=*), intent(in), optional :: EndStr Description This subroutine writes data to a file","tags":"","loc":"interface/n_write_file.html"},{"title":"model_add – Fortran Program","text":"private function model_add(Obj, Name) result(Ans) This function add the model\n Currently only one model can be added\n model_name_buffer.txt Arguments Type Intent Optional Attributes Name class( gmshModel_ ), intent(inout), TARGET :: Obj character(len=*), intent(in) :: Name Return Value integer(kind=I4B) Contents Source Code model_add Source Code FUNCTION model_add ( Obj , Name ) RESULT ( Ans ) CLASS ( gmshModel_ ), TARGET , INTENT ( INOUT ) :: Obj CHARACTER ( LEN = * ), INTENT ( IN ) :: Name INTEGER ( I4B ) :: Ans CALL Display ( \"gmsh%model:: Model \" // trim ( Name ) // \" added\" ) Ans = 0 CALL Display ( \"gmsh%model:: setting name of Model\" ) Obj % name = trim ( name ) obj % next => NULL ( ) ! model % geo CALL Display ( \"gmsh%model:: allocating obj%geo\" ) ALLOCATE ( obj % geo ) ! model model % geo % mesh CALL Display ( \"gmsh%model:: allocating obj%geo%mesh\" ) ALLOCATE ( obj % geo % mesh ) ! allocate obj % geo % buffer CALL Display ( \"gmsh%model:: allocating obj%geo%buffer\" ) ALLOCATE ( obj % geo % buffer ) ! model % mesh CALL Display ( \"gmsh%model:: allocating obj%mesh\" ) ALLOCATE ( obj % mesh ) !! model_name_buffer.txt CALL Display ( \"gmsh%model:: allocating obj%buffer\" ) ALLOCATE ( obj % buffer ) END FUNCTION model_add","tags":"","loc":"proc/model_add.html"},{"title":"model_addPhysicalGroup – Fortran Program","text":"private function model_addPhysicalGroup(Obj, dim, tags, uid) result(Ans) Add a physical group of dimension dim, grouping the model entities with\n tags tags. Return the tag of the physical group, equal to tag if tag is\n positive, or a new tag if tag < 0.\n check\n check\n If it is the first call then\n check\n check\n If it is the first call then\n check\n check\n If it is the first call then\n check\n check\n If it is the first call then Arguments Type Intent Optional Attributes Name class( gmshModel_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: dim integer(kind=I4B), intent(in) :: tags (:) integer(kind=I4B), intent(in) :: uid Return Value integer(kind=I4B) Contents Source Code model_addPhysicalGroup Source Code FUNCTION model_addPhysicalGroup ( Obj , dim , tags , uid ) RESULT ( Ans ) CLASS ( gmshModel_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: dim INTEGER ( I4B ), INTENT ( IN ) :: tags ( : ) INTEGER ( I4B ), INTENT ( IN ) :: uid INTEGER ( I4B ) :: Ans ! internal variables INTEGER ( I4B ) :: ii , n , te2p , tp2e , jj TYPE ( String ), ALLOCATABLE :: s ( : ) TYPE ( String ) :: ss IF ( uid . LT . 0 ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"        model_addPhysicalGroup( )\" ) CALL Display ( \"          negative uid not supported\" ) STOP END IF ! internal variables SELECT CASE ( dim ) CASE ( 0 ) ! CALL Display( \"gmsh%model:: adding physical point\") #include \"./addphysicalpoint.inc\" CASE ( 1 ) ! CALL Display( \"gmsh%model:: adding physical curve\") #include \"./addphysicalcurve.inc\" CASE ( 2 ) ! CALL Display( \"gmsh%model:: adding physical surface\") #include \"./addphysicalsurface.inc\" CASE ( 3 ) ! CALL Display( \"gmsh%model:: adding physical volume\") #include \"./addphysicalvolume.inc\" END SELECT END FUNCTION model_addPhysicalGroup","tags":"","loc":"proc/model_addphysicalgroup.html"},{"title":"model_getEntities – Fortran Program","text":"private function model_getEntities(Obj, dim) result(Ans) Get all the entities in the current model. If dim is >= 0, return only\n the entities of the specified dimension (e.g. points if dim == 0).\n The entities are returned as a vector of (dim, tag) integer pairs. Arguments Type Intent Optional Attributes Name class( gmshModel_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: dim Return Value integer(kind=I4B),\n  ALLOCATABLE,(:,:) Contents Source Code model_getEntities Source Code FUNCTION model_getEntities ( Obj , dim ) RESULT ( Ans ) CLASS ( gmshModel_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: dim INTEGER ( I4B ), ALLOCATABLE :: Ans ( :, : ) ! internal variables INTEGER ( I4B ) :: ii , n , jj IF ( . NOT . ASSOCIATED ( Obj % geo ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"        model_getEntities()\" ) CALL Display ( \"          Obj % geo not associated\" ) STOP END IF SELECT CASE ( dim ) CASE ( 3 ) IF ( Obj % geo % tVolumes . NE . 0 ) THEN n = Obj % geo % tVolumes ALLOCATE ( Ans ( n , 2 ) ) Ans = 0 DO ii = 1 , n Ans ( ii , 1 ) = dim Ans ( ii , 2 ) = Obj % geo % Volume ( ii ) % Ptr % Uid END DO ELSE CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"        model_getEntities()\" ) CALL Display ( \"          Obj % geo % Volume not associated\" ) STOP END IF CASE ( 2 ) IF ( Obj % geo % tSurfaces . NE . 0 ) THEN n = Obj % geo % tSurfaces ALLOCATE ( Ans ( n , 2 ) ) Ans = 0 DO ii = 1 , n Ans ( ii , 1 ) = dim Ans ( ii , 2 ) = Obj % geo % Surface ( ii ) % Ptr % Uid END DO ELSE CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"        model_getEntities()\" ) CALL Display ( \"          Obj % geo % Surface not associated\" ) STOP END IF CASE ( 1 ) IF ( Obj % geo % tCurves . NE . 0 ) THEN n = Obj % geo % tCurves ALLOCATE ( Ans ( n , 2 ) ) Ans = 0 DO ii = 1 , n Ans ( ii , 1 ) = dim Ans ( ii , 2 ) = Obj % geo % Curve ( ii ) % Ptr % Uid END DO ELSE CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"        model_getEntities()\" ) CALL Display ( \"          Obj % geo % Curve not associated\" ) STOP END IF CASE ( 0 ) IF ( Obj % geo % tPoints . NE . 0 ) THEN n = Obj % geo % tPoints ALLOCATE ( Ans ( n , 2 ) ) Ans = 0 DO ii = 1 , n Ans ( ii , 1 ) = dim Ans ( ii , 2 ) = Obj % geo % Point ( ii ) % Ptr % Uid END DO ELSE CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"        model_getEntities()\" ) CALL Display ( \"          Obj % geo % Point not associated\" ) STOP END IF CASE DEFAULT n = Obj % geo % tPoints + Obj % geo % tCurves & & + Obj % geo % tSurfaces + Obj % geo % tVolumes IF ( n . NE . 0 ) THEN ALLOCATE ( Ans ( n , 2 ) ) ELSE CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"        model_getEntities()\" ) CALL Display ( \"          Obj % geo seems empty\" ) STOP END IF DO ii = 1 , Obj % geo % tPoints Ans ( ii , 1 ) = 0 Ans ( ii , 2 ) = Obj % geo % Point ( ii ) % Ptr % Uid END DO DO ii = 1 , Obj % geo % tCurves jj = ii + Obj % geo % tPoints Ans ( jj , 1 ) = 1 Ans ( jj , 2 ) = Obj % geo % Curve ( ii ) % Ptr % Uid END DO DO ii = 1 , Obj % geo % tSurfaces jj = ii + Obj % geo % tPoints + Obj % geo % tCurves Ans ( jj , 1 ) = 2 Ans ( jj , 2 ) = Obj % geo % Surface ( ii ) % Ptr % Uid END DO DO ii = 1 , Obj % geo % tVolumes jj = ii + Obj % geo % tPoints + Obj % geo % tCurves & + Obj % geo % tSurfaces Ans ( jj , 1 ) = 3 Ans ( jj , 2 ) = Obj % geo % Volume ( ii ) % Ptr % Uid END DO END SELECT END FUNCTION model_getEntities","tags":"","loc":"proc/model_getentities.html"},{"title":"model_getEntitiesForPhysicalGroup – Fortran Program","text":"private function model_getEntitiesForPhysicalGroup(Obj, dim, tag) result(Ans) Get the tags of the model entities making up the physical group of\n dimension dim and tag tag. Arguments Type Intent Optional Attributes Name class( gmshModel_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: dim integer(kind=I4B), intent(in) :: tag Return Value integer(kind=I4B),\n  ALLOCATABLE,(:) Contents Source Code model_getEntitiesForPhysicalGroup Source Code FUNCTION model_getEntitiesForPhysicalGroup ( Obj , dim , tag ) RESULT ( Ans ) CLASS ( gmshModel_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: dim , tag INTEGER ( I4B ), ALLOCATABLE :: Ans ( : ) ! define internal variables INTEGER ( I4B ) :: ii , n SELECT CASE ( dim ) CASE ( 0 ) IF ( . NOT . ALLOCATED ( Obj % PhysicalPointUID ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"          model_getEntitiesForPhysicalGroup()\" ) CALL Display ( \"          Physical points are not defined\" ) STOP END IF n = SIZE ( Obj % PhysicalPointUID ) DO ii = 1 , n IF ( Obj % PhysicalPointUID ( ii ) . EQ . tag ) THEN CALL Convert ( From = Obj % Point_PhysicalToEntity ( ii ) % Ptr , & & TO = Ans ) EXIT END IF END DO CASE ( 1 ) IF ( . NOT . ALLOCATED ( Obj % PhysicalCurveUID ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"          model_getEntitiesForPhysicalGroup()\" ) CALL Display ( \"          Physical Curves are not defined\" ) STOP END IF n = SIZE ( Obj % PhysicalCurveUID ) DO ii = 1 , n IF ( Obj % PhysicalCurveUID ( ii ) . EQ . tag ) THEN CALL Convert ( From = Obj % Curve_PhysicalToEntity ( ii ) % Ptr , & & TO = Ans ) EXIT END IF END DO CASE ( 2 ) IF ( . NOT . ALLOCATED ( Obj % PhysicalSurfaceUID ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"          model_getEntitiesForPhysicalGroup()\" ) CALL Display ( \"          Physical Surfaces are not defined\" ) STOP END IF n = SIZE ( Obj % PhysicalSurfaceUID ) DO ii = 1 , n IF ( Obj % PhysicalSurfaceUID ( ii ) . EQ . tag ) THEN CALL Convert ( From = Obj % Surface_PhysicalToEntity ( ii ) % Ptr , & & TO = Ans ) EXIT END IF END DO CASE ( 3 ) IF ( . NOT . ALLOCATED ( Obj % PhysicalVolumeUID ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"          model_getEntitiesForPhysicalGroup()\" ) CALL Display ( \"          Physical Volumes are not defined\" ) STOP END IF n = SIZE ( Obj % PhysicalVolumeUID ) DO ii = 1 , n IF ( Obj % PhysicalVolumeUID ( ii ) . EQ . tag ) THEN CALL Convert ( From = Obj % Volume_PhysicalToEntity ( ii ) % Ptr , & & TO = Ans ) EXIT END IF END DO END SELECT END FUNCTION model_getEntitiesForPhysicalGroup","tags":"","loc":"proc/model_getentitiesforphysicalgroup.html"},{"title":"model_getEntityName – Fortran Program","text":"private function model_getEntityName(Obj, dim, tag) result(Ans) get the name of the entity of dimension dim and tag tag Arguments Type Intent Optional Attributes Name class( gmshModel_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: dim integer(kind=I4B), intent(in) :: tag Return Value type(String) Contents Source Code model_getEntityName Source Code FUNCTION model_getEntityName ( Obj , dim , tag ) RESULT ( Ans ) CLASS ( gmshModel_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: dim , tag TYPE ( String ) :: Ans !internal variables INTEGER ( I4B ) :: ii SELECT CASE ( dim ) CASE ( 0 ) DO ii = 1 , obj % geo % tPoints IF ( obj % geo % point ( ii ) % ptr % uid . EQ . tag ) THEN Ans = obj % EntityPointName ( ii ) END IF END DO CASE ( 1 ) DO ii = 1 , obj % geo % tCurves IF ( obj % geo % Curve ( ii ) % ptr % uid . EQ . tag ) THEN Ans = obj % EntityCurveName ( ii ) END IF END DO CASE ( 2 ) DO ii = 1 , obj % geo % tSurfaces IF ( obj % geo % Surface ( ii ) % ptr % uid . EQ . tag ) THEN Ans = obj % EntitySurfaceName ( ii ) END IF END DO CASE ( 3 ) DO ii = 1 , obj % geo % tVolumes IF ( obj % geo % Volume ( ii ) % ptr % uid . EQ . tag ) THEN Ans = obj % EntityVolumeName ( ii ) END IF END DO END SELECT END FUNCTION model_getEntityName","tags":"","loc":"proc/model_getentityname.html"},{"title":"model_getPhysicalGroups – Fortran Program","text":"private function model_getPhysicalGroups(Obj, dim) result(Ans) Get all the physical groups in the current model. If dim is >= 0, return\n only the entities of the specified dimension (e.g. physical points\n if dim == 0). The entities are returned as a vector of (dim, tag)\n integer pairs. Arguments Type Intent Optional Attributes Name class( gmshModel_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: dim Return Value integer(kind=I4B),\n  ALLOCATABLE,(:,:) Contents Source Code model_getPhysicalGroups Source Code FUNCTION model_getPhysicalGroups ( Obj , dim ) RESULT ( Ans ) CLASS ( gmshModel_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: dim INTEGER ( I4B ), ALLOCATABLE :: Ans ( :,: ) ! internal variables INTEGER ( I4B ) :: ii , n , jj , i ( 0 : 3 ) SELECT CASE ( dim ) CASE ( 3 ) IF ( . NOT . ALLOCATED ( Obj % PhysicalVolumeUID ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"        model_getPhysicalGroups()\" ) CALL Display ( \"          Obj % PhysicalVolumeUID not allocated\" ) CALL Display ( \"          Seems no Physical Volume present\" ) STOP END IF n = SIZE ( Obj % PhysicalVolumeUID ) ALLOCATE ( Ans ( n , 2 ) ) Ans = 0 DO ii = 1 , n Ans ( ii , 1 ) = dim Ans ( ii , 2 ) = Obj % PhysicalVolumeUID ( ii ) END DO CASE ( 2 ) IF ( . NOT . ALLOCATED ( Obj % PhysicalSurfaceUID ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"        model_getPhysicalGroups()\" ) CALL Display ( \"          Obj % PhysicalSurfaceUID not allocated\" ) CALL Display ( \"          Seems no Physical Surface present\" ) STOP END IF n = SIZE ( Obj % PhysicalSurfaceUID ) ALLOCATE ( Ans ( n , 2 ) ) Ans = 0 DO ii = 1 , n Ans ( ii , 1 ) = dim Ans ( ii , 2 ) = Obj % PhysicalSurfaceUID ( ii ) END DO CASE ( 1 ) IF ( . NOT . ALLOCATED ( Obj % PhysicalCurveUID ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"        model_getPhysicalGroups()\" ) CALL Display ( \"          Obj % PhysicalCurveUID not allocated\" ) CALL Display ( \"          Seems no Physical Curve present\" ) STOP END IF n = SIZE ( Obj % PhysicalCurveUID ) ALLOCATE ( Ans ( n , 2 ) ) Ans = 0 DO ii = 1 , n Ans ( ii , 1 ) = dim Ans ( ii , 2 ) = Obj % PhysicalCurveUID ( ii ) END DO CASE ( 0 ) IF ( . NOT . ALLOCATED ( Obj % PhysicalPointUID ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"        model_getPhysicalGroups()\" ) CALL Display ( \"          Obj % PhysicalPointUID not allocated\" ) CALL Display ( \"          Seems no Physical Point present\" ) STOP END IF n = SIZE ( Obj % PhysicalPointUID ) ALLOCATE ( Ans ( n , 2 ) ) Ans = 0 DO ii = 1 , n Ans ( ii , 1 ) = dim Ans ( ii , 2 ) = Obj % PhysicalPointUID ( ii ) END DO CASE DEFAULT i = 0 IF ( ALLOCATED ( Obj % PhysicalPointUID ) ) THEN i ( 0 ) = SIZE ( Obj % PhysicalPointUID ) END IF IF ( ALLOCATED ( Obj % PhysicalCurveUID ) ) THEN i ( 1 ) = SIZE ( Obj % PhysicalCurveUID ) END IF IF ( ALLOCATED ( Obj % PhysicalSurfaceUID ) ) THEN i ( 2 ) = SIZE ( Obj % PhysicalSurfaceUID ) END IF IF ( ALLOCATED ( Obj % PhysicalVolumeUID ) ) THEN i ( 3 ) = SIZE ( Obj % PhysicalVolumeUID ) END IF n = SUM ( i ) IF ( n . NE . 0 ) THEN ALLOCATE ( Ans ( n , 2 ) ) ELSE CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"        model_getEntities()\" ) CALL Display ( \"          Seems no Physical groupd defined\" ) STOP END IF DO ii = 1 , i ( 0 ) Ans ( ii , 1 ) = 0 Ans ( ii , 2 ) = Obj % PhysicalPointUID ( ii ) END DO DO ii = 1 , i ( 1 ) jj = ii + i ( 0 ) Ans ( jj , 1 ) = 1 Ans ( jj , 2 ) = Obj % PhysicalCurveUID ( ii ) END DO DO ii = 1 , i ( 2 ) jj = ii + i ( 0 ) + i ( 1 ) Ans ( jj , 1 ) = 2 Ans ( jj , 2 ) = Obj % PhysicalSurfaceUID ( ii ) END DO DO ii = 1 , i ( 3 ) jj = ii + SUM ( i ( 0 : 2 ) ) Ans ( jj , 1 ) = 3 Ans ( jj , 2 ) = Obj % PhysicalVolumeUID ( ii ) END DO END SELECT END FUNCTION model_getPhysicalGroups","tags":"","loc":"proc/model_getphysicalgroups.html"},{"title":"model_getPhysicalGroupsForEntity – Fortran Program","text":"private function model_getPhysicalGroupsForEntity(Obj, dim, tag) result(Ans) Get the tags of the physical groups (if any) to which the model entity of\n dimension dim and tag tag belongs. Arguments Type Intent Optional Attributes Name class( gmshModel_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: dim integer(kind=I4B), intent(in) :: tag Return Value integer(kind=I4B),\n  ALLOCATABLE,(:) Contents Source Code model_getPhysicalGroupsForEntity Source Code FUNCTION model_getPhysicalGroupsForEntity ( Obj , dim , tag ) RESULT ( Ans ) CLASS ( gmshModel_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: dim , tag INTEGER ( I4B ), ALLOCATABLE :: Ans ( : ) ! define internal variables INTEGER ( I4B ) :: ii , n SELECT CASE ( dim ) CASE ( 0 ) IF ( . NOT . ALLOCATED ( Obj % geo % Point ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"          model_getPhysicalGroupsForEntity()\" ) CALL Display ( \"          Points are not added in geometry\" ) STOP END IF n = Obj % geo % tPoints DO ii = 1 , n IF ( Obj % geo % Point ( ii ) % ptr % uid . EQ . tag ) THEN CALL Convert ( From = Obj % Point_EntityToPhysical ( ii ) % Ptr , & & TO = Ans ) EXIT END IF END DO CASE ( 1 ) IF ( . NOT . ALLOCATED ( Obj % geo % Curve ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"          model_getPhysicalGroupsForEntity()\" ) CALL Display ( \"          Curves are not added in geometry\" ) STOP END IF n = Obj % geo % tCurves DO ii = 1 , n IF ( Obj % geo % Curve ( ii ) % ptr % uid . EQ . tag ) THEN CALL Convert ( From = Obj % Curve_EntityToPhysical ( ii ) % Ptr , & & TO = Ans ) EXIT END IF END DO CASE ( 2 ) IF ( . NOT . ALLOCATED ( Obj % geo % Surface ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"          model_getPhysicalGroupsForEntity()\" ) CALL Display ( \"          Surfaces are not added in geometry\" ) STOP END IF n = Obj % geo % tSurfaces DO ii = 1 , n IF ( Obj % geo % Surface ( ii ) % ptr % uid . EQ . tag ) THEN CALL Convert ( From = Obj % Surface_EntityToPhysical ( ii ) % Ptr , & & TO = Ans ) EXIT END IF END DO CASE ( 3 ) IF ( . NOT . ALLOCATED ( Obj % geo % Volume ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"          model_getPhysicalGroupsForEntity()\" ) CALL Display ( \"          Volumes are not added in geometry\" ) STOP END IF n = Obj % geo % tVolumes DO ii = 1 , n IF ( Obj % geo % Volume ( ii ) % ptr % uid . EQ . tag ) THEN CALL Convert ( From = Obj % Volume_EntityToPhysical ( ii ) % Ptr , & & TO = Ans ) EXIT END IF END DO END SELECT END FUNCTION model_getPhysicalGroupsForEntity","tags":"","loc":"proc/model_getphysicalgroupsforentity.html"},{"title":"model_getPhysicalName – Fortran Program","text":"private function model_getPhysicalName(Obj, dim, tag) result(Ans) Arguments Type Intent Optional Attributes Name class( gmshModel_ ), intent(in) :: Obj integer(kind=I4B) :: dim integer(kind=I4B) :: tag Return Value type(String) Contents Source Code model_getPhysicalName Source Code FUNCTION model_getPhysicalName ( Obj , dim , tag ) RESULT ( Ans ) CLASS ( gmshModel_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ) :: dim , tag TYPE ( String ) :: Ans INTEGER ( I4B ) :: ii , n SELECT CASE ( dim ) CASE ( 0 ) IF ( . NOT . ALLOCATED ( Obj % PhysicalPointName ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"          model_getPhysicalName()\" ) CALL Display ( \"          Physical Points are not set\" ) STOP END IF n = SIZE ( Obj % PhysicalPointName ) DO ii = 1 , n IF ( Obj % PhysicalPointUID ( ii ) . EQ . tag ) THEN Ans = Obj % PhysicalPointName ( ii ) EXIT END IF END DO CASE ( 1 ) IF ( . NOT . ALLOCATED ( Obj % PhysicalCurveName ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"          model_getPhysicalName()\" ) CALL Display ( \"          Physical Curves are not set\" ) STOP END IF n = SIZE ( Obj % PhysicalCurveName ) DO ii = 1 , n IF ( Obj % PhysicalCurveUID ( ii ) . EQ . tag ) THEN Ans = Obj % PhysicalCurveName ( ii ) EXIT END IF END DO CASE ( 2 ) IF ( . NOT . ALLOCATED ( Obj % PhysicalSurfaceName ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"          model_getPhysicalName()\" ) CALL Display ( \"          Physical Surfaces are not set\" ) STOP END IF n = SIZE ( Obj % PhysicalSurfaceName ) DO ii = 1 , n IF ( Obj % PhysicalSurfaceUID ( ii ) . EQ . tag ) THEN Ans = Obj % PhysicalSurfaceName ( ii ) EXIT END IF END DO CASE ( 3 ) IF ( . NOT . ALLOCATED ( Obj % PhysicalVolumeName ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"          model_getPhysicalName()\" ) CALL Display ( \"          Physical Volumes are not set\" ) STOP END IF n = SIZE ( Obj % PhysicalVolumeName ) DO ii = 1 , n IF ( Obj % PhysicalVolumeUID ( ii ) . EQ . tag ) THEN Ans = Obj % PhysicalVolumeName ( ii ) EXIT END IF END DO END SELECT END FUNCTION model_getPhysicalName","tags":"","loc":"proc/model_getphysicalname.html"},{"title":"model_setEntityName – Fortran Program","text":"private function model_setEntityName(Obj, dim, tag, name) result(Ans) Set the name of the entity of dimension dim and tag tag Arguments Type Intent Optional Attributes Name class( gmshModel_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: dim integer(kind=I4B), intent(in) :: tag character(len=*), intent(in) :: name Return Value integer(kind=I4B) Contents Source Code model_setEntityName Source Code FUNCTION model_setEntityName ( Obj , dim , tag , name ) RESULT ( Ans ) CLASS ( gmshModel_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: dim , tag CHARACTER ( LEN = * ), INTENT ( IN ) :: name INTEGER ( I4B ) :: Ans !internal variables INTEGER ( I4B ) :: ii SELECT CASE ( dim ) CASE ( 0 ) DO ii = 1 , obj % geo % tPoints IF ( obj % geo % point ( ii ) % ptr % uid . EQ . tag ) THEN obj % EntityPointName ( ii ) = name END IF END DO CASE ( 1 ) DO ii = 1 , obj % geo % tCurves IF ( obj % geo % Curve ( ii ) % ptr % uid . EQ . tag ) THEN obj % EntityCurveName ( ii ) = name END IF END DO CASE ( 2 ) DO ii = 1 , obj % geo % tSurfaces IF ( obj % geo % Surface ( ii ) % ptr % uid . EQ . tag ) THEN obj % EntitySurfaceName ( ii ) = name END IF END DO CASE ( 3 ) DO ii = 1 , obj % geo % tVolumes IF ( obj % geo % Volume ( ii ) % ptr % uid . EQ . tag ) THEN obj % EntityVolumeName ( ii ) = name END IF END DO END SELECT END FUNCTION model_setEntityName","tags":"","loc":"proc/model_setentityname.html"},{"title":"model_setPhysicalName – Fortran Program","text":"private function model_setPhysicalName(Obj, dim, tag, name) result(Ans) Set the name of the physical group of dimension dim and tag tag. Arguments Type Intent Optional Attributes Name class( gmshModel_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: dim integer(kind=I4B), intent(in) :: tag character(len=*), intent(in) :: name Return Value integer(kind=I4B) Contents Source Code model_setPhysicalName Source Code FUNCTION model_setPhysicalName ( Obj , dim , tag , name ) RESULT ( Ans ) CLASS ( gmshModel_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: dim , tag CHARACTER ( LEN = * ), INTENT ( IN ) :: name INTEGER ( I4B ) :: Ans ! internal varialbles INTEGER ( I4B ) :: ii , n TYPE ( String ), ALLOCATABLE :: s ( : ) TYPE ( String ) :: ss INTEGER ( I4B ), ALLOCATABLE :: tags ( : ) Ans = 0 SELECT CASE ( dim ) CASE ( 0 ) IF ( . NOT . ALLOCATED ( Obj % PhysicalPointName ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"          model_setPhysicalName()\" ) CALL Display ( \"          Physical Points are not set\" ) STOP END IF n = SIZE ( Obj % PhysicalPointName ) DO ii = 1 , n IF ( Obj % PhysicalPointUID ( ii ) . EQ . tag ) THEN Obj % PhysicalPointName ( ii ) = trim ( name ) CALL Convert ( From = Obj % Point_PhysicalToEntity ( ii ) % ptr , & & To = tags ) EXIT END IF END DO IF ( . NOT . ALLOCATED ( tags ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"          model_setPhysicalName()\" ) CALL Display ( \"          Given dim tag not found\" ) STOP END IF n = SIZE ( tags ) ALLOCATE ( s ( n ) ) DO ii = 1 , n s ( ii ) = trim ( str ( tags ( ii ), no_sign = . true . ) ) END DO ss = ss % join ( s , sep = \", \" ) ss = & & \"Physical Point( \" // & & '\"' // trim ( name ) // '\"' // & & \", \" // & & trim ( str ( tag , no_sign = . true . ) ) // & & \" ) = { \" // & & trim ( ss ) // & & \" };\" DEALLOCATE ( s , tags ) ! CALL Display( \"gmsh%model:: adding physical point to buffer\") CALL APPEND ( Obj % geo % buffer , ss ) CASE ( 1 ) IF ( . NOT . ALLOCATED ( Obj % PhysicalCurveName ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"          model_setPhysicalName()\" ) CALL Display ( \"          Physical Curves are not set\" ) STOP END IF n = SIZE ( Obj % PhysicalCurveName ) DO ii = 1 , n IF ( Obj % PhysicalCurveUID ( ii ) . EQ . tag ) THEN Obj % PhysicalCurveName ( ii ) = trim ( name ) CALL Convert ( From = Obj % Curve_PhysicalToEntity ( ii ) % ptr , & & To = tags ) EXIT END IF END DO IF ( . NOT . ALLOCATED ( tags ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"          model_setPhysicalName()\" ) CALL Display ( \"          Given dim tag not found\" ) STOP END IF n = SIZE ( tags ) ALLOCATE ( s ( n ) ) DO ii = 1 , n s ( ii ) = trim ( str ( tags ( ii ), no_sign = . true . ) ) END DO ss = ss % join ( s , sep = \", \" ) ss = & & \"Physical Curve( \" // & & '\"' // trim ( name ) // '\"' // & & \", \" // & & trim ( str ( tag , no_sign = . true . ) ) // & & \" ) = { \" // & & trim ( ss ) // & & \" };\" DEALLOCATE ( s , tags ) ! CALL Display( \"gmsh%model:: adding physical curve to buffer\") CALL APPEND ( Obj % geo % buffer , ss ) CASE ( 2 ) IF ( . NOT . ALLOCATED ( Obj % PhysicalSurfaceName ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"          model_setPhysicalName()\" ) CALL Display ( \"          Physical Surfaces are not set\" ) STOP END IF n = SIZE ( Obj % PhysicalSurfaceName ) DO ii = 1 , n IF ( Obj % PhysicalSurfaceUID ( ii ) . EQ . tag ) THEN Obj % PhysicalSurfaceName ( ii ) = trim ( name ) CALL Convert ( From = Obj % Surface_PhysicalToEntity ( ii ) % ptr , & & To = tags ) EXIT END IF END DO IF ( . NOT . ALLOCATED ( tags ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"          model_setPhysicalName()\" ) CALL Display ( \"          Given dim tag not found\" ) STOP END IF n = SIZE ( tags ) ALLOCATE ( s ( n ) ) DO ii = 1 , n s ( ii ) = trim ( str ( tags ( ii ), no_sign = . true . ) ) END DO ss = ss % join ( s , sep = \", \" ) ss = & & \"Physical Surface( \" // & & '\"' // trim ( name ) // '\"' // & & \", \" // & & trim ( str ( tag , no_sign = . true . ) ) // & & \" ) = { \" // & & trim ( ss ) // & & \" };\" DEALLOCATE ( s , tags ) ! CALL Display( \"gmsh%model:: adding physical surface to buffer\") CALL APPEND ( Obj % geo % buffer , ss ) CASE ( 3 ) IF ( . NOT . ALLOCATED ( Obj % PhysicalVolumeName ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"          model_setPhysicalName()\" ) CALL Display ( \"          Physical Volumes are not set\" ) STOP END IF n = SIZE ( Obj % PhysicalVolumeName ) DO ii = 1 , n IF ( Obj % PhysicalVolumeUID ( ii ) . EQ . tag ) THEN Obj % PhysicalVolumeName ( ii ) = trim ( name ) CALL Convert ( From = Obj % Volume_PhysicalToEntity ( ii ) % ptr , & & To = tags ) EXIT END IF END DO IF ( . NOT . ALLOCATED ( tags ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"          model_setPhysicalName()\" ) CALL Display ( \"          Given dim tag not found\" ) STOP END IF n = SIZE ( tags ) ALLOCATE ( s ( n ) ) DO ii = 1 , n s ( ii ) = trim ( str ( tags ( ii ), no_sign = . true . ) ) END DO ss = ss % join ( s , sep = \", \" ) ss = & & \"Physical Volume( \" // & & '\"' // trim ( name ) // '\"' // & & \", \" // & & trim ( str ( tag , no_sign = . true . ) ) // & & \" ) = { \" // & & trim ( ss ) // & & \" };\" DEALLOCATE ( s , tags ) ! WRITE( obj % buffer % unitno, \"(DT)\" ) ss ! CALL Display( \"gmsh%model:: adding physical volume to buffer\") CALL APPEND ( Obj % geo % buffer , ss ) END SELECT END FUNCTION model_setPhysicalName","tags":"","loc":"proc/model_setphysicalname.html"},{"title":"model_write – Fortran Program","text":"private function model_write(Obj, UnitNo) result(Ans) Arguments Type Intent Optional Attributes Name class( gmshModel_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: UnitNo Return Value integer(kind=I4B) Contents Source Code model_write Source Code FUNCTION model_write ( Obj , UnitNo ) RESULT ( Ans ) CLASS ( gmshModel_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: UnitNo INTEGER ( I4B ) :: Ans ! internal variables INTEGER ( I4B ) :: ii Ans = 0 IF ( . NOT . ASSOCIATED ( Obj % geo ) ) THEN CALL Display ( \"ERROR:: gmshModel_Class.f90\" ) CALL Display ( \"        Model_write()\" ) CALL Display ( \"          Obj % geo not allocated\" ) STOP END IF ! CALL Display( \"gmsh%model:: calling gmsh%model%geo%write()\" ) Ans = Obj % geo % write ( UnitNo ) IF ( ASSOCIATED ( Obj % buffer ) ) THEN ! CALL Display( \"gmsh%model:: writing gmsh%model%buffer()\" ) DO ii = 1 , Obj % Buffer % tLine WRITE ( UnitNo , \"(DT)\" ) Obj % Buffer % Line ( ii ) % Ptr END DO END IF IF ( ASSOCIATED ( Obj % geo % mesh ) ) THEN ! CALL Display( \"gmsh%model:: calling gmsh%model%geo%mesh%write()\" ) Ans = Obj % geo % mesh % write ( UnitNo ) END IF IF ( ASSOCIATED ( Obj % mesh ) ) THEN ! CALL Display( \"gmsh%model:: calling gmsh%model%mesh%write()\" ) Ans = Obj % mesh % write ( UnitNo ) END IF END FUNCTION model_write","tags":"","loc":"proc/model_write.html"},{"title":"ExpSFCC_PhaseInfo – Fortran Program","text":"interface private pure function ExpSFCC_PhaseInfo(Obj, Temp) result(Ans) Arguments Type Intent Optional Attributes Name class( SFCCModel_ ), intent(in) :: Obj real(kind=DFP), intent(in) :: Temp Return Value character(len=1)","tags":"","loc":"interface/expsfcc_phaseinfo.html"},{"title":"ExpSFCC_Pointer – Fortran Program","text":"interface public function ExpSFCC_Pointer(Theta_r, Theta_w, Temp_l, Temp_s, Coeff) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Theta_r real(kind=DFP), intent(in) :: Theta_w real(kind=DFP), intent(in) :: Temp_l real(kind=DFP), intent(in) :: Temp_s real(kind=DFP), intent(in), optional :: Coeff Return Value class( ExpSFCC_ ),\n  POINTER","tags":"","loc":"interface/expsfcc_pointer.html"},{"title":"ExpSFCC_get_slope – Fortran Program","text":"interface private pure function ExpSFCC_get_slope(Obj, Temp) result(Ans) Arguments Type Intent Optional Attributes Name class( SFCCModel_ ), intent(in) :: Obj real(kind=DFP), intent(in) :: Temp Return Value real(kind=DFP)","tags":"","loc":"interface/expsfcc_get_slope.html"},{"title":"ExpSFCC_get_val – Fortran Program","text":"interface private pure function ExpSFCC_get_val(Obj, Temp) result(Ans) Arguments Type Intent Optional Attributes Name class( SFCCModel_ ), intent(in) :: Obj real(kind=DFP), intent(in) :: Temp Return Value real(kind=DFP)","tags":"","loc":"interface/expsfcc_get_val.html"},{"title":"UserSFCC_Pointer – Fortran Program","text":"interface public function UserSFCC_Pointer() result(Ans) Arguments None Return Value class( UserSFCC_ ),\n  POINTER","tags":"","loc":"interface/usersfcc_pointer.html"},{"title":"MixVolHeatCap_Pointer – Fortran Program","text":"interface public function MixVolHeatCap_Pointer(volHeatCap_solid, SoilState) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), optional :: volHeatCap_solid integer(kind=I4B), optional :: SoilState Return Value class( MixVolHeatCap_ ),\n  POINTER","tags":"","loc":"interface/mixvolheatcap_pointer.html"},{"title":"UserVolHeatCap_Pointer – Fortran Program","text":"interface public function UserVolHeatCap_Pointer() result(Ans) Arguments None Return Value class( UserVolHeatCap_ ),\n  POINTER","tags":"","loc":"interface/uservolheatcap_pointer.html"},{"title":"mixvolheatcap_getval – Fortran Program","text":"interface This function returns the volumetric heat capacity values private pure function mixvolheatcap_getval(Obj, volFrac_solid, volFrac_water, volFrac_ice, volFrac_air, Temp, x, y, z) result(Ans) Arguments Type Intent Optional Attributes Name class( VolHeatCapModel_ ), intent(in) :: Obj real(kind=DFP), intent(in), optional :: volFrac_solid real(kind=DFP), intent(in), optional :: volFrac_water real(kind=DFP), intent(in), optional :: volFrac_ice real(kind=DFP), intent(in), optional :: volFrac_air real(kind=DFP), intent(in), optional :: Temp real(kind=DFP), intent(in), optional :: x real(kind=DFP), intent(in), optional :: y real(kind=DFP), intent(in), optional :: z Return Value real(kind=DFP)","tags":"","loc":"interface/mixvolheatcap_getval.html"},{"title":"userVolHeatCap_getval – Fortran Program","text":"interface This function returns the volumetric heat capacity values private pure function userVolHeatCap_getval(Obj, volFrac_solid, volFrac_water, volFrac_ice, volFrac_air, Temp, x, y, z) result(Ans) Arguments Type Intent Optional Attributes Name class( VolHeatCapModel_ ), intent(in) :: Obj real(kind=DFP), intent(in), optional :: volFrac_solid real(kind=DFP), intent(in), optional :: volFrac_water real(kind=DFP), intent(in), optional :: volFrac_ice real(kind=DFP), intent(in), optional :: volFrac_air real(kind=DFP), intent(in), optional :: Temp real(kind=DFP), intent(in), optional :: x real(kind=DFP), intent(in), optional :: y real(kind=DFP), intent(in), optional :: z Return Value real(kind=DFP)","tags":"","loc":"interface/uservolheatcap_getval.html"},{"title":"JohansenThermCond_Pointer – Fortran Program","text":"interface public function JohansenThermCond_Pointer(Lambda_Sat, Lambda_Dry, Lambda_e, Gamma_d, QuartzContent, SoilState, SoilType) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), optional :: Lambda_Sat real(kind=DFP), optional :: Lambda_Dry real(kind=DFP), optional :: Lambda_e real(kind=DFP), optional :: Gamma_d real(kind=DFP), optional :: QuartzContent integer(kind=I4B), optional :: SoilState integer(kind=I4B), optional :: SoilType Return Value class( JohansenThermCond_ ),\n  POINTER","tags":"","loc":"interface/johansenthermcond_pointer.html"},{"title":"UserThermCond_Pointer – Fortran Program","text":"interface public function UserThermCond_Pointer() result(Ans) Arguments None Return Value class( UserThermCond_ ),\n  POINTER","tags":"","loc":"interface/userthermcond_pointer.html"},{"title":"UserThermCond_getval – Fortran Program","text":"interface This function returns the thermal conductivity values private pure function UserThermCond_getval(Obj, volFrac_solid, volFrac_water, volFrac_ice, volFrac_air, Temp, x, y, z) result(Ans) Arguments Type Intent Optional Attributes Name class( ThermCondModel_ ), intent(in) :: Obj real(kind=DFP), intent(in), optional :: volFrac_solid real(kind=DFP), intent(in), optional :: volFrac_water real(kind=DFP), intent(in), optional :: volFrac_ice real(kind=DFP), intent(in), optional :: volFrac_air real(kind=DFP), intent(in), optional :: Temp real(kind=DFP), intent(in), optional :: x real(kind=DFP), intent(in), optional :: y real(kind=DFP), intent(in), optional :: z Return Value real(kind=DFP) Description This function returns the thermal conductivity values\n - volFrac contains volumetric fraction of solid, water, ice, air","tags":"","loc":"interface/userthermcond_getval.html"},{"title":"johansen_getval – Fortran Program","text":"interface This function returns the thermal conductivity values private pure function johansen_getval(Obj, volFrac_solid, volFrac_water, volFrac_ice, volFrac_air, Temp, x, y, z) result(Ans) Arguments Type Intent Optional Attributes Name class( ThermCondModel_ ), intent(in) :: Obj real(kind=DFP), intent(in), optional :: volFrac_solid real(kind=DFP), intent(in), optional :: volFrac_water real(kind=DFP), intent(in), optional :: volFrac_ice real(kind=DFP), intent(in), optional :: volFrac_air real(kind=DFP), intent(in), optional :: Temp real(kind=DFP), intent(in), optional :: x real(kind=DFP), intent(in), optional :: y real(kind=DFP), intent(in), optional :: z Return Value real(kind=DFP) Description This function returns the thermal conductivity values\n - volFrac contains volumetric fraction of solid, water, ice, air","tags":"","loc":"interface/johansen_getval.html"},{"title":"DeallocateData – Fortran Program","text":"public interface DeallocateData Contents Module Procedures skit_deallocatedata Module Procedures private interface skit_deallocatedata () Arguments None","tags":"","loc":"interface/deallocatedata~15.html"},{"title":"DeallocateData – Fortran Program","text":"private interface DeallocateData Contents Module Procedures lis_deallocatedata Module Procedures private interface lis_deallocatedata () Arguments None","tags":"","loc":"interface/deallocatedata~16.html"},{"title":"Display – Fortran Program","text":"public interface Display Contents Module Procedures skit_display Module Procedures private interface skit_display () Arguments None","tags":"","loc":"interface/display~12.html"},{"title":"Display – Fortran Program","text":"private interface Display Contents Module Procedures lis_display Module Procedures private interface lis_display () Arguments None","tags":"","loc":"interface/display~13.html"},{"title":"Initiate – Fortran Program","text":"public interface Initiate Generic subroutine to initiate Sparsekit_ Contents Module Procedures skit_initiate Module Procedures private interface skit_initiate () Initiate Sparsekit_ Arguments None","tags":"","loc":"interface/initiate~7.html"},{"title":"Initiate – Fortran Program","text":"private interface Initiate Contents Module Procedures lis_initiate Module Procedures private interface lis_initiate () — fpar( 1 ) : contains value of omega Arguments None","tags":"","loc":"interface/initiate~8.html"},{"title":"lis_deallocatedata – Fortran Program","text":"interface private subroutine lis_deallocatedata(Obj) Arguments Type Intent Optional Attributes Name class( LIS_ ), intent(inout) :: Obj","tags":"","loc":"interface/lis_deallocatedata.html"},{"title":"lis_display – Fortran Program","text":"interface private subroutine lis_display(Obj, msg, unitno) Arguments Type Intent Optional Attributes Name class( LIS_ ), intent(in) :: Obj character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitno","tags":"","loc":"interface/lis_display.html"},{"title":"lis_initiate – Fortran Program","text":"interface — fpar( 1 ) : contains value of omega private subroutine lis_initiate(Obj, SolverName, MaxIter, Tol, diagScale, ipar, fpar) Arguments Type Intent Optional Attributes Name class( LIS_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: SolverName integer(kind=I4B), intent(in) :: MaxIter real(kind=DFP), intent(in) :: Tol integer(kind=I4B), intent(in), optional :: diagScale integer(kind=I4B), intent(in), optional :: ipar (:) real(kind=DFP), intent(in), optional :: fpar (:)","tags":"","loc":"interface/lis_initiate.html"},{"title":"lis_setDBC_1 – Fortran Program","text":"interface private subroutine lis_setDBC_1(Obj, Nptrs, dofs) Arguments Type Intent Optional Attributes Name class( LIS_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Nptrs (:) integer(kind=I4B), intent(in) :: dofs (:)","tags":"","loc":"interface/lis_setdbc_1.html"},{"title":"lis_setDBC_2 – Fortran Program","text":"interface private subroutine lis_setDBC_2(Obj, Nptrs, dofs) Arguments Type Intent Optional Attributes Name class( LIS_ ), intent(inout) :: Obj type(IntVector_), intent(in) :: Nptrs (:) integer(kind=I4B), intent(in) :: dofs (:)","tags":"","loc":"interface/lis_setdbc_2.html"},{"title":"lis_set_sparsity – Fortran Program","text":"interface — set all values of lis_rhs and lis_sol to zero\n— set csr private subroutine lis_set_sparsity(From, To) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(in), TARGET :: From class( LIS_ ), intent(inout) :: To","tags":"","loc":"interface/lis_set_sparsity.html"},{"title":"lis_setmatrix – Fortran Program","text":"interface private subroutine lis_setmatrix(From, To) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(in), TARGET :: From class( LIS_ ), intent(inout) :: To","tags":"","loc":"interface/lis_setmatrix.html"},{"title":"lis_setprecond – Fortran Program","text":"interface private subroutine lis_setprecond(Obj, precondtype, ipar, fpar) Arguments Type Intent Optional Attributes Name class( LIS_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: precondtype integer(kind=I4B), intent(in), optional :: ipar (:) real(kind=DFP), intent(in), optional :: fpar (:)","tags":"","loc":"interface/lis_setprecond.html"},{"title":"lis_solve_1 – Fortran Program","text":"interface private subroutine lis_solve_1(Obj, sol, rhs) Arguments Type Intent Optional Attributes Name class( LIS_ ), intent(inout) :: Obj real(kind=DFP), intent(inout) :: sol (:) real(kind=DFP), intent(inout) :: rhs (:)","tags":"","loc":"interface/lis_solve_1.html"},{"title":"lis_write_res_his – Fortran Program","text":"interface private subroutine lis_write_res_his(Obj, path, prefix, fmt, iter) Arguments Type Intent Optional Attributes Name class( LIS_ ), intent(in) :: Obj character(len=*), intent(in) :: path character(len=*), intent(in) :: prefix character(len=*), intent(in) :: fmt integer(kind=I4B), intent(in), optional :: iter","tags":"","loc":"interface/lis_write_res_his.html"},{"title":"skit_deallocatedata – Fortran Program","text":"interface private subroutine skit_deallocatedata(Obj) Arguments Type Intent Optional Attributes Name class( Sparsekit_ ), intent(inout) :: Obj","tags":"","loc":"interface/skit_deallocatedata.html"},{"title":"skit_display – Fortran Program","text":"interface private subroutine skit_display(Obj, msg, Unitno) Arguments Type Intent Optional Attributes Name class( Sparsekit_ ), intent(in) :: Obj character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: Unitno","tags":"","loc":"interface/skit_display.html"},{"title":"skit_initiate – Fortran Program","text":"interface Initiate Sparsekit_ private subroutine skit_initiate(Obj, SolverName, MaxIter, Tol, diagScale, ipar, fpar) Arguments Type Intent Optional Attributes Name class( Sparsekit_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: SolverName integer(kind=I4B), intent(in) :: MaxIter real(kind=DFP), intent(in) :: Tol integer(kind=I4B), intent(in), optional :: diagScale integer(kind=I4B), intent(in), optional :: ipar (:) real(kind=DFP), intent(in), optional :: fpar (:) Description This subroutine initiate the Sparsekit_ object It sets the name of the solver It sets the parameters related to the solver If name of the solver is lis_gmres , lis_fgmres , lis_dqgmres ,\n or lis_om then ipar(1) denotes the number of restarts required in\n these algorithms. Default value is set to 20.","tags":"","loc":"interface/skit_initiate.html"},{"title":"skit_setDBC_1 – Fortran Program","text":"interface set Dirichlet boundary condition information private subroutine skit_setDBC_1(Obj, Nptrs, dofs) Arguments Type Intent Optional Attributes Name class( Sparsekit_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Nptrs (:) integer(kind=I4B), intent(in) :: dofs (:) Description This subroutine set the Dirichlet boundary condition in the linear solver\n In this case all DOFs have the same dirichlet nodes pointers Nptrs denotes the dirichlet node numbers storageFMT can be DOF_FMT or Nodes_FMT","tags":"","loc":"interface/skit_setdbc_1.html"},{"title":"skit_setDBC_2 – Fortran Program","text":"interface set Dirichlet boundary condition information private subroutine skit_setDBC_2(Obj, Nptrs, dofs) Arguments Type Intent Optional Attributes Name class( Sparsekit_ ), intent(inout) :: Obj type(IntVector_), intent(in) :: Nptrs (:) integer(kind=I4B), intent(in) :: dofs (:)","tags":"","loc":"interface/skit_setdbc_2.html"},{"title":"skit_set_sparsity – Fortran Program","text":"interface Set sparsity pattern in Sparsekit_ private subroutine skit_set_sparsity(From, To) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(in), TARGET :: From class( Sparsekit_ ), intent(inout) :: To Description This subroutine set the sparsity pattern in Sparsekit_","tags":"","loc":"interface/skit_set_sparsity.html"},{"title":"skit_setmatrix – Fortran Program","text":"interface set Matrix private subroutine skit_setmatrix(From, To) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(in), TARGET :: From class( Sparsekit_ ), intent(inout) :: To","tags":"","loc":"interface/skit_setmatrix.html"},{"title":"skit_setprecond – Fortran Program","text":"interface Set preconditioners in Sparsekit_ private subroutine skit_setprecond(Obj, precondtype, ipar, fpar) Arguments Type Intent Optional Attributes Name class( Sparsekit_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: precondtype integer(kind=I4B), intent(in), optional :: ipar (:) real(kind=DFP), intent(in), optional :: fpar (:) Description This subroutine set the preconditioner required to solve system of\n linear equations by using the For precondType=p_ilut ipar( 1 ) denotes number of fills and fpar(1) denotes the dropping tolerance For p_ilutp : ipar(1) number of fills default is 10 ipar(2) mbloc, default is size of problem fpar(1) drop tolerance, default is 1.0E-4 fpar(2) permutation tolerance, default is 0.5 For p_ilud fpar(1) denotes drop tolerance fpar(2) denotes value of alpha For p_iludp ipar(1) denotes mbloc fpar(1) denotes drop tolerance fpar(2) denotes value of alpha fpar(3) denotes permutation tolerance","tags":"","loc":"interface/skit_setprecond.html"},{"title":"skit_solve – Fortran Program","text":"interface private subroutine skit_solve(Obj, sol, rhs) Arguments Type Intent Optional Attributes Name class( Sparsekit_ ), intent(inout) :: Obj real(kind=DFP), intent(inout) :: sol (:) real(kind=DFP), intent(inout) :: rhs (:)","tags":"","loc":"interface/skit_solve.html"},{"title":"skit_write_res_his – Fortran Program","text":"interface private subroutine skit_write_res_his(Obj, path, prefix, fmt, iter) Arguments Type Intent Optional Attributes Name class( Sparsekit_ ), intent(in) :: Obj character(len=*), intent(in) :: path character(len=*), intent(in) :: prefix character(len=*), intent(in) :: fmt integer(kind=I4B), intent(in), optional :: iter","tags":"","loc":"interface/skit_write_res_his.html"},{"title":"Display – Fortran Program","text":"public interface Display Contents Module Procedures soil_display Module Procedures private interface soil_display () Arguments None","tags":"","loc":"interface/display~14.html"},{"title":"Soil – Fortran Program","text":"public interface Soil Contents Module Procedures Soil_Constructor Module Procedures private interface Soil_Constructor () Arguments None","tags":"","loc":"interface/soil.html"},{"title":"Soil_Constructor – Fortran Program","text":"interface private function Soil_Constructor(State, SoilType, Gravel, Sand, Silt, Clay, OrganicMatter, SpecificGravity, DryDensity, Gravimetric_Moisture, Porosity, voidRatio, volFrac_solid, volFrac_water, volFrac_ice, volFrac_air, Minerals, Lambda_sat, Lambda_dry, Lambda_e, ThermCondModel, ThermCondVal, UserThermCond, volHeatCap_solid, volHeatCapModel, volHeatCapVal, UservolHeatCap, SFCCModel, UserSFCC_Value, UserSFCC_Slope, SFCC_Theta_r, SFCC_Temp_l, SFCC_Temp_s, SFCC_Coeff) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), optional :: State integer(kind=I4B), intent(in), optional :: SoilType real(kind=DFP), intent(in), optional :: Gravel real(kind=DFP), intent(in), optional :: Sand real(kind=DFP), intent(in), optional :: Silt real(kind=DFP), intent(in), optional :: Clay real(kind=DFP), intent(in), optional :: OrganicMatter real(kind=DFP), intent(in), optional :: SpecificGravity real(kind=DFP), intent(in), optional :: DryDensity real(kind=DFP), intent(in), optional :: Gravimetric_Moisture real(kind=DFP), intent(in), optional :: Porosity real(kind=DFP), intent(in), optional :: voidRatio real(kind=DFP), intent(in), optional :: volFrac_solid real(kind=DFP), intent(in), optional :: volFrac_water real(kind=DFP), intent(in), optional :: volFrac_ice real(kind=DFP), intent(in), optional :: volFrac_air real(kind=DFP), intent(in), optional :: Minerals (:) real(kind=DFP), intent(in), optional :: Lambda_sat real(kind=DFP), intent(in), optional :: Lambda_dry real(kind=DFP), intent(in), optional :: Lambda_e integer(kind=I4B), intent(in), optional :: ThermCondModel real(kind=DFP), intent(in), optional :: ThermCondVal procedure( thermcond_get_value ), intent(in), optional POINTER :: UserThermCond real(kind=DFP), intent(in), optional :: volHeatCap_solid integer(kind=I4B), intent(in), optional :: volHeatCapModel real(kind=DFP), intent(in), optional :: volHeatCapVal procedure( volHeatCap_get_value ), intent(in), optional POINTER :: UservolHeatCap integer(kind=I4B), intent(in), optional :: SFCCModel procedure( sfcc_get_value ), intent(in), optional POINTER :: UserSFCC_Value procedure( sfcc_get_value ), intent(in), optional POINTER :: UserSFCC_Slope real(kind=DFP), intent(in), optional :: SFCC_Theta_r real(kind=DFP), intent(in), optional :: SFCC_Temp_l real(kind=DFP), intent(in), optional :: SFCC_Temp_s real(kind=DFP), intent(in), optional :: SFCC_Coeff Return Value type( Soil_ )","tags":"","loc":"interface/soil_constructor.html"},{"title":"soil_display – Fortran Program","text":"interface private subroutine soil_display(Obj, msg, unitNo) Arguments Type Intent Optional Attributes Name class( Soil_ ), intent(in) :: Obj character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitNo","tags":"","loc":"interface/soil_display.html"},{"title":"SpecificHeatCap_Air – Fortran Program","text":"public pure function SpecificHeatCap_Air(Temp, Pressure) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in), optional :: Temp real(kind=DFP), intent(in), optional :: Pressure Return Value real(kind=DFP) Contents None","tags":"","loc":"proc/specificheatcap_air.html"},{"title":"SpecificHeatCap_Quartz – Fortran Program","text":"public pure function SpecificHeatCap_Quartz(Temp, Pressure) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in), optional :: Temp real(kind=DFP), intent(in), optional :: Pressure Return Value real(kind=DFP) Contents None","tags":"","loc":"proc/specificheatcap_quartz.html"},{"title":"ThermCond_Air – Fortran Program","text":"public pure function ThermCond_Air(Temp, Pressure) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in), optional :: Temp real(kind=DFP), intent(in), optional :: Pressure Return Value real(kind=DFP) Contents None","tags":"","loc":"proc/thermcond_air.html"},{"title":"ThermCond_Quartz – Fortran Program","text":"public pure function ThermCond_Quartz(Temp, Pressure) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in), optional :: Temp real(kind=DFP), intent(in), optional :: Pressure Return Value real(kind=DFP) Contents None","tags":"","loc":"proc/thermcond_quartz.html"},{"title":"density_ice – Fortran Program","text":"public pure function density_ice(Temp, Pressure) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in), optional :: Temp real(kind=DFP), intent(in), optional :: Pressure Return Value real(kind=DFP) Contents None","tags":"","loc":"proc/density_ice.html"},{"title":"density_water – Fortran Program","text":"public pure function density_water(Temp, Pressure) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in), optional :: Temp real(kind=DFP), intent(in), optional :: Pressure Return Value real(kind=DFP) internal variables Contents None","tags":"","loc":"proc/density_water.html"},{"title":"density_water_Temp_Pressure – Fortran Program","text":"public pure function density_water_Temp_Pressure(Temp, Pressure) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Temp real(kind=DFP), intent(in) :: Pressure Return Value real(kind=DFP) Contents None","tags":"","loc":"proc/density_water_temp_pressure.html"},{"title":"density_water_pressure – Fortran Program","text":"public pure function density_water_pressure(Pressure) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Pressure Return Value real(kind=DFP) Contents None","tags":"","loc":"proc/density_water_pressure.html"},{"title":"density_water_temp – Fortran Program","text":"public pure function density_water_temp(Temp) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Temp Return Value real(kind=DFP) Contents None","tags":"","loc":"proc/density_water_temp.html"},{"title":"specificHeatCap_ice – Fortran Program","text":"public pure function specificHeatCap_ice(Temp, Pressure) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in), optional :: Temp real(kind=DFP), intent(in), optional :: Pressure Return Value real(kind=DFP) Contents None","tags":"","loc":"proc/specificheatcap_ice.html"},{"title":"specificHeatCap_water – Fortran Program","text":"public pure function specificHeatCap_water(Temp, Pressure) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in), optional :: Temp real(kind=DFP), intent(in), optional :: Pressure Return Value real(kind=DFP) internal variables Contents None","tags":"","loc":"proc/specificheatcap_water.html"},{"title":"specificHeatCap_water_Temp – Fortran Program","text":"public pure function specificHeatCap_water_Temp(Temp) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Temp Return Value real(kind=DFP) Contents None","tags":"","loc":"proc/specificheatcap_water_temp.html"},{"title":"specificHeatCap_water_Temp_Pressure – Fortran Program","text":"public pure function specificHeatCap_water_Temp_Pressure(Temp, Pressure) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Temp real(kind=DFP), intent(in) :: Pressure Return Value real(kind=DFP) Contents None","tags":"","loc":"proc/specificheatcap_water_temp_pressure.html"},{"title":"specificHeatCap_water_pressure – Fortran Program","text":"public pure function specificHeatCap_water_pressure(Pressure) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Pressure Return Value real(kind=DFP) Contents None","tags":"","loc":"proc/specificheatcap_water_pressure.html"},{"title":"thermCond_ice – Fortran Program","text":"public pure function thermCond_ice(Temp, Pressure) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in), optional :: Temp real(kind=DFP), intent(in), optional :: Pressure Return Value real(kind=DFP) Contents None","tags":"","loc":"proc/thermcond_ice.html"},{"title":"thermCond_water – Fortran Program","text":"public pure function thermCond_water(Temp, Pressure) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in), optional :: Temp real(kind=DFP), intent(in), optional :: Pressure Return Value real(kind=DFP) internal variables Contents None","tags":"","loc":"proc/thermcond_water.html"},{"title":"thermCond_water_Temp – Fortran Program","text":"public pure function thermCond_water_Temp(Temp) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Temp Return Value real(kind=DFP) Contents None","tags":"","loc":"proc/thermcond_water_temp.html"},{"title":"thermCond_water_Temp_Pressure – Fortran Program","text":"public pure function thermCond_water_Temp_Pressure(Temp, Pressure) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Temp real(kind=DFP), intent(in) :: Pressure Return Value real(kind=DFP) Contents None","tags":"","loc":"proc/thermcond_water_temp_pressure.html"},{"title":"thermCond_water_pressure – Fortran Program","text":"public pure function thermCond_water_pressure(Pressure) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Pressure Return Value real(kind=DFP) Contents None","tags":"","loc":"proc/thermcond_water_pressure.html"},{"title":"volHeatCap_Air – Fortran Program","text":"public pure function volHeatCap_Air(Temp, Pressure) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in), optional :: Temp real(kind=DFP), intent(in), optional :: Pressure Return Value real(kind=DFP) Contents None","tags":"","loc":"proc/volheatcap_air.html"},{"title":"volHeatCap_Quartz – Fortran Program","text":"public pure function volHeatCap_Quartz(Temp, Pressure) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in), optional :: Temp real(kind=DFP), intent(in), optional :: Pressure Return Value real(kind=DFP) Contents None","tags":"","loc":"proc/volheatcap_quartz.html"},{"title":"volHeatCap_ice – Fortran Program","text":"public pure function volHeatCap_ice(Temp, Pressure) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in), optional :: Temp real(kind=DFP), intent(in), optional :: Pressure Return Value real(kind=DFP) Contents None","tags":"","loc":"proc/volheatcap_ice.html"},{"title":"volHeatCap_water – Fortran Program","text":"public pure function volHeatCap_water(Temp, Pressure) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in), optional :: Temp real(kind=DFP), intent(in), optional :: Pressure Return Value real(kind=DFP) internal variables Contents None","tags":"","loc":"proc/volheatcap_water.html"},{"title":"DeallocateData – Fortran Program","text":"public interface DeallocateData Contents Module Procedures mat_deallocate Module Procedures private interface mat_deallocate () Deallocate data stored in Material_ Arguments None","tags":"","loc":"interface/deallocatedata~17.html"},{"title":"Display – Fortran Program","text":"public interface Display Contents Module Procedures mat_display mat_display_vec Module Procedures private interface mat_display () Arguments None private interface mat_display_vec () Arguments None","tags":"","loc":"interface/display~15.html"},{"title":"Initiate – Fortran Program","text":"public interface Initiate Generic subroutine to construct Material_ Contents Module Procedures mat_initiate Module Procedures private interface mat_initiate () Subroutine that constructs Material_ Arguments None","tags":"","loc":"interface/initiate~9.html"},{"title":"mat_append – Fortran Program","text":"interface Append keyval object to Material_ private subroutine mat_append(Obj, KeyValObj) Arguments Type Intent Optional Attributes Name class( Material_ ), intent(inout) :: Obj type(KeyValue_), intent(in) :: KeyValObj","tags":"","loc":"interface/mat_append.html"},{"title":"mat_deallocate – Fortran Program","text":"interface Deallocate data stored in Material_ private subroutine mat_deallocate(Obj) Arguments Type Intent Optional Attributes Name class( Material_ ), intent(inout) :: Obj","tags":"","loc":"interface/mat_deallocate.html"},{"title":"mat_display – Fortran Program","text":"interface private subroutine mat_display(Obj, msg, unitno) Arguments Type Intent Optional Attributes Name class( Material_ ), intent(in) :: Obj character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitno","tags":"","loc":"interface/mat_display.html"},{"title":"mat_display_vec – Fortran Program","text":"interface private subroutine mat_display_vec(Obj, msg, unitno) Arguments Type Intent Optional Attributes Name type( Material_ ), intent(in) :: Obj (:) character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitno","tags":"","loc":"interface/mat_display_vec.html"},{"title":"mat_get_prop – Fortran Program","text":"interface Function that return a property as an instance of KeyValue_ private pure function mat_get_prop(Obj, Key) result(Ans) Arguments Type Intent Optional Attributes Name class( Material_ ), intent(in) :: Obj character(len=*), intent(in) :: Key Return Value type(KeyValue_)","tags":"","loc":"interface/mat_get_prop.html"},{"title":"mat_initiate – Fortran Program","text":"interface Subroutine that constructs Material_ private subroutine mat_initiate(Obj, tprop) Arguments Type Intent Optional Attributes Name class( Material_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: tprop","tags":"","loc":"interface/mat_initiate.html"},{"title":"mat_size – Fortran Program","text":"interface Get total number of parameters stored in Material_ private pure function mat_size(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( Material_ ), intent(in) :: Obj Return Value integer(kind=I4B)","tags":"","loc":"interface/mat_size.html"},{"title":"kernel_dealloc – Fortran Program","text":"interface private subroutine kernel_dealloc(Obj) Arguments Type Intent Optional Attributes Name class( Kernel_ ), intent(inout) :: Obj","tags":"","loc":"interface/kernel_dealloc.html"},{"title":"kernel_init – Fortran Program","text":"interface This subroutine initiate the Kernel private subroutine kernel_init(Obj, nsd, nnt, dt, SpatialCoordType, tn, NTS, tol_res, tol_sol) Arguments Type Intent Optional Attributes Name class( Kernel_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: nsd integer(kind=I4B), intent(in), optional :: nnt real(kind=DFP), intent(in), optional :: dt integer(kind=I4B), intent(in), optional :: SpatialCoordType real(kind=DFP), intent(in), optional :: tn integer(kind=I4B), intent(in), optional :: NTS real(kind=DFP), intent(in), optional :: tol_res real(kind=DFP), intent(in), optional :: tol_sol Description This subroutine initiate the kernel\n - If NNT (num of nodes in time domain) is not given then NNT=1 - NSD is the spatial dimension of the problem\n - dt is the time step size; default value is ‘1.0’","tags":"","loc":"interface/kernel_init.html"},{"title":"kernel_mesh_quality – Fortran Program","text":"interface This subroutine computes the mesh quality private subroutine kernel_mesh_quality(Obj, qmin, qmax, qavg, measure, q, nodes) Arguments Type Intent Optional Attributes Name class( Kernel_ ), intent(inout) :: Obj real(kind=DFP), intent(inout) :: qmin real(kind=DFP), intent(inout) :: qmax real(kind=DFP), intent(inout) :: qavg integer(kind=I4B), intent(in), optional :: measure real(kind=DFP), intent(inout), optional ALLOCATABLE :: q (:) real(kind=DFP), intent(in), optional :: nodes (:,:) Description This subroutine computes the mesh quality\n - if q is present then mesh-quality of each element will be returned in it\n   otherwise meshquality will be stored in obj%meshq - qmin qmax and qavg are statistical parameters\n - measure is quality measure which can be\n     - meshquality%area\n     - meshquality%minAngle\n     - meshquality%maxAngle\n     - meshquality%angleRatio\n     - meshquality%radiusRatio\n     - meshquality%edgeRatio\n     - meshquality%aspectRatio\n     - meshquality%scaledJacobian\n - if nodes are not present then dom%nodes are used","tags":"","loc":"interface/kernel_mesh_quality.html"},{"title":"kernel_setalgo – Fortran Program","text":"interface This subroutine set the algorithm for the kernel private subroutine kernel_setalgo(Obj, mainOption, extraOption) Arguments Type Intent Optional Attributes Name class( Kernel_ ), intent(inout) :: Obj integer(kind=I4B), intent(in), optional :: mainOption (:) integer(kind=I4B), intent(in), optional :: extraOption (:) Description This subroutine set the algorithm of the Kernel\n This subroutine should be defined by specific kernel","tags":"","loc":"interface/kernel_setalgo.html"},{"title":"kernel_setdomain – Fortran Program","text":"interface This subroutine set the domain to the kernel private subroutine kernel_setdomain(Obj, dom, omegaNo) Arguments Type Intent Optional Attributes Name class( Kernel_ ), intent(inout) :: Obj class(Domain_), intent(inout), TARGET :: dom integer(kind=I4B), intent(in) :: omegaNo (:) Description This subroutine set the domain to the kernel\n - Here dom is the domain_ datatype\n - omegaNo is the IDs of regions which is required in the analysis\n - This subroutine will store information of omegano - It also prepares the mapping between local and global node numbers\n - Information such as, obj%tnodes and obj%telements are also stored\n inside the kernel Make sure that\n - dom%omega is allocated\n - dom%nodes is associated\n - dom%omegano contains valid pointer to elements of dom%omega(:) - dom%omegano contains","tags":"","loc":"interface/kernel_setdomain.html"},{"title":"kernel_setlinsol – Fortran Program","text":"interface private subroutine kernel_setlinsol(Obj, name, maxiter, tol, fpar, ipar) Arguments Type Intent Optional Attributes Name class( Kernel_ ), intent(inout) :: Obj integer(kind=I4B), intent(in), optional :: name integer(kind=I4B), intent(in), optional :: maxiter real(kind=DFP), intent(in), optional :: tol real(kind=DFP), intent(in), optional :: fpar (:) integer(kind=I4B), intent(in), optional :: ipar (:)","tags":"","loc":"interface/kernel_setlinsol.html"},{"title":"kernel_setmatprops – Fortran Program","text":"interface This subroutine set the material propeties in the kernel private subroutine kernel_setmatprops(Obj, matprops) Arguments Type Intent Optional Attributes Name class( Kernel_ ), intent(inout) :: Obj real(kind=DFP), intent(in) :: matprops (:,:) Description This subroutine set the material properties in the kernel matprops contains information about different materials\n Each column of matprops denote a material type\n This method can be extended by the other kernels","tags":"","loc":"interface/kernel_setmatprops.html"},{"title":"kernel_setprecond – Fortran Program","text":"interface private subroutine kernel_setprecond(Obj, name, fpar, ipar) Arguments Type Intent Optional Attributes Name class( Kernel_ ), intent(inout) :: Obj integer(kind=I4B), intent(in), optional :: name real(kind=DFP), intent(in), optional :: fpar (:) integer(kind=I4B), intent(in), optional :: ipar (:)","tags":"","loc":"interface/kernel_setprecond.html"},{"title":"kernel_settanmat – Fortran Program","text":"interface private subroutine kernel_settanmat(Obj) Arguments Type Intent Optional Attributes Name class( Kernel_ ), intent(inout) :: Obj","tags":"","loc":"interface/kernel_settanmat.html"},{"title":"set_material – Fortran Program","text":"interface private subroutine set_material(Obj, materialNo) Arguments Type Intent Optional Attributes Name class( Kernel_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: materialNo (:)","tags":"","loc":"interface/set_material.html"},{"title":"set_total_materials – Fortran Program","text":"interface private subroutine set_total_materials(Obj, tMaterials) Arguments Type Intent Optional Attributes Name class( Kernel_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: tMaterials","tags":"","loc":"interface/set_total_materials.html"},{"title":"lag_elem_refHexahedron – Fortran Program","text":"interface private module function lag_elem_refHexahedron(Obj, Order) result(Ans) Implementation → Arguments Type Intent Optional Attributes Name class( ReferenceHexahedron_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value class( ReferenceElement_ ),\n  POINTER","tags":"","loc":"interface/lag_elem_refhexahedron.html"},{"title":"lag_elem_refPrism – Fortran Program","text":"interface private module function lag_elem_refPrism(Obj, Order) result(Ans) Implementation → Arguments Type Intent Optional Attributes Name class( ReferencePrism_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value class( ReferenceElement_ ),\n  POINTER","tags":"","loc":"interface/lag_elem_refprism.html"},{"title":"lag_elem_refPyramid – Fortran Program","text":"interface private module function lag_elem_refPyramid(Obj, Order) result(Ans) Implementation → Arguments Type Intent Optional Attributes Name class( ReferencePyramid_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value class( ReferenceElement_ ),\n  POINTER","tags":"","loc":"interface/lag_elem_refpyramid.html"},{"title":"lag_elem_refQuadrangle – Fortran Program","text":"interface private module function lag_elem_refQuadrangle(Obj, Order) result(Ans) Implementation → Arguments Type Intent Optional Attributes Name class( ReferenceQuadrangle_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value class( ReferenceElement_ ),\n  POINTER","tags":"","loc":"interface/lag_elem_refquadrangle.html"},{"title":"lag_elem_refTetrahedron – Fortran Program","text":"interface private module function lag_elem_refTetrahedron(Obj, Order) result(Ans) Implementation → Arguments Type Intent Optional Attributes Name class( ReferenceTetrahedron_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value class( ReferenceElement_ ),\n  POINTER","tags":"","loc":"interface/lag_elem_reftetrahedron.html"},{"title":"lag_elem_refTriangle – Fortran Program","text":"interface private module function lag_elem_refTriangle(Obj, Order) result(Ans) Implementation → Arguments Type Intent Optional Attributes Name class( ReferenceTriangle_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value class( ReferenceElement_ ),\n  POINTER","tags":"","loc":"interface/lag_elem_reftriangle.html"},{"title":"lag_elem_refelem – Fortran Program","text":"interface private module function lag_elem_refelem(Obj, Order) result(Ans) Implementation → Arguments Type Intent Optional Attributes Name class( ReferenceElement_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value class( ReferenceElement_ ),\n  POINTER","tags":"","loc":"interface/lag_elem_refelem.html"},{"title":"lag_elem_refline – Fortran Program","text":"interface private module function lag_elem_refline(Obj, Order) result(Ans) Implementation → Arguments Type Intent Optional Attributes Name class( ReferenceLine_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value class( ReferenceElement_ ),\n  POINTER","tags":"","loc":"interface/lag_elem_refline.html"},{"title":"lp_refelem – Fortran Program","text":"interface private pure module function lp_refelem(Obj, Order) result(Ans) Implementation → Arguments Type Intent Optional Attributes Name class( ReferenceElement_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:)","tags":"","loc":"interface/lp_refelem.html"},{"title":"lp_refelem_Hexahedron – Fortran Program","text":"interface private pure module function lp_refelem_Hexahedron(Obj, Order) result(Ans) Implementation → Arguments Type Intent Optional Attributes Name class( ReferenceHexahedron_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:)","tags":"","loc":"interface/lp_refelem_hexahedron.html"},{"title":"lp_refelem_Prism – Fortran Program","text":"interface private pure module function lp_refelem_Prism(Obj, Order) result(Ans) Implementation → Arguments Type Intent Optional Attributes Name class( ReferencePrism_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:)","tags":"","loc":"interface/lp_refelem_prism.html"},{"title":"lp_refelem_Pyramid – Fortran Program","text":"interface private pure module function lp_refelem_Pyramid(Obj, Order) result(Ans) Implementation → Arguments Type Intent Optional Attributes Name class( ReferencePyramid_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:)","tags":"","loc":"interface/lp_refelem_pyramid.html"},{"title":"lp_refelem_Quadrangle – Fortran Program","text":"interface private pure module function lp_refelem_Quadrangle(Obj, Order) result(Ans) Implementation → Arguments Type Intent Optional Attributes Name class( ReferenceQuadrangle_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:)","tags":"","loc":"interface/lp_refelem_quadrangle.html"},{"title":"lp_refelem_Tetrahedron – Fortran Program","text":"interface private pure module function lp_refelem_Tetrahedron(Obj, Order) result(Ans) Implementation → Arguments Type Intent Optional Attributes Name class( ReferenceTetrahedron_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:)","tags":"","loc":"interface/lp_refelem_tetrahedron.html"},{"title":"lp_refelem_Triangle – Fortran Program","text":"interface private pure module function lp_refelem_Triangle(Obj, Order) result(Ans) Implementation → Arguments Type Intent Optional Attributes Name class( ReferenceTriangle_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:)","tags":"","loc":"interface/lp_refelem_triangle.html"},{"title":"lp_refelem_line – Fortran Program","text":"interface private pure module function lp_refelem_line(Obj, Order) result(Ans) Implementation → Arguments Type Intent Optional Attributes Name class( ReferenceLine_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:)","tags":"","loc":"interface/lp_refelem_line.html"},{"title":"get_shape – Fortran Program","text":"private pure function get_shape(Obj) result(Ans) Arguments Type Intent Optional Attributes Name type( AbstractMatrix_ ), intent(in) :: Obj Return Value integer(kind=I4B)\n  (2) Contents Source Code get_shape Source Code PURE FUNCTION get_shape ( Obj ) RESULT ( Ans ) TYPE ( AbstractMatrix_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ) :: Ans ( 2 ) Ans = 0_I4B END FUNCTION get_shape","tags":"","loc":"proc/get_shape.html"},{"title":"get_size – Fortran Program","text":"private pure function get_size(Obj, Dims) result(Ans) Arguments Type Intent Optional Attributes Name type( AbstractMatrix_ ), intent(in) :: Obj integer(kind=I4B), intent(in), optional :: Dims Return Value integer(kind=I4B) Contents Source Code get_size Source Code PURE FUNCTION get_size ( Obj , Dims ) RESULT ( Ans ) TYPE ( AbstractMatrix_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: Dims INTEGER ( I4B ) :: Ans Ans = 0 END FUNCTION get_size","tags":"","loc":"proc/get_size.html"},{"title":"Shape – Fortran Program","text":"public interface Shape Contents Module Procedures get_shape Module Procedures private pure function get_shape (Obj) result(Ans) Arguments Type Intent Optional Attributes Name type( AbstractMatrix_ ), intent(in) :: Obj Return Value integer(kind=I4B)\n  (2)","tags":"","loc":"interface/shape.html"},{"title":"Size – Fortran Program","text":"public interface Size Contents Module Procedures get_size Module Procedures private pure function get_size (Obj, Dims) result(Ans) Arguments Type Intent Optional Attributes Name type( AbstractMatrix_ ), intent(in) :: Obj integer(kind=I4B), intent(in), optional :: Dims Return Value integer(kind=I4B)","tags":"","loc":"interface/size.html"},{"title":"ASUM – Fortran Program","text":"public interface ASUM Contents Functions DASUM DZASUM SASUM SCASUM Functions public pure function DASUM(N, X, INCX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX Return Value real(kind=WP) public pure function DZASUM(N, X, INCX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX Return Value real(kind=WP) public pure function SASUM(N, X, INCX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX Return Value real(kind=WP) public pure function SCASUM(N, X, INCX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX Return Value real(kind=WP)","tags":"","loc":"interface/asum.html"},{"title":"AXPBY – Fortran Program","text":"public interface AXPBY Contents Subroutines CAXPBY DAXPBY SAXPBY ZAXPBY Subroutines public subroutine CAXPBY(N, ALPHA, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine DAXPBY(N, ALPHA, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(in) :: BETA real(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine SAXPBY(N, ALPHA, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(in) :: BETA real(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine ZAXPBY(N, ALPHA, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY","tags":"","loc":"interface/axpby.html"},{"title":"AXPY – Fortran Program","text":"public interface AXPY Contents Subroutines CAXPY DAXPY SAXPY ZAXPY Subroutines public subroutine CAXPY(N, A, X, INCX, Y, INCY) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N complex(kind=WP), intent(in) :: A complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine DAXPY(N, A, X, INCX, Y, INCY) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(in) :: A real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine SAXPY(N, A, X, INCX, Y, INCY) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(in) :: A real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine ZAXPY(N, A, X, INCX, Y, INCY) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N complex(kind=WP), intent(in) :: A complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY","tags":"","loc":"interface/axpy.html"},{"title":"AXPYI – Fortran Program","text":"public interface AXPYI Contents Subroutines CAXPYI DAXPYI SAXPYI ZAXPYI Subroutines public subroutine CAXPYI(NZ, A, X, INDX, Y) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NZ complex(kind=WP), intent(in) :: A complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INDX (*) complex(kind=WP), intent(inout) :: Y (*) public subroutine DAXPYI(NZ, A, X, INDX, Y) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NZ real(kind=WP), intent(in) :: A real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INDX (*) real(kind=WP), intent(inout) :: Y (*) public subroutine SAXPYI(NZ, A, X, INDX, Y) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NZ real(kind=WP), intent(in) :: A real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INDX (*) real(kind=WP), intent(inout) :: Y (*) public subroutine ZAXPYI(NZ, A, X, INDX, Y) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NZ complex(kind=WP), intent(in) :: A complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INDX (*) complex(kind=WP), intent(inout) :: Y (*)","tags":"","loc":"interface/axpyi.html"},{"title":"CABS1 – Fortran Program","text":"public interface CABS1 Contents Functions DCABS1 SCABS1 Functions public pure function DCABS1(Z) Arguments Type Intent Optional Attributes Name complex(kind=WP), intent(in) :: Z Return Value real(kind=WP) public pure function SCABS1(C) Arguments Type Intent Optional Attributes Name complex(kind=WP), intent(in) :: C Return Value real(kind=WP)","tags":"","loc":"interface/cabs1.html"},{"title":"COPY – Fortran Program","text":"public interface COPY Contents Subroutines CCOPY DCOPY SCOPY ZCOPY Subroutines public subroutine CCOPY(N, X, INCX, Y, INCY) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine DCOPY(N, X, INCX, Y, INCY) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine SCOPY(N, X, INCX, Y, INCY) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine ZCOPY(N, X, INCX, Y, INCY) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY","tags":"","loc":"interface/copy.html"},{"title":"DOT – Fortran Program","text":"public interface DOT Contents Functions DDOT SDOT Functions public pure function DDOT(N, X, INCX, Y, INCY) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(in) :: Y (*) integer, intent(in) :: INCY Return Value real(kind=WP) public pure function SDOT(N, X, INCX, Y, INCY) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(in) :: Y (*) integer, intent(in) :: INCY Return Value real(kind=WP)","tags":"","loc":"interface/dot.html"},{"title":"DOTC – Fortran Program","text":"public interface DOTC Contents Functions CDOTC ZDOTC Functions public pure function CDOTC(N, X, INCX, Y, INCY) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: Y (*) integer, intent(in) :: INCY Return Value complex(kind=WP) public pure function ZDOTC(N, X, INCX, Y, INCY) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: Y (*) integer, intent(in) :: INCY Return Value complex(kind=WP)","tags":"","loc":"interface/dotc.html"},{"title":"DOTCI – Fortran Program","text":"public interface DOTCI Contents Functions CDOTCI ZDOTCI Functions public pure function CDOTCI(NZ, X, INDX, Y) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NZ complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INDX (*) complex(kind=WP), intent(in) :: Y (*) Return Value complex(kind=WP) public pure function ZDOTCI(NZ, X, INDX, Y) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NZ complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INDX (*) complex(kind=WP), intent(in) :: Y (*) Return Value complex(kind=WP)","tags":"","loc":"interface/dotci.html"},{"title":"DOTI – Fortran Program","text":"public interface DOTI Contents Functions DDOTI SDOTI Functions public pure function DDOTI(NZ, X, INDX, Y) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NZ real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INDX (*) real(kind=WP), intent(in) :: Y (*) Return Value real(kind=WP) public pure function SDOTI(NZ, X, INDX, Y) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NZ real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INDX (*) real(kind=WP), intent(in) :: Y (*) Return Value real(kind=WP)","tags":"","loc":"interface/doti.html"},{"title":"DOTU – Fortran Program","text":"public interface DOTU Contents Functions CDOTU ZDOTU Functions public pure function CDOTU(N, X, INCX, Y, INCY) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: Y (*) integer, intent(in) :: INCY Return Value complex(kind=WP) public pure function ZDOTU(N, X, INCX, Y, INCY) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: Y (*) integer, intent(in) :: INCY Return Value complex(kind=WP)","tags":"","loc":"interface/dotu.html"},{"title":"DOTUI – Fortran Program","text":"public interface DOTUI Contents Functions CDOTUI ZDOTUI Functions public pure function CDOTUI(NZ, X, INDX, Y) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NZ complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INDX (*) complex(kind=WP), intent(in) :: Y (*) Return Value complex(kind=WP) public pure function ZDOTUI(NZ, X, INDX, Y) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NZ complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INDX (*) complex(kind=WP), intent(in) :: Y (*) Return Value complex(kind=WP)","tags":"","loc":"interface/dotui.html"},{"title":"GBMV – Fortran Program","text":"public interface GBMV Contents Subroutines CGBMV DGBMV SGBMV ZGBMV Subroutines public subroutine CGBMV(TRANS, M, N, KL, KU, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANS integer, intent(in) :: M integer, intent(in) :: N integer, intent(in) :: KL integer, intent(in) :: KU complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine DGBMV(TRANS, M, N, KL, KU, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANS integer, intent(in) :: M integer, intent(in) :: N integer, intent(in) :: KL integer, intent(in) :: KU real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(in) :: BETA real(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine SGBMV(TRANS, M, N, KL, KU, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANS integer, intent(in) :: M integer, intent(in) :: N integer, intent(in) :: KL integer, intent(in) :: KU real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(in) :: BETA real(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine ZGBMV(TRANS, M, N, KL, KU, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANS integer, intent(in) :: M integer, intent(in) :: N integer, intent(in) :: KL integer, intent(in) :: KU complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY","tags":"","loc":"interface/gbmv.html"},{"title":"GEM2V – Fortran Program","text":"public interface GEM2V Contents Subroutines CGEM2VC DGEM2VU SGEM2VU ZGEM2VC Subroutines public subroutine CGEM2VC(M, N, ALPHA, A, LDA, X1, INCX1, X2, INCX2, BETA, Y1, INCY1, Y2, INCY2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: M integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: X1 (*) integer, intent(in) :: INCX1 complex(kind=WP), intent(in) :: X2 (*) integer, intent(in) :: INCX2 complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: Y1 (*) integer, intent(in) :: INCY1 complex(kind=WP), intent(inout) :: Y2 (*) integer, intent(in) :: INCY2 public subroutine DGEM2VU(M, N, ALPHA, A, LDA, X1, INCX1, X2, INCX2, BETA, Y1, INCY1, Y2, INCY2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: M integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(in) :: X1 (*) integer, intent(in) :: INCX1 real(kind=WP), intent(in) :: X2 (*) integer, intent(in) :: INCX2 real(kind=WP), intent(in) :: BETA real(kind=WP), intent(inout) :: Y1 (*) integer, intent(in) :: INCY1 real(kind=WP), intent(inout) :: Y2 (*) integer, intent(in) :: INCY2 public subroutine SGEM2VU(M, N, ALPHA, A, LDA, X1, INCX1, X2, INCX2, BETA, Y1, INCY1, Y2, INCY2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: M integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(in) :: X1 (*) integer, intent(in) :: INCX1 real(kind=WP), intent(in) :: X2 (*) integer, intent(in) :: INCX2 real(kind=WP), intent(in) :: BETA real(kind=WP), intent(inout) :: Y1 (*) integer, intent(in) :: INCY1 real(kind=WP), intent(inout) :: Y2 (*) integer, intent(in) :: INCY2 public subroutine ZGEM2VC(M, N, ALPHA, A, LDA, X1, INCX1, X2, INCX2, BETA, Y1, INCY1, Y2, INCY2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: M integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: X1 (*) integer, intent(in) :: INCX1 complex(kind=WP), intent(in) :: X2 (*) integer, intent(in) :: INCX2 complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: Y1 (*) integer, intent(in) :: INCY1 complex(kind=WP), intent(inout) :: Y2 (*) integer, intent(in) :: INCY2","tags":"","loc":"interface/gem2v.html"},{"title":"GEMM – Fortran Program","text":"public interface GEMM Contents Subroutines CGEMM DGEMM DZGEMM SCGEMM SGEMM ZGEMM Subroutines public subroutine CGEMM(TRANSA, TRANSB, M, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANSA character(len=1), intent(in) :: TRANSB integer, intent(in) :: M integer, intent(in) :: N integer, intent(in) :: K complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: B (LDB,*) integer, intent(in) :: LDB complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public subroutine DGEMM(TRANSA, TRANSB, M, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANSA character(len=1), intent(in) :: TRANSB integer, intent(in) :: M integer, intent(in) :: N integer, intent(in) :: K real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(in) :: B (LDB,*) integer, intent(in) :: LDB real(kind=WP), intent(in) :: BETA real(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public subroutine DZGEMM(TRANSA, TRANSB, M, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANSA character(len=1), intent(in) :: TRANSB integer, intent(in) :: M integer, intent(in) :: N integer, intent(in) :: K complex(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: B (LDB,*) integer, intent(in) :: LDB complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public subroutine SCGEMM(TRANSA, TRANSB, M, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANSA character(len=1), intent(in) :: TRANSB integer, intent(in) :: M integer, intent(in) :: N integer, intent(in) :: K complex(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: B (LDB,*) integer, intent(in) :: LDB complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public subroutine SGEMM(TRANSA, TRANSB, M, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANSA character(len=1), intent(in) :: TRANSB integer, intent(in) :: M integer, intent(in) :: N integer, intent(in) :: K real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(in) :: B (LDB,*) integer, intent(in) :: LDB real(kind=WP), intent(in) :: BETA real(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public subroutine ZGEMM(TRANSA, TRANSB, M, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANSA character(len=1), intent(in) :: TRANSB integer, intent(in) :: M integer, intent(in) :: N integer, intent(in) :: K complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: B (LDB,*) integer, intent(in) :: LDB complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC","tags":"","loc":"interface/gemm.html"},{"title":"GEMM3M – Fortran Program","text":"public interface GEMM3M Contents Subroutines CGEMM3M ZGEMM3M Subroutines public subroutine CGEMM3M(TRANSA, TRANSB, M, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANSA character(len=1), intent(in) :: TRANSB integer, intent(in) :: M integer, intent(in) :: N integer, intent(in) :: K complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: B (LDB,*) integer, intent(in) :: LDB complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public subroutine ZGEMM3M(TRANSA, TRANSB, M, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANSA character(len=1), intent(in) :: TRANSB integer, intent(in) :: M integer, intent(in) :: N integer, intent(in) :: K complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: B (LDB,*) integer, intent(in) :: LDB complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC","tags":"","loc":"interface/gemm3m.html"},{"title":"GEMM3M_BATCH – Fortran Program","text":"public interface GEMM3M_BATCH Contents Subroutines CGEMM3M_BATCH ZGEMM3M_BATCH Subroutines public subroutine CGEMM3M_BATCH(TRANSA_ARRAY, TRANSB_ARRAY, M_ARRAY, N_ARRAY, K_ARRAY, ALPHA_ARRAY, A_ARRAY, LDA_ARRAY, B_ARRAY, LDB_ARRAY, BETA_ARRAY, C_ARRAY, LDC_ARRAY, GROUP_COUNT, GROUP_SIZE) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANSA_ARRAY (*) character(len=1), intent(in) :: TRANSB_ARRAY (*) integer, intent(in) :: M_ARRAY (*) integer, intent(in) :: N_ARRAY (*) integer, intent(in) :: K_ARRAY (*) complex(kind=WP), intent(in) :: ALPHA_ARRAY (*) integer(kind=C_SIZE_T), intent(in) :: A_ARRAY (*) integer, intent(in) :: LDA_ARRAY (*) integer(kind=C_SIZE_T), intent(in) :: B_ARRAY (*) integer, intent(in) :: LDB_ARRAY (*) complex(kind=WP), intent(in) :: BETA_ARRAY (*) integer(kind=C_SIZE_T), intent(inout) :: C_ARRAY (*) integer, intent(in) :: LDC_ARRAY (*) integer, intent(in) :: GROUP_COUNT integer, intent(in) :: GROUP_SIZE (*) public subroutine ZGEMM3M_BATCH(TRANSA_ARRAY, TRANSB_ARRAY, M_ARRAY, N_ARRAY, K_ARRAY, ALPHA_ARRAY, A_ARRAY, LDA_ARRAY, B_ARRAY, LDB_ARRAY, BETA_ARRAY, C_ARRAY, LDC_ARRAY, GROUP_COUNT, GROUP_SIZE) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANSA_ARRAY (*) character(len=1), intent(in) :: TRANSB_ARRAY (*) integer, intent(in) :: M_ARRAY (*) integer, intent(in) :: N_ARRAY (*) integer, intent(in) :: K_ARRAY (*) complex(kind=WP), intent(in) :: ALPHA_ARRAY (*) integer(kind=C_SIZE_T), intent(in) :: A_ARRAY (*) integer, intent(in) :: LDA_ARRAY (*) integer(kind=C_SIZE_T), intent(in) :: B_ARRAY (*) integer, intent(in) :: LDB_ARRAY (*) complex(kind=WP), intent(in) :: BETA_ARRAY (*) integer(kind=C_SIZE_T), intent(inout) :: C_ARRAY (*) integer, intent(in) :: LDC_ARRAY (*) integer, intent(in) :: GROUP_COUNT integer, intent(in) :: GROUP_SIZE (*)","tags":"","loc":"interface/gemm3m_batch.html"},{"title":"GEMMT – Fortran Program","text":"public interface GEMMT Contents Subroutines CGEMMT DGEMMT SGEMMT ZGEMMT Subroutines public subroutine CGEMMT(UPLO, TRANSA, TRANSB, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANSA character(len=1), intent(in) :: TRANSB integer, intent(in) :: N integer, intent(in) :: K complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: B (LDB,*) integer, intent(in) :: LDB complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public subroutine DGEMMT(UPLO, TRANSA, TRANSB, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANSA character(len=1), intent(in) :: TRANSB integer, intent(in) :: N integer, intent(in) :: K real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(in) :: B (LDB,*) integer, intent(in) :: LDB real(kind=WP), intent(in) :: BETA real(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public subroutine SGEMMT(UPLO, TRANSA, TRANSB, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANSA character(len=1), intent(in) :: TRANSB integer, intent(in) :: N integer, intent(in) :: K real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(in) :: B (LDB,*) integer, intent(in) :: LDB real(kind=WP), intent(in) :: BETA real(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public subroutine ZGEMMT(UPLO, TRANSA, TRANSB, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANSA character(len=1), intent(in) :: TRANSB integer, intent(in) :: N integer, intent(in) :: K complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: B (LDB,*) integer, intent(in) :: LDB complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC","tags":"","loc":"interface/gemmt.html"},{"title":"GEMM_BATCH – Fortran Program","text":"public interface GEMM_BATCH Contents Subroutines CGEMM_BATCH DGEMM_BATCH SGEMM_BATCH ZGEMM_BATCH Subroutines public subroutine CGEMM_BATCH(TRANSA_ARRAY, TRANSB_ARRAY, M_ARRAY, N_ARRAY, K_ARRAY, ALPHA_ARRAY, A_ARRAY, LDA_ARRAY, B_ARRAY, LDB_ARRAY, BETA_ARRAY, C_ARRAY, LDC_ARRAY, GROUP_COUNT, GROUP_SIZE) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANSA_ARRAY (*) character(len=1), intent(in) :: TRANSB_ARRAY (*) integer, intent(in) :: M_ARRAY (*) integer, intent(in) :: N_ARRAY (*) integer, intent(in) :: K_ARRAY (*) complex(kind=WP), intent(in) :: ALPHA_ARRAY (*) integer(kind=C_SIZE_T), intent(in) :: A_ARRAY (*) integer, intent(in) :: LDA_ARRAY (*) integer(kind=C_SIZE_T), intent(in) :: B_ARRAY (*) integer, intent(in) :: LDB_ARRAY (*) complex(kind=WP), intent(in) :: BETA_ARRAY (*) integer(kind=C_SIZE_T), intent(inout) :: C_ARRAY (*) integer, intent(in) :: LDC_ARRAY (*) integer, intent(in) :: GROUP_COUNT integer, intent(in) :: GROUP_SIZE (*) public subroutine DGEMM_BATCH(TRANSA_ARRAY, TRANSB_ARRAY, M_ARRAY, N_ARRAY, K_ARRAY, ALPHA_ARRAY, A_ARRAY, LDA_ARRAY, B_ARRAY, LDB_ARRAY, BETA_ARRAY, C_ARRAY, LDC_ARRAY, GROUP_COUNT, GROUP_SIZE) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANSA_ARRAY (*) character(len=1), intent(in) :: TRANSB_ARRAY (*) integer, intent(in) :: M_ARRAY (*) integer, intent(in) :: N_ARRAY (*) integer, intent(in) :: K_ARRAY (*) real(kind=WP), intent(in) :: ALPHA_ARRAY (*) integer(kind=C_SIZE_T), intent(in) :: A_ARRAY (*) integer, intent(in) :: LDA_ARRAY (*) integer(kind=C_SIZE_T), intent(in) :: B_ARRAY (*) integer, intent(in) :: LDB_ARRAY (*) real(kind=WP), intent(in) :: BETA_ARRAY (*) integer(kind=C_SIZE_T), intent(inout) :: C_ARRAY (*) integer, intent(in) :: LDC_ARRAY (*) integer, intent(in) :: GROUP_COUNT integer, intent(in) :: GROUP_SIZE (*) public subroutine SGEMM_BATCH(TRANSA_ARRAY, TRANSB_ARRAY, M_ARRAY, N_ARRAY, K_ARRAY, ALPHA_ARRAY, A_ARRAY, LDA_ARRAY, B_ARRAY, LDB_ARRAY, BETA_ARRAY, C_ARRAY, LDC_ARRAY, GROUP_COUNT, GROUP_SIZE) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANSA_ARRAY (*) character(len=1), intent(in) :: TRANSB_ARRAY (*) integer, intent(in) :: M_ARRAY (*) integer, intent(in) :: N_ARRAY (*) integer, intent(in) :: K_ARRAY (*) real(kind=WP), intent(in) :: ALPHA_ARRAY (*) integer(kind=C_SIZE_T), intent(in) :: A_ARRAY (*) integer, intent(in) :: LDA_ARRAY (*) integer(kind=C_SIZE_T), intent(in) :: B_ARRAY (*) integer, intent(in) :: LDB_ARRAY (*) real(kind=WP), intent(in) :: BETA_ARRAY (*) integer(kind=C_SIZE_T), intent(inout) :: C_ARRAY (*) integer, intent(in) :: LDC_ARRAY (*) integer, intent(in) :: GROUP_COUNT integer, intent(in) :: GROUP_SIZE (*) public subroutine ZGEMM_BATCH(TRANSA_ARRAY, TRANSB_ARRAY, M_ARRAY, N_ARRAY, K_ARRAY, ALPHA_ARRAY, A_ARRAY, LDA_ARRAY, B_ARRAY, LDB_ARRAY, BETA_ARRAY, C_ARRAY, LDC_ARRAY, GROUP_COUNT, GROUP_SIZE) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANSA_ARRAY (*) character(len=1), intent(in) :: TRANSB_ARRAY (*) integer, intent(in) :: M_ARRAY (*) integer, intent(in) :: N_ARRAY (*) integer, intent(in) :: K_ARRAY (*) complex(kind=WP), intent(in) :: ALPHA_ARRAY (*) integer(kind=C_SIZE_T), intent(in) :: A_ARRAY (*) integer, intent(in) :: LDA_ARRAY (*) integer(kind=C_SIZE_T), intent(in) :: B_ARRAY (*) integer, intent(in) :: LDB_ARRAY (*) complex(kind=WP), intent(in) :: BETA_ARRAY (*) integer(kind=C_SIZE_T), intent(inout) :: C_ARRAY (*) integer, intent(in) :: LDC_ARRAY (*) integer, intent(in) :: GROUP_COUNT integer, intent(in) :: GROUP_SIZE (*)","tags":"","loc":"interface/gemm_batch.html"},{"title":"GEMV – Fortran Program","text":"public interface GEMV Contents Subroutines CGEMV DGEMV DZGEMV SCGEMV SGEMV ZGEMV Subroutines public subroutine CGEMV(TRANS, M, N, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANS integer, intent(in) :: M integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine DGEMV(TRANS, M, N, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANS integer, intent(in) :: M integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(in) :: BETA real(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine DZGEMV(TRANS, M, N, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANS integer, intent(in) :: M integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine SCGEMV(TRANS, M, N, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANS integer, intent(in) :: M integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine SGEMV(TRANS, M, N, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANS integer, intent(in) :: M integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(in) :: BETA real(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine ZGEMV(TRANS, M, N, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANS integer, intent(in) :: M integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY","tags":"","loc":"interface/gemv.html"},{"title":"GER – Fortran Program","text":"public interface GER Contents Subroutines DGER SGER Subroutines public subroutine DGER(M, N, ALPHA, X, INCX, Y, INCY, A, LDA) Arguments Type Intent Optional Attributes Name integer, intent(in) :: M integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(in) :: Y (*) integer, intent(in) :: INCY real(kind=WP), intent(inout) :: A (LDA,*) integer, intent(in) :: LDA public subroutine SGER(M, N, ALPHA, X, INCX, Y, INCY, A, LDA) Arguments Type Intent Optional Attributes Name integer, intent(in) :: M integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(in) :: Y (*) integer, intent(in) :: INCY real(kind=WP), intent(inout) :: A (LDA,*) integer, intent(in) :: LDA","tags":"","loc":"interface/ger.html"},{"title":"GERC – Fortran Program","text":"public interface GERC Contents Subroutines CGERC ZGERC Subroutines public subroutine CGERC(M, N, ALPHA, X, INCX, Y, INCY, A, LDA) Arguments Type Intent Optional Attributes Name integer, intent(in) :: M integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: Y (*) integer, intent(in) :: INCY complex(kind=WP), intent(inout) :: A (LDA,*) integer, intent(in) :: LDA public subroutine ZGERC(M, N, ALPHA, X, INCX, Y, INCY, A, LDA) Arguments Type Intent Optional Attributes Name integer, intent(in) :: M integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: Y (*) integer, intent(in) :: INCY complex(kind=WP), intent(inout) :: A (LDA,*) integer, intent(in) :: LDA","tags":"","loc":"interface/gerc.html"},{"title":"GERU – Fortran Program","text":"public interface GERU Contents Subroutines CGERU ZGERU Subroutines public subroutine CGERU(M, N, ALPHA, X, INCX, Y, INCY, A, LDA) Arguments Type Intent Optional Attributes Name integer, intent(in) :: M integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: Y (*) integer, intent(in) :: INCY complex(kind=WP), intent(inout) :: A (LDA,*) integer, intent(in) :: LDA public subroutine ZGERU(M, N, ALPHA, X, INCX, Y, INCY, A, LDA) Arguments Type Intent Optional Attributes Name integer, intent(in) :: M integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: Y (*) integer, intent(in) :: INCY complex(kind=WP), intent(inout) :: A (LDA,*) integer, intent(in) :: LDA","tags":"","loc":"interface/geru.html"},{"title":"GTHR – Fortran Program","text":"public interface GTHR Contents Subroutines CGTHR DGTHR SGTHR ZGTHR Subroutines public subroutine CGTHR(NZ, Y, X, INDX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NZ complex(kind=WP), intent(in) :: Y (*) complex(kind=WP), intent(out) :: X (*) integer, intent(in) :: INDX (*) public subroutine DGTHR(NZ, Y, X, INDX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NZ real(kind=WP), intent(in) :: Y (*) real(kind=WP), intent(out) :: X (*) integer, intent(in) :: INDX (*) public subroutine SGTHR(NZ, Y, X, INDX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NZ real(kind=WP), intent(in) :: Y (*) real(kind=WP), intent(out) :: X (*) integer, intent(in) :: INDX (*) public subroutine ZGTHR(NZ, Y, X, INDX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NZ complex(kind=WP), intent(in) :: Y (*) complex(kind=WP), intent(out) :: X (*) integer, intent(in) :: INDX (*)","tags":"","loc":"interface/gthr.html"},{"title":"GTHRZ – Fortran Program","text":"public interface GTHRZ Contents Subroutines CGTHRZ DGTHRZ SGTHRZ ZGTHRZ Subroutines public subroutine CGTHRZ(NZ, Y, X, INDX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NZ complex(kind=WP), intent(inout) :: Y (*) complex(kind=WP), intent(out) :: X (*) integer, intent(in) :: INDX (*) public subroutine DGTHRZ(NZ, Y, X, INDX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NZ real(kind=WP), intent(inout) :: Y (*) real(kind=WP), intent(out) :: X (*) integer, intent(in) :: INDX (*) public subroutine SGTHRZ(NZ, Y, X, INDX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NZ real(kind=WP), intent(inout) :: Y (*) real(kind=WP), intent(out) :: X (*) integer, intent(in) :: INDX (*) public subroutine ZGTHRZ(NZ, Y, X, INDX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NZ complex(kind=WP), intent(inout) :: Y (*) complex(kind=WP), intent(out) :: X (*) integer, intent(in) :: INDX (*)","tags":"","loc":"interface/gthrz.html"},{"title":"HBMV – Fortran Program","text":"public interface HBMV Contents Subroutines CHBMV ZHBMV Subroutines public subroutine CHBMV(UPLO, N, K, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N integer, intent(in) :: K complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine ZHBMV(UPLO, N, K, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N integer, intent(in) :: K complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY","tags":"","loc":"interface/hbmv.html"},{"title":"HEMM – Fortran Program","text":"public interface HEMM Contents Subroutines CHEMM ZHEMM Subroutines public subroutine CHEMM(SIDE, UPLO, M, N, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: SIDE character(len=1), intent(in) :: UPLO integer, intent(in) :: M integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: B (LDB,*) integer, intent(in) :: LDB complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public subroutine ZHEMM(SIDE, UPLO, M, N, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: SIDE character(len=1), intent(in) :: UPLO integer, intent(in) :: M integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: B (LDB,*) integer, intent(in) :: LDB complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC","tags":"","loc":"interface/hemm.html"},{"title":"HEMV – Fortran Program","text":"public interface HEMV Contents Subroutines CHEMV ZHEMV Subroutines public subroutine CHEMV(UPLO, N, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine ZHEMV(UPLO, N, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY","tags":"","loc":"interface/hemv.html"},{"title":"HER – Fortran Program","text":"public interface HER Contents Subroutines CHER ZHER Subroutines public subroutine CHER(UPLO, N, ALPHA, X, INCX, A, LDA) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(inout) :: A (LDA,*) integer, intent(in) :: LDA public subroutine ZHER(UPLO, N, ALPHA, X, INCX, A, LDA) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(inout) :: A (LDA,*) integer, intent(in) :: LDA","tags":"","loc":"interface/her.html"},{"title":"HER2 – Fortran Program","text":"public interface HER2 Contents Subroutines CHER2 ZHER2 Subroutines public subroutine CHER2(UPLO, N, ALPHA, X, INCX, Y, INCY, A, LDA) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: Y (*) integer, intent(in) :: INCY complex(kind=WP), intent(inout) :: A (LDA,*) integer, intent(in) :: LDA public subroutine ZHER2(UPLO, N, ALPHA, X, INCX, Y, INCY, A, LDA) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: Y (*) integer, intent(in) :: INCY complex(kind=WP), intent(inout) :: A (LDA,*) integer, intent(in) :: LDA","tags":"","loc":"interface/her2.html"},{"title":"HER2K – Fortran Program","text":"public interface HER2K Contents Subroutines CHER2K ZHER2K Subroutines public subroutine CHER2K(UPLO, TRANS, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS integer, intent(in) :: N integer, intent(in) :: K complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: B (LDB,*) integer, intent(in) :: LDB real(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public subroutine ZHER2K(UPLO, TRANS, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS integer, intent(in) :: N integer, intent(in) :: K complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: B (LDB,*) integer, intent(in) :: LDB real(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC","tags":"","loc":"interface/her2k.html"},{"title":"HERK – Fortran Program","text":"public interface HERK Contents Subroutines CHERK ZHERK Subroutines public subroutine CHERK(UPLO, TRANS, N, K, ALPHA, A, LDA, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS integer, intent(in) :: N integer, intent(in) :: K real(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public subroutine ZHERK(UPLO, TRANS, N, K, ALPHA, A, LDA, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS integer, intent(in) :: N integer, intent(in) :: K real(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC","tags":"","loc":"interface/herk.html"},{"title":"HPMV – Fortran Program","text":"public interface HPMV Contents Subroutines CHPMV ZHPMV Subroutines public subroutine CHPMV(UPLO, N, ALPHA, AP, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: AP (*) complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine ZHPMV(UPLO, N, ALPHA, AP, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: AP (*) complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY","tags":"","loc":"interface/hpmv.html"},{"title":"HPR – Fortran Program","text":"public interface HPR Contents Subroutines CHPR ZHPR Subroutines public subroutine CHPR(UPLO, N, ALPHA, X, INCX, AP) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(inout) :: AP (*) public subroutine ZHPR(UPLO, N, ALPHA, X, INCX, AP) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(inout) :: AP (*)","tags":"","loc":"interface/hpr.html"},{"title":"HPR2 – Fortran Program","text":"public interface HPR2 Contents Subroutines CHPR2 ZHPR2 Subroutines public subroutine CHPR2(UPLO, N, ALPHA, X, INCX, Y, INCY, AP) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: Y (*) integer, intent(in) :: INCY complex(kind=WP), intent(inout) :: AP (*) public subroutine ZHPR2(UPLO, N, ALPHA, X, INCX, Y, INCY, AP) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: Y (*) integer, intent(in) :: INCY complex(kind=WP), intent(inout) :: AP (*)","tags":"","loc":"interface/hpr2.html"},{"title":"IAMAX – Fortran Program","text":"public interface IAMAX Contents Functions ICAMAX IDAMAX ISAMAX IZAMAX Functions public pure function ICAMAX(N, X, INCX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX Return Value integer public pure function IDAMAX(N, X, INCX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX Return Value integer public pure function ISAMAX(N, X, INCX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX Return Value integer public pure function IZAMAX(N, X, INCX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX Return Value integer","tags":"","loc":"interface/iamax.html"},{"title":"IAMIN – Fortran Program","text":"public interface IAMIN Contents Functions ICAMIN IDAMIN ISAMIN IZAMIN Functions public pure function ICAMIN(N, X, INCX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX Return Value integer public pure function IDAMIN(N, X, INCX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX Return Value integer public pure function ISAMIN(N, X, INCX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX Return Value integer public pure function IZAMIN(N, X, INCX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX Return Value integer","tags":"","loc":"interface/iamin.html"},{"title":"NRM2 – Fortran Program","text":"public interface NRM2 Contents Functions DNRM2 DZNRM2 SCNRM2 SNRM2 Functions public pure function DNRM2(N, X, INCX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX Return Value real(kind=WP) public pure function DZNRM2(N, X, INCX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX Return Value real(kind=WP) public pure function SCNRM2(N, X, INCX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX Return Value real(kind=WP) public pure function SNRM2(N, X, INCX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX Return Value real(kind=WP)","tags":"","loc":"interface/nrm2.html"},{"title":"ROT – Fortran Program","text":"public interface ROT Contents Subroutines CSROT DROT SROT ZDROT Subroutines public subroutine CSROT(N, X, INCX, Y, INCY, C, S) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N complex(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY real(kind=WP), intent(in) :: C real(kind=WP), intent(in) :: S public subroutine DROT(N, X, INCX, Y, INCY, C, S) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY real(kind=WP), intent(in) :: C real(kind=WP), intent(in) :: S public subroutine SROT(N, X, INCX, Y, INCY, C, S) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY real(kind=WP), intent(in) :: C real(kind=WP), intent(in) :: S public subroutine ZDROT(N, X, INCX, Y, INCY, C, S) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N complex(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY real(kind=WP), intent(in) :: C real(kind=WP), intent(in) :: S","tags":"","loc":"interface/rot.html"},{"title":"ROTG – Fortran Program","text":"public interface ROTG Contents Subroutines CROTG DROTG SROTG ZROTG Subroutines public subroutine CROTG(A, B, C, S) Arguments Type Intent Optional Attributes Name complex(kind=WP), intent(inout) :: A complex(kind=WP), intent(inout) :: B real(kind=WP), intent(out) :: C complex(kind=WP), intent(out) :: S public subroutine DROTG(A, B, C, S) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(inout) :: A real(kind=WP), intent(inout) :: B real(kind=WP), intent(out) :: C real(kind=WP), intent(out) :: S public subroutine SROTG(A, B, C, S) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(inout) :: A real(kind=WP), intent(inout) :: B real(kind=WP), intent(out) :: C real(kind=WP), intent(out) :: S public subroutine ZROTG(A, B, C, S) Arguments Type Intent Optional Attributes Name complex(kind=WP), intent(inout) :: A complex(kind=WP), intent(inout) :: B real(kind=WP), intent(out) :: C complex(kind=WP), intent(out) :: S","tags":"","loc":"interface/rotg.html"},{"title":"ROTI – Fortran Program","text":"public interface ROTI Contents Subroutines DROTI SROTI Subroutines public subroutine DROTI(NZ, X, INDX, Y, C, S) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NZ real(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INDX (*) real(kind=WP), intent(in) :: Y (*) real(kind=WP), intent(in) :: C real(kind=WP), intent(in) :: S public subroutine SROTI(NZ, X, INDX, Y, C, S) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NZ real(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INDX (*) real(kind=WP), intent(in) :: Y (*) real(kind=WP), intent(in) :: C real(kind=WP), intent(in) :: S","tags":"","loc":"interface/roti.html"},{"title":"ROTM – Fortran Program","text":"public interface ROTM Contents Subroutines DROTM SROTM Subroutines public subroutine DROTM(N, X, INCX, Y, INCY, PARAM) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY real(kind=WP), intent(in) :: PARAM (5) public subroutine SROTM(N, X, INCX, Y, INCY, PARAM) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY real(kind=WP), intent(in) :: PARAM (5)","tags":"","loc":"interface/rotm.html"},{"title":"ROTMG – Fortran Program","text":"public interface ROTMG Contents Subroutines DROTMG SROTMG Subroutines public subroutine DROTMG(D1, D2, X1, Y1, PARAM) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(inout) :: D1 real(kind=WP), intent(inout) :: D2 real(kind=WP), intent(inout) :: X1 real(kind=WP), intent(in) :: Y1 real(kind=WP), intent(out) :: PARAM (5) public subroutine SROTMG(D1, D2, X1, Y1, PARAM) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(inout) :: D1 real(kind=WP), intent(inout) :: D2 real(kind=WP), intent(inout) :: X1 real(kind=WP), intent(in) :: Y1 real(kind=WP), intent(out) :: PARAM (5)","tags":"","loc":"interface/rotmg.html"},{"title":"SBMV – Fortran Program","text":"public interface SBMV Contents Subroutines DSBMV SSBMV Subroutines public subroutine DSBMV(UPLO, N, K, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N integer, intent(in) :: K real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(in) :: BETA real(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine SSBMV(UPLO, N, K, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N integer, intent(in) :: K real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(in) :: BETA real(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY","tags":"","loc":"interface/sbmv.html"},{"title":"SCAL – Fortran Program","text":"public interface SCAL Contents Subroutines CSCAL CSSCAL DSCAL SSCAL ZDSCAL ZSCAL Subroutines public subroutine CSCAL(N, A, X, INCX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N complex(kind=WP), intent(in) :: A complex(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public subroutine CSSCAL(N, A, X, INCX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(in) :: A complex(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public subroutine DSCAL(N, A, X, INCX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(in) :: A real(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public subroutine SSCAL(N, A, X, INCX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(in) :: A real(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public subroutine ZDSCAL(N, A, X, INCX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(in) :: A complex(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public subroutine ZSCAL(N, A, X, INCX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N complex(kind=WP), intent(in) :: A complex(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX","tags":"","loc":"interface/scal.html"},{"title":"SCTR – Fortran Program","text":"public interface SCTR Contents Subroutines CSCTR DSCTR SSCTR ZSCTR Subroutines public subroutine CSCTR(NZ, X, INDX, Y) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NZ complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INDX (*) complex(kind=WP), intent(out) :: Y (*) public subroutine DSCTR(NZ, X, INDX, Y) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NZ real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INDX (*) real(kind=WP), intent(out) :: Y (*) public subroutine SSCTR(NZ, X, INDX, Y) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NZ real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INDX (*) real(kind=WP), intent(out) :: Y (*) public subroutine ZSCTR(NZ, X, INDX, Y) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NZ complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INDX (*) complex(kind=WP), intent(out) :: Y (*)","tags":"","loc":"interface/sctr.html"},{"title":"SDOT – Fortran Program","text":"public interface SDOT Contents Functions DSDOT SDSDOT Functions public pure function DSDOT(N, SX, INCX, SY, INCY) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=SP), intent(in) :: SX (*) integer, intent(in) :: INCX real(kind=SP), intent(in) :: SY (*) integer, intent(in) :: INCY Return Value real(kind=WP) public pure function SDSDOT(N, SB, SX, INCX, SY, INCY) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(in) :: SB real(kind=WP), intent(in) :: SX (*) integer, intent(in) :: INCX real(kind=WP), intent(in) :: SY (*) integer, intent(in) :: INCY Return Value real(kind=WP)","tags":"","loc":"interface/sdot.html"},{"title":"SPMV – Fortran Program","text":"public interface SPMV Contents Subroutines DSPMV SSPMV Subroutines public subroutine DSPMV(UPLO, N, ALPHA, AP, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: AP (*) real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(in) :: BETA real(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine SSPMV(UPLO, N, ALPHA, AP, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: AP (*) real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(in) :: BETA real(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY","tags":"","loc":"interface/spmv.html"},{"title":"SPR – Fortran Program","text":"public interface SPR Contents Subroutines DSPR SSPR Subroutines public subroutine DSPR(UPLO, N, ALPHA, X, INCX, AP) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(inout) :: AP (*) public subroutine SSPR(UPLO, N, ALPHA, X, INCX, AP) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(inout) :: AP (*)","tags":"","loc":"interface/spr.html"},{"title":"SPR2 – Fortran Program","text":"public interface SPR2 Contents Subroutines DSPR2 SSPR2 Subroutines public subroutine DSPR2(UPLO, N, ALPHA, X, INCX, Y, INCY, AP) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(in) :: Y (*) integer, intent(in) :: INCY real(kind=WP), intent(inout) :: AP (*) public subroutine SSPR2(UPLO, N, ALPHA, X, INCX, Y, INCY, AP) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(in) :: Y (*) integer, intent(in) :: INCY real(kind=WP), intent(inout) :: AP (*)","tags":"","loc":"interface/spr2.html"},{"title":"SWAP – Fortran Program","text":"public interface SWAP Contents Subroutines CSWAP DSWAP SSWAP ZSWAP Subroutines public subroutine CSWAP(N, X, INCX, Y, INCY) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N complex(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine DSWAP(N, X, INCX, Y, INCY) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine SSWAP(N, X, INCX, Y, INCY) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine ZSWAP(N, X, INCX, Y, INCY) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N complex(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY","tags":"","loc":"interface/swap.html"},{"title":"SYMM – Fortran Program","text":"public interface SYMM Contents Subroutines CSYMM DSYMM SSYMM ZSYMM Subroutines public subroutine CSYMM(SIDE, UPLO, M, N, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: SIDE character(len=1), intent(in) :: UPLO integer, intent(in) :: M integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: B (LDB,*) integer, intent(in) :: LDB complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public subroutine DSYMM(SIDE, UPLO, M, N, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: SIDE character(len=1), intent(in) :: UPLO integer, intent(in) :: M integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(in) :: B (LDB,*) integer, intent(in) :: LDB real(kind=WP), intent(in) :: BETA real(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public subroutine SSYMM(SIDE, UPLO, M, N, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: SIDE character(len=1), intent(in) :: UPLO integer, intent(in) :: M integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(in) :: B (LDB,*) integer, intent(in) :: LDB real(kind=WP), intent(in) :: BETA real(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public subroutine ZSYMM(SIDE, UPLO, M, N, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: SIDE character(len=1), intent(in) :: UPLO integer, intent(in) :: M integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: B (LDB,*) integer, intent(in) :: LDB complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC","tags":"","loc":"interface/symm.html"},{"title":"SYMV – Fortran Program","text":"public interface SYMV Contents Subroutines DSYMV SSYMV Subroutines public subroutine DSYMV(UPLO, N, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(in) :: BETA real(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine SSYMV(UPLO, N, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(in) :: BETA real(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY","tags":"","loc":"interface/symv.html"},{"title":"SYR – Fortran Program","text":"public interface SYR Contents Subroutines DSYR SSYR Subroutines public subroutine DSYR(UPLO, N, ALPHA, X, INCX, A, LDA) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(inout) :: A (LDA,*) integer, intent(in) :: LDA public subroutine SSYR(UPLO, N, ALPHA, X, INCX, A, LDA) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(inout) :: A (LDA,*) integer, intent(in) :: LDA","tags":"","loc":"interface/syr.html"},{"title":"SYR2 – Fortran Program","text":"public interface SYR2 Contents Subroutines DSYR2 SSYR2 Subroutines public subroutine DSYR2(UPLO, N, ALPHA, X, INCX, Y, INCY, A, LDA) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(in) :: Y (*) integer, intent(in) :: INCY real(kind=WP), intent(inout) :: A (LDA,*) integer, intent(in) :: LDA public subroutine SSYR2(UPLO, N, ALPHA, X, INCX, Y, INCY, A, LDA) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(in) :: Y (*) integer, intent(in) :: INCY real(kind=WP), intent(inout) :: A (LDA,*) integer, intent(in) :: LDA","tags":"","loc":"interface/syr2.html"},{"title":"SYR2K – Fortran Program","text":"public interface SYR2K Contents Subroutines CSYR2K DSYR2K SSYR2K ZSYR2K Subroutines public subroutine CSYR2K(UPLO, TRANS, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS integer, intent(in) :: N integer, intent(in) :: K complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: B (LDB,*) integer, intent(in) :: LDB complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public subroutine DSYR2K(UPLO, TRANS, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS integer, intent(in) :: N integer, intent(in) :: K real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(in) :: B (LDB,*) integer, intent(in) :: LDB real(kind=WP), intent(in) :: BETA real(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public subroutine SSYR2K(UPLO, TRANS, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS integer, intent(in) :: N integer, intent(in) :: K real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(in) :: B (LDB,*) integer, intent(in) :: LDB real(kind=WP), intent(in) :: BETA real(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public subroutine ZSYR2K(UPLO, TRANS, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS integer, intent(in) :: N integer, intent(in) :: K complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: B (LDB,*) integer, intent(in) :: LDB complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC","tags":"","loc":"interface/syr2k.html"},{"title":"SYRK – Fortran Program","text":"public interface SYRK Contents Subroutines CSYRK DSYRK SSYRK ZSYRK Subroutines public subroutine CSYRK(UPLO, TRANS, N, K, ALPHA, A, LDA, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS integer, intent(in) :: N integer, intent(in) :: K complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public subroutine DSYRK(UPLO, TRANS, N, K, ALPHA, A, LDA, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS integer, intent(in) :: N integer, intent(in) :: K real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(in) :: BETA real(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public subroutine SSYRK(UPLO, TRANS, N, K, ALPHA, A, LDA, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS integer, intent(in) :: N integer, intent(in) :: K real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(in) :: BETA real(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public subroutine ZSYRK(UPLO, TRANS, N, K, ALPHA, A, LDA, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS integer, intent(in) :: N integer, intent(in) :: K complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC","tags":"","loc":"interface/syrk.html"},{"title":"TBMV – Fortran Program","text":"public interface TBMV Contents Subroutines CTBMV DTBMV STBMV ZTBMV Subroutines public subroutine CTBMV(UPLO, TRANS, DIAG, N, K, A, LDA, X, INCX) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS character(len=1), intent(in) :: DIAG integer, intent(in) :: N integer, intent(in) :: K complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public subroutine DTBMV(UPLO, TRANS, DIAG, N, K, A, LDA, X, INCX) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS character(len=1), intent(in) :: DIAG integer, intent(in) :: N integer, intent(in) :: K real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public subroutine STBMV(UPLO, TRANS, DIAG, N, K, A, LDA, X, INCX) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS character(len=1), intent(in) :: DIAG integer, intent(in) :: N integer, intent(in) :: K real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public subroutine ZTBMV(UPLO, TRANS, DIAG, N, K, A, LDA, X, INCX) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS character(len=1), intent(in) :: DIAG integer, intent(in) :: N integer, intent(in) :: K complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX","tags":"","loc":"interface/tbmv.html"},{"title":"TBSV – Fortran Program","text":"public interface TBSV Contents Subroutines CTBSV DTBSV STBSV ZTBSV Subroutines public subroutine CTBSV(UPLO, TRANS, DIAG, N, K, A, LDA, X, INCX) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS character(len=1), intent(in) :: DIAG integer, intent(in) :: N integer, intent(in) :: K complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public subroutine DTBSV(UPLO, TRANS, DIAG, N, K, A, LDA, X, INCX) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS character(len=1), intent(in) :: DIAG integer, intent(in) :: N integer, intent(in) :: K real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public subroutine STBSV(UPLO, TRANS, DIAG, N, K, A, LDA, X, INCX) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS character(len=1), intent(in) :: DIAG integer, intent(in) :: N integer, intent(in) :: K real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public subroutine ZTBSV(UPLO, TRANS, DIAG, N, K, A, LDA, X, INCX) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS character(len=1), intent(in) :: DIAG integer, intent(in) :: N integer, intent(in) :: K complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX","tags":"","loc":"interface/tbsv.html"},{"title":"TPMV – Fortran Program","text":"public interface TPMV Contents Subroutines CTPMV DTPMV STPMV ZTPMV Subroutines public subroutine CTPMV(UPLO, TRANS, DIAG, N, AP, X, INCX) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS character(len=1), intent(in) :: DIAG integer, intent(in) :: N complex(kind=WP), intent(in) :: AP (*) complex(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public subroutine DTPMV(UPLO, TRANS, DIAG, N, AP, X, INCX) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS character(len=1), intent(in) :: DIAG integer, intent(in) :: N real(kind=WP), intent(in) :: AP (*) real(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public subroutine STPMV(UPLO, TRANS, DIAG, N, AP, X, INCX) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS character(len=1), intent(in) :: DIAG integer, intent(in) :: N real(kind=WP), intent(in) :: AP (*) real(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public subroutine ZTPMV(UPLO, TRANS, DIAG, N, AP, X, INCX) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS character(len=1), intent(in) :: DIAG integer, intent(in) :: N complex(kind=WP), intent(in) :: AP (*) complex(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX","tags":"","loc":"interface/tpmv.html"},{"title":"TPSV – Fortran Program","text":"public interface TPSV Contents Subroutines CTPSV DTPSV STPSV ZTPSV Subroutines public subroutine CTPSV(UPLO, TRANS, DIAG, N, AP, X, INCX) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS character(len=1), intent(in) :: DIAG integer, intent(in) :: N complex(kind=WP), intent(in) :: AP (*) complex(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public subroutine DTPSV(UPLO, TRANS, DIAG, N, AP, X, INCX) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS character(len=1), intent(in) :: DIAG integer, intent(in) :: N real(kind=WP), intent(in) :: AP (*) real(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public subroutine STPSV(UPLO, TRANS, DIAG, N, AP, X, INCX) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS character(len=1), intent(in) :: DIAG integer, intent(in) :: N real(kind=WP), intent(in) :: AP (*) real(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public subroutine ZTPSV(UPLO, TRANS, DIAG, N, AP, X, INCX) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS character(len=1), intent(in) :: DIAG integer, intent(in) :: N complex(kind=WP), intent(in) :: AP (*) complex(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX","tags":"","loc":"interface/tpsv.html"},{"title":"TRMM – Fortran Program","text":"public interface TRMM Contents Subroutines CTRMM DTRMM STRMM ZTRMM Subroutines public subroutine CTRMM(SIDE, UPLO, TRANSA, DIAG, M, N, ALPHA, A, LDA, B, LDB) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: SIDE character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANSA character(len=1), intent(in) :: DIAG integer, intent(in) :: M integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(inout) :: B (LDB,*) integer, intent(in) :: LDB public subroutine DTRMM(SIDE, UPLO, TRANSA, DIAG, M, N, ALPHA, A, LDA, B, LDB) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: SIDE character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANSA character(len=1), intent(in) :: DIAG integer, intent(in) :: M integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(inout) :: B (LDB,*) integer, intent(in) :: LDB public subroutine STRMM(SIDE, UPLO, TRANSA, DIAG, M, N, ALPHA, A, LDA, B, LDB) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: SIDE character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANSA character(len=1), intent(in) :: DIAG integer, intent(in) :: M integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(inout) :: B (LDB,*) integer, intent(in) :: LDB public subroutine ZTRMM(SIDE, UPLO, TRANSA, DIAG, M, N, ALPHA, A, LDA, B, LDB) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: SIDE character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANSA character(len=1), intent(in) :: DIAG integer, intent(in) :: M integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(inout) :: B (LDB,*) integer, intent(in) :: LDB","tags":"","loc":"interface/trmm.html"},{"title":"TRMV – Fortran Program","text":"public interface TRMV Contents Subroutines CTRMV DTRMV STRMV ZTRMV Subroutines public subroutine CTRMV(UPLO, TRANS, DIAG, N, A, LDA, X, INCX) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS character(len=1), intent(in) :: DIAG integer, intent(in) :: N complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public subroutine DTRMV(UPLO, TRANS, DIAG, N, A, LDA, X, INCX) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS character(len=1), intent(in) :: DIAG integer, intent(in) :: N real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public subroutine STRMV(UPLO, TRANS, DIAG, N, A, LDA, X, INCX) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS character(len=1), intent(in) :: DIAG integer, intent(in) :: N real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public subroutine ZTRMV(UPLO, TRANS, DIAG, N, A, LDA, X, INCX) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS character(len=1), intent(in) :: DIAG integer, intent(in) :: N complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX","tags":"","loc":"interface/trmv.html"},{"title":"TRSM – Fortran Program","text":"public interface TRSM Contents Subroutines CTRSM DTRSM STRSM ZTRSM Subroutines public subroutine CTRSM(SIDE, UPLO, TRANSA, DIAG, M, N, ALPHA, A, LDA, B, LDB) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: SIDE character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANSA character(len=1), intent(in) :: DIAG integer, intent(in) :: M integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(inout) :: B (LDB,*) integer, intent(in) :: LDB public subroutine DTRSM(SIDE, UPLO, TRANSA, DIAG, M, N, ALPHA, A, LDA, B, LDB) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: SIDE character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANSA character(len=1), intent(in) :: DIAG integer, intent(in) :: M integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(inout) :: B (LDB,*) integer, intent(in) :: LDB public subroutine STRSM(SIDE, UPLO, TRANSA, DIAG, M, N, ALPHA, A, LDA, B, LDB) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: SIDE character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANSA character(len=1), intent(in) :: DIAG integer, intent(in) :: M integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(inout) :: B (LDB,*) integer, intent(in) :: LDB public subroutine ZTRSM(SIDE, UPLO, TRANSA, DIAG, M, N, ALPHA, A, LDA, B, LDB) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: SIDE character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANSA character(len=1), intent(in) :: DIAG integer, intent(in) :: M integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(inout) :: B (LDB,*) integer, intent(in) :: LDB","tags":"","loc":"interface/trsm.html"},{"title":"TRSM_BATCH – Fortran Program","text":"public interface TRSM_BATCH Contents Subroutines CTRSM_BATCH DTRSM_BATCH STRSM_BATCH ZTRSM_BATCH Subroutines public subroutine CTRSM_BATCH(SIDE_ARRAY, UPLO_ARRAY, TRANSA_ARRAY, DIAG_ARRAY, M_ARRAY, N_ARRAY, ALPHA_ARRAY, A_ARRAY, LDA_ARRAY, B_ARRAY, LDB_ARRAY, GROUP_COUNT, GROUP_SIZE) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: SIDE_ARRAY (*) character(len=1), intent(in) :: UPLO_ARRAY (*) character(len=1), intent(in) :: TRANSA_ARRAY (*) character(len=1), intent(in) :: DIAG_ARRAY (*) integer, intent(in) :: M_ARRAY (*) integer, intent(in) :: N_ARRAY (*) complex(kind=WP), intent(in) :: ALPHA_ARRAY (*) integer(kind=C_SIZE_T), intent(in) :: A_ARRAY (*) integer, intent(in) :: LDA_ARRAY (*) integer(kind=C_SIZE_T), intent(in) :: B_ARRAY (*) integer, intent(in) :: LDB_ARRAY (*) integer, intent(in) :: GROUP_COUNT integer, intent(in) :: GROUP_SIZE (*) public subroutine DTRSM_BATCH(SIDE_ARRAY, UPLO_ARRAY, TRANSA_ARRAY, DIAG_ARRAY, M_ARRAY, N_ARRAY, ALPHA_ARRAY, A_ARRAY, LDA_ARRAY, B_ARRAY, LDB_ARRAY, GROUP_COUNT, GROUP_SIZE) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: SIDE_ARRAY (*) character(len=1), intent(in) :: UPLO_ARRAY (*) character(len=1), intent(in) :: TRANSA_ARRAY (*) character(len=1), intent(in) :: DIAG_ARRAY (*) integer, intent(in) :: M_ARRAY (*) integer, intent(in) :: N_ARRAY (*) real(kind=WP), intent(in) :: ALPHA_ARRAY (*) integer(kind=C_SIZE_T), intent(in) :: A_ARRAY (*) integer, intent(in) :: LDA_ARRAY (*) integer(kind=C_SIZE_T), intent(in) :: B_ARRAY (*) integer, intent(in) :: LDB_ARRAY (*) integer, intent(in) :: GROUP_COUNT integer, intent(in) :: GROUP_SIZE (*) public subroutine STRSM_BATCH(SIDE_ARRAY, UPLO_ARRAY, TRANSA_ARRAY, DIAG_ARRAY, M_ARRAY, N_ARRAY, ALPHA_ARRAY, A_ARRAY, LDA_ARRAY, B_ARRAY, LDB_ARRAY, GROUP_COUNT, GROUP_SIZE) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: SIDE_ARRAY (*) character(len=1), intent(in) :: UPLO_ARRAY (*) character(len=1), intent(in) :: TRANSA_ARRAY (*) character(len=1), intent(in) :: DIAG_ARRAY (*) integer, intent(in) :: M_ARRAY (*) integer, intent(in) :: N_ARRAY (*) real(kind=WP), intent(in) :: ALPHA_ARRAY (*) integer(kind=C_SIZE_T), intent(in) :: A_ARRAY (*) integer, intent(in) :: LDA_ARRAY (*) integer(kind=C_SIZE_T), intent(in) :: B_ARRAY (*) integer, intent(in) :: LDB_ARRAY (*) integer, intent(in) :: GROUP_COUNT integer, intent(in) :: GROUP_SIZE (*) public subroutine ZTRSM_BATCH(SIDE_ARRAY, UPLO_ARRAY, TRANSA_ARRAY, DIAG_ARRAY, M_ARRAY, N_ARRAY, ALPHA_ARRAY, A_ARRAY, LDA_ARRAY, B_ARRAY, LDB_ARRAY, GROUP_COUNT, GROUP_SIZE) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: SIDE_ARRAY (*) character(len=1), intent(in) :: UPLO_ARRAY (*) character(len=1), intent(in) :: TRANSA_ARRAY (*) character(len=1), intent(in) :: DIAG_ARRAY (*) integer, intent(in) :: M_ARRAY (*) integer, intent(in) :: N_ARRAY (*) complex(kind=WP), intent(in) :: ALPHA_ARRAY (*) integer(kind=C_SIZE_T), intent(in) :: A_ARRAY (*) integer, intent(in) :: LDA_ARRAY (*) integer(kind=C_SIZE_T), intent(in) :: B_ARRAY (*) integer, intent(in) :: LDB_ARRAY (*) integer, intent(in) :: GROUP_COUNT integer, intent(in) :: GROUP_SIZE (*)","tags":"","loc":"interface/trsm_batch.html"},{"title":"TRSV – Fortran Program","text":"public interface TRSV Contents Subroutines CTRSV DTRSV STRSV ZTRSV Subroutines public subroutine CTRSV(UPLO, TRANS, DIAG, N, A, LDA, X, INCX) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS character(len=1), intent(in) :: DIAG integer, intent(in) :: N complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public subroutine DTRSV(UPLO, TRANS, DIAG, N, A, LDA, X, INCX) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS character(len=1), intent(in) :: DIAG integer, intent(in) :: N real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public subroutine STRSV(UPLO, TRANS, DIAG, N, A, LDA, X, INCX) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS character(len=1), intent(in) :: DIAG integer, intent(in) :: N real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public subroutine ZTRSV(UPLO, TRANS, DIAG, N, A, LDA, X, INCX) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS character(len=1), intent(in) :: DIAG integer, intent(in) :: N complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX","tags":"","loc":"interface/trsv.html"},{"title":"XERBLA – Fortran Program","text":"public interface XERBLA Contents Subroutines XERBLA Subroutines public subroutine XERBLA(NAME, INFO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: NAME integer, intent(in) :: INFO","tags":"","loc":"interface/xerbla.html"},{"title":"AllocationErr – Fortran Program","text":"public subroutine AllocationErr(istat, aMsg, alloc, UnitNo, File, Routine, Line) Checks for successful (de)allocation.  Stops the code. Use this after an allocate/deallocate statement\n allocate(x(nz,ny,nx), stat=istat); call mErr(istat,’x’,1)\n deallocate(x, stat=istat); call mErr(istat,’x’,2) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: istat results of stat=istat in (de)allocate character(len=*), intent(in) :: aMsg Message associated with the (de)allocate integer(kind=I4B), intent(in) :: alloc 1 = allocate, 2 = deallocate integer(kind=I4B), intent(in), optional :: UnitNo Optional file id to write the message to character(len=*), intent(in) :: File Filename and routine name character(len=*), intent(in) :: Routine Filename and routine name integer(kind=I4B), intent(in) :: Line Contents Source Code AllocationErr Source Code SUBROUTINE AllocationErr ( istat , aMsg , alloc , UnitNo , File , Routine , Line ) !! Checks for successful (de)allocation.  Stops the code. !! !! Use this after an allocate/deallocate statement !! allocate(x(nz,ny,nx), stat=istat); call mErr(istat,'x',1) !! deallocate(x, stat=istat); call mErr(istat,'x',2) !====================================================================! INTEGER ( I4B ), intent ( in ) :: istat !! results of stat=istat in (de)allocate character ( len =* ), intent ( in ) :: aMsg !! Message associated with the (de)allocate INTEGER ( I4B ), intent ( in ) :: alloc !! 1 = allocate, 2 = deallocate INTEGER ( I4B ), OPTIONAL , intent ( in ) :: UnitNo !! Optional file id to write the message to CHARACTER ( LEN = * ), INTENT ( IN ) :: File , Routine !! Filename and routine name INTEGER ( I4B ), INTENT ( IN ) :: Line ! Define internal variables CHARACTER ( LEN = : ), ALLOCATABLE :: tmp INTEGER ( I4B ) :: iunit IF ( istat == 0 ) RETURN tmp = '' SELECT CASE ( alloc ) CASE ( OPT_ALLOC ) tmp = 'Allocating Memory: ' // trim ( aMsg ) CASE ( OPT_DEALLOC ) tmp = 'Deallocating Memory: ' // trim ( aMsg ) END SELECT call ErrorMSG ( Msg = tmp , UnitNo = iunit , File = File , Line = Line , & & Routine = Routine ) END SUBROUTINE AllocationErr","tags":"","loc":"proc/allocationerr.html"},{"title":"ErrorMSG – Fortran Program","text":"public subroutine ErrorMSG(Msg, File, Routine, Line, UnitNo) Write a message Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Msg Message to write character(len=*), intent(in) :: File Message to write character(len=*), intent(in) :: Routine Message to write integer(kind=I4B), intent(in) :: Line Line number integer(kind=I4B), intent(in), optional :: UnitNo file id to write the message to Contents Source Code ErrorMSG Source Code SUBROUTINE ErrorMSG ( Msg , File , Routine , Line , UnitNo ) !! Write a message CHARACTER ( LEN = * ), INTENT ( IN ) :: Msg , File , Routine !! Message to write INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: UnitNo !! file id to write the message to INTEGER ( I4B ), INTENT ( IN ) :: Line !! Line number INTEGER ( I4B ) :: Unit_No IF ( PRESENT ( UnitNo ) ) THEN Unit_No = UnitNo ELSE Unit_No = stdout END IF CALL Display ( FILE , \"Error:: In File \" , UnitNo = Unit_No ) CALL Display ( LINE , \"Line number = \" , UnitNo = Unit_No ) CALL Display ( \" \" , \"Routine named \" // TRIM ( Routine ) // & & \" has ERROR with message \" , UnitNo = Unit_No ) CALL Display ( Msg , UnitNo = Unit_No ) END SUBROUTINE ErrorMSG","tags":"","loc":"proc/errormsg.html"},{"title":"FileError – Fortran Program","text":"public subroutine FileError(istat, fname, flg, UnitNo, File, Routine, Line) Checks for a file error Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: istat Result of iostat=istat for open,read,write,close character(len=*), intent(in) :: fname Name of the file integer(kind=I4B), intent(in) :: flg IO_OPEN=Open, IO_READ=Read, IO_WRITE=Write, IO_CLOSE=Close integer(kind=I4B), intent(in), optional :: UnitNo file id to write the error to character(len=*), intent(in) :: File Filename and routine name character(len=*), intent(in) :: Routine Filename and routine name integer(kind=I4B), intent(in) :: Line Contents Source Code FileError Source Code SUBROUTINE FileError ( istat , fname , flg , UnitNo , File , Routine , Line ) !! Checks for a file error INTEGER ( I4B ), INTENT ( IN ) :: istat !! Result of iostat=istat for open,read,write,close CHARACTER ( len =* ), INTENT ( IN ) :: fname !! Name of the file INTEGER ( I4B ), INTENT ( IN ) :: flg !! IO_OPEN=Open, IO_READ=Read, IO_WRITE=Write, IO_CLOSE=Close INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: UnitNo !! file id to write the error to CHARACTER ( LEN = * ), INTENT ( IN ) :: File , Routine !! Filename and routine name INTEGER ( I4B ), INTENT ( IN ) :: Line ! Define internal variables CHARACTER ( len = :), allocatable :: Amsg INTEGER ( I4B ) :: iunit IF ( istat == 0 ) RETURN IF ( PRESENT ( UnitNo ) ) THEN iunit = UnitNo ELSE iunit = stdout END IF Amsg = '' SELECT CASE ( flg ) CASE ( IO_OPEN ) Amsg = 'Opening file: ' // trim ( fname ) CASE ( IO_READ ) Amsg = 'Reading from: ' // trim ( fname ) CASE ( IO_WRITE ) Amsg = 'Writing to file: ' // trim ( fname ) CASE ( IO_CLOSE ) Amsg = 'Closing file: ' // trim ( fname ) CASE DEFAULT Amsg = 'Error:Invalid error flag [1-4]' END SELECT call ErrorMSG ( Msg = aMsg , UnitNo = iunit , File = File , Line = Line , & & Routine = Routine ) END SUBROUTINE FileError","tags":"","loc":"proc/fileerror.html"},{"title":"WarningMSG – Fortran Program","text":"public subroutine WarningMSG(Msg, File, Routine, Line, UnitNo) This subroutine prints the warning message Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Msg Message to write character(len=*), intent(in) :: File Message to write character(len=*), intent(in) :: Routine Message to write integer(kind=I4B), intent(in) :: Line Line number integer(kind=I4B), intent(in), optional :: UnitNo file id to write the message to Contents Source Code WarningMSG Source Code SUBROUTINE WarningMSG ( Msg , File , Routine , Line , UnitNo ) !! This subroutine prints the warning message CHARACTER ( LEN = * ), INTENT ( IN ) :: Msg , File , Routine !! Message to write INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: UnitNo !! file id to write the message to INTEGER ( I4B ), INTENT ( IN ) :: Line !! Line number INTEGER ( I4B ) :: Unit_No IF ( PRESENT ( UnitNo ) ) THEN Unit_No = UnitNo ELSE Unit_No = stdout END IF CALL Display ( FILE , \"Warning:: In File \" , UnitNo = Unit_No ) CALL Display ( LINE , \"Line number = \" , UnitNo = Unit_No ) CALL Display ( \" \" , \"Routine named \" // TRIM ( Routine ) // & & \" has ERROR with message \" , UnitNo = Unit_No ) CALL Display ( Msg , UnitNo = Unit_No ) END SUBROUTINE WarningMSG","tags":"","loc":"proc/warningmsg.html"},{"title":"get_shape – Fortran Program","text":"private pure function get_shape(Obj) result(Ans) Arguments Type Intent Optional Attributes Name type( AbstractVector_ ), intent(in) :: Obj Return Value integer(kind=I4B)\n  (1) Contents Source Code get_shape Source Code PURE FUNCTION get_shape ( Obj ) RESULT ( Ans ) TYPE ( AbstractVector_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ) :: Ans ( 1 ) Ans = 0_I4B END FUNCTION get_shape","tags":"","loc":"proc/get_shape~2.html"},{"title":"get_size – Fortran Program","text":"private pure function get_size(Obj, Dims) result(Ans) Arguments Type Intent Optional Attributes Name type( AbstractVector_ ), intent(in) :: Obj integer(kind=I4B), intent(in), optional :: Dims Return Value integer(kind=I4B) Contents Source Code get_size Source Code PURE FUNCTION get_size ( Obj , Dims ) RESULT ( Ans ) TYPE ( AbstractVector_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: Dims INTEGER ( I4B ) :: Ans Ans = 0 END FUNCTION get_size","tags":"","loc":"proc/get_size~2.html"},{"title":"Shape – Fortran Program","text":"public interface Shape Contents Module Procedures get_shape Module Procedures private pure function get_shape (Obj) result(Ans) Arguments Type Intent Optional Attributes Name type( AbstractVector_ ), intent(in) :: Obj Return Value integer(kind=I4B)\n  (1)","tags":"","loc":"interface/shape~2.html"},{"title":"Size – Fortran Program","text":"public interface Size Contents Module Procedures get_Size Module Procedures private pure function get_size (Obj, Dims) result(Ans) Arguments Type Intent Optional Attributes Name type( AbstractVector_ ), intent(in) :: Obj integer(kind=I4B), intent(in), optional :: Dims Return Value integer(kind=I4B)","tags":"","loc":"interface/size~2.html"},{"title":"CROSS_PRODUCT_R1_R1 – Fortran Program","text":"private pure function CROSS_PRODUCT_R1_R1(a, b) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a (3) real(kind=DFP), intent(in) :: b (3) Return Value real(kind=DFP)\n  (3) Contents Source Code CROSS_PRODUCT_R1_R1 Source Code PURE FUNCTION CROSS_PRODUCT_R1_R1 ( a , b ) RESULT ( Ans ) REAL ( DFP ), INTENT ( IN ) :: a ( 3 ), b ( 3 ) REAL ( DFP ) :: Ans ( 3 ) Ans ( 1 ) = a ( 2 ) * b ( 3 ) - a ( 3 ) * b ( 2 ) Ans ( 2 ) = a ( 3 ) * b ( 1 ) - a ( 1 ) * b ( 3 ) Ans ( 3 ) = a ( 1 ) * b ( 2 ) - a ( 2 ) * b ( 1 ) END FUNCTION CROSS_PRODUCT_R1_R1","tags":"","loc":"proc/cross_product_r1_r1.html"},{"title":"DP2Str – Fortran Program","text":"private function DP2Str(I) Convert REAL to string Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: I Return Value character(len=20) Contents Source Code DP2Str Source Code FUNCTION DP2Str ( I ) REAL ( DP ), INTENT ( IN ) :: I CHARACTER ( LEN = 20 ) :: DP2Str CHARACTER ( LEN = 20 ) :: Str WRITE ( Str , \"(G17.7)\" ) I DP2Str = TRIM ( ADJUSTL ( Str ) ) END FUNCTION DP2Str","tags":"","loc":"proc/dp2str.html"},{"title":"Factorial – Fortran Program","text":"public recursive function Factorial(N) result(Fact) This FUNCTION computes the factorial of an INTEGER Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: N Return Value integer(kind=I4B) Contents Source Code Factorial Source Code RECURSIVE FUNCTION Factorial ( N ) RESULT ( Fact ) INTEGER ( I4B ), INTENT ( IN ) :: N INTEGER ( I4B ) :: Fact IF ( N . EQ . 0 ) THEN Fact = 1 ELSE Fact = N * Factorial ( N - 1 ) END IF END FUNCTION Factorial","tags":"","loc":"proc/factorial.html"},{"title":"Int2Str – Fortran Program","text":"public pure function Int2Str(I) Convert INTEGER  to  string Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: I Return Value character(len=15) Contents Source Code Int2Str Source Code PURE FUNCTION Int2Str ( I ) INTEGER ( I4B ), INTENT ( IN ) :: I CHARACTER ( LEN = 15 ) :: Int2Str CHARACTER ( LEN = 15 ) :: Str WRITE ( Str , \"(I15)\" ) I Int2Str = TRIM ( ADJUSTL ( Str ) ) END FUNCTION Int2Str","tags":"","loc":"proc/int2str.html"},{"title":"Loc_Nearest_Point – Fortran Program","text":"private function Loc_Nearest_Point(Array, x) result(id) This subroutine search the location of nearest point to x in the\n array of coordinates; Array Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Array (:,:) Nodal coordinates in XiJ format real(kind=DFP), intent(in) :: x (:) Return Value integer(kind=I4B) Contents Source Code Loc_Nearest_Point Source Code FUNCTION Loc_Nearest_Point ( Array , x ) RESULT ( id ) REAL ( DFP ), INTENT ( IN ) :: Array ( :, : ) !! Nodal coordinates in XiJ format REAL ( DFP ), INTENT ( IN ) :: x ( : ) INTEGER ( I4B ) :: id ! Define internal variables REAL ( DFP ) :: xr ( 3 ) INTEGER ( I4B ) :: i , n , m , norm , tr_norm n = SIZE ( Array , 1 ) m = SIZE ( Array , 2 ) IF ( n . NE . SIZE ( x ) ) THEN CALL Display ( __ FILE__ , \"ERROR :: In File :: \" ) CALL Display ( __ LINE__ , \"         At line number :: \" ) CALL Display ( \"Loc_Nearest_Point()\" , \"In routine :: \" ) CALL Display ( \"SearchNearestCoord >> size(Array,1) should be =size(x)\" ) STOP ENDIF DO i = 1 , m xr ( 1 : n ) = Array ( 1 : n , i ) tr_norm = DOT_PRODUCT ( xr ( 1 : n ) - x ( 1 : n ), xr ( 1 : n ) - x ( 1 : n ) ) IF ( i . EQ . 1 ) THEN norm = tr_norm id = i ELSE IF ( norm . GT . tr_norm ) THEN norm = tr_norm id = i ELSE CYCLE END IF END IF END DO END FUNCTION Loc_Nearest_Point","tags":"","loc":"proc/loc_nearest_point.html"},{"title":"OUTERPROD1_1 – Fortran Program","text":"private pure function OUTERPROD1_1(a, b) result(Ans) This FUNCTION returns outerproduct(matrix) of two vectors \\mathbf{ans} = \\mathbf{a} \\otimes \\mathbf{b} Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in), DIMENSION(:) :: a real(kind=DFP), intent(in), DIMENSION(:) :: b Return Value real(kind=DFP),\n  DIMENSION(SIZE(a),SIZE(b)) Contents Source Code OUTERPROD1_1 Source Code PURE FUNCTION OUTERPROD1_1 ( a , b ) RESULT ( Ans ) REAL ( DFP ), DIMENSION (:), INTENT ( IN ) :: a , b REAL ( DFP ), DIMENSION ( SIZE ( a ), SIZE ( b )) :: Ans Ans = 0.0_DFP Ans = SPREAD ( a , dim = 2 , ncopies = size ( b )) * & & SPREAD ( b , dim = 1 , ncopies = size ( a )) END FUNCTION OUTERPROD1_1","tags":"","loc":"proc/outerprod1_1.html"},{"title":"OUTERPROD1_1_sym – Fortran Program","text":"private pure function OUTERPROD1_1_sym(a, b, Sym) result(Ans) This FUNCTION returns outerproduct(matrix) of two vectors\n - \\mathbf{ans} = \\mathbf{a} \\otimes \\mathbf{b} - If Sym is .true. THEN symmetric part is returned Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a (:) real(kind=DFP), intent(in) :: b (:) logical(kind=LGT), intent(in) :: Sym Return Value real(kind=DFP),\n  DIMENSION(SIZE(a),SIZE(b)) Contents Source Code OUTERPROD1_1_sym Source Code PURE FUNCTION OUTERPROD1_1_sym ( a , b , Sym ) RESULT ( Ans ) ! Define INTENT of dummy variables REAL ( DFP ), INTENT ( IN ) :: a ( : ), b ( : ) REAL ( DFP ), DIMENSION ( SIZE ( a ), SIZE ( b )) :: Ans LOGICAL ( LGT ), INTENT ( IN ) :: Sym Ans = 0.0_DFP IF ( Sym ) THEN Ans = SPREAD ( 0.5_DFP * a , dim = 2 , ncopies = size ( b ) ) & & * SPREAD ( b , dim = 1 , ncopies = size ( a ) ) & & + SPREAD ( 0.5_DFP * b , dim = 2 , ncopies = size ( a ) ) & & * SPREAD ( a , dim = 1 , ncopies = size ( b ) ) ELSE Ans = SPREAD ( a , dim = 2 , ncopies = size ( b )) * & & SPREAD ( b , dim = 1 , ncopies = size ( a )) END IF END FUNCTION OUTERPROD1_1_sym","tags":"","loc":"proc/outerprod1_1_sym.html"},{"title":"OUTERPROD2_1 – Fortran Program","text":"private pure function OUTERPROD2_1(a, b) result(Ans) This FUNCTION returns outerprod between a matrix and a vector Ans(:,:,i) = a(:,:) * b(i) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a (:,:) real(kind=DFP), intent(in) :: b (:) Return Value real(kind=DFP)\n  (SIZE(a,1),SIZE(a,2),SIZE(b)) Contents Source Code OUTERPROD2_1 Source Code PURE FUNCTION OUTERPROD2_1 ( a , b ) RESULT ( Ans ) REAL ( DFP ), INTENT ( IN ) :: a ( :, : ) REAL ( DFP ), INTENT ( IN ) :: b ( : ) REAL ( DFP ) :: Ans ( SIZE ( a , 1 ), SIZE ( a , 2 ), SIZE ( b ) ) ! Definen internal variables INTEGER ( I4B ) :: I Ans = 0.0_DFP FORALL ( I = 1 : SIZE ( b )) Ans ( :, :, I ) = a ( :, : ) * b ( I ) END FORALL END FUNCTION OUTERPROD2_1","tags":"","loc":"proc/outerprod2_1.html"},{"title":"OUTERPROD2_11 – Fortran Program","text":"private pure function OUTERPROD2_11(a, b, c) result(ANS) This FUNCTION evaluates outer product between a matrix and two vector Ans = a \\otimes b \\otimes c Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a (:,:) real(kind=DFP), intent(in) :: b (:) real(kind=DFP), intent(in) :: c (:) Return Value real(kind=DFP)\n  (SIZE(a,1),SIZE(a,2),SIZE(b),SIZE(c)) Contents Source Code OUTERPROD2_11 Source Code PURE FUNCTION OUTERPROD2_11 ( a , b , c ) RESULT ( ANS ) REAL ( DFP ), INTENT ( IN ) :: a ( :, : ) REAL ( DFP ), INTENT ( IN ) :: b ( : ), c ( : ) REAL ( DFP ) :: ANS ( SIZE ( a , 1 ), SIZE ( a , 2 ), SIZE ( b ), SIZE ( c ) ) ! Definen internal variables REAL ( DFP ), DIMENSION ( SIZE ( a , 1 ), SIZE ( a , 2 ), SIZE ( b ) ) :: Dummy3 Dummy3 = OUTERPROD2_1 ( a , b ) ANS = OUTERPROD3_1 ( Dummy3 , c ) END FUNCTION OUTERPROD2_11","tags":"","loc":"proc/outerprod2_11.html"},{"title":"OUTERPROD3_1 – Fortran Program","text":"private pure function OUTERPROD3_1(a, b) result(Ans) This FUNCTION evaluate outerproduct between a 3D matrix and a vector\n - Ans( :, :, :,  I ) = a( :, :, : ) * b( I ) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a (:,:,:) real(kind=DFP), intent(in) :: b (:) Return Value real(kind=DFP)\n  (SIZE(a,1),SIZE(a,2),SIZE(a,3),SIZE(b)) Contents Source Code OUTERPROD3_1 Source Code PURE FUNCTION OUTERPROD3_1 ( a , b ) RESULT ( Ans ) REAL ( DFP ), INTENT ( IN ) :: a (:,:,:) REAL ( DFP ), INTENT ( IN ) :: b (:) REAL ( DFP ) :: Ans ( SIZE ( a , 1 ), SIZE ( a , 2 ), SIZE ( a , 3 ), SIZE ( b ) ) INTEGER ( I4B ) :: I Ans = 0.0_DFP FORALL ( I = 1 : SIZE ( b ) ) Ans ( :, :, :, I ) = a ( :, :, : ) * b ( I ) END FORALL END FUNCTION OUTERPROD3_1","tags":"","loc":"proc/outerprod3_1.html"},{"title":"SP2Str – Fortran Program","text":"private function SP2Str(I) Convert REAL to string Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: I Return Value character(len=20) Contents Source Code SP2Str Source Code FUNCTION SP2Str ( I ) REAL ( SP ), INTENT ( IN ) :: I CHARACTER ( LEN = 20 ) :: SP2Str CHARACTER ( LEN = 20 ) :: Str WRITE ( Str , \"(G17.7)\" ) I SP2Str = TRIM ( ADJUSTL ( Str ) ) END FUNCTION SP2Str","tags":"","loc":"proc/sp2str.html"},{"title":"arth_d – Fortran Program","text":"private pure function arth_d(first, increment, n) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: first real(kind=DP), intent(in) :: increment integer(kind=I4B), intent(in) :: n Return Value real(kind=DP),\n  DIMENSION(n) Contents Source Code arth_d Source Code PURE FUNCTION arth_d ( first , increment , n ) REAL ( DP ), INTENT ( IN ) :: first , increment INTEGER ( I4B ), INTENT ( IN ) :: n REAL ( DP ), DIMENSION ( n ) :: arth_d INTEGER ( I4B ) :: k , k2 REAL ( DP ) :: temp IF ( n > 0 ) arth_d ( 1 ) = first IF ( n <= NPAR_ARTH ) THEN DO k = 2 , n arth_d ( k ) = arth_d ( k - 1 ) + increment END DO ELSE DO k = 2 , NPAR2_ARTH arth_d ( k ) = arth_d ( k - 1 ) + increment END DO temp = increment * NPAR2_ARTH k = NPAR2_ARTH DO IF ( k >= n ) exit k2 = k + k arth_d ( k + 1 : min ( k2 , n )) = temp + arth_d ( 1 : min ( k , n - k )) temp = temp + temp k = k2 END DO END IF END FUNCTION arth_d","tags":"","loc":"proc/arth_d.html"},{"title":"arth_i – Fortran Program","text":"private pure function arth_i(first, increment, n) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: first integer(kind=I4B), intent(in) :: increment integer(kind=I4B), intent(in) :: n Return Value integer(kind=I4B),\n  DIMENSION(n) Contents Source Code arth_i Source Code PURE FUNCTION arth_i ( first , increment , n ) INTEGER ( I4B ), INTENT ( IN ) :: first , increment , n INTEGER ( I4B ), DIMENSION ( n ) :: arth_i INTEGER ( I4B ) :: k , k2 , temp IF ( n > 0 ) arth_i ( 1 ) = first IF ( n <= NPAR_ARTH ) THEN DO k = 2 , n arth_i ( k ) = arth_i ( k - 1 ) + increment END DO ELSE DO k = 2 , NPAR2_ARTH arth_i ( k ) = arth_i ( k - 1 ) + increment END DO temp = increment * NPAR2_ARTH k = NPAR2_ARTH DO IF ( k >= n ) exit k2 = k + k arth_i ( k + 1 : min ( k2 , n )) = temp + arth_i ( 1 : min ( k , n - k )) temp = temp + temp k = k2 END DO END IF END FUNCTION arth_i","tags":"","loc":"proc/arth_i.html"},{"title":"arth_r – Fortran Program","text":"private pure function arth_r(first, increment, n) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: first real(kind=SP), intent(in) :: increment integer(kind=I4B), intent(in) :: n Return Value real(kind=SP),\n  DIMENSION(n) Contents Source Code arth_r Source Code PURE FUNCTION arth_r ( first , increment , n ) REAL ( SP ), INTENT ( IN ) :: first , increment INTEGER ( I4B ), INTENT ( IN ) :: n REAL ( SP ), DIMENSION ( n ) :: arth_r INTEGER ( I4B ) :: k , k2 REAL ( SP ) :: temp IF ( n > 0 ) arth_r ( 1 ) = first IF ( n <= NPAR_ARTH ) THEN DO k = 2 , n arth_r ( k ) = arth_r ( k - 1 ) + increment END DO ELSE DO k = 2 , NPAR2_ARTH arth_r ( k ) = arth_r ( k - 1 ) + increment END DO temp = increment * NPAR2_ARTH k = NPAR2_ARTH DO IF ( k >= n ) exit k2 = k + k arth_r ( k + 1 : min ( k2 , n )) = temp + arth_r ( 1 : min ( k , n - k )) temp = temp + temp k = k2 END DO END IF END FUNCTION arth_r","tags":"","loc":"proc/arth_r.html"},{"title":"assert_eq2 – Fortran Program","text":"private function assert_eq2(n1, n2, string) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n1 integer(kind=I4B), intent(in) :: n2 character(len=*), intent(in) :: string Return Value integer(kind=I4B) Contents Source Code assert_eq2 Source Code FUNCTION assert_eq2 ( n1 , n2 , string ) CHARACTER ( LEN =* ), INTENT ( IN ) :: string INTEGER ( I4B ), INTENT ( IN ) :: n1 , n2 INTEGER ( I4B ) :: assert_eq2 IF ( n1 . EQ . n2 ) THEN assert_eq2 = n1 ELSE CALL ErrorMsg ( & & File = __ FILE__ , & & Routine = \"Assert_Eq()\" , & & Line = __ LINE__ , & & MSG = \" Sizes of Matrices are not the same; Program Stopped \" ) STOP END IF END FUNCTION assert_eq2","tags":"","loc":"proc/assert_eq2.html"},{"title":"assert_eq3 – Fortran Program","text":"private function assert_eq3(n1, n2, n3, string) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n1 integer(kind=I4B), intent(in) :: n2 integer(kind=I4B), intent(in) :: n3 character(len=*), intent(in) :: string Return Value integer(kind=I4B) Contents Source Code assert_eq3 Source Code FUNCTION assert_eq3 ( n1 , n2 , n3 , string ) CHARACTER ( LEN =* ), INTENT ( IN ) :: string INTEGER ( I4B ), INTENT ( IN ) :: n1 , n2 , n3 INTEGER ( I4B ) :: assert_eq3 IF ( n1 == n2 . and . n2 == n3 ) THEN assert_eq3 = n1 ELSE CALL ErrorMsg ( & & File = __ FILE__ , & & Routine = \"Assert_Eq()\" , & & Line = __ LINE__ , & & MSG = \" Sizes of Matrices are not the same; Program Stopped \" ) STOP END IF END FUNCTION assert_eq3","tags":"","loc":"proc/assert_eq3.html"},{"title":"assert_eq4 – Fortran Program","text":"private function assert_eq4(n1, n2, n3, n4, string) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n1 integer(kind=I4B), intent(in) :: n2 integer(kind=I4B), intent(in) :: n3 integer(kind=I4B), intent(in) :: n4 character(len=*), intent(in) :: string Return Value integer(kind=I4B) Contents Source Code assert_eq4 Source Code FUNCTION assert_eq4 ( n1 , n2 , n3 , n4 , string ) CHARACTER ( LEN =* ), INTENT ( IN ) :: string INTEGER ( I4B ), INTENT ( IN ) :: n1 , n2 , n3 , n4 INTEGER ( I4B ) :: assert_eq4 IF ( n1 == n2 . and . n2 == n3 . and . n3 == n4 ) THEN assert_eq4 = n1 ELSE CALL ErrorMsg ( & & File = __ FILE__ , & & Routine = \"Assert_Eq()\" , & & Line = __ LINE__ , & & MSG = \" Sizes of Matrices are not the same; Program Stopped \" ) STOP END IF END FUNCTION assert_eq4","tags":"","loc":"proc/assert_eq4.html"},{"title":"assert_eqn – Fortran Program","text":"private function assert_eqn(nn, string) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION( : ) :: nn character(len=*), intent(in) :: string Return Value integer(kind=I4B) Contents Source Code assert_eqn Source Code FUNCTION assert_eqn ( nn , string ) CHARACTER ( LEN =* ), INTENT ( IN ) :: string INTEGER ( I4B ), DIMENSION ( : ), INTENT ( IN ) :: nn INTEGER ( I4B ) :: assert_eqn IF ( all ( nn ( 2 :) == nn ( 1 ))) THEN assert_eqn = nn ( 1 ) ELSE CALL ErrorMsg ( & & File = __ FILE__ , & & Routine = \"Assert_Eq()\" , & & Line = __ LINE__ , & & MSG = \" Sizes of Matrices are not the same; Program Stopped \" ) STOP END IF END FUNCTION assert_eqn","tags":"","loc":"proc/assert_eqn.html"},{"title":"degrees_dfp – Fortran Program","text":"private pure function degrees_dfp(rad) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: rad Return Value real(kind=DFP) Contents Source Code degrees_dfp Source Code PURE FUNCTION degrees_dfp ( rad ) RESULT ( Ans ) REAL ( DFP ), INTENT ( IN ) :: rad REAL ( DFP ) :: Ans Ans = rad / 3.1415926535_DFP * 18 0.0_DFP END FUNCTION degrees_dfp","tags":"","loc":"proc/degrees_dfp.html"},{"title":"det_2D – Fortran Program","text":"private pure function det_2D(A) result(Ans) This FUNCTION returns determinent of 2 by 2 and 3 by 3 matrix Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: A (:,:) Return Value real(kind=DFP) Contents Source Code det_2D Source Code PURE FUNCTION det_2D ( A ) RESULT ( Ans ) REAL ( DFP ), INTENT ( IN ) :: A ( :, : ) REAL ( DFP ) :: Ans SELECT CASE ( SIZE ( A , 1 ) ) CASE ( 1 ) Ans = A ( 1 , 1 ) CASE ( 2 ) Ans = A ( 1 , 1 ) * A ( 2 , 2 ) - A ( 1 , 2 ) * A ( 2 , 1 ) CASE ( 3 ) Ans = A ( 1 , 1 ) * ( A ( 2 , 2 ) * A ( 3 , 3 ) - A ( 2 , 3 ) * A ( 3 , 2 )) & & - A ( 1 , 2 ) * ( A ( 2 , 1 ) * A ( 3 , 3 ) - A ( 2 , 3 ) * A ( 3 , 1 )) & & + A ( 1 , 3 ) * ( A ( 2 , 1 ) * A ( 3 , 2 ) - A ( 3 , 1 ) * A ( 2 , 2 )) CASE ( 4 ) Ans = A ( 1 , 1 ) * ( A ( 2 , 2 ) * ( A ( 3 , 3 ) * A ( 4 , 4 ) - A ( 3 , 4 ) * A ( 4 , 3 ))& & + A ( 2 , 3 ) * ( A ( 3 , 4 ) * A ( 4 , 2 ) - A ( 3 , 2 ) * A ( 4 , 4 )) & & + A ( 2 , 4 ) * ( A ( 3 , 2 ) * A ( 4 , 3 ) & & - A ( 3 , 3 ) * A ( 4 , 2 ))) - A ( 1 , 2 ) * ( A ( 2 , 1 ) * ( A ( 3 , 3 ) * A ( 4 , 4 ) & & - A ( 3 , 4 ) * A ( 4 , 3 )) + A ( 2 , 3 ) * ( A ( 3 , 4 ) * A ( 4 , 1 ) - A ( 3 , 1 ) * A ( 4 , 4 )) & & + A ( 2 , 4 ) * ( A ( 3 , 1 ) * A ( 4 , 3 ) - A ( 3 , 3 ) * A ( 4 , 1 ))) & & + A ( 1 , 3 ) * ( A ( 2 , 1 ) * ( A ( 3 , 2 ) * A ( 4 , 4 ) - A ( 3 , 4 ) * A ( 4 , 2 )) & & + A ( 2 , 2 ) * ( A ( 3 , 4 ) * A ( 4 , 1 ) & & - A ( 3 , 1 ) * A ( 4 , 4 )) + A ( 2 , 4 ) * ( A ( 3 , 1 ) * A ( 4 , 2 ) - A ( 3 , 2 ) * A ( 4 , 1 ))) & & - A ( 1 , 4 ) * ( A ( 2 , 1 ) * ( A ( 3 , 2 ) * A ( 4 , 3 ) - A ( 3 , 3 ) * A ( 4 , 2 )) & & + A ( 2 , 2 ) * ( A ( 3 , 3 ) * A ( 4 , 1 ) - A ( 3 , 1 ) * A ( 4 , 3 )) & & + A ( 2 , 3 ) * ( A ( 3 , 1 ) * A ( 4 , 2 ) - A ( 3 , 2 ) * A ( 4 , 1 ))) END SELECT END FUNCTION det_2D","tags":"","loc":"proc/det_2d.html"},{"title":"det_3D – Fortran Program","text":"private pure function det_3D(A) result(Ans) This FUNCTION returns the determinent of matrix Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: A (:,:,:) Return Value real(kind=DFP),\n  ALLOCATABLE,(:) Contents Source Code det_3D Source Code PURE FUNCTION det_3D ( A ) RESULT ( Ans ) REAL ( DFP ), INTENT ( IN ) :: A ( :, :, : ) REAL ( DFP ), ALLOCATABLE :: Ans ( : ) INTEGER ( I4B ) :: i , n n = SIZE ( A , 3 ) ALLOCATE ( Ans ( n ) ) DO i = 1 , n Ans ( i ) = Det ( A ( :, :, i ) ) END DO END FUNCTION det_3D","tags":"","loc":"proc/det_3d.html"},{"title":"eval_poly – Fortran Program","text":"private function eval_poly(PowerTable, Coeff, X, tTerms) result(Ans) this FUNCTION evaluate a polynomial\n - Power table contains the power of x, y, z\n - Its shape IF ( tTerms, 3 )\n    - Coeff is vector its size is tTerms\n    - X( 3 ) contains x, y, z Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in), DIMENSION( tTerms, 3 ) :: PowerTable real(kind=DFP), intent(in), DIMENSION( tTerms ) :: Coeff real(kind=DFP), intent(in) :: X (3) integer(kind=I4B), intent(in) :: tTerms Return Value real(kind=DFP) Contents Source Code eval_poly Source Code FUNCTION eval_poly ( PowerTable , Coeff , X , tTerms ) RESULT ( Ans ) INTEGER ( I4B ), INTENT ( IN ) :: tTerms REAL ( DFP ), DIMENSION ( tTerms , 3 ), INTENT ( IN ) :: PowerTable REAL ( DFP ), DIMENSION ( tTerms ), INTENT ( IN ) :: Coeff REAL ( DFP ), INTENT ( IN ) :: X ( 3 ) REAL ( DFP ) :: Ans ! Define internal variable INTEGER ( I4B ) :: i Ans = 0.0_DFP DO i = 1 , tTerms IF ( Coeff ( i ) . NE . 0.0_DFP ) THEN Ans = Ans + Coeff ( i ) * & & ( X ( 1 ) ** PowerTable ( i , 1 ) & & * X ( 2 ) ** PowerTable ( i , 2 ) & & * X ( 3 ) ** PowerTable ( i , 3 ) & & ) END IF END DO END FUNCTION eval_poly","tags":"","loc":"proc/eval_poly.html"},{"title":"getExtension – Fortran Program","text":"public function getExtension(char) result(ext) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: char Return Value character(len=7) Contents None","tags":"","loc":"proc/getextension.html"},{"title":"getUnitNo – Fortran Program","text":"public function getUnitNo(Str) This FUNCTION returns valid unit no for input output Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Str Return Value integer(kind=I4B) Contents Source Code getUnitNo Source Code FUNCTION getUnitNo ( Str ) ! Define INTENT of dumy varibales INTEGER ( I4B ) :: getUnitNo CHARACTER ( LEN = * ), INTENT ( IN ) :: Str ! Define internal variables LOGICAL ( LGT ) :: isOpen , isExist INTEGER ( I4B ) :: Imin , Imax , I Imin = 10 Imax = 1000 DO I = Imin , Imax , 1 INQUIRE ( UNIT = I , OPENED = isOpen , EXIST = isExist ) IF ( isExist . AND . . NOT . isOpen ) EXIT END DO IF ( isOpen . OR . . NOT . isExist ) THEN CALL ErrorMsg ( & & File = __ FILE__ , & & Routine = \"getUnitNo()\" , & & Line = __ LINE__ , & & MSG = \" cannot find a valid unit number; Program Stopped\" ) STOP END IF getUnitNo = I END FUNCTION getUnitNo","tags":"","loc":"proc/getunitno.html"},{"title":"imaxloc_i – Fortran Program","text":"private pure function imaxloc_i(iarr) Function for getting location of maximum value Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION(:) :: iarr Return Value integer(kind=I4B) Contents Source Code imaxloc_i Source Code PURE FUNCTION imaxloc_i ( iarr ) INTEGER ( I4B ), DIMENSION (:), INTENT ( IN ) :: iarr INTEGER ( I4B ), DIMENSION ( 1 ) :: imax INTEGER ( I4B ) :: imaxloc_i imax = MAXLOC ( iarr ( : ) ) imaxloc_i = imax ( 1 ) END FUNCTION imaxloc_i","tags":"","loc":"proc/imaxloc_i.html"},{"title":"imaxloc_r – Fortran Program","text":"private pure function imaxloc_r(arr) Function for getting location of maximum value Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in), DIMENSION(:) :: arr Return Value integer(kind=I4B) Contents Source Code imaxloc_r Source Code PURE FUNCTION imaxloc_r ( arr ) REAL ( DFP ), DIMENSION (:), INTENT ( IN ) :: arr INTEGER ( I4B ) :: imaxloc_r INTEGER ( I4B ), DIMENSION ( 1 ) :: imax imax = MAXLOC ( arr (:) ) imaxloc_r = imax ( 1 ) END FUNCTION imaxloc_r","tags":"","loc":"proc/imaxloc_r.html"},{"title":"iminloc_r – Fortran Program","text":"private function iminloc_r(arr) Function for getting location of minimum value Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in), DIMENSION(:) :: arr Return Value integer(kind=I4B) Contents Source Code iminloc_r Source Code FUNCTION iminloc_r ( arr ) REAL ( DFP ), DIMENSION (:), INTENT ( IN ) :: arr INTEGER ( I4B ), DIMENSION ( 1 ) :: imin INTEGER ( I4B ) :: iminloc_r imin = MINLOC ( arr (:)) iminloc_r = imin ( 1 ) END FUNCTION iminloc_r","tags":"","loc":"proc/iminloc_r.html"},{"title":"input_Int – Fortran Program","text":"private pure function input_Int(default, option) result(val) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: default integer(kind=I4B), intent(in), optional :: option Return Value integer(kind=I4B) Contents None","tags":"","loc":"proc/input_int.html"},{"title":"input_IntArray – Fortran Program","text":"private pure function input_IntArray(default, option) result(val) This function input integer array Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: default (:,:) integer(kind=I4B), intent(in), optional :: option (:,:) Return Value integer(kind=I4B),\n  ALLOCATABLE,(:,:) Contents Source Code input_IntArray Source Code PURE FUNCTION input_IntArray ( default , option ) RESULT ( val ) INTEGER ( I4B ), INTENT ( IN ) :: default (:,:) INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: option (:,:) INTEGER ( I4B ), ALLOCATABLE :: val (:,:) IF ( PRESENT ( option ) ) THEN val = option ELSE val = default ENDIF END FUNCTION input_IntArray","tags":"","loc":"proc/input_intarray.html"},{"title":"input_IntVec – Fortran Program","text":"private function input_IntVec(default, option) result(val) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: default (:) integer(kind=I4B), intent(in), optional :: option (:) Return Value integer(kind=I4B),\n  ALLOCATABLE,(:) Contents None","tags":"","loc":"proc/input_intvec.html"},{"title":"input_Real – Fortran Program","text":"private function input_Real(default, option) result(val) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: default real(kind=DFP), intent(in), optional :: option Return Value real(kind=DFP) Contents None","tags":"","loc":"proc/input_real.html"},{"title":"input_RealArray – Fortran Program","text":"private pure function input_RealArray(default, option) result(val) This function input real array Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: default (:,:) real(kind=DFP), intent(in), optional :: option (:,:) Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:) Contents Source Code input_RealArray Source Code PURE FUNCTION input_RealArray ( default , option ) RESULT ( val ) REAL ( DFP ), INTENT ( IN ) :: default (:,:) REAL ( DFP ), OPTIONAL , INTENT ( IN ) :: option (:,:) REAL ( DFP ), ALLOCATABLE :: val (:,:) IF ( PRESENT ( option ) ) THEN val = option ELSE val = default ENDIF END FUNCTION input_RealArray","tags":"","loc":"proc/input_realarray.html"},{"title":"input_Realvec – Fortran Program","text":"private function input_Realvec(default, option) result(val) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: default (:) real(kind=DFP), intent(in), optional :: option (:) Return Value real(kind=DFP),\n  ALLOCATABLE,(:) Contents None","tags":"","loc":"proc/input_realvec.html"},{"title":"input_String – Fortran Program","text":"private pure function input_String(default, option) result(val) This function input string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: default character(len=*), intent(in), optional :: option Return Value character(len=200) Contents Source Code input_String Source Code PURE FUNCTION input_String ( default , option ) RESULT ( val ) CHARACTER ( LEN =* ), INTENT ( IN ) :: default CHARACTER ( LEN =* ), OPTIONAL , INTENT ( IN ) :: option CHARACTER ( 200 ) :: val IF ( PRESENT ( option ) ) THEN val = TRIM ( option ) ELSE val = TRIM ( default ) ENDIF END FUNCTION input_String","tags":"","loc":"proc/input_string.html"},{"title":"input_logical – Fortran Program","text":"private pure function input_logical(default, option) result(val) This function input logical variables Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(in) :: default logical(kind=LGT), intent(in), optional :: option Return Value logical(kind=LGT) Contents Source Code input_logical Source Code PURE FUNCTION input_logical ( default , option ) RESULT ( val ) LOGICAL ( LGT ), INTENT ( IN ) :: default LOGICAL ( LGT ), OPTIONAL , INTENT ( IN ) :: option LOGICAL ( LGT ) :: val IF ( PRESENT ( option ) ) THEN val = option ELSE val = default ENDIF END FUNCTION input_logical","tags":"","loc":"proc/input_logical.html"},{"title":"matmul_r1_r3 – Fortran Program","text":"private pure function matmul_r1_r3(a1, a2) result(Ans) This fuction performs following task Ans(i,j) = a1(a)*a2(a,i,j) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a1 (:) real(kind=DFP), intent(in) :: a2 (:,:,:) Return Value real(kind=DFP)\n  (size(a2,2),size(a2,3)) Contents Source Code matmul_r1_r3 Source Code PURE FUNCTION matmul_r1_r3 ( a1 , a2 ) RESULT ( Ans ) REAL ( DFP ), INTENT ( IN ) :: a1 ( : ), a2 ( :, :, : ) REAL ( DFP ) :: Ans ( size ( a2 , 2 ), size ( a2 , 3 ) ) INTEGER ( I4B ) :: ii Ans = a1 ( 1 ) * a2 ( 1 ,:,:) DO ii = 2 , SIZE ( a1 ) Ans = Ans + a1 ( ii ) * a2 ( ii ,:,:) END DO END FUNCTION matmul_r1_r3","tags":"","loc":"proc/matmul_r1_r3.html"},{"title":"matmul_r2_r3 – Fortran Program","text":"private pure function matmul_r2_r3(a1, a2) result(Ans) This fuction performs following task Ans(i,j,ip) = a1(i,I)*a2(I,j,ip) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a1 (:,:) real(kind=DFP), intent(in) :: a2 (:,:,:) Return Value real(kind=DFP)\n  (size(a1,1),size(a2,2),size(a2,3)) Contents Source Code matmul_r2_r3 Source Code PURE FUNCTION matmul_r2_r3 ( a1 , a2 ) RESULT ( Ans ) REAL ( DFP ), INTENT ( IN ) :: a1 ( :, : ), a2 ( :, :, : ) REAL ( DFP ) :: Ans ( size ( a1 , 1 ), size ( a2 , 2 ), size ( a2 , 3 ) ) INTEGER ( I4B ) :: ii DO ii = 1 , SIZE ( a2 , 3 ) Ans ( :, :, ii ) = MATMUL ( a1 , a2 ( :, :, ii ) ) END DO END FUNCTION matmul_r2_r3","tags":"","loc":"proc/matmul_r2_r3.html"},{"title":"matmul_r3_r1 – Fortran Program","text":"private pure function matmul_r3_r1(a1, a2) result(Ans) This fuction performs following task Ans(:,:) = a1(:,:,a)*a2(a) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a1 (:,:,:) real(kind=DFP), intent(in) :: a2 (:) Return Value real(kind=DFP)\n  (size(a1,1),size(a1,2)) Contents Source Code matmul_r3_r1 Source Code PURE FUNCTION matmul_r3_r1 ( a1 , a2 ) RESULT ( Ans ) REAL ( DFP ), INTENT ( IN ) :: a1 ( :, :, : ), a2 ( : ) REAL ( DFP ) :: Ans ( size ( a1 , 1 ), size ( a1 , 2 ) ) INTEGER ( I4B ) :: ii Ans = a2 ( 1 ) * a1 ( :, :, 1 ) DO ii = 2 , SIZE ( a2 ) Ans = Ans + a2 ( ii ) * a1 ( :, :, ii ) END DO END FUNCTION matmul_r3_r1","tags":"","loc":"proc/matmul_r3_r1.html"},{"title":"matmul_r3_r2 – Fortran Program","text":"private pure function matmul_r3_r2(a1, a2) result(Ans) This fuction performs following task Ans(i,j,ip) = a1(i,j,I)*a2(I,ip) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a1 (:,:,:) real(kind=DFP), intent(in) :: a2 (:,:) Return Value real(kind=DFP)\n  (size(a1,1),size(a1,2),size(a2,2)) Contents Source Code matmul_r3_r2 Source Code PURE FUNCTION matmul_r3_r2 ( a1 , a2 ) RESULT ( Ans ) REAL ( DFP ), INTENT ( IN ) :: a1 ( :, :, : ), a2 ( :, : ) REAL ( DFP ) :: Ans ( size ( a1 , 1 ), size ( a1 , 2 ), size ( a2 , 2 ) ) INTEGER ( I4B ) :: ip DO ip = 1 , SIZE ( a2 , 2 ) Ans ( :,:, ip ) = MATMUL ( a1 , a2 ( :, ip ) ) END DO END FUNCTION matmul_r3_r2","tags":"","loc":"proc/matmul_r3_r2.html"},{"title":"matmul_r4_r1 – Fortran Program","text":"private pure function matmul_r4_r1(a1, a2) result(Ans) This fuction performs following task Ans(:,:,:) = a1(:,:,:,a)*a2(a) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a1 (:,:,:,:) real(kind=DFP), intent(in) :: a2 (:) Return Value real(kind=DFP)\n  (size(a1,1),size(a1,2),size(a1,3)) Contents Source Code matmul_r4_r1 Source Code PURE FUNCTION matmul_r4_r1 ( a1 , a2 ) RESULT ( Ans ) REAL ( DFP ), INTENT ( IN ) :: a1 ( :, :, :, : ), a2 ( : ) REAL ( DFP ) :: Ans ( size ( a1 , 1 ), size ( a1 , 2 ), size ( a1 , 3 ) ) INTEGER ( I4B ) :: ii Ans = a2 ( 1 ) * a1 ( :, :, :, 1 ) DO ii = 2 , SIZE ( a2 ) Ans = Ans + a2 ( ii ) * a1 ( :, :, :, ii ) END DO END FUNCTION matmul_r4_r1","tags":"","loc":"proc/matmul_r4_r1.html"},{"title":"outerdIFf_d – Fortran Program","text":"private pure function outerdIFf_d(a, b) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: a real(kind=DP), intent(in), DIMENSION(:) :: b Return Value real(kind=DP),\n  DIMENSION(size(a),size(b)) Contents Source Code outerdIFf_d Source Code PURE FUNCTION outerdIFf_d ( a , b ) REAL ( DP ), DIMENSION (:), INTENT ( IN ) :: a , b REAL ( DP ), DIMENSION ( size ( a ), size ( b )) :: outerdIFf_d outerdIFf_d = SPREAD ( a , dim = 2 , ncopies = size ( b )) - & SPREAD ( b , dim = 1 , ncopies = size ( a )) END FUNCTION outerdIFf_d","tags":"","loc":"proc/outerdiff_d.html"},{"title":"outerdIFf_i – Fortran Program","text":"private pure function outerdIFf_i(a, b) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION(:) :: a integer(kind=I4B), intent(in), DIMENSION(:) :: b Return Value integer(kind=I4B),\n  DIMENSION(size(a),size(b)) Contents Source Code outerdIFf_i Source Code PURE FUNCTION outerdIFf_i ( a , b ) INTEGER ( I4B ), DIMENSION (:), INTENT ( IN ) :: a , b INTEGER ( I4B ), DIMENSION ( size ( a ), size ( b )) :: outerdIFf_i outerdIFf_i = SPREAD ( a , dim = 2 , ncopies = size ( b )) - & SPREAD ( b , dim = 1 , ncopies = size ( a )) END FUNCTION outerdIFf_i","tags":"","loc":"proc/outerdiff_i.html"},{"title":"outerdIFf_r – Fortran Program","text":"private pure function outerdIFf_r(a, b) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: a real(kind=SP), intent(in), DIMENSION(:) :: b Return Value real(kind=SP),\n  DIMENSION(size(a),size(b)) Contents Source Code outerdIFf_r Source Code PURE FUNCTION outerdIFf_r ( a , b ) REAL ( SP ), DIMENSION (:), INTENT ( IN ) :: a , b REAL ( SP ), DIMENSION ( size ( a ), size ( b )) :: outerdIFf_r outerdIFf_r = SPREAD ( a , dim = 2 , ncopies = size ( b )) - & SPREAD ( b , dim = 1 , ncopies = size ( a )) END FUNCTION outerdIFf_r","tags":"","loc":"proc/outerdiff_r.html"},{"title":"radian_dfp – Fortran Program","text":"private pure function radian_dfp(deg) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: deg Return Value real(kind=DFP) Contents Source Code radian_dfp Source Code PURE FUNCTION radian_dfp ( deg ) RESULT ( Ans ) REAL ( DFP ), INTENT ( IN ) :: deg REAL ( DFP ) :: Ans Ans = deg / 18 0.0_DFP * 3.1415926535_DFP END FUNCTION radian_dfp","tags":"","loc":"proc/radian_dfp.html"},{"title":"radian_int – Fortran Program","text":"private pure function radian_int(deg) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: deg Return Value real(kind=DFP) Contents Source Code radian_int Source Code PURE FUNCTION radian_int ( deg ) RESULT ( Ans ) INTEGER ( I4B ), INTENT ( IN ) :: deg REAL ( DFP ) :: Ans Ans = REAL ( deg , KIND = DFP ) / 18 0.0_DFP * 3.1415926535_DFP END FUNCTION radian_int","tags":"","loc":"proc/radian_int.html"},{"title":"vec_prod – Fortran Program","text":"private pure function vec_prod(a, b) result(c) This FUNCTION evaluate vectors product \\mathbf{ans} = \\mathbf{a} \\times \\mathbf{b} Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a (3) real(kind=DFP), intent(in) :: b (3) Return Value real(kind=DFP)\n  (3) Contents Source Code vec_prod Source Code PURE FUNCTION vec_prod ( a , b ) RESULT ( c ) ! Define INTENT of dummy argument REAL ( DFP ), INTENT ( IN ) :: a ( 3 ), b ( 3 ) REAL ( DFP ) :: c ( 3 ) c ( 1 ) = a ( 2 ) * b ( 3 ) - a ( 3 ) * b ( 2 ) c ( 2 ) = a ( 3 ) * b ( 1 ) - a ( 1 ) * b ( 3 ) c ( 3 ) = a ( 1 ) * b ( 2 ) - a ( 2 ) * b ( 1 ) END FUNCTION vec_prod","tags":"","loc":"proc/vec_prod.html"},{"title":"Append_I1 – Fortran Program","text":"private subroutine Append_I1(A, Entry) Append scalar INTEGER  to  INTEGER  vec tor Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), ALLOCATABLE :: A (:) integer(kind=I4B), intent(in) :: Entry Contents Source Code Append_I1 Source Code PURE SUBROUTINE Append_I1 ( A , Entry ) INTEGER ( I4B ), ALLOCATABLE , INTENT ( INOUT ) :: A ( : ) INTEGER ( I4B ), INTENT ( IN ) :: Entry INTEGER ( I4B ), ALLOCATABLE :: Dummy ( : ) INTEGER ( I4B ) :: tSize IF ( . NOT . ALLOCATED ( A ) ) THEN A = [ Entry ] ELSE tSize = SIZE ( A ); ALLOCATE ( Dummy ( tSize + 1 ) ) Dummy ( 1 : tSize ) = A ; Dummy ( tSize + 1 ) = Entry CALL MOVE_ALLOC ( From = Dummy , To = A ) END IF END SUBROUTINE Append_I1","tags":"","loc":"proc/append_i1.html"},{"title":"Append_I2 – Fortran Program","text":"private subroutine Append_I2(A, Entry) Append vector of INTEGER  to  INTEGER  vec tor Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), ALLOCATABLE :: A (:) integer(kind=I4B), intent(in) :: Entry (:) Contents Source Code Append_I2 Source Code PURE SUBROUTINE Append_I2 ( A , Entry ) INTEGER ( I4B ), ALLOCATABLE , INTENT ( INOUT ) :: A ( : ) INTEGER ( I4B ), INTENT ( IN ) :: Entry ( : ) INTEGER ( I4B ), ALLOCATABLE :: Dummy ( : ) INTEGER ( I4B ) :: n , m IF ( . NOT . ALLOCATED ( A ) ) THEN A = Entry ELSE m = SIZE ( Entry ); n = SIZE ( A ) ALLOCATE ( Dummy ( n + m ) ); Dummy ( 1 : n ) = A ; Dummy ( n + 1 : ) = Entry CALL MOVE_ALLOC ( From = Dummy , To = A ) END IF END SUBROUTINE Append_I2","tags":"","loc":"proc/append_i2.html"},{"title":"Append_R1 – Fortran Program","text":"private subroutine Append_R1(A, Entry) Append scalar REAL to the REAL-vector Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: A (:) real(kind=DFP), intent(in) :: Entry Contents Source Code Append_R1 Source Code PURE SUBROUTINE Append_R1 ( A , Entry ) REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: A ( : ) REAL ( DFP ), INTENT ( IN ) :: Entry REAL ( DFP ), ALLOCATABLE :: Dummy ( : ) INTEGER ( I4B ) :: n IF ( . NOT . ALLOCATED ( A ) ) THEN A = [ Entry ] ELSE n = SIZE ( A ); ALLOCATE ( Dummy ( n + 1 ) ) Dummy ( 1 : n ) = A ; Dummy ( 1 + n ) = Entry CALL MOVE_ALLOC ( From = Dummy , TO = A ) END IF END SUBROUTINE Append_R1","tags":"","loc":"proc/append_r1.html"},{"title":"Append_R2 – Fortran Program","text":"private subroutine Append_R2(A, Entry) Append vector of REAL to REAL-vector Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: A (:) real(kind=DFP), intent(in) :: Entry (:) Contents Source Code Append_R2 Source Code PURE SUBROUTINE Append_R2 ( A , Entry ) REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: A ( : ) REAL ( DFP ), INTENT ( IN ) :: Entry ( : ) REAL ( DFP ), ALLOCATABLE :: Dummy ( : ) INTEGER ( I4B ) :: n , m IF ( . NOT . ALLOCATED ( A ) ) THEN A = Entry ELSE m = SIZE ( Entry ); n = SIZE ( A ); ALLOCATE ( Dummy ( n + m ) ) Dummy ( 1 : n ) = A ; Dummy ( 1 + n : ) = Entry CALL MOVE_ALLOC ( FROM = Dummy , TO = A ) END IF END SUBROUTINE Append_R2","tags":"","loc":"proc/append_r2.html"},{"title":"HEAPSORT_INT – Fortran Program","text":"private subroutine HEAPSORT_INT(array) Heap Sort algorithm for Integer Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout) :: array (:) Contents Source Code HEAPSORT_INT Source Code PURE SUBROUTINE HEAPSORT_INT ( array ) INTEGER ( I4B ), INTENT ( INOUT ) :: array ( : ) INTEGER ( I4B ) :: n , i , k , j , l , t n = SIZE ( array ) IF ( n . EQ . 1 ) RETURN l = n / 2 + 1 k = n DO WHILE ( k . NE . 1 ) IF ( l . GT . 1 ) THEN l = l - 1 t = array ( L ) ELSE t = array ( k ) array ( k ) = array ( 1 ) k = k - 1 IF ( k . EQ . 1 ) THEN array ( 1 ) = t EXIT ENDIF ENDIF i = l j = l + l DO WHILE ( j . LE . k ) IF ( j . LT . k ) THEN IF ( array ( j ) . LT . array ( j + 1 ) ) j = j + 1 ENDIF IF ( t . LT . array ( j ) ) THEN array ( i ) = array ( j ) i = j j = j + j ELSE j = k + 1 ENDIF END DO array ( i ) = t ENDDO END SUBROUTINE HEAPSORT_INT","tags":"","loc":"proc/heapsort_int.html"},{"title":"HEAPSORT_REAL – Fortran Program","text":"private subroutine HEAPSORT_REAL(array) Heap Sort algorithm for Real Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout) :: array (:) Contents Source Code HEAPSORT_REAL Source Code PURE SUBROUTINE HEAPSORT_REAL ( array ) REAL ( DFP ), INTENT ( INOUT ) :: array ( : ) INTEGER ( I4B ) :: n , i , k , j , l REAL ( DFP ) :: t n = SIZE ( array ) IF ( n . EQ . 1 ) RETURN l = n / 2 + 1 k = n DO WHILE ( k . NE . 1 ) IF ( l . GT . 1 ) THEN l = l - 1 t = array ( L ) ELSE t = array ( k ) array ( k ) = array ( 1 ) k = k - 1 IF ( k . EQ . 1 ) THEN array ( 1 ) = t EXIT ENDIF ENDIF i = l j = l + l DO WHILE ( j . LE . k ) IF ( j . LT . k ) THEN IF ( array ( j ) . LT . array ( j + 1 ) ) j = j + 1 ENDIF IF ( t . LT . array ( j ) ) THEN array ( i ) = array ( j ) i = j j = j + j ELSE j = k + 1 ENDIF END DO array ( i ) = t ENDDO END SUBROUTINE HEAPSORT_REAL","tags":"","loc":"proc/heapsort_real.html"},{"title":"Inv_2D – Fortran Program","text":"private subroutine Inv_2D(invA, A) This subroutine returns inverse of 2 by 2 and 3 by 3 matrix Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout) :: invA (:,:) real(kind=DFP), intent(in) :: A (:,:) Contents Source Code Inv_2D Source Code PURE SUBROUTINE Inv_2D ( invA , A ) REAL ( DFP ), INTENT ( INOUT ) :: invA ( :, : ) REAL ( DFP ), INTENT ( IN ) :: A ( :, : ) !Define internal variables REAL ( DFP ) :: d , co ( 4 , 4 ) d = det ( A ) IF ( ABS ( d ) . LT . ZERO ) THEN invA = 0.0_DFP ELSE SELECT CASE ( SIZE ( A , 1 ) ) CASE ( 1 ) invA = 1.0 / d CASE ( 2 ) invA ( 1 , 1 ) = A ( 2 , 2 ) / d invA ( 1 , 2 ) = - A ( 1 , 2 ) / d invA ( 2 , 1 ) = - A ( 2 , 1 ) / d invA ( 2 , 2 ) = A ( 1 , 1 ) / d CASE ( 3 ) co ( 1 , 1 ) = ( A ( 2 , 2 ) * A ( 3 , 3 ) - A ( 2 , 3 ) * A ( 3 , 2 )) co ( 1 , 2 ) = - ( A ( 2 , 1 ) * A ( 3 , 3 ) - A ( 2 , 3 ) * A ( 3 , 1 )) co ( 1 , 3 ) = + ( A ( 2 , 1 ) * A ( 3 , 2 ) - A ( 2 , 2 ) * A ( 3 , 1 )) co ( 2 , 1 ) = - ( A ( 1 , 2 ) * A ( 3 , 3 ) - A ( 1 , 3 ) * A ( 3 , 2 )) co ( 2 , 2 ) = + ( A ( 1 , 1 ) * A ( 3 , 3 ) - A ( 1 , 3 ) * A ( 3 , 1 )) co ( 2 , 3 ) = - ( A ( 1 , 1 ) * A ( 3 , 2 ) - A ( 1 , 2 ) * A ( 3 , 1 )) co ( 3 , 1 ) = + ( A ( 1 , 2 ) * A ( 2 , 3 ) - A ( 1 , 3 ) * A ( 2 , 2 )) co ( 3 , 2 ) = - ( A ( 1 , 1 ) * A ( 2 , 3 ) - A ( 1 , 3 ) * A ( 2 , 1 )) co ( 3 , 3 ) = + ( A ( 1 , 1 ) * A ( 2 , 2 ) - A ( 1 , 2 ) * A ( 2 , 1 )) invA = TRANSPOSE ( co ( 1 : 3 , 1 : 3 ) ) / d CASE ( 4 ) co ( 1 , 1 ) = A ( 2 , 2 ) * ( A ( 3 , 3 ) * A ( 4 , 4 ) - A ( 3 , 4 ) * A ( 4 , 3 )) + & A ( 2 , 3 ) * ( A ( 3 , 4 ) * A ( 4 , 2 ) - A ( 3 , 2 ) * A ( 4 , 4 )) + & A ( 2 , 4 ) * ( A ( 3 , 2 ) * A ( 4 , 3 ) - A ( 3 , 3 ) * A ( 4 , 2 )) co ( 1 , 2 ) = A ( 2 , 1 ) * ( A ( 3 , 4 ) * A ( 4 , 3 ) - A ( 3 , 3 ) * A ( 4 , 4 )) + & A ( 2 , 3 ) * ( A ( 3 , 1 ) * A ( 4 , 4 ) - A ( 3 , 4 ) * A ( 4 , 1 )) + & A ( 2 , 4 ) * ( A ( 3 , 3 ) * A ( 4 , 1 ) - A ( 3 , 1 ) * A ( 4 , 3 )) co ( 1 , 3 ) = A ( 2 , 1 ) * ( A ( 3 , 2 ) * A ( 4 , 4 ) - A ( 3 , 4 ) * A ( 4 , 2 )) + & A ( 2 , 2 ) * ( A ( 3 , 4 ) * A ( 4 , 1 ) - A ( 3 , 1 ) * A ( 4 , 4 )) + & A ( 2 , 4 ) * ( A ( 3 , 1 ) * A ( 4 , 2 ) - A ( 3 , 2 ) * A ( 4 , 1 )) co ( 1 , 4 ) = A ( 2 , 1 ) * ( A ( 3 , 3 ) * A ( 4 , 2 ) - A ( 3 , 2 ) * A ( 4 , 3 )) + & A ( 2 , 2 ) * ( A ( 3 , 1 ) * A ( 4 , 3 ) - A ( 3 , 3 ) * A ( 4 , 1 )) + & A ( 2 , 3 ) * ( A ( 3 , 2 ) * A ( 4 , 1 ) - A ( 3 , 1 ) * A ( 4 , 2 )) co ( 2 , 1 ) = A ( 1 , 2 ) * ( A ( 3 , 4 ) * A ( 4 , 3 ) - A ( 3 , 3 ) * A ( 4 , 4 )) + & A ( 1 , 3 ) * ( A ( 3 , 2 ) * A ( 4 , 4 ) - A ( 3 , 4 ) * A ( 4 , 2 )) + & A ( 1 , 4 ) * ( A ( 3 , 3 ) * A ( 4 , 2 ) - A ( 3 , 2 ) * A ( 4 , 3 )) co ( 2 , 2 ) = A ( 1 , 1 ) * ( A ( 3 , 3 ) * A ( 4 , 4 ) - A ( 3 , 4 ) * A ( 4 , 3 )) + & A ( 1 , 3 ) * ( A ( 3 , 4 ) * A ( 4 , 1 ) - A ( 3 , 1 ) * A ( 4 , 4 )) + & A ( 1 , 4 ) * ( A ( 3 , 1 ) * A ( 4 , 3 ) - A ( 3 , 3 ) * A ( 4 , 1 )) co ( 2 , 3 ) = A ( 1 , 1 ) * ( A ( 3 , 4 ) * A ( 4 , 2 ) - A ( 3 , 2 ) * A ( 4 , 4 )) + & A ( 1 , 2 ) * ( A ( 3 , 1 ) * A ( 4 , 4 ) - A ( 3 , 4 ) * A ( 4 , 1 )) + & A ( 1 , 4 ) * ( A ( 3 , 2 ) * A ( 4 , 1 ) - A ( 3 , 1 ) * A ( 4 , 2 )) co ( 2 , 4 ) = A ( 1 , 1 ) * ( A ( 3 , 2 ) * A ( 4 , 3 ) - A ( 3 , 3 ) * A ( 4 , 2 )) + & A ( 1 , 2 ) * ( A ( 3 , 3 ) * A ( 4 , 1 ) - A ( 3 , 1 ) * A ( 4 , 3 )) + & A ( 1 , 3 ) * ( A ( 3 , 1 ) * A ( 4 , 2 ) - A ( 3 , 2 ) * A ( 4 , 1 )) co ( 3 , 1 ) = A ( 1 , 2 ) * ( A ( 2 , 3 ) * A ( 4 , 4 ) - A ( 2 , 4 ) * A ( 4 , 3 )) + & A ( 1 , 3 ) * ( A ( 2 , 4 ) * A ( 4 , 2 ) - A ( 2 , 2 ) * A ( 4 , 4 )) + & A ( 1 , 4 ) * ( A ( 2 , 2 ) * A ( 4 , 3 ) - A ( 2 , 3 ) * A ( 4 , 2 )) co ( 3 , 2 ) = A ( 1 , 1 ) * ( A ( 2 , 4 ) * A ( 4 , 3 ) - A ( 2 , 3 ) * A ( 4 , 4 )) + & A ( 1 , 3 ) * ( A ( 2 , 1 ) * A ( 4 , 4 ) - A ( 2 , 4 ) * A ( 4 , 1 )) + & A ( 1 , 4 ) * ( A ( 2 , 3 ) * A ( 4 , 1 ) - A ( 2 , 1 ) * A ( 4 , 3 )) co ( 3 , 3 ) = A ( 1 , 1 ) * ( A ( 2 , 2 ) * A ( 4 , 4 ) - A ( 2 , 4 ) * A ( 4 , 2 )) + & A ( 1 , 2 ) * ( A ( 2 , 4 ) * A ( 4 , 1 ) - A ( 2 , 1 ) * A ( 4 , 4 )) + & A ( 1 , 4 ) * ( A ( 2 , 1 ) * A ( 4 , 2 ) - A ( 2 , 2 ) * A ( 4 , 1 )) co ( 3 , 4 ) = A ( 1 , 1 ) * ( A ( 2 , 3 ) * A ( 4 , 2 ) - A ( 2 , 2 ) * A ( 4 , 3 )) + & A ( 1 , 2 ) * ( A ( 2 , 1 ) * A ( 4 , 3 ) - A ( 2 , 3 ) * A ( 4 , 1 )) + & A ( 1 , 3 ) * ( A ( 2 , 2 ) * A ( 4 , 1 ) - A ( 2 , 1 ) * A ( 4 , 2 )) co ( 4 , 1 ) = A ( 1 , 2 ) * ( A ( 2 , 4 ) * A ( 3 , 3 ) - A ( 2 , 3 ) * A ( 3 , 4 )) + & A ( 1 , 3 ) * ( A ( 2 , 2 ) * A ( 3 , 4 ) - A ( 2 , 4 ) * A ( 3 , 2 )) + & A ( 1 , 4 ) * ( A ( 2 , 3 ) * A ( 3 , 2 ) - A ( 2 , 2 ) * A ( 3 , 3 )) co ( 4 , 2 ) = A ( 1 , 1 ) * ( A ( 2 , 3 ) * A ( 3 , 4 ) - A ( 2 , 4 ) * A ( 3 , 3 )) + & A ( 1 , 3 ) * ( A ( 2 , 4 ) * A ( 3 , 1 ) - A ( 2 , 1 ) * A ( 3 , 4 )) + & A ( 1 , 4 ) * ( A ( 2 , 1 ) * A ( 3 , 3 ) - A ( 2 , 3 ) * A ( 3 , 1 )) co ( 4 , 3 ) = A ( 1 , 1 ) * ( A ( 2 , 4 ) * A ( 3 , 2 ) - A ( 2 , 2 ) * A ( 3 , 4 )) + & A ( 1 , 2 ) * ( A ( 2 , 1 ) * A ( 3 , 4 ) - A ( 2 , 4 ) * A ( 3 , 1 )) + & A ( 1 , 4 ) * ( A ( 2 , 2 ) * A ( 3 , 1 ) - A ( 2 , 1 ) * A ( 3 , 2 )) co ( 4 , 4 ) = A ( 1 , 1 ) * ( A ( 2 , 2 ) * A ( 3 , 3 ) - A ( 2 , 3 ) * A ( 3 , 2 )) + & A ( 1 , 2 ) * ( A ( 2 , 3 ) * A ( 3 , 1 ) - A ( 2 , 1 ) * A ( 3 , 3 )) + & A ( 1 , 3 ) * ( A ( 2 , 1 ) * A ( 3 , 2 ) - A ( 2 , 2 ) * A ( 3 , 1 )) invA = TRANSPOSE ( co ) / d END SELECT END IF END SUBROUTINE Inv_2D","tags":"","loc":"proc/inv_2d.html"},{"title":"Inv_3D – Fortran Program","text":"private subroutine Inv_3D(invA, A) This subroutine returns inverse of 2 by 2 and 3 by 3 matrix Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout) :: invA (:,:,:) real(kind=DFP), intent(in) :: A (:,:,:) Contents Source Code Inv_3D Source Code PURE SUBROUTINE Inv_3D ( invA , A ) REAL ( DFP ), INTENT ( INOUT ) :: invA ( :, :, : ) REAL ( DFP ), INTENT ( IN ) :: A ( :, :, : ) ! define internal variables INTEGER ( I4B ) :: i , n n = SIZE ( A , 3 ) DO i = 1 , n CALL Inv ( invA = invA ( :, :, i ), A = A ( :, :, i ) ) END DO END SUBROUTINE Inv_3D","tags":"","loc":"proc/inv_3d.html"},{"title":"Rank1ToRank3 – Fortran Program","text":"private subroutine Rank1ToRank3(R1, R3, NSD, NNS, NNT) Returns a 3D arrays of pointers Arguments Type Intent Optional Attributes Name real(kind=DFP), DIMENSION( : ), CONTIGUOUS, TARGET :: R1 real(kind=DFP), DIMENSION( :, :, : ), POINTER :: R3 integer(kind=I4B), intent(in) :: NSD integer(kind=I4B), intent(in) :: NNS integer(kind=I4B), intent(in) :: NNT Contents Source Code Rank1ToRank3 Source Code SUBROUTINE Rank1ToRank3 ( R1 , R3 , NSD , NNS , NNT ) REAL ( DFP ), DIMENSION ( : ), CONTIGUOUS , TARGET :: R1 REAL ( DFP ), DIMENSION ( :, :, : ), POINTER :: R3 INTEGER ( I4B ), INTENT ( IN ) :: NSD , NNS , NNT INTEGER ( I4B ) :: I , N , a , b , K ! Free the memory IF R3 is already allocated IF ( ASSOCIATED ( R3 ) ) DEALLOCATE ( R3 ) NULLIFY ( R3 ) N = SIZE ( R1 ) ! Flag-1 IF ( N . NE . ( NSD * NNS * NNT ) ) THEN CALL ErrorMsg ( & & File = __ FILE__ , & & Routine = \"Rank1ToRank3()\" , & & Line = __ LINE__ , & & MSG = \" Factor Problem\" ) RETURN END IF DO K = 1 , NNT DO I = 1 , NSD a = ( K - 1 ) * NSD * NNS + ( I - 1 ) * NNS + 1 b = a + NNS - 1 R3 ( I : I , 1 : NNS , K : K ) => R1 ( a : b ) END DO END DO END SUBROUTINE Rank1ToRank3","tags":"","loc":"proc/rank1torank3.html"},{"title":"Reallocate1 – Fortran Program","text":"private subroutine Reallocate1(Mat, row, col) Reallocate a 2D array Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: Mat (:,:) integer(kind=I4B), intent(in) :: row integer(kind=I4B), intent(in) :: col Contents Source Code Reallocate1 Source Code PURE SUBROUTINE Reallocate1 ( Mat , row , col ) REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: Mat ( :, : ) INTEGER ( I4B ), INTENT ( IN ) :: row , col IF ( ALLOCATED ( Mat ) ) THEN IF ( ( SIZE ( Mat , 1 ) . NE . row ) . OR . ( SIZE ( Mat , 2 ) . NE . col ) ) THEN DEALLOCATE ( Mat ) ALLOCATE ( Mat ( row , col ) ) END IF ELSE ALLOCATE ( Mat ( row , col ) ) END IF Mat = 0.0_DFP END SUBROUTINE Reallocate1","tags":"","loc":"proc/reallocate1.html"},{"title":"Reallocate10 – Fortran Program","text":"private subroutine Reallocate10(Mat, i1, i2, i3, i4) This subroutine reallocates a 3D array Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: Mat (:,:,:,:) integer(kind=I4B), intent(in) :: i1 integer(kind=I4B), intent(in) :: i2 integer(kind=I4B), intent(in) :: i3 integer(kind=I4B), intent(in) :: i4 Contents Source Code Reallocate10 Source Code PURE SUBROUTINE Reallocate10 ( Mat , i1 , i2 , i3 , i4 ) REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: Mat ( :, :, :, : ) INTEGER ( I4B ), INTENT ( IN ) :: i1 , i2 , i3 , i4 IF ( ALLOCATED ( Mat ) ) THEN IF ( ( SIZE ( Mat , 1 ) . NE . i1 ) & & . OR . ( SIZE ( Mat , 2 ) . NE . i2 ) & & . OR . ( SIZE ( Mat , 3 ) . NE . i3 ) & & . OR . ( SIZE ( Mat , 4 ) . NE . i4 ) & & ) THEN DEALLOCATE ( Mat ) ALLOCATE ( Mat ( i1 , i2 , i3 , i4 ) ) END IF ELSE ALLOCATE ( Mat ( i1 , i2 , i3 , i4 ) ) END IF Mat = 0.0_DFP END SUBROUTINE Reallocate10","tags":"","loc":"proc/reallocate10.html"},{"title":"Reallocate2 – Fortran Program","text":"private subroutine Reallocate2(Mat, row) This subroutine reallocates a vector Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: Mat (:) integer(kind=I4B), intent(in) :: row Contents Source Code Reallocate2 Source Code PURE SUBROUTINE Reallocate2 ( Mat , row ) REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: Mat ( : ) INTEGER ( I4B ), INTENT ( IN ) :: row IF ( ALLOCATED ( Mat ) ) THEN IF ( SIZE ( Mat ) . NE . row ) THEN DEALLOCATE ( Mat ) ALLOCATE ( Mat ( row ) ) END IF ELSE ALLOCATE ( Mat ( row ) ) END IF Mat = 0.0_DFP END SUBROUTINE Reallocate2","tags":"","loc":"proc/reallocate2.html"},{"title":"Reallocate3 – Fortran Program","text":"private subroutine Reallocate3(Mat, i1, i2, i3) This subroutine reallocates a 3D array Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: Mat (:,:,:) integer(kind=I4B), intent(in) :: i1 integer(kind=I4B), intent(in) :: i2 integer(kind=I4B), intent(in) :: i3 Contents Source Code Reallocate3 Source Code PURE SUBROUTINE Reallocate3 ( Mat , i1 , i2 , i3 ) REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: Mat ( :, :, : ) INTEGER ( I4B ), INTENT ( IN ) :: i1 , i2 , i3 IF ( ALLOCATED ( Mat ) ) THEN IF ( ( SIZE ( Mat , 1 ) . NE . i1 ) & & . OR . ( SIZE ( Mat , 2 ) . NE . i2 ) & & . OR . ( SIZE ( Mat , 3 ) . NE . i3 ) ) THEN DEALLOCATE ( Mat ) ALLOCATE ( Mat ( i1 , i2 , i3 ) ) END IF ELSE ALLOCATE ( Mat ( i1 , i2 , i3 ) ) END IF Mat = 0.0_DFP END SUBROUTINE Reallocate3","tags":"","loc":"proc/reallocate3.html"},{"title":"Reallocate4 – Fortran Program","text":"private subroutine Reallocate4(Mat, row, col) This subroutine reallocates a 2D matrix Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), ALLOCATABLE :: Mat (:,:) integer(kind=I4B), intent(in) :: row integer(kind=I4B), intent(in) :: col Contents Source Code Reallocate4 Source Code PURE SUBROUTINE Reallocate4 ( Mat , row , col ) INTEGER ( I4B ), ALLOCATABLE , INTENT ( INOUT ) :: Mat ( :, : ) INTEGER ( I4B ), INTENT ( IN ) :: row , col IF ( ALLOCATED ( Mat ) ) THEN IF ( ( SIZE ( Mat , 1 ) . NE . row ) . OR . ( SIZE ( Mat , 2 ) . NE . col ) ) THEN DEALLOCATE ( Mat ) ALLOCATE ( Mat ( row , col ) ) END IF ELSE ALLOCATE ( Mat ( row , col ) ) END IF Mat = 0 END SUBROUTINE Reallocate4","tags":"","loc":"proc/reallocate4.html"},{"title":"Reallocate5 – Fortran Program","text":"private subroutine Reallocate5(Mat, row) This subroutine reallocates a vector Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), ALLOCATABLE :: Mat (:) integer(kind=I4B), intent(in) :: row Contents Source Code Reallocate5 Source Code PURE SUBROUTINE Reallocate5 ( Mat , row ) INTEGER ( I4B ), ALLOCATABLE , INTENT ( INOUT ) :: Mat ( : ) INTEGER ( I4B ), INTENT ( IN ) :: row IF ( ALLOCATED ( Mat ) ) THEN IF ( SIZE ( Mat ) . NE . row ) THEN DEALLOCATE ( Mat ) ALLOCATE ( Mat ( row ) ) END IF ELSE ALLOCATE ( Mat ( row ) ) END IF Mat = 0 END SUBROUTINE Reallocate5","tags":"","loc":"proc/reallocate5.html"},{"title":"Reallocate6 – Fortran Program","text":"private subroutine Reallocate6(Vec1, n1, Vec2, n2, Vec3, n3, Vec4, n4, Vec5, n5, Vec6, n6) This subroutine can reallocates upto six vectors Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), ALLOCATABLE :: Vec1 (:) integer(kind=I4B), intent(in) :: n1 integer(kind=I4B), intent(inout), ALLOCATABLE :: Vec2 (:) integer(kind=I4B), intent(in) :: n2 integer(kind=I4B), intent(inout), optional ALLOCATABLE :: Vec3 (:) integer(kind=I4B), intent(in), optional :: n3 integer(kind=I4B), intent(inout), optional ALLOCATABLE :: Vec4 (:) integer(kind=I4B), intent(in), optional :: n4 integer(kind=I4B), intent(inout), optional ALLOCATABLE :: Vec5 (:) integer(kind=I4B), intent(in), optional :: n5 integer(kind=I4B), intent(inout), optional ALLOCATABLE :: Vec6 (:) integer(kind=I4B), intent(in), optional :: n6 Contents Source Code Reallocate6 Source Code PURE SUBROUTINE Reallocate6 ( Vec1 , n1 , Vec2 , n2 , Vec3 , n3 , Vec4 , n4 , & & Vec5 , n5 , Vec6 , n6 ) INTEGER ( I4B ), ALLOCATABLE , INTENT ( INOUT ) :: Vec1 ( : ), Vec2 ( : ) INTEGER ( I4B ), ALLOCATABLE , OPTIONAL , INTENT ( INOUT ) :: Vec3 ( : ), & & Vec4 ( : ), Vec5 ( : ), Vec6 ( : ) INTEGER ( I4B ), INTENT ( IN ) :: n1 , n2 INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: n3 , n4 , n5 , n6 IF ( ALLOCATED ( Vec1 ) ) THEN IF ( SIZE ( Vec1 ) . NE . n1 ) THEN DEALLOCATE ( Vec1 ) ALLOCATE ( Vec1 ( n1 ) ) END IF ELSE ALLOCATE ( Vec1 ( n1 ) ) END IF Vec1 = 0 IF ( ALLOCATED ( Vec2 ) ) THEN IF ( SIZE ( Vec2 ) . NE . n2 ) THEN DEALLOCATE ( Vec2 ) ALLOCATE ( Vec2 ( n2 ) ) END IF ELSE ALLOCATE ( Vec2 ( n2 ) ) END IF Vec2 = 0 IF ( PRESENT ( Vec3 ) ) THEN IF ( ALLOCATED ( Vec3 ) ) THEN IF ( SIZE ( Vec3 ) . NE . n3 ) THEN DEALLOCATE ( Vec3 ) ALLOCATE ( Vec3 ( n3 ) ) END IF ELSE ALLOCATE ( Vec3 ( n3 ) ) END IF Vec3 = 0 END IF IF ( PRESENT ( Vec4 ) ) THEN IF ( ALLOCATED ( Vec4 ) ) THEN IF ( SIZE ( Vec4 ) . NE . n4 ) THEN DEALLOCATE ( Vec4 ) ALLOCATE ( Vec4 ( n4 ) ) END IF ELSE ALLOCATE ( Vec4 ( n4 ) ) END IF Vec4 = 0 END IF IF ( PRESENT ( Vec5 ) ) THEN IF ( ALLOCATED ( Vec5 ) ) THEN IF ( SIZE ( Vec5 ) . NE . n5 ) THEN DEALLOCATE ( Vec5 ) ALLOCATE ( Vec5 ( n5 ) ) END IF ELSE ALLOCATE ( Vec5 ( n5 ) ) END IF Vec5 = 0 END IF IF ( PRESENT ( Vec6 ) ) THEN IF ( ALLOCATED ( Vec6 ) ) THEN IF ( SIZE ( Vec6 ) . NE . n6 ) THEN DEALLOCATE ( Vec6 ) ALLOCATE ( Vec6 ( n6 ) ) END IF ELSE ALLOCATE ( Vec6 ( n6 ) ) END IF Vec6 = 0 END IF END SUBROUTINE Reallocate6","tags":"","loc":"proc/reallocate6.html"},{"title":"Reallocate7 – Fortran Program","text":"private subroutine Reallocate7(Vec1, n1, Vec2, n2, Vec3, n3, Vec4, n4, Vec5, n5, Vec6, n6) This subroutine can reallocate upto six vectors Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: Vec1 (:) integer(kind=I4B), intent(in) :: n1 real(kind=DFP), intent(inout), ALLOCATABLE :: Vec2 (:) integer(kind=I4B), intent(in) :: n2 real(kind=DFP), intent(inout), optional ALLOCATABLE :: Vec3 (:) integer(kind=I4B), intent(in), optional :: n3 real(kind=DFP), intent(inout), optional ALLOCATABLE :: Vec4 (:) integer(kind=I4B), intent(in), optional :: n4 real(kind=DFP), intent(inout), optional ALLOCATABLE :: Vec5 (:) integer(kind=I4B), intent(in), optional :: n5 real(kind=DFP), intent(inout), optional ALLOCATABLE :: Vec6 (:) integer(kind=I4B), intent(in), optional :: n6 Contents Source Code Reallocate7 Source Code PURE SUBROUTINE Reallocate7 ( Vec1 , n1 , Vec2 , n2 , Vec3 , n3 , Vec4 , n4 , & & Vec5 , n5 , Vec6 , n6 ) REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: Vec1 ( : ), Vec2 ( : ) REAL ( DFP ), ALLOCATABLE , OPTIONAL , INTENT ( INOUT ) :: Vec3 ( : ), & & Vec4 ( : ), Vec5 ( : ), Vec6 ( : ) INTEGER ( I4B ), INTENT ( IN ) :: n1 , n2 INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: n3 , n4 , n5 , n6 IF ( ALLOCATED ( Vec1 ) ) THEN IF ( SIZE ( Vec1 ) . NE . n1 ) THEN DEALLOCATE ( Vec1 ) ALLOCATE ( Vec1 ( n1 ) ) END IF ELSE ALLOCATE ( Vec1 ( n1 ) ) END IF Vec1 = 0.0 IF ( ALLOCATED ( Vec2 ) ) THEN IF ( SIZE ( Vec2 ) . NE . n2 ) THEN DEALLOCATE ( Vec2 ) ALLOCATE ( Vec2 ( n2 ) ) END IF ELSE ALLOCATE ( Vec2 ( n2 ) ) END IF Vec2 = 0.0 IF ( PRESENT ( Vec3 ) ) THEN IF ( ALLOCATED ( Vec3 ) ) THEN IF ( SIZE ( Vec3 ) . NE . n3 ) THEN DEALLOCATE ( Vec3 ) ALLOCATE ( Vec3 ( n3 ) ) END IF ELSE ALLOCATE ( Vec3 ( n3 ) ) END IF Vec3 = 0.0 END IF IF ( PRESENT ( Vec4 ) ) THEN IF ( ALLOCATED ( Vec4 ) ) THEN IF ( SIZE ( Vec4 ) . NE . n4 ) THEN DEALLOCATE ( Vec4 ) ALLOCATE ( Vec4 ( n4 ) ) END IF ELSE ALLOCATE ( Vec4 ( n4 ) ) END IF Vec4 = 0.0 END IF IF ( PRESENT ( Vec5 ) ) THEN IF ( ALLOCATED ( Vec5 ) ) THEN IF ( SIZE ( Vec5 ) . NE . n5 ) THEN DEALLOCATE ( Vec5 ) ALLOCATE ( Vec5 ( n5 ) ) END IF ELSE ALLOCATE ( Vec5 ( n5 ) ) END IF Vec5 = 0.0 END IF IF ( PRESENT ( Vec6 ) ) THEN IF ( ALLOCATED ( Vec6 ) ) THEN IF ( SIZE ( Vec6 ) . NE . n6 ) THEN DEALLOCATE ( Vec6 ) ALLOCATE ( Vec6 ( n6 ) ) END IF ELSE ALLOCATE ( Vec6 ( n6 ) ) END IF Vec6 = 0.0 END IF END SUBROUTINE Reallocate7","tags":"","loc":"proc/reallocate7.html"},{"title":"Reallocate8 – Fortran Program","text":"private subroutine Reallocate8(A, nA, IA, nIA, JA, nJA) This subroutine can reallocate three vectors; it is useful for\n sparse matrix related methods Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: A (:) integer(kind=I4B), intent(in) :: nA integer(kind=I4B), intent(inout), ALLOCATABLE :: IA (:) integer(kind=I4B), intent(in) :: nIA integer(kind=I4B), intent(inout), ALLOCATABLE :: JA (:) integer(kind=I4B), intent(in) :: nJA Contents Source Code Reallocate8 Source Code PURE SUBROUTINE Reallocate8 ( A , nA , IA , nIA , JA , nJA ) REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: A ( : ) INTEGER ( I4B ), ALLOCATABLE , INTENT ( INOUT ) :: IA ( : ), JA ( : ) INTEGER ( I4B ), INTENT ( IN ) :: nA , nIA , nJA IF ( ALLOCATED ( A ) ) THEN IF ( SIZE ( A ) . NE . nA ) THEN DEALLOCATE ( A ) ALLOCATE ( A ( nA ) ) END IF ELSE ALLOCATE ( A ( nA ) ) END IF A = 0.0 IF ( ALLOCATED ( IA ) ) THEN IF ( SIZE ( IA ) . NE . nIA ) THEN DEALLOCATE ( IA ) ALLOCATE ( IA ( nIA ) ) END IF ELSE ALLOCATE ( IA ( nIA ) ) END IF IA = 0 IF ( ALLOCATED ( JA ) ) THEN IF ( SIZE ( JA ) . NE . nJA ) THEN DEALLOCATE ( JA ) ALLOCATE ( JA ( nJA ) ) END IF ELSE ALLOCATE ( JA ( nJA ) ) END IF JA = 0 END SUBROUTINE Reallocate8","tags":"","loc":"proc/reallocate8.html"},{"title":"Reallocate9 – Fortran Program","text":"private subroutine Reallocate9(A, nA, IA, nIA) This subroutine can reallocate two vectors Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: A (:) integer(kind=I4B), intent(in) :: nA integer(kind=I4B), intent(inout), ALLOCATABLE :: IA (:) integer(kind=I4B), intent(in) :: nIA Contents Source Code Reallocate9 Source Code PURE SUBROUTINE Reallocate9 ( A , nA , IA , nIA ) REAL ( DFP ), ALLOCATABLE , INTENT ( INOUT ) :: A ( : ) INTEGER ( I4B ), ALLOCATABLE , INTENT ( INOUT ) :: IA ( : ) INTEGER ( I4B ), INTENT ( IN ) :: nA , nIA IF ( ALLOCATED ( A ) ) THEN IF ( SIZE ( A ) . NE . nA ) THEN DEALLOCATE ( A ) ALLOCATE ( A ( nA ) ) END IF ELSE ALLOCATE ( A ( nA ) ) END IF A = 0.0 IF ( ALLOCATED ( IA ) ) THEN IF ( SIZE ( IA ) . NE . nIA ) THEN DEALLOCATE ( IA ) ALLOCATE ( IA ( nIA ) ) END IF ELSE ALLOCATE ( IA ( nIA ) ) END IF IA = 0 END SUBROUTINE Reallocate9","tags":"","loc":"proc/reallocate9.html"},{"title":"exe_cmd – Fortran Program","text":"private subroutine exe_cmd(CMD, Str) This subroutine run a system commoand on terminal Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: CMD character(len=*), intent(in) :: Str Contents Source Code exe_cmd Source Code SUBROUTINE exe_cmd ( CMD , Str ) CHARACTER ( LEN = * ), INTENT ( IN ) :: CMD , Str ! Define internal variables INTEGER ( I4B ) :: CMDSTAT , EXITSTAT LOGICAL ( LGT ) :: WAIT = . TRUE . CHARACTER ( LEN = 300 ) :: CMDMSG = \"\" CALL EXECUTE_COMMAND_LINE ( TRIM ( CMD ), CMDSTAT = CMDSTAT , & & EXITSTAT = EXITSTAT , WAIT = WAIT , CMDMSG = CMDMSG ) IF ( CMDSTAT . NE . 0 ) THEN IF ( CMDSTAT . EQ . - 1 ) THEN CALL ErrorMsg ( & & File = __ FILE__ , & & Routine = \"exe_cmd()\" , & & Line = __ LINE__ , & & MSG = \"following command failed \" // TRIM ( CMDMSG ) ) END IF CALL ErrorMsg ( & & File = __ FILE__ , & & Routine = \"exe_cmd()\" , & & Line = __ LINE__ , & & MSG = \"following command failed \" // TRIM ( CMDMSG ) ) STOP END IF END SUBROUTINE exe_cmd","tags":"","loc":"proc/exe_cmd.html"},{"title":"masked_swap_rm – Fortran Program","text":"private subroutine masked_swap_rm(a, b, mask) Subroutine for interchanging two REAL valued matrices Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), DIMENSION(:,:) :: a real(kind=DFP), intent(inout), DIMENSION(:,:) :: b logical(kind=LGT), intent(in), DIMENSION(:,:) :: mask Contents Source Code masked_swap_rm Source Code PURE SUBROUTINE masked_swap_rm ( a , b , mask ) REAL ( DFP ), DIMENSION (:,:), INTENT ( INOUT ) :: a , b LOGICAL ( LGT ), DIMENSION (:,:), INTENT ( IN ) :: mask REAL ( DFP ), DIMENSION ( size ( a , 1 ), size ( a , 2 )) :: swp where ( mask ) swp = a a = b b = swp END where END SUBROUTINE masked_swap_rm","tags":"","loc":"proc/masked_swap_rm.html"},{"title":"masked_swap_rs – Fortran Program","text":"private subroutine masked_swap_rs(a, b, mask) Subroutine for interchanging two REAL valued number Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout) :: a real(kind=DFP), intent(inout) :: b logical(kind=LGT), intent(in) :: mask Contents Source Code masked_swap_rs Source Code PURE SUBROUTINE masked_swap_rs ( a , b , mask ) REAL ( DFP ), INTENT ( INOUT ) :: a , b LOGICAL ( LGT ), INTENT ( IN ) :: mask REAL ( DFP ) :: swp IF ( mask ) THEN swp = a a = b b = swp END IF END SUBROUTINE masked_swap_rs","tags":"","loc":"proc/masked_swap_rs.html"},{"title":"masked_swap_rv – Fortran Program","text":"private subroutine masked_swap_rv(a, b, mask) Subroutine for interchanging two REAL valued vectors Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), DIMENSION(:) :: a real(kind=DFP), intent(inout), DIMENSION(:) :: b logical(kind=LGT), intent(in), DIMENSION(:) :: mask Contents Source Code masked_swap_rv Source Code PURE SUBROUTINE masked_swap_rv ( a , b , mask ) REAL ( DFP ), DIMENSION (:), INTENT ( INOUT ) :: a , b LOGICAL ( LGT ), DIMENSION (:), INTENT ( IN ) :: mask REAL ( DFP ), DIMENSION ( size ( a )) :: swp WHERE ( mask ) swp = a a = b b = swp END WHERE END SUBROUTINE masked_swap_rv","tags":"","loc":"proc/masked_swap_rv.html"},{"title":"nrerror – Fortran Program","text":"private subroutine nrerror(string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Contents Source Code nrerror Source Code SUBROUTINE nrerror ( string ) CHARACTER ( LEN =* ), INTENT ( IN ) :: string write ( * , * ) 'nrerror: ' , string STOP 'program terminated by nrerror' END SUBROUTINE nrerror","tags":"","loc":"proc/nrerror.html"},{"title":"swap_c – Fortran Program","text":"private subroutine swap_c(a, b) Subroutine for interchanging two complex numbers Arguments Type Intent Optional Attributes Name complex(kind=DFPC), intent(inout) :: a complex(kind=DFPC), intent(inout) :: b Contents Source Code swap_c Source Code PURE SUBROUTINE swap_c ( a , b ) COMPLEX ( DFPC ), INTENT ( INOUT ) :: a , b COMPLEX ( DFPC ) :: dum dum = a a = b b = dum END SUBROUTINE swap_c","tags":"","loc":"proc/swap_c.html"},{"title":"swap_cm – Fortran Program","text":"private subroutine swap_cm(a, b) Subroutine for interchanging two complexed valued matrices Arguments Type Intent Optional Attributes Name complex(kind=DFPC), intent(inout), DIMENSION(:,:) :: a complex(kind=DFPC), intent(inout), DIMENSION(:,:) :: b Contents Source Code swap_cm Source Code PURE SUBROUTINE swap_cm ( a , b ) COMPLEX ( DFPC ), DIMENSION (:,:), INTENT ( INOUT ) :: a , b COMPLEX ( DFPC ), DIMENSION ( size ( a , 1 ), size ( a , 2 )) :: dum dum = a a = b b = dum END SUBROUTINE swap_cm","tags":"","loc":"proc/swap_cm.html"},{"title":"swap_cv – Fortran Program","text":"private subroutine swap_cv(a, b) Subroutine for interchanging two complexed valued vectors Arguments Type Intent Optional Attributes Name complex(kind=DFPC), intent(inout), DIMENSION(:) :: a complex(kind=DFPC), intent(inout), DIMENSION(:) :: b Contents Source Code swap_cv Source Code PURE SUBROUTINE swap_cv ( a , b ) COMPLEX ( DFPC ), DIMENSION (:), INTENT ( INOUT ) :: a , b COMPLEX ( DFPC ), DIMENSION ( SIZE ( a )) :: dum dum = a a = b b = dum END SUBROUTINE swap_cv","tags":"","loc":"proc/swap_cv.html"},{"title":"swap_i – Fortran Program","text":"private subroutine swap_i(a, b) Subroutine for interchanging two INTEGER Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout) :: a integer(kind=I4B), intent(inout) :: b Contents Source Code swap_i Source Code PURE SUBROUTINE swap_i ( a , b ) INTEGER ( I4B ), INTENT ( INOUT ) :: a , b INTEGER ( I4B ) :: dum dum = a a = b b = dum END SUBROUTINE swap_i","tags":"","loc":"proc/swap_i.html"},{"title":"swap_r – Fortran Program","text":"private subroutine swap_r(a, b) Subroutine for interchanging two REAL numbers Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout) :: a real(kind=DFP), intent(inout) :: b Contents Source Code swap_r Source Code PURE SUBROUTINE swap_r ( a , b ) REAL ( DFP ), INTENT ( INOUT ) :: a , b REAL ( DFP ) :: dum dum = a a = b b = dum END SUBROUTINE swap_r","tags":"","loc":"proc/swap_r.html"},{"title":"swap_rv – Fortran Program","text":"private subroutine swap_rv(a, b) Subroutine for interchanging two REAL valued vectors Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), DIMENSION(:) :: a real(kind=DFP), intent(inout), DIMENSION(:) :: b Contents Source Code swap_rv Source Code PURE SUBROUTINE swap_rv ( a , b ) REAL ( DFP ), DIMENSION (:), INTENT ( INOUT ) :: a , b REAL ( DFP ), DIMENSION ( SIZE ( a )) :: dum dum = a a = b b = dum END SUBROUTINE swap_rv","tags":"","loc":"proc/swap_rv.html"},{"title":"Append – Fortran Program","text":"public interface Append Contents Module Procedures Append_I1 Append_I2 Append_R1 Append_R2 Module Procedures private subroutine Append_I1 (A, Entry) Append scalar INTEGER  to  INTEGER  vec tor Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), ALLOCATABLE :: A (:) integer(kind=I4B), intent(in) :: Entry private subroutine Append_I2 (A, Entry) Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), ALLOCATABLE :: A (:) integer(kind=I4B), intent(in) :: Entry (:) private subroutine Append_R1 (A, Entry) Read more… Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: A (:) real(kind=DFP), intent(in) :: Entry private subroutine Append_R2 (A, Entry) Append vector of REAL to REAL-vector Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: A (:) real(kind=DFP), intent(in) :: Entry (:)","tags":"","loc":"interface/append.html"},{"title":"Cross_Product – Fortran Program","text":"public interface Cross_Product Contents Module Procedures CROSS_PRODUCT_R1_R1 Module Procedures private pure function CROSS_PRODUCT_R1_R1 (a, b) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a (3) real(kind=DFP), intent(in) :: b (3) Return Value real(kind=DFP)\n  (3)","tags":"","loc":"interface/cross_product.html"},{"title":"Degrees – Fortran Program","text":"public interface Degrees Contents Module Procedures degrees_dfp Module Procedures private pure function degrees_dfp (rad) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: rad Return Value real(kind=DFP)","tags":"","loc":"interface/degrees.html"},{"title":"Det – Fortran Program","text":"public interface Det Generic FUNCTION to get determinent of 2x2 and 3x3 matrix Contents Module Procedures det_2D det_3D Module Procedures private pure function det_2D (A) result(Ans) This FUNCTION returns determinent of 2 by 2 and 3 by 3 matrix Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: A (:,:) Return Value real(kind=DFP) private pure function det_3D (A) result(Ans) This FUNCTION returns the determinent of matrix Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: A (:,:,:) Return Value real(kind=DFP),\n  ALLOCATABLE, (:)","tags":"","loc":"interface/det.html"},{"title":"EvaluatePolynomial – Fortran Program","text":"public interface EvaluatePolynomial Generic FUNCTION to evaluate a polynomial Contents Module Procedures eval_poly Module Procedures private function eval_poly (PowerTable, Coeff, X, tTerms) result(Ans) this FUNCTION evaluate a polynomial\n - Power table contains the power of x, y, z\n - Its shape IF ( tTerms, 3 )\n    - Coeff is vector its size is tTerms\n    - X( 3 ) contains x, y, z Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in), DIMENSION( tTerms, 3 ) :: PowerTable real(kind=DFP), intent(in), DIMENSION( tTerms ) :: Coeff real(kind=DFP), intent(in) :: X (3) integer(kind=I4B), intent(in) :: tTerms Return Value real(kind=DFP)","tags":"","loc":"interface/evaluatepolynomial.html"},{"title":"ExecuteCommand – Fortran Program","text":"public interface ExecuteCommand Contents Module Procedures exe_cmd Module Procedures private subroutine exe_cmd (CMD, Str) This subroutine run a system commoand on terminal Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: CMD character(len=*), intent(in) :: Str","tags":"","loc":"interface/executecommand.html"},{"title":"HeapSort – Fortran Program","text":"public interface HeapSort Contents Module Procedures HEAPSORT_INT HEAPSORT_REAL Module Procedures private subroutine HEAPSORT_INT (array) Heap Sort algorithm for Integer Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout) :: array (:) private subroutine HEAPSORT_REAL (array) Heap Sort algorithm for Real Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout) :: array (:)","tags":"","loc":"interface/heapsort.html"},{"title":"IMAXLOC – Fortran Program","text":"public interface IMAXLOC Generic FUNCTION to get local of maximum value Contents Module Procedures imaxloc_r imaxloc_i Module Procedures private pure function imaxloc_r (arr) Function for getting location of maximum value Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in), DIMENSION(:) :: arr Return Value integer(kind=I4B) private pure function imaxloc_i (iarr) Function for getting location of maximum value Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION(:) :: iarr Return Value integer(kind=I4B)","tags":"","loc":"interface/imaxloc.html"},{"title":"IMINLOC – Fortran Program","text":"public interface IMINLOC Generic FUNCTION for getting location of minmum value Contents Module Procedures iminloc_r Module Procedures private function iminloc_r (arr) Function for getting location of minimum value Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in), DIMENSION(:) :: arr Return Value integer(kind=I4B)","tags":"","loc":"interface/iminloc.html"},{"title":"Input – Fortran Program","text":"public interface Input Contents Module Procedures input_Int input_Real input_IntVec input_RealVec input_IntArray input_RealArray input_String input_logical Module Procedures private pure function input_Int (default, option) result(val) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: default integer(kind=I4B), intent(in), optional :: option Return Value integer(kind=I4B) private function input_Real (default, option) result(val) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: default real(kind=DFP), intent(in), optional :: option Return Value real(kind=DFP) private function input_IntVec (default, option) result(val) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: default (:) integer(kind=I4B), intent(in), optional :: option (:) Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) private function input_Realvec (default, option) result(val) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: default (:) real(kind=DFP), intent(in), optional :: option (:) Return Value real(kind=DFP),\n  ALLOCATABLE, (:) private pure function input_IntArray (default, option) result(val) This function input integer array Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: default (:,:) integer(kind=I4B), intent(in), optional :: option (:,:) Return Value integer(kind=I4B),\n  ALLOCATABLE, (:,:) private pure function input_RealArray (default, option) result(val) This function input real array Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: default (:,:) real(kind=DFP), intent(in), optional :: option (:,:) Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) private pure function input_String (default, option) result(val) This function input string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: default character(len=*), intent(in), optional :: option Return Value character(len=200) private pure function input_logical (default, option) result(val) This function input logical variables Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(in) :: default logical(kind=LGT), intent(in), optional :: option Return Value logical(kind=LGT)","tags":"","loc":"interface/input.html"},{"title":"Inv – Fortran Program","text":"public interface Inv Generic subroutine to get inverse of 2x2 and 3x3 matrix Contents Module Procedures Inv_2D Inv_3D Module Procedures private subroutine Inv_2D (invA, A) This subroutine returns inverse of 2 by 2 and 3 by 3 matrix Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout) :: invA (:,:) real(kind=DFP), intent(in) :: A (:,:) private subroutine Inv_3D (invA, A) This subroutine returns inverse of 2 by 2 and 3 by 3 matrix Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout) :: invA (:,:,:) real(kind=DFP), intent(in) :: A (:,:,:)","tags":"","loc":"interface/inv.html"},{"title":"LOC_NearestPoint – Fortran Program","text":"public interface LOC_NearestPoint Contents Module Procedures Loc_Nearest_Point Module Procedures private function Loc_Nearest_Point (Array, x) result(id) This subroutine search the location of nearest point to x in the\n array of coordinates; Array Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Array (:,:) Nodal coordinates in XiJ format real(kind=DFP), intent(in) :: x (:) Return Value integer(kind=I4B)","tags":"","loc":"interface/loc_nearestpoint.html"},{"title":"OUTERPROD – Fortran Program","text":"public interface OUTERPROD Generic FUNCTION to evaluate outerproduct. Contents Module Procedures OUTERPROD1_1 OUTERPROD2_1 OUTERPROD3_1 OUTERPROD2_11 OUTERPROD1_1_sym Module Procedures private pure function OUTERPROD1_1 (a, b) result(Ans) This FUNCTION returns outerproduct(matrix) of two vectors \\mathbf{ans} = \\mathbf{a} \\otimes \\mathbf{b} Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in), DIMENSION(:) :: a real(kind=DFP), intent(in), DIMENSION(:) :: b Return Value real(kind=DFP),\n  DIMENSION(SIZE(a),SIZE(b)) private pure function OUTERPROD2_1 (a, b) result(Ans) This FUNCTION returns outerprod between a matrix and a vector Ans(:,:,i) = a(:,:) * b(i) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a (:,:) real(kind=DFP), intent(in) :: b (:) Return Value real(kind=DFP)\n  (SIZE(a,1),SIZE(a,2),SIZE(b)) private pure function OUTERPROD3_1 (a, b) result(Ans) This FUNCTION evaluate outerproduct between a 3D matrix and a vector\n - Ans( :, :, :,  I ) = a( :, :, : ) * b( I ) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a (:,:,:) real(kind=DFP), intent(in) :: b (:) Return Value real(kind=DFP)\n  (SIZE(a,1),SIZE(a,2),SIZE(a,3),SIZE(b)) private pure function OUTERPROD2_11 (a, b, c) result(ANS) This FUNCTION evaluates outer product between a matrix and two vector Read more… Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a (:,:) real(kind=DFP), intent(in) :: b (:) real(kind=DFP), intent(in) :: c (:) Return Value real(kind=DFP)\n  (SIZE(a,1),SIZE(a,2),SIZE(b),SIZE(c)) private pure function OUTERPROD1_1_sym (a, b, Sym) result(Ans) This FUNCTION returns outerproduct(matrix) of two vectors\n - \\mathbf{ans} = \\mathbf{a} \\otimes \\mathbf{b} - If Sym is .true. THEN symmetric part is returned Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a (:) real(kind=DFP), intent(in) :: b (:) logical(kind=LGT), intent(in) :: Sym Return Value real(kind=DFP),\n  DIMENSION(SIZE(a),SIZE(b))","tags":"","loc":"interface/outerprod.html"},{"title":"Real2Str – Fortran Program","text":"public interface Real2Str Contents Module Procedures SP2STR DP2STR Module Procedures private function SP2Str (I) Convert REAL to string Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: I Return Value character(len=20) private function DP2Str (I) Convert REAL to string Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: I Return Value character(len=20)","tags":"","loc":"interface/real2str.html"},{"title":"Reallocate – Fortran Program","text":"public interface Reallocate Generic subroutine to reallocate arrays Contents Module Procedures Reallocate1 Reallocate2 Reallocate3 Reallocate4 Reallocate5 Reallocate6 Reallocate7 Reallocate8 Reallocate9 Reallocate10 Module Procedures private subroutine Reallocate1 (Mat, row, col) Reallocate a 2D array Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: Mat (:,:) integer(kind=I4B), intent(in) :: row integer(kind=I4B), intent(in) :: col private subroutine Reallocate2 (Mat, row) This subroutine reallocates a vector Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: Mat (:) integer(kind=I4B), intent(in) :: row private subroutine Reallocate3 (Mat, i1, i2, i3) This subroutine reallocates a 3D array Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: Mat (:,:,:) integer(kind=I4B), intent(in) :: i1 integer(kind=I4B), intent(in) :: i2 integer(kind=I4B), intent(in) :: i3 private subroutine Reallocate4 (Mat, row, col) This subroutine reallocates a 2D matrix Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), ALLOCATABLE :: Mat (:,:) integer(kind=I4B), intent(in) :: row integer(kind=I4B), intent(in) :: col private subroutine Reallocate5 (Mat, row) This subroutine reallocates a vector Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), ALLOCATABLE :: Mat (:) integer(kind=I4B), intent(in) :: row private subroutine Reallocate6 (Vec1, n1, Vec2, n2, Vec3, n3, Vec4, n4, Vec5, n5, Vec6, n6) This subroutine can reallocates upto six vectors Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), ALLOCATABLE :: Vec1 (:) integer(kind=I4B), intent(in) :: n1 integer(kind=I4B), intent(inout), ALLOCATABLE :: Vec2 (:) integer(kind=I4B), intent(in) :: n2 integer(kind=I4B), intent(inout), optional ALLOCATABLE :: Vec3 (:) integer(kind=I4B), intent(in), optional :: n3 integer(kind=I4B), intent(inout), optional ALLOCATABLE :: Vec4 (:) integer(kind=I4B), intent(in), optional :: n4 integer(kind=I4B), intent(inout), optional ALLOCATABLE :: Vec5 (:) integer(kind=I4B), intent(in), optional :: n5 integer(kind=I4B), intent(inout), optional ALLOCATABLE :: Vec6 (:) integer(kind=I4B), intent(in), optional :: n6 private subroutine Reallocate7 (Vec1, n1, Vec2, n2, Vec3, n3, Vec4, n4, Vec5, n5, Vec6, n6) This subroutine can reallocate upto six vectors Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: Vec1 (:) integer(kind=I4B), intent(in) :: n1 real(kind=DFP), intent(inout), ALLOCATABLE :: Vec2 (:) integer(kind=I4B), intent(in) :: n2 real(kind=DFP), intent(inout), optional ALLOCATABLE :: Vec3 (:) integer(kind=I4B), intent(in), optional :: n3 real(kind=DFP), intent(inout), optional ALLOCATABLE :: Vec4 (:) integer(kind=I4B), intent(in), optional :: n4 real(kind=DFP), intent(inout), optional ALLOCATABLE :: Vec5 (:) integer(kind=I4B), intent(in), optional :: n5 real(kind=DFP), intent(inout), optional ALLOCATABLE :: Vec6 (:) integer(kind=I4B), intent(in), optional :: n6 private subroutine Reallocate8 (A, nA, IA, nIA, JA, nJA) This subroutine can reallocate three vectors; it is useful for\n sparse matrix related methods Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: A (:) integer(kind=I4B), intent(in) :: nA integer(kind=I4B), intent(inout), ALLOCATABLE :: IA (:) integer(kind=I4B), intent(in) :: nIA integer(kind=I4B), intent(inout), ALLOCATABLE :: JA (:) integer(kind=I4B), intent(in) :: nJA private subroutine Reallocate9 (A, nA, IA, nIA) This subroutine can reallocate two vectors Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: A (:) integer(kind=I4B), intent(in) :: nA integer(kind=I4B), intent(inout), ALLOCATABLE :: IA (:) integer(kind=I4B), intent(in) :: nIA private subroutine Reallocate10 (Mat, i1, i2, i3, i4) This subroutine reallocates a 3D array Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: Mat (:,:,:,:) integer(kind=I4B), intent(in) :: i1 integer(kind=I4B), intent(in) :: i2 integer(kind=I4B), intent(in) :: i3 integer(kind=I4B), intent(in) :: i4","tags":"","loc":"interface/reallocate.html"},{"title":"SWAP – Fortran Program","text":"public interface SWAP Generic subroutine for swapping Contents Module Procedures swap_i swap_r swap_rv swap_c swap_cv swap_cm masked_swap_rs masked_swap_rv masked_swap_rm Module Procedures private subroutine swap_i (a, b) Subroutine for interchanging two INTEGER Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout) :: a integer(kind=I4B), intent(inout) :: b private subroutine swap_r (a, b) Subroutine for interchanging two REAL numbers Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout) :: a real(kind=DFP), intent(inout) :: b private subroutine swap_rv (a, b) Subroutine for interchanging two REAL valued vectors Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), DIMENSION(:) :: a real(kind=DFP), intent(inout), DIMENSION(:) :: b private subroutine swap_c (a, b) Subroutine for interchanging two complex numbers Arguments Type Intent Optional Attributes Name complex(kind=DFPC), intent(inout) :: a complex(kind=DFPC), intent(inout) :: b private subroutine swap_cv (a, b) Subroutine for interchanging two complexed valued vectors Arguments Type Intent Optional Attributes Name complex(kind=DFPC), intent(inout), DIMENSION(:) :: a complex(kind=DFPC), intent(inout), DIMENSION(:) :: b private subroutine swap_cm (a, b) Subroutine for interchanging two complexed valued matrices Arguments Type Intent Optional Attributes Name complex(kind=DFPC), intent(inout), DIMENSION(:,:) :: a complex(kind=DFPC), intent(inout), DIMENSION(:,:) :: b private subroutine masked_swap_rs (a, b, mask) Subroutine for interchanging two REAL valued number Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout) :: a real(kind=DFP), intent(inout) :: b logical(kind=LGT), intent(in) :: mask private subroutine masked_swap_rv (a, b, mask) Subroutine for interchanging two REAL valued vectors Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), DIMENSION(:) :: a real(kind=DFP), intent(inout), DIMENSION(:) :: b logical(kind=LGT), intent(in), DIMENSION(:) :: mask private subroutine masked_swap_rm (a, b, mask) Subroutine for interchanging two REAL valued matrices Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), DIMENSION(:,:) :: a real(kind=DFP), intent(inout), DIMENSION(:,:) :: b logical(kind=LGT), intent(in), DIMENSION(:,:) :: mask","tags":"","loc":"interface/swap~2.html"},{"title":"SearchNearestCoord – Fortran Program","text":"public interface SearchNearestCoord Contents Module Procedures Loc_Nearest_Point Module Procedures private function Loc_Nearest_Point (Array, x) result(id) This subroutine search the location of nearest point to x in the\n array of coordinates; Array Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Array (:,:) Nodal coordinates in XiJ format real(kind=DFP), intent(in) :: x (:) Return Value integer(kind=I4B)","tags":"","loc":"interface/searchnearestcoord.html"},{"title":"VectorProduct – Fortran Program","text":"public interface VectorProduct Generic FUNCTION to evaluate vector product Contents Module Procedures vec_prod Module Procedures private pure function vec_prod (a, b) result(c) This FUNCTION evaluate vectors product \\mathbf{ans} = \\mathbf{a} \\times \\mathbf{b} Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a (3) real(kind=DFP), intent(in) :: b (3) Return Value real(kind=DFP)\n  (3)","tags":"","loc":"interface/vectorproduct.html"},{"title":"arth – Fortran Program","text":"public interface arth Contents Module Procedures arth_r arth_d arth_i Module Procedures private pure function arth_r (first, increment, n) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: first real(kind=SP), intent(in) :: increment integer(kind=I4B), intent(in) :: n Return Value real(kind=SP),\n  DIMENSION(n) private pure function arth_d (first, increment, n) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: first real(kind=DP), intent(in) :: increment integer(kind=I4B), intent(in) :: n Return Value real(kind=DP),\n  DIMENSION(n) private pure function arth_i (first, increment, n) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: first integer(kind=I4B), intent(in) :: increment integer(kind=I4B), intent(in) :: n Return Value integer(kind=I4B),\n  DIMENSION(n)","tags":"","loc":"interface/arth.html"},{"title":"assert_eq – Fortran Program","text":"public interface assert_eq Contents Module Procedures assert_eq2 assert_eq3 assert_eq4 assert_eqn Module Procedures private function assert_eq2 (n1, n2, string) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n1 integer(kind=I4B), intent(in) :: n2 character(len=*), intent(in) :: string Return Value integer(kind=I4B) private function assert_eq3 (n1, n2, n3, string) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n1 integer(kind=I4B), intent(in) :: n2 integer(kind=I4B), intent(in) :: n3 character(len=*), intent(in) :: string Return Value integer(kind=I4B) private function assert_eq4 (n1, n2, n3, n4, string) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n1 integer(kind=I4B), intent(in) :: n2 integer(kind=I4B), intent(in) :: n3 integer(kind=I4B), intent(in) :: n4 character(len=*), intent(in) :: string Return Value integer(kind=I4B) private function assert_eqn (nn, string) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION( : ) :: nn character(len=*), intent(in) :: string Return Value integer(kind=I4B)","tags":"","loc":"interface/assert_eq.html"},{"title":"matmul – Fortran Program","text":"public interface matmul Contents Module Procedures matmul_r3_r1 matmul_r4_r1 matmul_r3_r2 matmul_r1_r3 matmul_r2_r3 Module Procedures private pure function matmul_r3_r1 (a1, a2) result(Ans) This fuction performs following task Ans(:,:) = a1(:,:,a)*a2(a) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a1 (:,:,:) real(kind=DFP), intent(in) :: a2 (:) Return Value real(kind=DFP)\n  (size(a1,1),size(a1,2)) private pure function matmul_r4_r1 (a1, a2) result(Ans) This fuction performs following task Ans(:,:,:) = a1(:,:,:,a)*a2(a) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a1 (:,:,:,:) real(kind=DFP), intent(in) :: a2 (:) Return Value real(kind=DFP)\n  (size(a1,1),size(a1,2),size(a1,3)) private pure function matmul_r3_r2 (a1, a2) result(Ans) This fuction performs following task Ans(i,j,ip) = a1(i,j,I)*a2(I,ip) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a1 (:,:,:) real(kind=DFP), intent(in) :: a2 (:,:) Return Value real(kind=DFP)\n  (size(a1,1),size(a1,2),size(a2,2)) private pure function matmul_r1_r3 (a1, a2) result(Ans) This fuction performs following task Ans(i,j) = a1(a)*a2(a,i,j) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a1 (:) real(kind=DFP), intent(in) :: a2 (:,:,:) Return Value real(kind=DFP)\n  (size(a2,2),size(a2,3)) private pure function matmul_r2_r3 (a1, a2) result(Ans) This fuction performs following task Ans(i,j,ip) = a1(i,I)*a2(I,j,ip) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a1 (:,:) real(kind=DFP), intent(in) :: a2 (:,:,:) Return Value real(kind=DFP)\n  (size(a1,1),size(a2,2),size(a2,3))","tags":"","loc":"interface/matmul.html"},{"title":"outerdIFf – Fortran Program","text":"public interface outerdIFf Contents Module Procedures outerdIFf_r outerdIFf_i outerdIFf_d Module Procedures private pure function outerdIFf_r (a, b) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: a real(kind=SP), intent(in), DIMENSION(:) :: b Return Value real(kind=SP),\n  DIMENSION(size(a),size(b)) private pure function outerdIFf_i (a, b) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION(:) :: a integer(kind=I4B), intent(in), DIMENSION(:) :: b Return Value integer(kind=I4B),\n  DIMENSION(size(a),size(b)) private pure function outerdIFf_d (a, b) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: a real(kind=DP), intent(in), DIMENSION(:) :: b Return Value real(kind=DP),\n  DIMENSION(size(a),size(b))","tags":"","loc":"interface/outerdiff.html"},{"title":"radian – Fortran Program","text":"public interface radian Contents Module Procedures radian_dfp radian_int Module Procedures private pure function radian_dfp (deg) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: deg Return Value real(kind=DFP) private pure function radian_int (deg) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: deg Return Value real(kind=DFP)","tags":"","loc":"interface/radian.html"},{"title":"get_shape – Fortran Program","text":"private pure function get_shape(Obj) result(Ans) Arguments Type Intent Optional Attributes Name type( AbstractArray_ ), intent(in) :: Obj Return Value integer(kind=I4B),\n  ALLOCATABLE,(:) Contents Source Code get_shape Source Code PURE FUNCTION get_shape ( Obj ) RESULT ( Ans ) TYPE ( AbstractArray_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), ALLOCATABLE :: Ans ( : ) Ans = [ 0 ] END FUNCTION get_shape","tags":"","loc":"proc/get_shape~3.html"},{"title":"get_size – Fortran Program","text":"private pure function get_size(Obj, Dims) result(Ans) Arguments Type Intent Optional Attributes Name type( AbstractArray_ ), intent(in) :: Obj integer(kind=I4B), intent(in), optional :: Dims Return Value integer(kind=I4B) Contents Source Code get_size Source Code PURE FUNCTION get_size ( Obj , Dims ) RESULT ( Ans ) TYPE ( AbstractArray_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: Dims INTEGER ( I4B ) :: Ans Ans = 0 END FUNCTION get_size","tags":"","loc":"proc/get_size~3.html"},{"title":"get_tdimension – Fortran Program","text":"private pure function get_tdimension(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( AbstractArray_ ), intent(in) :: Obj Return Value integer(kind=I4B) Contents Source Code get_tdimension Source Code PURE FUNCTION get_tdimension ( Obj ) RESULT ( Ans ) CLASS ( AbstractArray_ ), INTENT ( IN ) :: Obj INTEGER ( I4B ) :: Ans Ans = Obj % tDimension END FUNCTION get_tdimension","tags":"","loc":"proc/get_tdimension.html"},{"title":"set_tdimension – Fortran Program","text":"private subroutine set_tdimension(Obj, tDimension) Arguments Type Intent Optional Attributes Name class( AbstractArray_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: tDimension Contents Source Code set_tdimension Source Code PURE SUBROUTINE set_tdimension ( Obj , tDimension ) CLASS ( AbstractArray_ ), INTENT ( INOUT ) :: Obj INTEGER ( I4B ), INTENT ( IN ) :: tDimension Obj % tDimension = tDimension END SUBROUTINE set_tdimension","tags":"","loc":"proc/set_tdimension.html"},{"title":"Shape – Fortran Program","text":"public interface Shape Contents Module Procedures get_shape Module Procedures private pure function get_shape (Obj) result(Ans) Arguments Type Intent Optional Attributes Name type( AbstractArray_ ), intent(in) :: Obj Return Value integer(kind=I4B),\n  ALLOCATABLE, (:)","tags":"","loc":"interface/shape~3.html"},{"title":"Size – Fortran Program","text":"public interface Size Contents Module Procedures get_size Module Procedures private pure function get_size (Obj, Dims) result(Ans) Arguments Type Intent Optional Attributes Name type( AbstractArray_ ), intent(in) :: Obj integer(kind=I4B), intent(in), optional :: Dims Return Value integer(kind=I4B)","tags":"","loc":"interface/size~3.html"},{"title":"TotalDimension – Fortran Program","text":"public interface TotalDimension Contents Module Procedures get_tdimension Module Procedures private pure function get_tdimension (Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( AbstractArray_ ), intent(in) :: Obj Return Value integer(kind=I4B)","tags":"","loc":"interface/totaldimension.html"},{"title":"setTotalDimension – Fortran Program","text":"public interface setTotalDimension Contents Module Procedures set_tdimension Module Procedures private subroutine set_tdimension (Obj, tDimension) Arguments Type Intent Optional Attributes Name class( AbstractArray_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: tDimension","tags":"","loc":"interface/settotaldimension.html"},{"title":"Int2Str – Fortran Program","text":"private function Int2Str(I) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: I Return Value character(len=15) Contents Source Code Int2Str Source Code FUNCTION Int2Str ( I ) ! Define intent of dummy arguments INTEGER ( I4B ), INTENT ( IN ) :: I CHARACTER ( LEN = 15 ) :: Int2Str ! Define internal variables CHARACTER ( LEN = 15 ) :: Str WRITE ( Str , \"(I15)\" ) I Int2Str = TRIM ( ADJUSTL ( Str ) ) END FUNCTION Int2Str","tags":"","loc":"proc/int2str~2.html"},{"title":"BlankLines – Fortran Program","text":"public subroutine BlankLines(unitNo, NOL) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), optional :: unitNo integer(kind=I4B), intent(in), optional :: NOL Contents Source Code BlankLines Source Code SUBROUTINE BlankLines ( unitNo , NOL ) ! INTENT OF DUMMY VARIABLES INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: NOL , unitNo ! Define internal variables INTEGER ( I4B ) :: M = 1 , I IF ( PRESENT ( NOL ) ) M = NOL IF ( PRESENT ( unitNo ) ) THEN DO I = 1 , M WRITE ( unitNo , \"(A)\" ) \"\" END DO ELSE DO I = 1 , M WRITE ( stdout , * ) \"\" END DO END IF END SUBROUTINE BlankLines","tags":"","loc":"proc/blanklines.html"},{"title":"DashLine – Fortran Program","text":"public subroutine DashLine(unitNo) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), optional :: unitNo Contents Source Code DashLine Source Code SUBROUTINE DashLine ( unitNo ) ! INTENT OF DUMMY VARIABLES INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: unitNo IF ( PRESENT ( unitNo ) ) THEN WRITE ( unitNo , \"(A)\" ) \"-------------------------------------------------\" ELSE WRITE ( stdout , \"(A)\" ) \"-------------------------------------------------\" END IF END SUBROUTINE DashLine","tags":"","loc":"proc/dashline.html"},{"title":"DebugTag – Fortran Program","text":"public subroutine DebugTag(Tag, unitNo) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), optional :: Tag integer(kind=I4B), intent(in), optional :: unitNo Contents Source Code DebugTag Source Code SUBROUTINE DebugTag ( Tag , unitNo ) ! INTENT OF DUMMY VARIABLES INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: Tag , unitNo ! Define internal variables INTEGER ( I4B ) :: M = 1 IF ( PRESENT ( Tag ) ) M = Tag IF ( PRESENT ( unitNo ) ) THEN WRITE ( unitNo , \"(A,I4)\" ) \"**Debug**\" , M ELSE WRITE ( stdout , \"(A,I4)\" ) \"**Debug**\" , M END IF END SUBROUTINE DebugTag","tags":"","loc":"proc/debugtag.html"},{"title":"Display_Int – Fortran Program","text":"private subroutine Display_Int(vec, msg, unitNo) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: vec character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitNo Contents Source Code Display_Int Source Code SUBROUTINE Display_Int ( vec , msg , unitNo ) ! Define intent of dummy variables INTEGER ( I4B ), INTENT ( IN ) :: vec CHARACTER ( LEN = * ), INTENT ( IN ) :: msg INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: unitNo ! Define internal variables INTEGER ( I4B ) :: I I = stdout IF ( PRESENT ( unitNo ) ) I = unitNo call disp ( title = msg , x = vec , unit = I , style = 'left' ) END SUBROUTINE Display_Int","tags":"","loc":"proc/display_int.html"},{"title":"Display_Logical – Fortran Program","text":"private subroutine Display_Logical(vec, msg, unitNo) Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(in) :: vec character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitNo Contents Source Code Display_Logical Source Code SUBROUTINE Display_Logical ( vec , msg , unitNo ) ! Define intent of dummy variables INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: unitNo LOGICAL ( LGT ), INTENT ( IN ) :: vec CHARACTER ( LEN = * ), INTENT ( IN ) :: msg ! Define internal variables INTEGER ( I4B ) :: I ! I = stdout IF ( PRESENT ( unitNo ) ) I = unitNo call disp ( title = msg , x = vec , unit = I , style = 'left' ) END SUBROUTINE Display_Logical","tags":"","loc":"proc/display_logical.html"},{"title":"Display_Mat2_Int – Fortran Program","text":"private subroutine Display_Mat2_Int(Mat, msg, unitNo, full) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Mat (:,:) character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitNo logical(kind=LGT), intent(in), optional :: full Contents Source Code Display_Mat2_Int Source Code SUBROUTINE Display_Mat2_Int ( Mat , msg , unitNo , full ) !   Define intent of dummy variables INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: unitNo INTEGER ( I4B ), INTENT ( IN ) :: Mat ( :, : ) CHARACTER ( LEN = * ), INTENT ( IN ) :: msg LOGICAL ( LGT ), INTENT ( IN ), OPTIONAL :: full !   Define internal variables INTEGER ( I4B ) :: I , j , r ! I = stdout IF ( PRESENT ( unitNo ) ) I = unitNo call disp ( title = msg , & & x = mat , & & unit = I , & & style = 'underline & pad' , & & sep = ', ' , & & advance = 'double' ) ! IF( LEN_TRIM( msg ) .NE. 0 ) THEN !   WRITE( I, \"(A)\" ) TRIM( msg ) ! END IF ! ! ! r = SIZE( Mat, 1 ) ! IF( I .EQ. stdout ) THEN !   IF( PRESENT( full ) ) THEN !     DO j = 1, r !       CALL Display( Mat( j, : ), \"\", I, full ) !     END DO !   ELSE !     IF( r .LE. 10 ) THEN !       DO j = 1, r !         CALL Display( Mat( j, : ), \"\", I ) !       END DO !     ELSE !       DO j = 1, minRow !         CALL Display( Mat( j, : ), \"\", I ) !       END DO !       WRITE( I, \"(A)\") \".\" !       WRITE( I, \"(A)\") \".\" !       WRITE( I, \"(A)\") \".\" !       DO j = r, r-minRow, -1 !         CALL Display( Mat( j, : ), \"\", I ) !       END DO !     END IF !   END IF ! ELSE !   DO j = 1, r !     CALL Display( Mat( j, : ), \"\", I ) !   END DO ! END IF END SUBROUTINE Display_Mat2_Int","tags":"","loc":"proc/display_mat2_int.html"},{"title":"Display_Mat2_Real – Fortran Program","text":"private subroutine Display_Mat2_Real(Mat, msg, unitNo, full) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in), DIMENSION( :, : ) :: Mat character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitNo logical(kind=LGT), intent(in), optional :: full Contents Source Code Display_Mat2_Real Source Code SUBROUTINE Display_Mat2_Real ( Mat , msg , unitNo , full ) !   Define intent of dummy variables INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: unitNo REAL ( DFP ), DIMENSION ( :, : ), INTENT ( IN ) :: Mat CHARACTER ( LEN = * ), INTENT ( IN ) :: msg LOGICAL ( LGT ), INTENT ( IN ), OPTIONAL :: full !   Define internal variables INTEGER ( I4B ) :: I , j , r ! I = stdout IF ( PRESENT ( unitNo ) ) I = unitNo call disp ( title = msg , & & x = mat , & & unit = I , & & style = 'underline & pad' , & & sep = ', ' , & & advance = 'double' ) ! IF( LEN_TRIM( msg ) .NE. 0 ) THEN !   WRITE( I, \"(A)\" ) TRIM( msg ) ! END IF ! ! ! r = SIZE( Mat, 1 ) ! IF( I .EQ. stdout ) THEN !   IF( PRESENT( full ) ) THEN !     DO j = 1, r !       CALL Display( Mat( j, : ), \"\", I, full ) !     END DO !   ELSE !     IF( r .LE. 10 ) THEN !       DO j = 1, r !         CALL Display( Mat( j, : ), \"\", I ) !       END DO !     ELSE !       DO j = 1, minRow !         CALL Display( Mat( j, : ), \"\", I ) !       END DO !       WRITE( I, \"(A)\") \".\" !       WRITE( I, \"(A)\") \".\" !       WRITE( I, \"(A)\") \".\" !       DO j = r, r-minRow, -1 !         CALL Display( Mat( j, : ), \"\", I ) !       END DO !     END IF !   END IF ! ELSE !   DO j = 1, r !     CALL Display( Mat( j, : ), \"\", I ) !   END DO ! END IF END SUBROUTINE Display_Mat2_Real","tags":"","loc":"proc/display_mat2_real.html"},{"title":"Display_Mat3_Real – Fortran Program","text":"private subroutine Display_Mat3_Real(Mat, msg, unitNo) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Mat (:,:,:) character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitNo Contents Source Code Display_Mat3_Real Source Code SUBROUTINE Display_Mat3_Real ( Mat , msg , unitNo ) !   Define intent of dummy variables INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: unitNo REAL ( DFP ), INTENT ( IN ) :: Mat ( :, :, : ) CHARACTER ( LEN = * ), INTENT ( IN ) :: msg !   Define internal variables INTEGER ( I4B ) :: I , J ! I = stdout IF ( PRESENT ( unitNo ) ) I = unitNo ! DO J = 1 , SIZE ( Mat , 3 ) CALL Display ( Mat ( :, :, J ), & & TRIM ( msg ) // \"( :, :, \" // TRIM ( Int2Str ( J ) ) // \" )\" , I ) END DO END SUBROUTINE Display_Mat3_Real","tags":"","loc":"proc/display_mat3_real.html"},{"title":"Display_Mat4_Real – Fortran Program","text":"private subroutine Display_Mat4_Real(Mat, msg, unitNo) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Mat (:,:,:,:) character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitNo Contents Source Code Display_Mat4_Real Source Code SUBROUTINE Display_Mat4_Real ( Mat , msg , unitNo ) !   Define intent of dummy variables INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: unitNo REAL ( DFP ), INTENT ( IN ) :: Mat ( :, :, :, : ) CHARACTER ( LEN = * ), INTENT ( IN ) :: msg !   Define internal variables INTEGER ( I4B ) :: I , J , K ! I = stdout IF ( PRESENT ( unitNo ) ) I = unitNo ! DO K = 1 , SIZE ( Mat , 4 ) DO J = 1 , SIZE ( Mat , 3 ) CALL Display ( Mat ( :, :, J , K ), & & TRIM ( msg ) & & // \"( :, :, \" & & // TRIM ( Int2Str ( J ) ) & & // \", \" & & // TRIM ( Int2Str ( K ) ) & & // \" )\" & & , I ) END DO END DO END SUBROUTINE Display_Mat4_Real","tags":"","loc":"proc/display_mat4_real.html"},{"title":"Display_Real – Fortran Program","text":"private subroutine Display_Real(vec, msg, unitNo) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: vec character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitNo Contents Source Code Display_Real Source Code SUBROUTINE Display_Real ( vec , msg , unitNo ) ! Define intent of dummy variables INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: unitNo REAL ( DFP ), INTENT ( IN ) :: vec CHARACTER ( LEN = * ), INTENT ( IN ) :: msg ! Define internal variables INTEGER ( I4B ) :: I ! I = stdout IF ( PRESENT ( unitNo ) ) I = unitNo call disp ( title = msg , x = vec , unit = I , style = 'left' ) END SUBROUTINE Display_Real","tags":"","loc":"proc/display_real.html"},{"title":"Display_Str – Fortran Program","text":"private subroutine Display_Str(msg, unitno) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitno Contents Source Code Display_Str Source Code SUBROUTINE Display_Str ( msg , unitno ) CHARACTER ( LEN = * ), INTENT ( IN ) :: msg INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: unitno INTEGER ( I4B ) :: i if ( PRESENT ( unitno ) ) then i = unitno ELSE i = stdout END IF ! write( i, \"(A)\" ) TRIM( msg ) call disp ( title = '' , & & x = msg , & & FMT = 'a' , & & unit = i , & & style = 'left' ) END SUBROUTINE Display_Str","tags":"","loc":"proc/display_str.html"},{"title":"Display_Str2 – Fortran Program","text":"private subroutine Display_Str2(val, msg, unitno) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: val character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitno Contents Source Code Display_Str2 Source Code SUBROUTINE Display_Str2 ( val , msg , unitno ) CHARACTER ( LEN = * ), INTENT ( IN ) :: val CHARACTER ( LEN = * ), INTENT ( IN ) :: msg INTEGER ( I4B ), OPTIONAL , INTENT ( IN ) :: unitno INTEGER ( I4B ) :: i if ( PRESENT ( unitno ) ) then i = unitno ELSE i = stdout END IF call disp ( title = '' , & & x = trim ( msg ) // trim ( val ), & & FMT = 'a' , & & unit = i , & & style = 'left' ) END SUBROUTINE Display_Str2","tags":"","loc":"proc/display_str2.html"},{"title":"Display_Vector_Int – Fortran Program","text":"private subroutine Display_Vector_Int(vec, msg, unitNo, full) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION( : ) :: vec character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitNo logical(kind=LGT), intent(in), optional :: full Contents Source Code Display_Vector_Int Source Code SUBROUTINE Display_Vector_Int ( vec , msg , unitNo , full ) ! Define intent of dummy variables INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: unitNo INTEGER ( I4B ), DIMENSION ( : ), INTENT ( IN ) :: vec CHARACTER ( LEN = * ), INTENT ( IN ) :: msg LOGICAL ( LGT ), INTENT ( IN ), OPTIONAL :: full ! Define internal variables INTEGER ( I4B ) :: I ! INTEGER( I4B ) :: I, j, n ! CHARACTER( LEN = 120 ) :: fmt I = stdout IF ( PRESENT ( unitNo ) ) I = unitNo IF ( LBOUND ( vec , 1 ) . EQ . 1 ) THEN call disp ( title = msg , & & x = vec , & & unit = I , & & style = 'underline & pad' , & & orient = 'row' ) ELSE call disp ( title = msg , & & x = vec , & & unit = I , & & style = 'underline & pad' , & & sep = ' ---> ' , & & lbound = LBOUND ( Vec ) ) END IF END SUBROUTINE Display_Vector_Int","tags":"","loc":"proc/display_vector_int.html"},{"title":"DotLine – Fortran Program","text":"public subroutine DotLine(unitNo) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), optional :: unitNo Contents Source Code DotLine Source Code SUBROUTINE DotLine ( unitNo ) ! INTENT OF DUMMY VARIABLES INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: unitNo IF ( PRESENT ( unitNo ) ) THEN WRITE ( unitNo , \"(A)\" ) \".................................................\" ELSE WRITE ( stdout , \"(A)\" ) \".................................................\" END IF END SUBROUTINE DotLine","tags":"","loc":"proc/dotline.html"},{"title":"EqualLine – Fortran Program","text":"public subroutine EqualLine(unitNo) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), optional :: unitNo Contents Source Code EqualLine Source Code SUBROUTINE EqualLine ( unitNo ) ! INTENT OF DUMMY VARIABLES INTEGER ( I4B ), INTENT ( IN ), OPTIONAL :: unitNo IF ( PRESENT ( unitNo ) ) THEN WRITE ( unitNo , \"(A)\" ) \"=================================================\" ELSE WRITE ( stdout , \"(A)\" ) \"=================================================\" END IF END SUBROUTINE EqualLine","tags":"","loc":"proc/equalline.html"},{"title":"ExecuteCommand – Fortran Program","text":"private subroutine ExecuteCommand(CMD, Str) This subroutine run a system commoand on terminal Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: CMD character(len=*), intent(in) :: Str Contents Source Code ExecuteCommand Source Code SUBROUTINE ExecuteCommand ( CMD , Str ) CHARACTER ( LEN = * ), INTENT ( IN ) :: CMD , Str ! Define internal variables INTEGER ( I4B ) :: CMDSTAT , EXITSTAT LOGICAL ( LGT ) :: WAIT = . TRUE . CHARACTER ( LEN = 300 ) :: CMDMSG = \"\" CALL EXECUTE_COMMAND_LINE ( TRIM ( CMD ), CMDSTAT = CMDSTAT , & & EXITSTAT = EXITSTAT , & WAIT = WAIT , CMDMSG = CMDMSG ) IF ( CMDSTAT . NE . 0 ) THEN IF ( CMDSTAT . EQ . - 1 ) THEN STOP END IF STOP END IF END SUBROUTINE ExecuteCommand","tags":"","loc":"proc/executecommand.html"},{"title":"TIMESTAMP – Fortran Program","text":"public subroutine TIMESTAMP() Arguments None Contents Source Code TIMESTAMP Source Code SUBROUTINE TIMESTAMP ( ) ! Define Intent of dummy Variable CHARACTER ( LEN = 8 ) :: ampm INTEGER ( I4B ) :: d INTEGER ( I4B ) :: h INTEGER ( I4B ) :: m INTEGER ( I4B ) :: mm CHARACTER ( LEN = 9 ), PARAMETER , DIMENSION ( 12 ) :: month = ( / & 'January  ' , 'February ' , 'March    ' , 'April    ' , & 'May      ' , 'June     ' , 'July     ' , 'August   ' , & 'September' , 'October  ' , 'November ' , 'December ' / ) INTEGER ( I4B ) :: n INTEGER ( I4B ) :: s INTEGER ( I4B ) :: values ( 8 ) INTEGER ( I4B ) :: y CALL date_and_time ( values = values ) y = values ( 1 ) m = values ( 2 ) d = values ( 3 ) h = values ( 5 ) n = values ( 6 ) s = values ( 7 ) mm = values ( 8 ) IF ( h < 12 ) THEN ampm = 'AM' ELSE IF ( h == 12 ) THEN IF ( n == 0 . and . s == 0 ) THEN ampm = 'Noon' ELSE ampm = 'PM' END IF ELSE h = h - 12 IF ( h < 12 ) THEN ampm = 'PM' ELSE IF ( h == 12 ) THEN IF ( n == 0 . and . s == 0 ) THEN ampm = 'Midnight' ELSE ampm = 'AM' END IF END IF END IF WRITE ( * , '(8x, i2,1x,a,1x,i4,2x,i2,a1,i2.2,a1,i2.2,a1,i3.3,1x,a)' ) & d , TRIM ( month ( m ) ), y , h , ':' , n , ':' , s , '.' , mm , TRIM ( ampm ) END SUBROUTINE TIMESTAMP","tags":"","loc":"proc/timestamp.html"},{"title":"Display – Fortran Program","text":"public interface Display Contents Module Procedures Display_Str Display_Str2 Display_Real Display_Int Display_Logical Display_Vector_Int Display_Mat2_Real Display_Mat2_Int Display_Mat3_Real Display_Mat4_Real Module Procedures private subroutine Display_Str (msg, unitno) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitno private subroutine Display_Str2 (val, msg, unitno) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: val character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitno private subroutine Display_Real (vec, msg, unitNo) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: vec character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitNo private subroutine Display_Int (vec, msg, unitNo) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: vec character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitNo private subroutine Display_Logical (vec, msg, unitNo) Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(in) :: vec character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitNo private subroutine Display_Vector_Int (vec, msg, unitNo, full) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION( : ) :: vec character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitNo logical(kind=LGT), intent(in), optional :: full private subroutine Display_Mat2_Real (Mat, msg, unitNo, full) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in), DIMENSION( :, : ) :: Mat character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitNo logical(kind=LGT), intent(in), optional :: full private subroutine Display_Mat2_Int (Mat, msg, unitNo, full) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Mat (:,:) character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitNo logical(kind=LGT), intent(in), optional :: full private subroutine Display_Mat3_Real (Mat, msg, unitNo) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Mat (:,:,:) character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitNo private subroutine Display_Mat4_Real (Mat, msg, unitNo) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Mat (:,:,:,:) character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitNo","tags":"","loc":"interface/display~16.html"},{"title":"Constructor1 – Fortran Program","text":"interface private pure function Constructor1(Points) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Points (:,:) Return Value type(QuadraturePoint_)","tags":"","loc":"interface/constructor1~5.html"},{"title":"Constructor_1 – Fortran Program","text":"interface private pure function Constructor_1(Points) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Points (:,:) Return Value class(QuadraturePoint_),\n  POINTER","tags":"","loc":"interface/constructor_1.html"},{"title":"DeallocateData – Fortran Program","text":"public interface DeallocateData Contents Module Procedures deallocate_data Module Procedures private interface deallocate_data () Arguments None","tags":"","loc":"interface/deallocatedata~18.html"},{"title":"Display – Fortran Program","text":"public interface Display Contents Module Procedures display_obj Module Procedures private interface display_obj () Arguments None","tags":"","loc":"interface/display~17.html"},{"title":"GaussLegendreQuadrature – Fortran Program","text":"public interface GaussLegendreQuadrature Contents Module Procedures getGaussLegendreQP1 getGaussLegendreQP2 Module Procedures private interface getGaussLegendreQP1 () Arguments None private interface getGaussLegendreQP2 () Arguments None","tags":"","loc":"interface/gausslegendrequadrature.html"},{"title":"GetQuadraturePoints – Fortran Program","text":"public interface GetQuadraturePoints Contents Module Procedures getQP1 getQP2 Module Procedures private interface getQP1 () Arguments None private interface getQP2 () Arguments None","tags":"","loc":"interface/getquadraturepoints.html"},{"title":"Initiate – Fortran Program","text":"public interface Initiate Contents Module Procedures initiate_obj initiate_obj_txi Module Procedures private interface initiate_obj () Arguments None private interface initiate_obj_txi () Arguments None","tags":"","loc":"interface/initiate~10.html"},{"title":"QuadraturePoint – Fortran Program","text":"public interface QuadraturePoint Contents Module Procedures Constructor1 Module Procedures private interface Constructor1 () Arguments None","tags":"","loc":"interface/quadraturepoint.html"},{"title":"QuadraturePoint_Pointer – Fortran Program","text":"public interface QuadraturePoint_Pointer Contents Module Procedures Constructor_1 Module Procedures private interface Constructor_1 () Arguments None","tags":"","loc":"interface/quadraturepoint_pointer.html"},{"title":"SIZE – Fortran Program","text":"public interface SIZE Contents Module Procedures size_obj Module Procedures private interface size_obj () Arguments None","tags":"","loc":"interface/size.html"},{"title":"deallocate_data – Fortran Program","text":"interface private subroutine deallocate_data(Obj) Arguments Type Intent Optional Attributes Name class(QuadraturePoint_), intent(inout) :: Obj","tags":"","loc":"interface/deallocate_data.html"},{"title":"display_obj – Fortran Program","text":"interface private subroutine display_obj(Obj, msg, unitno) Arguments Type Intent Optional Attributes Name class(QuadraturePoint_), intent(in) :: Obj character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitno","tags":"","loc":"interface/display_obj.html"},{"title":"getGaussLegendreQP1 – Fortran Program","text":"interface private pure function getGaussLegendreQP1(RefElem, Order) result(Obj) Arguments Type Intent Optional Attributes Name class(ReferenceElement_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: Order Return Value type(QuadraturePoint_)","tags":"","loc":"interface/getgausslegendreqp1.html"},{"title":"getGaussLegendreQP2 – Fortran Program","text":"interface private pure function getGaussLegendreQP2(RefElem, NIPS) result(Obj) Arguments Type Intent Optional Attributes Name class(ReferenceElement_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: NIPS (1) Return Value type(QuadraturePoint_)","tags":"","loc":"interface/getgausslegendreqp2.html"},{"title":"getGaussLegendreQPHexahedron1 – Fortran Program","text":"interface private pure function getGaussLegendreQPHexahedron1(RefElem, Order) result(Obj) Arguments Type Intent Optional Attributes Name type(ReferenceHexahedron_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: Order Return Value type(QuadraturePoint_)","tags":"","loc":"interface/getgausslegendreqphexahedron1.html"},{"title":"getGaussLegendreQPHexahedron2 – Fortran Program","text":"interface private pure function getGaussLegendreQPHexahedron2(RefElem, NIPS) result(Obj) Arguments Type Intent Optional Attributes Name type(ReferenceHexahedron_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: NIPS (1) Return Value type(QuadraturePoint_)","tags":"","loc":"interface/getgausslegendreqphexahedron2.html"},{"title":"getGaussLegendreQPLine1 – Fortran Program","text":"interface private pure function getGaussLegendreQPLine1(RefElem, Order) result(Obj) Arguments Type Intent Optional Attributes Name type(ReferenceLine_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: Order Return Value type(QuadraturePoint_)","tags":"","loc":"interface/getgausslegendreqpline1.html"},{"title":"getGaussLegendreQPLine2 – Fortran Program","text":"interface private pure function getGaussLegendreQPLine2(RefElem, NIPS) result(Obj) Arguments Type Intent Optional Attributes Name type(ReferenceLine_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: NIPS (1) Return Value type(QuadraturePoint_)","tags":"","loc":"interface/getgausslegendreqpline2.html"},{"title":"getGaussLegendreQPPrism1 – Fortran Program","text":"interface private pure function getGaussLegendreQPPrism1(RefElem, Order) result(Obj) Arguments Type Intent Optional Attributes Name type(ReferencePrism_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: Order Return Value type(QuadraturePoint_)","tags":"","loc":"interface/getgausslegendreqpprism1.html"},{"title":"getGaussLegendreQPPrism2 – Fortran Program","text":"interface private pure function getGaussLegendreQPPrism2(RefElem, NIPS) result(Obj) Arguments Type Intent Optional Attributes Name type(ReferencePrism_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: NIPS (1) Return Value type(QuadraturePoint_)","tags":"","loc":"interface/getgausslegendreqpprism2.html"},{"title":"getGaussLegendreQPPyramid1 – Fortran Program","text":"interface private pure function getGaussLegendreQPPyramid1(RefElem, Order) result(Obj) Arguments Type Intent Optional Attributes Name type(ReferencePyramid_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: Order Return Value type(QuadraturePoint_)","tags":"","loc":"interface/getgausslegendreqppyramid1.html"},{"title":"getGaussLegendreQPPyramid2 – Fortran Program","text":"interface private pure function getGaussLegendreQPPyramid2(RefElem, NIPS) result(Obj) Arguments Type Intent Optional Attributes Name type(ReferencePyramid_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: NIPS (1) Return Value type(QuadraturePoint_)","tags":"","loc":"interface/getgausslegendreqppyramid2.html"},{"title":"getGaussLegendreQPQuadrangle1 – Fortran Program","text":"interface private pure function getGaussLegendreQPQuadrangle1(RefElem, Order) result(Obj) Arguments Type Intent Optional Attributes Name type(ReferenceQuadrangle_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: Order Return Value type(QuadraturePoint_)","tags":"","loc":"interface/getgausslegendreqpquadrangle1.html"},{"title":"getGaussLegendreQPQuadrangle2 – Fortran Program","text":"interface private pure function getGaussLegendreQPQuadrangle2(RefElem, NIPS) result(Obj) Arguments Type Intent Optional Attributes Name type(ReferenceQuadrangle_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: NIPS (1) Return Value type(QuadraturePoint_)","tags":"","loc":"interface/getgausslegendreqpquadrangle2.html"},{"title":"getGaussLegendreQPTetrahedron1 – Fortran Program","text":"interface private pure function getGaussLegendreQPTetrahedron1(RefElem, Order) result(Obj) Arguments Type Intent Optional Attributes Name type(ReferenceTetrahedron_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: Order Return Value type(QuadraturePoint_)","tags":"","loc":"interface/getgausslegendreqptetrahedron1.html"},{"title":"getGaussLegendreQPTetrahedron2 – Fortran Program","text":"interface private pure function getGaussLegendreQPTetrahedron2(RefElem, NIPS) result(Obj) Arguments Type Intent Optional Attributes Name type(ReferenceTetrahedron_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: NIPS (1) Return Value type(QuadraturePoint_)","tags":"","loc":"interface/getgausslegendreqptetrahedron2.html"},{"title":"getGaussLegendreQPTriangle1 – Fortran Program","text":"interface private pure function getGaussLegendreQPTriangle1(RefElem, Order) result(Obj) Arguments Type Intent Optional Attributes Name type(ReferenceTriangle_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: Order Return Value type(QuadraturePoint_)","tags":"","loc":"interface/getgausslegendreqptriangle1.html"},{"title":"getGaussLegendreQPTriangle2 – Fortran Program","text":"interface private pure function getGaussLegendreQPTriangle2(RefElem, NIPS) result(Obj) Arguments Type Intent Optional Attributes Name type(ReferenceTriangle_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: NIPS (1) Return Value type(QuadraturePoint_)","tags":"","loc":"interface/getgausslegendreqptriangle2.html"},{"title":"getQP1 – Fortran Program","text":"interface private subroutine getQP1(Obj, Point, Weight, Num) Arguments Type Intent Optional Attributes Name class(QuadraturePoint_), intent(in) :: Obj real(kind=DFP), intent(inout) :: Point (3) real(kind=DFP), intent(inout) :: Weight integer(kind=I4B), intent(in) :: Num","tags":"","loc":"interface/getqp1.html"},{"title":"getQP2 – Fortran Program","text":"interface private subroutine getQP2(Obj, Point, Weight) Arguments Type Intent Optional Attributes Name class(QuadraturePoint_), intent(in) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: Point (:,:) real(kind=DFP), intent(inout), ALLOCATABLE :: Weight (:)","tags":"","loc":"interface/getqp2.html"},{"title":"initiate_obj – Fortran Program","text":"interface private subroutine initiate_obj(Obj, Points) Arguments Type Intent Optional Attributes Name class(QuadraturePoint_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Points (:,:)","tags":"","loc":"interface/initiate_obj~3.html"},{"title":"initiate_obj_txi – Fortran Program","text":"interface private subroutine initiate_obj_txi(Obj, tXi, tPoints) Arguments Type Intent Optional Attributes Name class(QuadraturePoint_), intent(inout) :: Obj integer(kind=I4B), intent(in) :: tXi integer(kind=I4B), intent(in) :: tPoints","tags":"","loc":"interface/initiate_obj_txi.html"},{"title":"size_obj – Fortran Program","text":"interface private pure function size_obj(Obj, dims) result(Ans) Arguments Type Intent Optional Attributes Name class(QuadraturePoint_), intent(in) :: Obj integer(kind=I4B), intent(in) :: dims Return Value integer(kind=I4B)","tags":"","loc":"interface/size_obj.html"},{"title":"Constructor_1 – Fortran Program","text":"private function Constructor_1(tNodes, Names, SpaceCompo, TimeCompo, StorageFMT) result(Obj) This function returns the pointer to instance of DOF_ object\n for more see DOF_ Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: tNodes (:) character(len=1), intent(in) :: Names (:) integer(kind=I4B), intent(in) :: SpaceCompo (:) integer(kind=I4B), intent(in) :: TimeCompo (:) integer(kind=I4B), intent(in) :: StorageFMT Return Value class(DOF_),\n  POINTER Contents Source Code Constructor_1 Source Code FUNCTION Constructor_1 ( tNodes , Names , SpaceCompo , TimeCompo , & & StorageFMT ) RESULT ( Obj ) CLASS ( DOF_ ), POINTER :: Obj INTEGER ( I4B ), INTENT ( IN ) :: tNodes ( : ), SpaceCompo ( : ), & & TimeCompo ( : ), StorageFMT CHARACTER ( LEN = 1 ), INTENT ( IN ) :: Names ( : ) ALLOCATE ( Obj ) CALL Initiate ( Obj = Obj , Names = Names , tNodes = tNodes , & & SpaceCompo = SpaceCompo , TimeCompo = TimeCompo , StorageFMT = StorageFMT ) END FUNCTION Constructor_1","tags":"","loc":"proc/constructor_1~4.html"},{"title":"ArrayValues – Fortran Program","text":"public interface ArrayValues Contents Module Procedures arrayvalues_single_vec Module Procedures private interface arrayvalues_single_vec () Arguments None","tags":"","loc":"interface/arrayvalues.html"},{"title":"Constructor1 – Fortran Program","text":"interface Constructor for DOF_ object private pure function Constructor1(tNodes, Names, SpaceCompo, TimeCompo, StorageFMT) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: tNodes (:) character(len=1), intent(in) :: Names (:) integer(kind=I4B), intent(in) :: SpaceCompo (:) integer(kind=I4B), intent(in) :: TimeCompo (:) integer(kind=I4B), intent(in) :: StorageFMT Return Value type(DOF_) Description This function return instance of DOF_ for more see DOF_","tags":"","loc":"interface/constructor1~6.html"},{"title":"DOF – Fortran Program","text":"public interface DOF Generic function to construct DOF_ object Contents Module Procedures Constructor1 Module Procedures private interface Constructor1 () Constructor for DOF_ object Arguments None","tags":"","loc":"interface/dof.html"},{"title":"DOF_Pointer – Fortran Program","text":"public interface DOF_Pointer Generic interface to get pointer to instance of DOF_ object Contents Module Procedures Constructor_1 Module Procedures private function Constructor_1 (tNodes, Names, SpaceCompo, TimeCompo, StorageFMT) result(Obj) This function returns the pointer to instance of DOF_ object\n for more see DOF_ Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: tNodes (:) character(len=1), intent(in) :: Names (:) integer(kind=I4B), intent(in) :: SpaceCompo (:) integer(kind=I4B), intent(in) :: TimeCompo (:) integer(kind=I4B), intent(in) :: StorageFMT Return Value class(DOF_),\n  POINTER","tags":"","loc":"interface/dof_pointer.html"},{"title":"DeallocateData – Fortran Program","text":"public interface DeallocateData Generic interface to deallocate data in DOF_ Contents Module Procedures deallocate_data Module Procedures private interface deallocate_data () Deallocate data in DOF_ Arguments None","tags":"","loc":"interface/deallocatedata~19.html"},{"title":"Display – Fortran Program","text":"public interface Display Generic subroutine to displacy content of DOF_ Contents Module Procedures display_obj dof_display_vec Module Procedures private interface display_obj () Display content of DOF_ Arguments None private interface dof_display_vec () Display content of fortran vec with DOF_ object info Arguments None","tags":"","loc":"interface/display~18.html"},{"title":"IndexOf – Fortran Program","text":"public interface IndexOf Contents Module Procedures get_index_of_name Module Procedures private interface get_index_of_name () Arguments None","tags":"","loc":"interface/indexof.html"},{"title":"Initiate – Fortran Program","text":"public interface Initiate Generic interface to initiate Fortran vectors or realvectors_ from DOF_ object Contents Module Procedures initiate_st_dof initiate_val initiate_realvector_scalar initiate_realvector_vector initiate_2val Module Procedures private interface initiate_st_dof () Initiate DOF_ object Arguments None private interface initiate_val () Initiate a fortran vector using DOF_ object Arguments None private interface initiate_realvector_scalar () Initiate RealVector_ using DOF_ object Arguments None private interface initiate_realvector_vector () Initiate a vector of RealVector_ from DOF_ object Arguments None private interface initiate_2val () Initiate two fortran vectors using DOF_ object Arguments None","tags":"","loc":"interface/initiate~11.html"},{"title":"OPERATOR( .Names. ) – Fortran Program","text":"public interface OPERATOR( .Names. ) Contents Module Procedures dof_all_names dof_single_name Module Procedures private interface dof_all_names () This function returns the name of all physical variables stored in obj Arguments None private interface dof_single_name () This function returns the name of a physical variable Arguments None","tags":"","loc":"interface/operator( .names. ).html"},{"title":"OPERATOR( .tDOF. ) – Fortran Program","text":"public interface OPERATOR( .tDOF. ) Contents Module Procedures get_tDOF Module Procedures private interface get_tDOF () This function returns the total number of degree of freedom Arguments None","tags":"","loc":"interface/operator( .tdof. ).html"},{"title":"OPERATOR( .tDOF. ) – Fortran Program","text":"private interface OPERATOR( .tDOF. ) Contents Module Procedures get_tDOF_iname Module Procedures private interface get_tDOF_iname () This subroutine returns the total number of degrees of freedom Arguments None","tags":"","loc":"interface/operator( .tdof. )~2.html"},{"title":"OPERATOR( .tNames. ) – Fortran Program","text":"public interface OPERATOR( .tNames. ) Contents Module Procedures get_tNames Module Procedures private interface get_tNames () This subroutine returns the total number of names Arguments None","tags":"","loc":"interface/operator( .tnames. ).html"},{"title":"OPERATOR( .tNodes. ) – Fortran Program","text":"public interface OPERATOR( .tNodes. ) Contents Module Procedures get_tNodes Module Procedures private interface get_tNodes () This function returns the total number of nodes Arguments None","tags":"","loc":"interface/operator( .tnodes. ).html"},{"title":"OPERATOR( .tNodes. ) – Fortran Program","text":"private interface OPERATOR( .tNodes. ) Contents Module Procedures get_tNodes_idof Module Procedures private interface get_tNodes_idof () This function returns the total number of nodes Arguments None","tags":"","loc":"interface/operator( .tnodes. )~2.html"},{"title":"OPERATOR( .tSpaceComponents. ) – Fortran Program","text":"public interface OPERATOR( .tSpaceComponents. ) Contents Module Procedures get_tspace_compo Module Procedures private interface get_tspace_compo () Arguments None","tags":"","loc":"interface/operator( .tspacecomponents. ).html"},{"title":"OPERATOR( .tTimeComponents. ) – Fortran Program","text":"public interface OPERATOR( .tTimeComponents. ) Contents Module Procedures get_tTime_compo Module Procedures private interface get_tTime_compo () Arguments None","tags":"","loc":"interface/operator( .ttimecomponents. ).html"},{"title":"SIZE – Fortran Program","text":"public interface SIZE Contents Module Procedures get_tNodes Module Procedures private interface get_tNodes () This function returns the total number of nodes Arguments None","tags":"","loc":"interface/size~2.html"},{"title":"SIZE – Fortran Program","text":"private interface SIZE Contents Module Procedures get_tNodes_idof Module Procedures private interface get_tNodes_idof () This function returns the total number of nodes Arguments None","tags":"","loc":"interface/size~3.html"},{"title":"addContribution – Fortran Program","text":"public interface addContribution Generic subroutine to add values in vectors using DOF_ object Contents Module Procedures dof_addValue_1 dof_addValue_2 Module Procedures private interface dof_addValue_1 () Set values in a vector of real numbers Arguments None private interface dof_addValue_2 () Set values in a vector of real numbers Arguments None","tags":"","loc":"interface/addcontribution.html"},{"title":"arrayvalues_single_vec – Fortran Program","text":"interface private pure function arrayvalues_single_vec(Val, Obj, DOFNo, StorageFMT, Nptrs, force3D) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Val (:) class(DOF_), intent(in) :: Obj integer(kind=I4B), intent(in) :: DOFNo (:) integer(kind=I4B), intent(in) :: StorageFMT integer(kind=I4B), intent(in), optional :: Nptrs (:) logical(kind=LGT), intent(in), optional :: force3D Return Value real(kind=DFP),\n  ALLOCATABLE,(:)","tags":"","loc":"interface/arrayvalues_single_vec.html"},{"title":"deallocate_data – Fortran Program","text":"interface Deallocate data in DOF_ private subroutine deallocate_data(Obj) Arguments Type Intent Optional Attributes Name class(DOF_), intent(inout) :: Obj Description This subroutine deallocates the data in DOF_ object","tags":"","loc":"interface/deallocate_data~2.html"},{"title":"display_obj – Fortran Program","text":"interface Display content of DOF_ private subroutine display_obj(Obj, msg, UnitNo) Arguments Type Intent Optional Attributes Name class(DOF_), intent(in) :: Obj character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: UnitNo Description This subroutine display the content of DOF_ object","tags":"","loc":"interface/display_obj~2.html"},{"title":"dof_addValue_1 – Fortran Program","text":"interface Set values in a vector of real numbers private subroutine dof_addValue_1(Vec, Obj, Nptrs, Val, scale, Conversion) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout) :: Vec (:) class(DOF_), intent(in) :: Obj integer(kind=I4B), intent(in) :: Nptrs (:) real(kind=DFP), intent(in) :: Val (:) real(kind=DFP), intent(in) :: scale integer(kind=I4B), intent(in) :: Conversion (1) Description This subroutine is designed to add values in a vector of real number\n - DOF_ object obj contains the storage pattern of degrees of freedom\n inside Vec . This storage pattern can be FMT_Nodes or FMT_DOF - Val denotes the nodal values of all dof defined inside Obj . Once\n storage pattern in Val can be FMT_DOF or FMT_Nodes .\n - To tackle this Conversion can be set to DOFToNodes , NodesToDOF or NONE . This subroutine effectivily performes Vec( Nptrs ) = Vec(Nptrs) + scale * Val","tags":"","loc":"interface/dof_addvalue_1.html"},{"title":"dof_addValue_2 – Fortran Program","text":"interface Set values in a vector of real numbers private subroutine dof_addValue_2(Vec, Obj, Nptrs, Val, scale, dofno) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout) :: Vec (:) class(DOF_), intent(in) :: Obj integer(kind=I4B), intent(in) :: Nptrs (:) real(kind=DFP), intent(in) :: Val (:) real(kind=DFP), intent(in) :: scale integer(kind=I4B), intent(in) :: dofno Description This subroutine is designed to add values in a vector of real number\n - DOF_ object obj contains the storage pattern of degrees of freedom\n inside Vec . This storage pattern can be FMT_Nodes or FMT_DOF - Val denotes the nodal values of dof dofno . This subroutine effectivily performes Vec( Nptrs ) = Vec(Nptrs) + scale * Val","tags":"","loc":"interface/dof_addvalue_2.html"},{"title":"dof_all_names – Fortran Program","text":"interface This function returns the name of all physical variables stored in obj private pure function dof_all_names(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class(DOF_), intent(in) :: Obj Return Value character(len=1),\n  ALLOCATABLE,(:)","tags":"","loc":"interface/dof_all_names.html"},{"title":"dof_display_vec – Fortran Program","text":"interface Display content of fortran vec with DOF_ object info private subroutine dof_display_vec(Vec, Obj, msg, unitno) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Vec (:) class(DOF_), intent(in) :: Obj character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitno","tags":"","loc":"interface/dof_display_vec.html"},{"title":"dof_setValue_1 – Fortran Program","text":"interface Set values in a vector of real numbers private subroutine dof_setValue_1(Vec, Obj, Nptrs, Val, Conversion) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout) :: Vec (:) class(DOF_), intent(in) :: Obj integer(kind=I4B), intent(in) :: Nptrs (:) real(kind=DFP), intent(in) :: Val (:) integer(kind=I4B), intent(in) :: Conversion (1) Description This subroutine is designed to set the values in a vector of real number DOF_ object obj contains the storage pattern of degrees of freedom\n inside Vec . This storage pattern can be FMT_Nodes or FMT_DOF Val denotes the nodal values of all dof defined inside Obj . Once\n storage pattern in Val can be FMT_DOF or FMT_Nodes . To tackle this Conversion can be set to DOFToNodes , NodesToDOF or NONE . This subroutine effectivily performes Vec( Nptrs ) = Val If SIZE(val)==1 then all values are set to val(1) If SIZE(val) .EQ. SIZE(Nptrs) then for each dof its value set to val If SIZE(val)=tDOF*Size(Nptrs) then each dof will be set to\n corresponding val","tags":"","loc":"interface/dof_setvalue_1.html"},{"title":"dof_setValue_2 – Fortran Program","text":"interface Set values in a vector of real numbers private subroutine dof_setValue_2(Vec, Obj, Nptrs, Val, dofno) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout) :: Vec (:) class(DOF_), intent(in) :: Obj integer(kind=I4B), intent(in) :: Nptrs (:) real(kind=DFP), intent(in) :: Val (:) integer(kind=I4B), intent(in) :: dofno Description This subroutine is designed to set the values in a vector of real number\n - DOF_ object obj contains the storage pattern of degrees of freedom\n inside Vec . This storage pattern can be FMT_Nodes or FMT_DOF - Val denotes the nodal values of dof dofno . This subroutine effectivily performes Vec( Nptrs ) = Val","tags":"","loc":"interface/dof_setvalue_2.html"},{"title":"dof_single_name – Fortran Program","text":"interface This function returns the name of a physical variable private pure function dof_single_name(Obj, ii) result(Ans) Arguments Type Intent Optional Attributes Name class(DOF_), intent(in) :: Obj integer(kind=I4B), intent(in) :: ii Return Value character(len=1),\n  ALLOCATABLE","tags":"","loc":"interface/dof_single_name.html"},{"title":"getArrayValues – Fortran Program","text":"public interface getArrayValues Contents Module Procedures get_arrayvalues_single_vec Module Procedures private interface get_arrayvalues_single_vec () Returns the values of degrees of freedom in a single vector Arguments None","tags":"","loc":"interface/getarrayvalues.html"},{"title":"getArrayValues – Fortran Program","text":"private interface getArrayValues Contents Module Procedures get_arrayvalues_array Module Procedures private interface get_arrayvalues_array () Returns the values of degrees of freedom in a 2D array Arguments None","tags":"","loc":"interface/getarrayvalues~2.html"},{"title":"get_arrayvalues_array – Fortran Program","text":"interface Returns the values of degrees of freedom in a 2D array private subroutine get_arrayvalues_array(v, Val, Obj, DOFNo, force3D) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: v (:,:) real(kind=DFP), intent(in) :: Val (:) class(DOF_), intent(in) :: Obj integer(kind=I4B), intent(in) :: DOFNo (:) logical(kind=LGT), intent(in), optional :: force3D Description This subroutine extracts the values of from val corresponding to\n degrees of freedom specified by DOFNo(:) and return it in V(:,:) Values in Val(:,:) are stored in xiJ format. Force3D will return a vector in 3D. if there are only two components\n then it will set the third component to 0","tags":"","loc":"interface/get_arrayvalues_array.html"},{"title":"get_arrayvalues_single_vec – Fortran Program","text":"interface Returns the values of degrees of freedom in a single vector private subroutine get_arrayvalues_single_vec(v, Val, Obj, DOFNo, StorageFMT, Nptrs) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: v (:) real(kind=DFP), intent(in) :: Val (:) class(DOF_), intent(in) :: Obj integer(kind=I4B), intent(in) :: DOFNo (:) integer(kind=I4B), intent(in) :: StorageFMT integer(kind=I4B), intent(in), optional :: Nptrs (:) Description This subroutine extracts the values of from val corresponding to\n degrees of freedom specified by DOFNo(:) and return it in V StorageFMT can be ‘Nodes_FMT’ or DOF_FMT","tags":"","loc":"interface/get_arrayvalues_single_vec.html"},{"title":"get_index_of_name – Fortran Program","text":"interface private pure function get_index_of_name(Obj, Name) result(Ans) Arguments Type Intent Optional Attributes Name class(DOF_), intent(in) :: Obj character(len=1), intent(in) :: Name Return Value integer(kind=I4B)","tags":"","loc":"interface/get_index_of_name.html"},{"title":"get_tDOF – Fortran Program","text":"interface This function returns the total number of degree of freedom private pure function get_tDOF(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class(DOF_), intent(in) :: Obj Return Value integer(kind=I4B) Description This function returns the total dof","tags":"","loc":"interface/get_tdof.html"},{"title":"get_tDOF_iname – Fortran Program","text":"interface This subroutine returns the total number of degrees of freedom private pure function get_tDOF_iname(Obj, Name) result(Ans) Arguments Type Intent Optional Attributes Name class(DOF_), intent(in) :: Obj character(len=1), intent(in) :: Name Return Value integer(kind=I4B) Description This function returns the total number of dof in given physical name","tags":"","loc":"interface/get_tdof_iname.html"},{"title":"get_tNames – Fortran Program","text":"interface This subroutine returns the total number of names private pure function get_tNames(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class(DOF_), intent(in) :: Obj Return Value integer(kind=I4B) Description This subroutine returns the total number of names or total number of\n physical quantities","tags":"","loc":"interface/get_tnames.html"},{"title":"get_tNodes – Fortran Program","text":"interface This function returns the total number of nodes private pure function get_tNodes(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class(DOF_), intent(in) :: Obj Return Value integer(kind=I4B) Description This function returns the total length of the vector which stores the\n dof stored inside obj .","tags":"","loc":"interface/get_tnodes.html"},{"title":"get_tNodes_idof – Fortran Program","text":"interface This function returns the total number of nodes private pure function get_tNodes_idof(Obj, idof) result(Ans) Arguments Type Intent Optional Attributes Name class(DOF_), intent(in) :: Obj integer(kind=I4B), intent(in) :: idof Return Value integer(kind=I4B) Description This subroutine returns the size of a given degree of freedom","tags":"","loc":"interface/get_tnodes_idof.html"},{"title":"get_tTime_compo – Fortran Program","text":"interface private pure function get_tTime_compo(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class(DOF_), intent(in) :: Obj Return Value integer(kind=I4B)","tags":"","loc":"interface/get_ttime_compo.html"},{"title":"get_tspace_compo – Fortran Program","text":"interface private pure function get_tspace_compo(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class(DOF_), intent(in) :: Obj Return Value integer(kind=I4B)","tags":"","loc":"interface/get_tspace_compo.html"},{"title":"initiate_2val – Fortran Program","text":"interface Initiate two fortran vectors using DOF_ object private subroutine initiate_2val(Val1, Val2, Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: Val1 (:) real(kind=DFP), intent(inout), ALLOCATABLE :: Val2 (:) class(DOF_), intent(in) :: Obj Description This subroutine initiate two fortran vectors using  the information\n stored inside the DOF_ object","tags":"","loc":"interface/initiate_2val.html"},{"title":"initiate_realvector_scalar – Fortran Program","text":"interface Initiate RealVector_ using DOF_ object private subroutine initiate_realvector_scalar(Val, Obj) Arguments Type Intent Optional Attributes Name class(RealVector_), intent(inout) :: Val class(DOF_), intent(in) :: Obj Description This subroutine initiate RealVector_ using information stored inside DOF_ object","tags":"","loc":"interface/initiate_realvector_scalar.html"},{"title":"initiate_realvector_vector – Fortran Program","text":"interface Initiate a vector of RealVector_ from DOF_ object private subroutine initiate_realvector_vector(Val, Obj) Arguments Type Intent Optional Attributes Name type(RealVector_), intent(inout), ALLOCATABLE :: Val (:) class(DOF_), intent(in) :: Obj Description This subroutine initiate a vector of RealVector_ object\n Each entry Val( idof ) denotes degree of freedom idof","tags":"","loc":"interface/initiate_realvector_vector.html"},{"title":"initiate_st_dof – Fortran Program","text":"interface Initiate DOF_ object private subroutine initiate_st_dof(Obj, tNodes, Names, SpaceCompo, TimeCompo, StorageFMT) Arguments Type Intent Optional Attributes Name class(DOF_), intent(inout) :: Obj degree of freedom object integer(kind=I4B), intent(in) :: tNodes (:) number of nodes for each physical variable character(len=1), intent(in) :: Names (:) Names of each physical variable integer(kind=I4B), intent(in) :: SpaceCompo (:) Space component of each physical variable integer(kind=I4B), intent(in) :: TimeCompo (:) Time component of each physical variable integer(kind=I4B), intent(in) :: StorageFMT Storage format FMT_DOF , FMT_Nodes Description This subroutine initiate DOF_ object If size of all dof are same then set tNodes = [tNodes] otherwise\n   we need to provide length of all dofs If a dof is scalar, such as pressure, temperature etc., then set\n its spaceCompo to -1. For a time independent dof set TimeCompo=1 . The size of Names , SpaceCompo , TimeCompo should be same Note $\\matbf{v}$ is a physical variable, however,\n   its component $v_1, v_2, v_3$ all are degrees of freedom. Usage fortran\n    type( dof_ ) :: obj\n call initiate( obj, tNodes = [10], Names = ['x', 'y'], &\n   & SpaceCompo = [3,3], TimeCompo = [1,1], StorageFMT = FMT_Nodes )","tags":"","loc":"interface/initiate_st_dof.html"},{"title":"initiate_val – Fortran Program","text":"interface Initiate a fortran vector using DOF_ object private subroutine initiate_val(Val, Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: Val (:) class(DOF_), intent(in) :: Obj Description This subroutine initiate a fortran vector using information stored inside DOF_ object","tags":"","loc":"interface/initiate_val.html"},{"title":"setValue – Fortran Program","text":"public interface setValue Generic subroutine to set values in fortran vectors using DOF_ object Contents Module Procedures dof_setValue_1 dof_setValue_2 Module Procedures private interface dof_setValue_1 () Set values in a vector of real numbers Arguments None private interface dof_setValue_2 () Set values in a vector of real numbers Arguments None","tags":"","loc":"interface/setvalue.html"},{"title":"Constructor_1 – Fortran Program","text":"private function Constructor_1() result(Obj) Arguments None Return Value class(File_),\n  POINTER Contents Source Code Constructor_1 Source Code FUNCTION Constructor_1 ( ) RESULT ( Obj ) ! Define intent of dummy variables CLASS ( File_ ), POINTER :: Obj ALLOCATE ( Obj ) Obj % isOpen = . FALSE . END FUNCTION Constructor_1","tags":"","loc":"proc/constructor_1~5.html"},{"title":"CloseFile – Fortran Program","text":"public interface CloseFile Contents Module Procedures close_file Module Procedures private interface close_file () Arguments None","tags":"","loc":"interface/closefile.html"},{"title":"Constructor1 – Fortran Program","text":"interface private function Constructor1() result(Ans) Arguments None Return Value type(File_)","tags":"","loc":"interface/constructor1~7.html"},{"title":"DeleteFile – Fortran Program","text":"interface This subroutine deletes the file on the hard-disk public subroutine DeleteFile(Obj) Arguments Type Intent Optional Attributes Name class(File_), intent(in) :: Obj Description This routine deletes the file on the hard disk","tags":"","loc":"interface/deletefile.html"},{"title":"Exists – Fortran Program","text":"public interface Exists Contents Module Procedures fileExists Module Procedures private interface fileExists () This subroutine checks whether filename exists or not Arguments None","tags":"","loc":"interface/exists.html"},{"title":"File – Fortran Program","text":"public interface File Contents Module Procedures Constructor1 Module Procedures private interface Constructor1 () Arguments None","tags":"","loc":"interface/file.html"},{"title":"File_Pointer – Fortran Program","text":"public interface File_Pointer Contents Module Procedures Constructor_1 Module Procedures private function Constructor_1 () result(Obj) Arguments None Return Value class(File_),\n  POINTER","tags":"","loc":"interface/file_pointer.html"},{"title":"Initiate – Fortran Program","text":"public interface Initiate Contents Module Procedures init_file Module Procedures private interface init_file () This routine intiate the File_ object Arguments None","tags":"","loc":"interface/initiate~12.html"},{"title":"OpenBinaryFileToWrite – Fortran Program","text":"public interface OpenBinaryFileToWrite Contents Module Procedures open_bfile_write_a Module Procedures private interface open_bfile_write_a () This routine open a binary file to write Arguments None","tags":"","loc":"interface/openbinaryfiletowrite.html"},{"title":"OpenFile – Fortran Program","text":"public interface OpenFile Contents Module Procedures open_file Module Procedures private interface open_file () Arguments None","tags":"","loc":"interface/openfile.html"},{"title":"OpenFileToAppend – Fortran Program","text":"public interface OpenFileToAppend Contents Module Procedures open_file_Append_a open_file_Append_b open_file_Append_c Module Procedures private interface open_file_Append_a () Arguments None private interface open_file_Append_b () Arguments None private interface open_file_Append_c () Arguments None","tags":"","loc":"interface/openfiletoappend.html"},{"title":"OpenFileToRead – Fortran Program","text":"public interface OpenFileToRead Contents Module Procedures open_file_Read_a open_file_Read_b open_file_Read_c Module Procedures private interface open_file_Read_a () Arguments None private interface open_file_Read_b () Arguments None private interface open_file_Read_c () Arguments None","tags":"","loc":"interface/openfiletoread.html"},{"title":"OpenFileToWrite – Fortran Program","text":"public interface OpenFileToWrite Contents Module Procedures open_file_write_a open_file_write_b open_file_write_c Module Procedures private interface open_file_write_a () This routine open a file to write Arguments None private interface open_file_write_b () This routine open a file to write Arguments None private interface open_file_write_c () This routine open a file to write Arguments None","tags":"","loc":"interface/openfiletowrite.html"},{"title":"ReadLine – Fortran Program","text":"public interface ReadLine Contents Module Procedures readline_a readline_ab readline_abc readline_abcd readline_abcde Module Procedures private interface readline_a () Arguments None private interface readline_ab () Arguments None private interface readline_abc () Arguments None private interface readline_abcd () Arguments None private interface readline_abcde () Arguments None","tags":"","loc":"interface/readline.html"},{"title":"ReadLine – Fortran Program","text":"private interface ReadLine Contents Module Procedures readline_av readline_avbv readline_avbvcv Module Procedures private interface readline_av () Arguments None private interface readline_avbv () Arguments None private interface readline_avbvcv () Arguments None","tags":"","loc":"interface/readline~2.html"},{"title":"ReadLine – Fortran Program","text":"private interface ReadLine Contents Module Procedures readline_abv readline_abvcv readline_abcv readline_abcvdv readline_abcdv readline_abcdvev readline_abcdev Module Procedures private interface readline_abv () Arguments None private interface readline_abvcv () Arguments None private interface readline_abcv () Arguments None private interface readline_abcvdv () Arguments None private interface readline_abcdv () Arguments None private interface readline_abcdvev () Arguments None private interface readline_abcdev () Arguments None","tags":"","loc":"interface/readline~3.html"},{"title":"ReopenFile – Fortran Program","text":"public interface ReopenFile Contents Module Procedures reopen_file Module Procedures private interface reopen_file () This subroutine opens a file to Arguments None","tags":"","loc":"interface/reopenfile.html"},{"title":"SIZE – Fortran Program","text":"public interface SIZE Contents Module Procedures file_size Module Procedures private interface file_size () this function returns the file size in bytes Arguments None","tags":"","loc":"interface/size~4.html"},{"title":"Write – Fortran Program","text":"public interface Write Contents Module Procedures write_data_ascii_r1 write_data_ascii_r2 write_data_ascii_scalar Module Procedures private interface write_data_ascii_r1 () This routine writes data into a file Arguments None private interface write_data_ascii_r2 () This routine writes data into a file Arguments None private interface write_data_ascii_scalar () This routine writes data into a file Arguments None","tags":"","loc":"interface/write.html"},{"title":"WriteLine – Fortran Program","text":"public interface WriteLine Contents Module Procedures writeLine_a writeLine_ab writeLine_abc writeLine_abcd writeLine_abcde writeLine_av writeLine_avbv writeLine_avbvcv Module Procedures private interface writeLine_a () Arguments None private interface writeLine_ab () Arguments None private interface writeLine_abc () Arguments None private interface writeLine_abcd () Arguments None private interface writeLine_abcde () Arguments None private interface writeLine_av () Arguments None private interface writeLine_avbv () Arguments None private interface writeLine_avbvcv () Arguments None","tags":"","loc":"interface/writeline.html"},{"title":"checkIsOpen – Fortran Program","text":"interface private function checkIsOpen(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class(File_), intent(in) :: Obj Return Value logical(kind=LGT)","tags":"","loc":"interface/checkisopen.html"},{"title":"close_file – Fortran Program","text":"interface private subroutine close_file(Obj) Arguments Type Intent Optional Attributes Name class(File_), intent(inout) :: Obj","tags":"","loc":"interface/close_file.html"},{"title":"fileExists – Fortran Program","text":"interface This subroutine checks whether filename exists or not private function fileExists(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class(File_), intent(in) :: Obj Return Value logical(kind=LGT) Description This function checks whether the filename exists or not","tags":"","loc":"interface/fileexists.html"},{"title":"file_size – Fortran Program","text":"interface this function returns the file size in bytes private function file_size(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class(File_), intent(in) :: Obj Return Value integer(kind=I4B) Description This subroutine returns the file size in bytes","tags":"","loc":"interface/file_size.html"},{"title":"hasExtension – Fortran Program","text":"interface public function hasExtension(Obj, Extension) result(Ans) Arguments Type Intent Optional Attributes Name class(File_), intent(in) :: Obj character(len=3), intent(in) :: Extension Return Value logical(kind=LGT)","tags":"","loc":"interface/hasextension.html"},{"title":"init_file – Fortran Program","text":"interface This routine intiate the File_ object private subroutine init_file(Obj, Path, FileName, Extension, Status, Action, Access, isBinary, Comment, Separator) Arguments Type Intent Optional Attributes Name class(File_), intent(inout) :: Obj File object character(len=*), intent(in) :: Path character(len=*), intent(in) :: FileName character(len=*), intent(in) :: Extension character(len=*), intent(in) :: Status character(len=*), intent(in) :: Action character(len=*), intent(in), optional :: Access logical(kind=LGT), intent(in), optional :: isBinary Flag for binary file character(len=1), intent(in), optional :: Comment character(len=1), intent(in), optional :: Separator","tags":"","loc":"interface/init_file.html"},{"title":"isOpen – Fortran Program","text":"public interface isOpen Contents Module Procedures checkIsOpen Module Procedures private interface checkIsOpen () Arguments None","tags":"","loc":"interface/isopen.html"},{"title":"open_bfile_write_a – Fortran Program","text":"interface This routine open a binary file to write private subroutine open_bfile_write_a(Obj, Path, FileName, Extension) Arguments Type Intent Optional Attributes Name class(File_), intent(inout) :: Obj character(len=*), intent(in) :: Path character(len=*), intent(in) :: FileName character(len=*), intent(in) :: Extension Description This routine opens a binary file to write","tags":"","loc":"interface/open_bfile_write_a.html"},{"title":"open_file – Fortran Program","text":"interface private subroutine open_file(Obj) Arguments Type Intent Optional Attributes Name class(File_), intent(inout) :: Obj","tags":"","loc":"interface/open_file.html"},{"title":"open_file_Append_a – Fortran Program","text":"interface private subroutine open_file_Append_a(Obj, Path, FileName, Extension) Arguments Type Intent Optional Attributes Name class(File_), intent(inout) :: Obj character(len=*), intent(in) :: Path character(len=*), intent(in) :: FileName character(len=*), intent(in) :: Extension","tags":"","loc":"interface/open_file_append_a.html"},{"title":"open_file_Append_b – Fortran Program","text":"interface private subroutine open_file_Append_b(Obj, PFE) Arguments Type Intent Optional Attributes Name class(File_), intent(inout) :: Obj type(String), intent(in) :: PFE (:)","tags":"","loc":"interface/open_file_append_b.html"},{"title":"open_file_Append_c – Fortran Program","text":"interface private subroutine open_file_Append_c(Obj, Path, FileName, Extension) Arguments Type Intent Optional Attributes Name class(File_), intent(inout) :: Obj type(String), intent(in) :: Path type(String), intent(in) :: FileName type(String), intent(in) :: Extension","tags":"","loc":"interface/open_file_append_c.html"},{"title":"open_file_Read_a – Fortran Program","text":"interface private subroutine open_file_Read_a(Obj, Path, FileName, Extension) Arguments Type Intent Optional Attributes Name class(File_), intent(inout) :: Obj character(len=*), intent(in) :: Path character(len=*), intent(in) :: FileName character(len=*), intent(in) :: Extension","tags":"","loc":"interface/open_file_read_a.html"},{"title":"open_file_Read_b – Fortran Program","text":"interface private subroutine open_file_Read_b(Obj, PFE) Arguments Type Intent Optional Attributes Name class(File_), intent(inout) :: Obj type(String), intent(in) :: PFE (:)","tags":"","loc":"interface/open_file_read_b.html"},{"title":"open_file_Read_c – Fortran Program","text":"interface private subroutine open_file_Read_c(Obj, Path, FileName, Extension) Arguments Type Intent Optional Attributes Name class(File_), intent(inout) :: Obj type(String), intent(in) :: Path type(String), intent(in) :: FileName type(String), intent(in) :: Extension","tags":"","loc":"interface/open_file_read_c.html"},{"title":"open_file_write_a – Fortran Program","text":"interface This routine open a file to write private subroutine open_file_write_a(Obj, Path, FileName, Extension) Arguments Type Intent Optional Attributes Name class(File_), intent(inout) :: Obj character(len=*), intent(in) :: Path character(len=*), intent(in) :: FileName character(len=*), intent(in) :: Extension Description This routine opens a file to write","tags":"","loc":"interface/open_file_write_a.html"},{"title":"open_file_write_b – Fortran Program","text":"interface This routine open a file to write private subroutine open_file_write_b(Obj, PFE) Arguments Type Intent Optional Attributes Name class(File_), intent(inout) :: Obj type(String), intent(in) :: PFE (:) Description This routine opens a file to write","tags":"","loc":"interface/open_file_write_b.html"},{"title":"open_file_write_c – Fortran Program","text":"interface This routine open a file to write private subroutine open_file_write_c(Obj, Path, FileName, Extension) Arguments Type Intent Optional Attributes Name class(File_), intent(inout) :: Obj type(String), intent(in) :: Path type(String), intent(in) :: FileName type(String), intent(in) :: Extension Description This routine opens a file to write","tags":"","loc":"interface/open_file_write_c.html"},{"title":"readline_a – Fortran Program","text":"interface private subroutine readline_a(a, buffer, fileName, UnitNo) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(out) :: a Number character(len=*), intent(in), optional :: buffer Character string to read from instead of the line in the file character(len=*), intent(in), optional :: fileName File name integer(kind=I4B), intent(in), optional :: UnitNo File id number to read from","tags":"","loc":"interface/readline_a.html"},{"title":"readline_ab – Fortran Program","text":"interface private subroutine readline_ab(a, b, buffer, fileName, UnitNo) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(out) :: a Number real(kind=DFP), intent(out) :: b Number character(len=*), intent(in), optional :: buffer Character string to read from instead of the line in the file character(len=*), intent(in), optional :: fileName File name integer(kind=I4B), intent(in), optional :: UnitNo File id number to read from","tags":"","loc":"interface/readline_ab.html"},{"title":"readline_abc – Fortran Program","text":"interface private subroutine readline_abc(a, b, c, buffer, fileName, UnitNo) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(out) :: a Number real(kind=DFP), intent(out) :: b Number real(kind=DFP), intent(out) :: c Number character(len=*), intent(in), optional :: buffer Character string to read from instead of the line in the file character(len=*), intent(in), optional :: fileName File name integer(kind=I4B), intent(in), optional :: UnitNo File id number to read from","tags":"","loc":"interface/readline_abc.html"},{"title":"readline_abcd – Fortran Program","text":"interface private subroutine readline_abcd(a, b, c, d, buffer, fileName, UnitNo) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(out) :: a Number real(kind=DFP), intent(out) :: b Number real(kind=DFP), intent(out) :: c Number real(kind=DFP), intent(out) :: d Number character(len=*), intent(in), optional :: buffer Character string to read from instead of the line in the file character(len=*), intent(in) :: fileName File name integer(kind=I4B), intent(in) :: UnitNo File id number to read from","tags":"","loc":"interface/readline_abcd.html"},{"title":"readline_abcde – Fortran Program","text":"interface private subroutine readline_abcde(a, b, c, d, e, buffer, fileName, UnitNo) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(out) :: a Number real(kind=DFP), intent(out) :: b Number real(kind=DFP), intent(out) :: c Number real(kind=DFP), intent(out) :: d Number real(kind=DFP), intent(out) :: e Number character(len=*), intent(in), optional :: buffer Character string to read from instead of the line in the file character(len=*), intent(in), optional :: fileName File name integer(kind=I4B), intent(in), optional :: UnitNo File id number to read from","tags":"","loc":"interface/readline_abcde.html"},{"title":"readline_abcdev – Fortran Program","text":"interface private subroutine readline_abcdev(a, b, c, d, e, buffer, fileName, UnitNo) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(out) :: a Number real(kind=DFP), intent(out) :: b Number real(kind=DFP), intent(out) :: c Number real(kind=DFP), intent(out) :: d Number real(kind=DFP), intent(out) :: e (:) Number character(len=*), intent(in), optional :: buffer Character string to read from instead of the line in the file character(len=*), intent(in), optional :: fileName File name integer(kind=I4B), intent(in), optional :: UnitNo File id number to read from","tags":"","loc":"interface/readline_abcdev.html"},{"title":"readline_abcdv – Fortran Program","text":"interface private subroutine readline_abcdv(a, b, c, d, buffer, fileName, UnitNo) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(out) :: a Number real(kind=DFP), intent(out) :: b Number real(kind=DFP), intent(out) :: c Number real(kind=DFP), intent(out) :: d (:) Number character(len=*), intent(in), optional :: buffer Character string to read from instead of the line in the file character(len=*), intent(in), optional :: fileName File name integer(kind=I4B), intent(in), optional :: UnitNo File id number to read from","tags":"","loc":"interface/readline_abcdv.html"},{"title":"readline_abcdvev – Fortran Program","text":"interface private subroutine readline_abcdvev(a, b, c, d, e, buffer, fileName, UnitNo) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(out) :: a Number real(kind=DFP), intent(out) :: b Number real(kind=DFP), intent(out) :: c Number real(kind=DFP), intent(out) :: d (:) Number real(kind=DFP), intent(out) :: e (:) Number character(len=*), intent(in), optional :: buffer Character string to read from instead of the line in the file character(len=*), intent(in), optional :: fileName File name integer(kind=I4B), intent(in), optional :: UnitNo File id number to read from","tags":"","loc":"interface/readline_abcdvev.html"},{"title":"readline_abcv – Fortran Program","text":"interface private subroutine readline_abcv(a, b, c, buffer, fileName, UnitNo) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(out) :: a Number real(kind=DFP), intent(out) :: b Number real(kind=DFP), intent(out) :: c (:) Number character(len=*), intent(in), optional :: buffer Character string to read from instead of the line in the file character(len=*), intent(in), optional :: fileName File name integer(kind=I4B), intent(in), optional :: UnitNo File id number to read from","tags":"","loc":"interface/readline_abcv.html"},{"title":"readline_abcvdv – Fortran Program","text":"interface private subroutine readline_abcvdv(a, b, c, d, buffer, fileName, UnitNo) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(out) :: a Number real(kind=DFP), intent(out) :: b Number real(kind=DFP), intent(out) :: c (:) Number real(kind=DFP), intent(out) :: d (:) Number character(len=*), intent(in), optional :: buffer Character string to read from instead of the line in the file character(len=*), intent(in), optional :: fileName File name integer(kind=I4B), intent(in), optional :: UnitNo File id number to read from","tags":"","loc":"interface/readline_abcvdv.html"},{"title":"readline_abv – Fortran Program","text":"interface private subroutine readline_abv(a, b, buffer, fileName, UnitNo) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(out) :: a Number real(kind=DFP), intent(out) :: b (:) Number character(len=*), intent(in), optional :: buffer Character string to read from instead of the line in the file character(len=*), intent(in), optional :: fileName File name integer(kind=I4B), intent(in), optional :: UnitNo File id number to read from","tags":"","loc":"interface/readline_abv.html"},{"title":"readline_abvcv – Fortran Program","text":"interface private subroutine readline_abvcv(a, b, c, buffer, fileName, UnitNo) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(out) :: a Number real(kind=DFP), intent(out) :: b (:) Number real(kind=DFP), intent(out) :: c (:) Number character(len=*), intent(in), optional :: buffer Character string to read from instead of the line in the file character(len=*), intent(in), optional :: fileName File name integer(kind=I4B), intent(in), optional :: UnitNo File id number to read from","tags":"","loc":"interface/readline_abvcv.html"},{"title":"readline_av – Fortran Program","text":"interface private subroutine readline_av(a, buffer, fileName, UnitNo) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(out) :: a (:) Number character(len=*), intent(in), optional :: buffer Character string to read from instead of the line in the file character(len=*), intent(in), optional :: fileName File name integer(kind=I4B), intent(in), optional :: UnitNo File id number to read from","tags":"","loc":"interface/readline_av.html"},{"title":"readline_avbv – Fortran Program","text":"interface private subroutine readline_avbv(a, b, buffer, fileName, UnitNo) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(out) :: a (:) Number real(kind=DFP), intent(out) :: b (:) Number character(len=*), intent(in), optional :: buffer Character string to read from instead of the line in the file character(len=*), intent(in), optional :: fileName File name integer(kind=I4B), intent(in), optional :: UnitNo File id number to read from","tags":"","loc":"interface/readline_avbv.html"},{"title":"readline_avbvcv – Fortran Program","text":"interface private subroutine readline_avbvcv(a, b, c, buffer, fileName, UnitNo) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(out) :: a (:) Number real(kind=DFP), intent(out) :: b (:) Number real(kind=DFP), intent(out) :: c (:) Number character(len=*), intent(in), optional :: buffer Character string to read from instead of the line in the file character(len=*), intent(in), optional :: fileName File name integer(kind=I4B), intent(in), optional :: UnitNo File id number to read from","tags":"","loc":"interface/readline_avbvcv.html"},{"title":"reopen_file – Fortran Program","text":"interface This subroutine opens a file to private subroutine reopen_file(Obj) Arguments Type Intent Optional Attributes Name class(File_), intent(inout) :: Obj Description This subroutine reopens the file","tags":"","loc":"interface/reopen_file.html"},{"title":"writeLine_a – Fortran Program","text":"interface private subroutine writeLine_a(a, fileName, unitno) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a character(len=*), intent(in) :: fileName integer(kind=I4B), intent(in), optional :: unitno","tags":"","loc":"interface/writeline_a.html"},{"title":"writeLine_ab – Fortran Program","text":"interface private subroutine writeLine_ab(a, b, fileName, unitno) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a real(kind=DFP), intent(in) :: b character(len=*), intent(in) :: fileName integer(kind=I4B), intent(in), optional :: unitno","tags":"","loc":"interface/writeline_ab.html"},{"title":"writeLine_abc – Fortran Program","text":"interface private subroutine writeLine_abc(a, b, c, fileName, unitno) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a real(kind=DFP), intent(in) :: b real(kind=DFP), intent(in) :: c character(len=*), intent(in) :: fileName integer(kind=I4B), intent(in), optional :: unitno","tags":"","loc":"interface/writeline_abc.html"},{"title":"writeLine_abcd – Fortran Program","text":"interface private subroutine writeLine_abcd(a, b, c, d, fileName, unitno) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a real(kind=DFP), intent(in) :: b real(kind=DFP), intent(in) :: c real(kind=DFP), intent(in) :: d character(len=*), intent(in) :: fileName integer(kind=I4B), intent(in), optional :: unitno","tags":"","loc":"interface/writeline_abcd.html"},{"title":"writeLine_abcde – Fortran Program","text":"interface private subroutine writeLine_abcde(a, b, c, d, e, fileName, unitno) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a real(kind=DFP), intent(in) :: b real(kind=DFP), intent(in) :: c real(kind=DFP), intent(in) :: d real(kind=DFP), intent(in) :: e character(len=*), intent(in) :: fileName integer(kind=I4B), intent(in), optional :: unitno","tags":"","loc":"interface/writeline_abcde.html"},{"title":"writeLine_av – Fortran Program","text":"interface private subroutine writeLine_av(a, fileName, unitno) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a (:) character(len=*), intent(in) :: fileName integer(kind=I4B), intent(in), optional :: unitno","tags":"","loc":"interface/writeline_av.html"},{"title":"writeLine_avbv – Fortran Program","text":"interface private subroutine writeLine_avbv(a, b, fileName, unitno) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a (:) real(kind=DFP), intent(in) :: b (:) character(len=*), intent(in) :: fileName integer(kind=I4B), intent(in), optional :: unitno","tags":"","loc":"interface/writeline_avbv.html"},{"title":"writeLine_avbvcv – Fortran Program","text":"interface private subroutine writeLine_avbvcv(a, b, c, fileName, unitno) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a (:) real(kind=DFP), intent(in) :: b (:) real(kind=DFP), intent(in) :: c (:) character(len=*), intent(in) :: fileName integer(kind=I4B), intent(in), optional :: unitno","tags":"","loc":"interface/writeline_avbvcv.html"},{"title":"write_data_ascii_r1 – Fortran Program","text":"interface This routine writes data into a file private subroutine write_data_ascii_r1(Obj, Val, row, col) Arguments Type Intent Optional Attributes Name class(File_), intent(inout) :: Obj File object class(*), intent(in) :: Val (:) One D array logical(kind=LGT), intent(in), optional :: row If present then vector will be printed as rowwise logical(kind=LGT), intent(in), optional :: col If present then vector will be printed as column wise Description This routine writes data into a file\n If row is present then data is printed as row\n If col is present then data is printed as column\n If both row or col are absent then data is printed as row","tags":"","loc":"interface/write_data_ascii_r1.html"},{"title":"write_data_ascii_r2 – Fortran Program","text":"interface This routine writes data into a file private subroutine write_data_ascii_r2(Obj, Val, transpose) Arguments Type Intent Optional Attributes Name class(File_), intent(inout) :: Obj class(*), intent(in) :: Val (:,:) logical(kind=LGT), intent(in) :: transpose Description This routine writes data into a file\n If transpose is true then data is printed after taking transpose","tags":"","loc":"interface/write_data_ascii_r2.html"},{"title":"write_data_ascii_scalar – Fortran Program","text":"interface This routine writes data into a file private subroutine write_data_ascii_scalar(Obj, Val) Arguments Type Intent Optional Attributes Name class(File_), intent(inout) :: Obj class(*), intent(in) :: Val Description This routine writes data into a file\n If transpose is present then data is printed after taking transpose","tags":"","loc":"interface/write_data_ascii_scalar.html"},{"title":"DiffusionMatrix – Fortran Program","text":"public interface DiffusionMatrix Contents Module Procedures Space_DiffusionMatrix Space_DiffusionMatrix_K Space_DiffusionMatrix_C st_DiffusionMatrix st_DiffusionMatrix_K st_DiffusionMatrix_C Module Procedures private interface Space_DiffusionMatrix () This subroutine returns the diffusion matrix in space domain Arguments None private interface Space_DiffusionMatrix_K () This subroutine returns the diffusion matrix in space domain Arguments None private interface Space_DiffusionMatrix_C () This subroutine returns the diffusion matrix in space domain Arguments None private interface st_diffusionMatrix () Arguments None private interface st_diffusionMatrix_K () Arguments None private interface st_diffusionMatrix_C () Arguments None","tags":"","loc":"interface/diffusionmatrix.html"},{"title":"MassMatrix – Fortran Program","text":"public interface MassMatrix Generic function to obtain mass matrix Contents Module Procedures Space_MassMatrix st_massMatrix_a Module Procedures private interface Space_MassMatrix () This subroutine makes mass matrix in space domain Arguments None private interface st_massMatrix_a () This subroutine makes mass matrix in space time domain Arguments None","tags":"","loc":"interface/massmatrix.html"},{"title":"NitscheMatrix – Fortran Program","text":"public interface NitscheMatrix Contents Module Procedures space_nitsche_mat_1 space_nitsche_mat_2 space_nitsche_mat_3 space_nitsche_mat_4 space_nitsche_mat_5 space_nitsche_mat_7 Module Procedures private interface space_nitsche_mat_1 () Arguments None private interface space_nitsche_mat_2 () Arguments None private interface space_nitsche_mat_3 () Arguments None private interface space_nitsche_mat_4 () Arguments None private interface space_nitsche_mat_5 () Arguments None private interface space_nitsche_mat_7 () Arguments None","tags":"","loc":"interface/nitschematrix.html"},{"title":"Space_DiffusionMatrix – Fortran Program","text":"interface This subroutine returns the diffusion matrix in space domain private pure function Space_DiffusionMatrix(Test, Trial, nCopy) result(Ans) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Test class(ElemshapeData_), intent(in) :: Trial integer(kind=I4B), intent(in), optional :: nCopy Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:) Description This function returns the diffusion matrix in space domain \\int&#94;{}_{\\Omega } \\frac{\\partial N&#94;{I}}{\\partial x_{i}} \\frac{\\partial N&#94;\n {J}}{\\partial x_{i}} d\\Omega","tags":"","loc":"interface/space_diffusionmatrix.html"},{"title":"Space_DiffusionMatrix_C – Fortran Program","text":"interface This subroutine returns the diffusion matrix in space domain private pure function Space_DiffusionMatrix_C(Test, Trial, C1, C2, nCopy) result(Ans) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Test class(ElemshapeData_), intent(in) :: Trial class(FEVariable_), intent(in) :: C1 class(FEVariable_), intent(in) :: C2 integer(kind=I4B), intent(in), optional :: nCopy Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:) Description This function returns the diffusion matrix in space domain \\int&#94;{}_{\\Omega } \\frac{\\partial N&#94;{I}}{\\partial x_{i}} c_i\n\\frac{\\partial N&#94;{J}}{\\partial x_{j}} c_j d\\Omega","tags":"","loc":"interface/space_diffusionmatrix_c.html"},{"title":"Space_DiffusionMatrix_K – Fortran Program","text":"interface This subroutine returns the diffusion matrix in space domain private pure function Space_DiffusionMatrix_K(Test, Trial, K, nCopy) result(Ans) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Test class(ElemshapeData_), intent(in) :: Trial class(FEVariable_), intent(in) :: K integer(kind=I4B), intent(in), optional :: nCopy Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:) Description This function returns the diffusion matrix in space domain \\int&#94;{}_{\\Omega } \\frac{\\partial N&#94;{I}}{\\partial x_{i}} k_{ij}\n\\frac{\\partial N&#94;{J}}{\\partial x_{j}} d\\Omega","tags":"","loc":"interface/space_diffusionmatrix_k.html"},{"title":"Space_MassMatrix – Fortran Program","text":"interface This subroutine makes mass matrix in space domain private pure function Space_MassMatrix(Test, Trial, Rho, nCopy) result(Ans) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Test Shapedata for test function class(ElemshapeData_), intent(in) :: Trial Shapedata for trial function class(FEVariable_), intent(in), optional :: Rho Finite element variable (density) integer(kind=I4B), intent(in), optional :: nCopy number of diagonal copies Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:) Description This subroutine makes space matrix in space domain, Here Rho $\\rho$ is a\n finite element variable \\int_{\\Omega } N&#94;{I}\\rho N&#94;{J}d\\Omega","tags":"","loc":"interface/space_massmatrix.html"},{"title":"Space_StiffnessMatrix_Cijkl – Fortran Program","text":"interface private pure function Space_StiffnessMatrix_Cijkl(Test, Trial, Cijkl) result(Ans) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Test class(ElemshapeData_), intent(in) :: Trial class(FEVariable_), intent(in) :: Cijkl Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:)","tags":"","loc":"interface/space_stiffnessmatrix_cijkl.html"},{"title":"Space_StiffnessMatrix_LamMu – Fortran Program","text":"interface private pure function Space_StiffnessMatrix_LamMu(Test, Trial, Lambda, Mu) result(Ans) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Test class(ElemshapeData_), intent(in) :: Trial real(kind=DFP), intent(in) :: Lambda real(kind=DFP), intent(in) :: Mu Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:)","tags":"","loc":"interface/space_stiffnessmatrix_lammu.html"},{"title":"Space_StiffnessMatrix_Lambda – Fortran Program","text":"interface private pure function Space_StiffnessMatrix_Lambda(Test, Trial, Lambda, Mu) result(Ans) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Test class(ElemshapeData_), intent(in) :: Trial class(FEVariable_), intent(in) :: Lambda class(FEVariable_), intent(in) :: Mu Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:)","tags":"","loc":"interface/space_stiffnessmatrix_lambda.html"},{"title":"StiffnessMatrix – Fortran Program","text":"public interface StiffnessMatrix Contents Module Procedures Space_StiffnessMatrix_Cijkl Module Procedures private interface Space_StiffnessMatrix_Cijkl () Arguments None","tags":"","loc":"interface/stiffnessmatrix.html"},{"title":"StiffnessMatrix – Fortran Program","text":"private interface StiffnessMatrix Contents Module Procedures Space_StiffnessMatrix_Lambda Module Procedures private interface Space_StiffnessMatrix_Lambda () Arguments None","tags":"","loc":"interface/stiffnessmatrix~2.html"},{"title":"StiffnessMatrix – Fortran Program","text":"private interface StiffnessMatrix Contents Module Procedures Space_StiffnessMatrix_LamMu Module Procedures private interface Space_StiffnessMatrix_LamMu () Arguments None","tags":"","loc":"interface/stiffnessmatrix~3.html"},{"title":"space_nitsche_mat_1 – Fortran Program","text":"interface private pure function space_nitsche_mat_1(Test, Trial, Lambda, Mu, Evec) result(Ans) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Test class(ElemshapeData_), intent(in) :: Trial class(FEVariable_), intent(in) :: Lambda class(FEVariable_), intent(in) :: Mu class(FEVariable_), intent(in) :: Evec Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:)","tags":"","loc":"interface/space_nitsche_mat_1.html"},{"title":"space_nitsche_mat_2 – Fortran Program","text":"interface private pure function space_nitsche_mat_2(Test, Trial, Alpha, Evec) result(Ans) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Test class(ElemshapeData_), intent(in) :: Trial class(FEVariable_), intent(in) :: Alpha class(FEVariable_), intent(in) :: Evec Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:)","tags":"","loc":"interface/space_nitsche_mat_2.html"},{"title":"space_nitsche_mat_3 – Fortran Program","text":"interface private pure function space_nitsche_mat_3(Test, Trial, Lambda, Mu, Evec) result(Ans) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Test class(ElemshapeData_), intent(in) :: Trial real(kind=DFP), intent(in) :: Lambda real(kind=DFP), intent(in) :: Mu class(FEVariable_), intent(in) :: Evec Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:)","tags":"","loc":"interface/space_nitsche_mat_3.html"},{"title":"space_nitsche_mat_4 – Fortran Program","text":"interface private pure function space_nitsche_mat_4(Test, Trial, Alpha, Evec) result(Ans) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Test class(ElemshapeData_), intent(in) :: Trial real(kind=DFP), intent(in) :: Alpha class(FEVariable_), intent(in) :: Evec Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:)","tags":"","loc":"interface/space_nitsche_mat_4.html"},{"title":"space_nitsche_mat_5 – Fortran Program","text":"interface private pure function space_nitsche_mat_5(Test, Trial, Lambda, Mu, isNoSlip) result(Ans) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Test class(ElemshapeData_), intent(in) :: Trial real(kind=DFP), intent(in) :: Lambda real(kind=DFP), intent(in) :: Mu logical(kind=LGT), intent(in) :: isNoSlip Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:)","tags":"","loc":"interface/space_nitsche_mat_5.html"},{"title":"space_nitsche_mat_7 – Fortran Program","text":"interface private pure function space_nitsche_mat_7(Test, Trial, Lambda, Mu, isNoSlip) result(Ans) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Test class(ElemshapeData_), intent(in) :: Trial class(FEVariable_), intent(in) :: Lambda class(FEVariable_), intent(in) :: Mu logical(kind=LGT), intent(in) :: isNoSlip Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:)","tags":"","loc":"interface/space_nitsche_mat_7.html"},{"title":"st_diffusionMatrix – Fortran Program","text":"interface private pure function st_diffusionMatrix(Test, Trial, nCopy) result(Ans) Arguments Type Intent Optional Attributes Name class(STElemshapeData_), intent(in) :: Test (:) class(STElemshapeData_), intent(in) :: Trial (:) integer(kind=I4B), intent(in), optional :: nCopy Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:)","tags":"","loc":"interface/st_diffusionmatrix.html"},{"title":"st_diffusionMatrix_C – Fortran Program","text":"interface private pure function st_diffusionMatrix_C(Test, Trial, C1, C2, nCopy) result(Ans) Arguments Type Intent Optional Attributes Name class(STElemshapeData_), intent(in) :: Test (:) class(STElemshapeData_), intent(in) :: Trial (:) class(FEVariable_), intent(in) :: C1 class(FEVariable_), intent(in) :: C2 integer(kind=I4B), intent(in), optional :: nCopy Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:)","tags":"","loc":"interface/st_diffusionmatrix_c.html"},{"title":"st_diffusionMatrix_K – Fortran Program","text":"interface private pure function st_diffusionMatrix_K(Test, Trial, K, nCopy) result(Ans) Arguments Type Intent Optional Attributes Name class(STElemshapeData_), intent(in) :: Test (:) class(STElemshapeData_), intent(in) :: Trial (:) class(FEVariable_), intent(in) :: K integer(kind=I4B), intent(in), optional :: nCopy Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:)","tags":"","loc":"interface/st_diffusionmatrix_k.html"},{"title":"st_massMatrix_a – Fortran Program","text":"interface This subroutine makes mass matrix in space time domain private pure function st_massMatrix_a(Test, Trial, Rho, Term1, Term2, nCopy) result(Ans) Arguments Type Intent Optional Attributes Name class(STElemshapeData_), intent(in) :: Test (:) class(STElemshapeData_), intent(in) :: Trial (:) type(FEVariable_), intent(in), optional :: Rho integer(kind=I4B), intent(in) :: Term1 If 0 then time derivative in first term true, otherwise false integer(kind=I4B), intent(in) :: Term2 If 0 then time derivative in second term true, otherwise false integer(kind=I4B), intent(in), optional :: nCopy Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:) Description This subroutine makes space matrix in space domain, Here Rho $\\rho$ is a\n finite element variable. Following expression can be evaluated \\int_{\\Omega } N&#94;{I}T_{a}\\rho N&#94;{J}T_{b}d\\Omega \\iint \\frac{\\partial N&#94;{I}T_{a}}{\\partial t} \\rho N&#94;{J}T_{b}d\\Omega dt \\iint \\frac{\\partial N&#94;{I}T_{a}}{\\partial t} \\rho \\frac{\\partial\n N&#94;{J}T_{b}}{\\partial t} d\\Omega dt \\iint N&#94;{I}T_{a}\\rho \\frac{\\partial N&#94;{J}T_{b}}{\\partial t} d\\Omega dt","tags":"","loc":"interface/st_massmatrix_a.html"},{"title":"Constructor1 – Fortran Program","text":"interface private pure function Constructor1(Indx, Val) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Indx real(kind=DFP), intent(in) :: Val Return Value type(IndexValue_)","tags":"","loc":"interface/constructor1~8.html"},{"title":"Constructor2 – Fortran Program","text":"interface private pure function Constructor2(Indx, Val) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Indx (:) real(kind=DFP), intent(in) :: Val (:) Return Value type(IndexValue_),\n  ALLOCATABLE,(:)","tags":"","loc":"interface/constructor2~3.html"},{"title":"Constructor3 – Fortran Program","text":"interface private pure function Constructor3(Indx, Val) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Indx (:) real(kind=DFP), intent(in) :: Val Return Value type(IndexValue_),\n  ALLOCATABLE,(:)","tags":"","loc":"interface/constructor3~4.html"},{"title":"IndexValue – Fortran Program","text":"public interface IndexValue Contents Module Procedures Constructor1 Constructor2 Constructor3 Module Procedures private interface Constructor1 () Arguments None private interface Constructor2 () Arguments None private interface Constructor3 () Arguments None","tags":"","loc":"interface/indexvalue.html"},{"title":"Display – Fortran Program","text":"public interface Display Contents Module Procedures Display_obj Module Procedures private interface Display_obj () Arguments None","tags":"","loc":"interface/display~19.html"},{"title":"Display_obj – Fortran Program","text":"interface private subroutine Display_obj(Obj, msg, UnitNo) Arguments Type Intent Optional Attributes Name type(IterationData_), intent(in) :: Obj character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: UnitNo","tags":"","loc":"interface/display_obj~2.html"},{"title":"Initiate – Fortran Program","text":"public interface Initiate Contents Module Procedures initiate_obj Module Procedures private interface initiate_obj () Arguments None","tags":"","loc":"interface/initiate~13.html"},{"title":"initiate_obj – Fortran Program","text":"interface private subroutine initiate_obj(Obj, MaxIter, IterationNumber, Tolerance, ErrorAtStart, ErrorAtEnd, TimeAtStart, TimeAtEnd, ConvergenceType, ConvergenceIn, NormType, Converged) Arguments Type Intent Optional Attributes Name type(IterationData_), intent(inout) :: Obj integer(kind=I4B), intent(in), optional :: MaxIter integer(kind=I4B), intent(in), optional :: IterationNumber real(kind=DFP), intent(in), optional :: Tolerance real(kind=DFP), intent(in), optional :: ErrorAtStart real(kind=DFP), intent(in), optional :: ErrorAtEnd real(kind=DFP), intent(in), optional :: TimeAtStart real(kind=DFP), intent(in), optional :: TimeAtEnd integer(kind=I4B), intent(in), optional :: ConvergenceType integer(kind=I4B), intent(in), optional :: ConvergenceIn integer(kind=I4B), intent(in), optional :: NormType logical(kind=LGT), intent(in), optional :: Converged","tags":"","loc":"interface/initiate_obj~4.html"},{"title":"isConverged – Fortran Program","text":"public interface isConverged Contents Module Procedures is_converged Module Procedures private interface is_converged () Arguments None","tags":"","loc":"interface/isconverged.html"},{"title":"is_converged – Fortran Program","text":"interface private pure function is_converged(Obj) result(Ans) Arguments Type Intent Optional Attributes Name type(IterationData_), intent(in) :: Obj Return Value logical(kind=LGT)","tags":"","loc":"interface/is_converged.html"},{"title":"Constructor_1 – Fortran Program","text":"private function Constructor_1(Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Key real(kind=DFP), intent(in) :: Value Return Value class(keyValue_),\n  POINTER Contents None","tags":"","loc":"proc/constructor_1~6.html"},{"title":"Constructor_10 – Fortran Program","text":"private function Constructor_10(Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name type(String), intent(in) :: Key integer(kind=I4B), intent(in) :: Value (:) Return Value class(keyValue_),\n  POINTER Contents None","tags":"","loc":"proc/constructor_10.html"},{"title":"Constructor_11 – Fortran Program","text":"private function Constructor_11(Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Key integer(kind=I4B), intent(in) :: Value (:,:) Return Value class(keyValue_),\n  POINTER Contents None","tags":"","loc":"proc/constructor_11.html"},{"title":"Constructor_12 – Fortran Program","text":"private function Constructor_12(Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name type(String), intent(in) :: Key integer(kind=I4B), intent(in) :: Value (:,:) Return Value class(keyValue_),\n  POINTER Contents None","tags":"","loc":"proc/constructor_12.html"},{"title":"Constructor_2 – Fortran Program","text":"private function Constructor_2(Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name type(String), intent(in) :: Key real(kind=DFP), intent(in) :: Value Return Value class(keyValue_),\n  POINTER Contents None","tags":"","loc":"proc/constructor_2~3.html"},{"title":"Constructor_3 – Fortran Program","text":"private function Constructor_3(Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Key real(kind=DFP), intent(in) :: Value (:) Return Value class(keyValue_),\n  POINTER Contents None","tags":"","loc":"proc/constructor_3~3.html"},{"title":"Constructor_4 – Fortran Program","text":"private function Constructor_4(Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name type(String), intent(in) :: Key real(kind=DFP), intent(in) :: Value (:) Return Value class(keyValue_),\n  POINTER Contents None","tags":"","loc":"proc/constructor_4.html"},{"title":"Constructor_5 – Fortran Program","text":"private function Constructor_5(Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Key real(kind=DFP), intent(in) :: Value (:,:) Return Value class(keyValue_),\n  POINTER Contents None","tags":"","loc":"proc/constructor_5.html"},{"title":"Constructor_6 – Fortran Program","text":"private function Constructor_6(Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name type(String), intent(in) :: Key real(kind=DFP), intent(in) :: Value (:,:) Return Value class(keyValue_),\n  POINTER Contents None","tags":"","loc":"proc/constructor_6.html"},{"title":"Constructor_7 – Fortran Program","text":"private function Constructor_7(Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Key integer(kind=I4B), intent(in) :: Value Return Value class(keyValue_),\n  POINTER Contents None","tags":"","loc":"proc/constructor_7.html"},{"title":"Constructor_8 – Fortran Program","text":"private function Constructor_8(Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name type(String), intent(in) :: Key integer(kind=I4B), intent(in) :: Value Return Value class(keyValue_),\n  POINTER Contents None","tags":"","loc":"proc/constructor_8.html"},{"title":"Constructor_9 – Fortran Program","text":"private function Constructor_9(Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Key integer(kind=I4B), intent(in) :: Value (:) Return Value class(keyValue_),\n  POINTER Contents None","tags":"","loc":"proc/constructor_9.html"},{"title":"ASSIGNMENT( = ) – Fortran Program","text":"public interface ASSIGNMENT( = ) Contents Module Procedures SetValue1 SetValue2 SetValue3 SetValue4 SetValue5 SetValue6 Module Procedures private interface SetValue1 () Set value in KeyValue_ object Arguments None private interface SetValue2 () Set value in KeyValue_ object Arguments None private interface SetValue3 () Set value in KeyValue_ object Arguments None private interface SetValue4 () Set value in KeyValue_ object Arguments None private interface SetValue5 () Set value in KeyValue_ object Arguments None private interface SetValue6 () Set value in KeyValue_ object Arguments None","tags":"","loc":"interface/assignment( = ).html"},{"title":"ASSIGNMENT( = ) – Fortran Program","text":"private interface ASSIGNMENT( = ) Contents Module Procedures setKey1 setKey2 Module Procedures private interface setKey1 () Set key in KeyValue_ object Arguments None private interface setKey2 () Set key in KeyValue_ object Arguments None","tags":"","loc":"interface/assignment( = )~2.html"},{"title":"ASSIGNMENT( = ) – Fortran Program","text":"private interface ASSIGNMENT( = ) Contents Module Procedures getKey1 getKey2 Module Procedures private interface getKey1 () get key from KeyValue_ Arguments None private interface getKey2 () get key from KeyValue_ Arguments None","tags":"","loc":"interface/assignment( = )~3.html"},{"title":"ASSIGNMENT( = ) – Fortran Program","text":"private interface ASSIGNMENT( = ) Contents Module Procedures getValue1 getValue2 getValue3 getValue4 getValue5 getValue6 Module Procedures private interface getValue1 () getValue from KeyValue_ Arguments None private interface getValue2 () getValue from KeyValue_ Arguments None private interface getValue3 () getValue from KeyValue_ Arguments None private interface getValue4 () getValue from KeyValue_ Arguments None private interface getValue5 () getValue from KeyValue_ Arguments None private interface getValue6 () getValue from KeyValue_ Arguments None","tags":"","loc":"interface/assignment( = )~4.html"},{"title":"Append – Fortran Program","text":"public interface Append Contents Module Procedures keyvalue_append Module Procedures private interface keyvalue_append () Subroutine that append keyvalue_ instance to an array of KeyValue_ type Arguments None","tags":"","loc":"interface/append~2.html"},{"title":"Constructor1 – Fortran Program","text":"interface Function that constructs KeyValue_ private elemental function Constructor1(Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Key real(kind=DFP), intent(in) :: Value Return Value type(keyValue_)","tags":"","loc":"interface/constructor1~9.html"},{"title":"Constructor10 – Fortran Program","text":"interface Function that constructs KeyValue_ private pure function Constructor10(Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name type(String), intent(in) :: Key integer(kind=I4B), intent(in) :: Value (:) Return Value type(keyValue_)","tags":"","loc":"interface/constructor10.html"},{"title":"Constructor11 – Fortran Program","text":"interface Function that constructs KeyValue_ private pure function Constructor11(Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Key integer(kind=I4B), intent(in) :: Value (:,:) Return Value type(keyValue_)","tags":"","loc":"interface/constructor11.html"},{"title":"Constructor12 – Fortran Program","text":"interface Function that constructs KeyValue_ private pure function Constructor12(Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name type(String), intent(in) :: Key integer(kind=I4B), intent(in) :: Value (:,:) Return Value type(keyValue_)","tags":"","loc":"interface/constructor12.html"},{"title":"Constructor2 – Fortran Program","text":"interface Function that constructs KeyValue_ private elemental function Constructor2(Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name type(String), intent(in) :: Key real(kind=DFP), intent(in) :: Value Return Value type(keyValue_)","tags":"","loc":"interface/constructor2~4.html"},{"title":"Constructor3 – Fortran Program","text":"interface Function that constructs KeyValue_ private pure function Constructor3(Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Key real(kind=DFP), intent(in) :: Value (:) Return Value type(keyValue_)","tags":"","loc":"interface/constructor3~5.html"},{"title":"Constructor4 – Fortran Program","text":"interface Function that constructs KeyValue_ private pure function Constructor4(Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name type(String), intent(in) :: Key real(kind=DFP), intent(in) :: Value (:) Return Value type(keyValue_)","tags":"","loc":"interface/constructor4.html"},{"title":"Constructor5 – Fortran Program","text":"interface Function that constructs KeyValue_ private pure function Constructor5(Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Key real(kind=DFP), intent(in) :: Value (:,:) Return Value type(keyValue_)","tags":"","loc":"interface/constructor5.html"},{"title":"Constructor6 – Fortran Program","text":"interface Function that constructs KeyValue_ private pure function Constructor6(Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name type(String), intent(in) :: Key real(kind=DFP), intent(in) :: Value (:,:) Return Value type(keyValue_)","tags":"","loc":"interface/constructor6.html"},{"title":"Constructor7 – Fortran Program","text":"interface Function that constructs KeyValue_ private elemental function Constructor7(Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Key integer(kind=I4B), intent(in) :: Value Return Value type(keyValue_)","tags":"","loc":"interface/constructor7.html"},{"title":"Constructor8 – Fortran Program","text":"interface Function that constructs KeyValue_ private elemental function Constructor8(Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name type(String), intent(in) :: Key integer(kind=I4B), intent(in) :: Value Return Value type(keyValue_)","tags":"","loc":"interface/constructor8.html"},{"title":"Constructor9 – Fortran Program","text":"interface Function that constructs KeyValue_ private pure function Constructor9(Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Key integer(kind=I4B), intent(in) :: Value (:) Return Value type(keyValue_)","tags":"","loc":"interface/constructor9.html"},{"title":"Contains1 – Fortran Program","text":"interface private pure function Contains1(Obj, Key) result(Ans) Arguments Type Intent Optional Attributes Name type(KeyValue_), intent(in) :: Obj (:) character(len=*), intent(in) :: Key Return Value logical(kind=LGT)","tags":"","loc":"interface/contains1.html"},{"title":"Contains2 – Fortran Program","text":"interface private pure function Contains2(Obj, Key) result(Ans) Arguments Type Intent Optional Attributes Name type(KeyValue_), intent(in) :: Obj (:) type(String), intent(in) :: Key Return Value logical(kind=LGT)","tags":"","loc":"interface/contains2.html"},{"title":"DeallocateData – Fortran Program","text":"public interface DeallocateData Contents Module Procedures keyvalue_deallocate Module Procedures private interface keyvalue_deallocate () Arguments None","tags":"","loc":"interface/deallocatedata~20.html"},{"title":"Display – Fortran Program","text":"public interface Display Generic subroutine to display content of KeyValue_ Contents Module Procedures keyvalue_display mp_display Module Procedures private interface keyvalue_display () This subroutine display contents of KeyValue_ Arguments None private interface mp_display () Display content of vector of KeyValue_ Arguments None","tags":"","loc":"interface/display~20.html"},{"title":"Equal1 – Fortran Program","text":"interface Function to check equality in KeyValue_ private elemental function Equal1(Obj, Key) result(Ans) Arguments Type Intent Optional Attributes Name class(KeyValue_), intent(in) :: Obj character(len=*), intent(in) :: Key Return Value logical(kind=LGT)","tags":"","loc":"interface/equal1.html"},{"title":"Equal2 – Fortran Program","text":"interface Function to check equality in KeyValue_ private elemental function Equal2(Key, Obj) result(Ans) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Key class(KeyValue_), intent(in) :: Obj Return Value logical(kind=LGT)","tags":"","loc":"interface/equal2.html"},{"title":"Equal3 – Fortran Program","text":"interface Function to check equality in KeyValue_ private elemental function Equal3(Obj, Key) result(Ans) Arguments Type Intent Optional Attributes Name class(KeyValue_), intent(in) :: Obj type(String), intent(in) :: Key Return Value logical(kind=LGT)","tags":"","loc":"interface/equal3.html"},{"title":"Equal4 – Fortran Program","text":"interface Function to check equality in KeyValue_ private elemental function Equal4(Key, Obj) result(Ans) Arguments Type Intent Optional Attributes Name type(String), intent(in) :: Key class(KeyValue_), intent(in) :: Obj Return Value logical(kind=LGT)","tags":"","loc":"interface/equal4.html"},{"title":"Index1 – Fortran Program","text":"interface private pure function Index1(Obj, Key) result(Ans) Arguments Type Intent Optional Attributes Name type(KeyValue_), intent(in) :: Obj (:) character(len=*), intent(in) :: Key Return Value integer(kind=I4B)","tags":"","loc":"interface/index1.html"},{"title":"Index2 – Fortran Program","text":"interface private pure function Index2(Obj, Key) result(Ans) Arguments Type Intent Optional Attributes Name type(KeyValue_), intent(in) :: Obj (:) type(String), intent(in) :: Key Return Value integer(kind=I4B)","tags":"","loc":"interface/index2.html"},{"title":"IndexOf – Fortran Program","text":"public interface IndexOf Contents Module Procedures Index1 Index2 Module Procedures private interface Index1 () Arguments None private interface Index2 () Arguments None","tags":"","loc":"interface/indexof~2.html"},{"title":"Initiate – Fortran Program","text":"public interface Initiate Contents Module Procedures Initiate1 Initiate2 Initiate3 Initiate4 Initiate5 Initiate6 Initiate7 Initiate8 Initiate9 Initiate10 Initiate11 Initiate12 Initiate13 Module Procedures private interface Initiate1 () Subroutine that initiate instance of KeyValue_ Arguments None private interface Initiate2 () Subroutine that initiate instance of KeyValue_ Arguments None private interface Initiate3 () Subroutine that initiate instance of KeyValue_ Arguments None private interface Initiate4 () Subroutine that initiate instance of KeyValue_ Arguments None private interface Initiate5 () Subroutine that initiate instance of KeyValue_ Arguments None private interface Initiate6 () Subroutine that initiate instance of KeyValue_ Arguments None private interface Initiate7 () Subroutine that initiate instance of KeyValue_ Arguments None private interface Initiate8 () Subroutine that initiate instance of KeyValue_ Arguments None private interface Initiate9 () Subroutine that initiate instance of KeyValue_ Arguments None private interface Initiate10 () Subroutine that initiate instance of KeyValue_ Arguments None private interface Initiate11 () Subroutine that initiate instance of KeyValue_ Arguments None private interface Initiate12 () Subroutine that initiate instance of KeyValue_ Arguments None private interface Initiate13 () Subroutine that initiate instance of KeyValue_ Arguments None","tags":"","loc":"interface/initiate~14.html"},{"title":"Initiate1 – Fortran Program","text":"interface Subroutine that initiate instance of KeyValue_ private subroutine Initiate1(Obj, Key, Value) Arguments Type Intent Optional Attributes Name class(keyValue_), intent(inout) :: Obj character(len=*), intent(in) :: Key real(kind=DFP), intent(in) :: Value Description This suborutine constructs KeyValue_ object\n - Key = char - Value = Real Rank 0 Usage fortran\n    call initiate( Obj, Key = 'E', Value = 1.0_dfp )","tags":"","loc":"interface/initiate1.html"},{"title":"Initiate10 – Fortran Program","text":"interface Subroutine that initiate instance of KeyValue_ private subroutine Initiate10(Obj, Key, Value) Arguments Type Intent Optional Attributes Name class(keyValue_), intent(inout) :: Obj type(String), intent(in) :: Key integer(kind=I4B), intent(in) :: Value (:) Description This suborutine constructs KeyValue_ object\n - Key = string - Value = Int Rank 1","tags":"","loc":"interface/initiate10.html"},{"title":"Initiate11 – Fortran Program","text":"interface Subroutine that initiate instance of KeyValue_ private subroutine Initiate11(Obj, Key, Value) Arguments Type Intent Optional Attributes Name class(keyValue_), intent(inout) :: Obj character(len=*), intent(in) :: Key integer(kind=I4B), intent(in) :: Value (:,:) Description This suborutine constructs KeyValue_ object\n - Key = char - Value = Int Rank 2","tags":"","loc":"interface/initiate11.html"},{"title":"Initiate12 – Fortran Program","text":"interface Subroutine that initiate instance of KeyValue_ private subroutine Initiate12(Obj, Key, Value) Arguments Type Intent Optional Attributes Name class(keyValue_), intent(inout) :: Obj type(String), intent(in) :: Key integer(kind=I4B), intent(in) :: Value (:,:) Description This suborutine constructs KeyValue_ object\n - Key = string - Value = Int Rank 2","tags":"","loc":"interface/initiate12.html"},{"title":"Initiate13 – Fortran Program","text":"interface Subroutine that initiate instance of KeyValue_ private subroutine Initiate13(Obj, Obj2) Arguments Type Intent Optional Attributes Name class(keyValue_), intent(inout) :: Obj class(keyValue_), intent(in) :: Obj2 Description This suborutine constructs KeyValue_ object","tags":"","loc":"interface/initiate13.html"},{"title":"Initiate2 – Fortran Program","text":"interface Subroutine that initiate instance of KeyValue_ private subroutine Initiate2(Obj, Key, Value) Arguments Type Intent Optional Attributes Name class(keyValue_), intent(inout) :: Obj type(String), intent(in) :: Key real(kind=DFP), intent(in) :: Value Description This suborutine constructs KeyValue_ object\n - Key = string - Value = Real Rank 0 Usage fortran\n    call initiate( Obj, Key = string('E'), Value = 1.0_dfp )","tags":"","loc":"interface/initiate2.html"},{"title":"Initiate3 – Fortran Program","text":"interface Subroutine that initiate instance of KeyValue_ private subroutine Initiate3(Obj, Key, Value) Arguments Type Intent Optional Attributes Name class(keyValue_), intent(inout) :: Obj character(len=*), intent(in) :: Key real(kind=DFP), intent(in) :: Value (:) Description This suborutine constructs KeyValue_ object\n - Key = char - Value = Real Rank 1","tags":"","loc":"interface/initiate3.html"},{"title":"Initiate4 – Fortran Program","text":"interface Subroutine that initiate instance of KeyValue_ private subroutine Initiate4(Obj, Key, Value) Arguments Type Intent Optional Attributes Name class(keyValue_), intent(inout) :: Obj type(String), intent(in) :: Key real(kind=DFP), intent(in) :: Value (:) Description This suborutine constructs KeyValue_ object\n - Key = String - Value = Real Rank 1","tags":"","loc":"interface/initiate4.html"},{"title":"Initiate5 – Fortran Program","text":"interface Subroutine that initiate instance of KeyValue_ private subroutine Initiate5(Obj, Key, Value) Arguments Type Intent Optional Attributes Name class(keyValue_), intent(inout) :: Obj character(len=*), intent(in) :: Key real(kind=DFP), intent(in) :: Value (:,:) Description This suborutine constructs KeyValue_ object\n - Key = char - Value = Real Rank 2","tags":"","loc":"interface/initiate5.html"},{"title":"Initiate6 – Fortran Program","text":"interface Subroutine that initiate instance of KeyValue_ private subroutine Initiate6(Obj, Key, Value) Arguments Type Intent Optional Attributes Name class(keyValue_), intent(inout) :: Obj type(String), intent(in) :: Key real(kind=DFP), intent(in) :: Value (:,:) Description This suborutine constructs KeyValue_ object\n - Key = String - Value = Real Rank 2","tags":"","loc":"interface/initiate6.html"},{"title":"Initiate7 – Fortran Program","text":"interface Subroutine that initiate instance of KeyValue_ private subroutine Initiate7(Obj, Key, Value) Arguments Type Intent Optional Attributes Name class(keyValue_), intent(inout) :: Obj character(len=*), intent(in) :: Key integer(kind=I4B), intent(in) :: Value Description This suborutine constructs KeyValue_ object\n - Key = char - Value = Int Rank 0","tags":"","loc":"interface/initiate7.html"},{"title":"Initiate8 – Fortran Program","text":"interface Subroutine that initiate instance of KeyValue_ private subroutine Initiate8(Obj, Key, Value) Arguments Type Intent Optional Attributes Name class(keyValue_), intent(inout) :: Obj type(String), intent(in) :: Key integer(kind=I4B), intent(in) :: Value Description This suborutine constructs KeyValue_ object\n - Key = String - Value = Int Rank 0","tags":"","loc":"interface/initiate8.html"},{"title":"Initiate9 – Fortran Program","text":"interface Subroutine that initiate instance of KeyValue_ private subroutine Initiate9(Obj, Key, Value) Arguments Type Intent Optional Attributes Name class(keyValue_), intent(inout) :: Obj character(len=*), intent(in) :: Key integer(kind=I4B), intent(in) :: Value (:) Description This suborutine constructs KeyValue_ object\n - Key = char - Value = Int Rank 1","tags":"","loc":"interface/initiate9.html"},{"title":"KeyValue – Fortran Program","text":"public interface KeyValue Contents Module Procedures Constructor1 Constructor2 Constructor3 Constructor4 Constructor5 Constructor6 Constructor7 Constructor8 Constructor9 Constructor10 Constructor11 Constructor12 Module Procedures private interface Constructor1 () Function that constructs KeyValue_ Arguments None private interface Constructor2 () Function that constructs KeyValue_ Arguments None private interface Constructor3 () Function that constructs KeyValue_ Arguments None private interface Constructor4 () Function that constructs KeyValue_ Arguments None private interface Constructor5 () Function that constructs KeyValue_ Arguments None private interface Constructor6 () Function that constructs KeyValue_ Arguments None private interface Constructor7 () Function that constructs KeyValue_ Arguments None private interface Constructor8 () Function that constructs KeyValue_ Arguments None private interface Constructor9 () Function that constructs KeyValue_ Arguments None private interface Constructor10 () Function that constructs KeyValue_ Arguments None private interface Constructor11 () Function that constructs KeyValue_ Arguments None private interface Constructor12 () Function that constructs KeyValue_ Arguments None","tags":"","loc":"interface/keyvalue.html"},{"title":"KeyValue_Pointer – Fortran Program","text":"public interface KeyValue_Pointer Contents Module Procedures Constructor_1 Constructor_2 Constructor_3 Constructor_4 Constructor_5 Constructor_6 Constructor_7 Constructor_8 Constructor_9 Constructor_10 Constructor_11 Constructor_12 Module Procedures private function Constructor_1 (Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Key real(kind=DFP), intent(in) :: Value Return Value class(keyValue_),\n  POINTER private function Constructor_2 (Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name type(String), intent(in) :: Key real(kind=DFP), intent(in) :: Value Return Value class(keyValue_),\n  POINTER private function Constructor_3 (Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Key real(kind=DFP), intent(in) :: Value (:) Return Value class(keyValue_),\n  POINTER private function Constructor_4 (Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name type(String), intent(in) :: Key real(kind=DFP), intent(in) :: Value (:) Return Value class(keyValue_),\n  POINTER private function Constructor_5 (Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Key real(kind=DFP), intent(in) :: Value (:,:) Return Value class(keyValue_),\n  POINTER private function Constructor_6 (Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name type(String), intent(in) :: Key real(kind=DFP), intent(in) :: Value (:,:) Return Value class(keyValue_),\n  POINTER private function Constructor_7 (Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Key integer(kind=I4B), intent(in) :: Value Return Value class(keyValue_),\n  POINTER private function Constructor_8 (Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name type(String), intent(in) :: Key integer(kind=I4B), intent(in) :: Value Return Value class(keyValue_),\n  POINTER private function Constructor_9 (Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Key integer(kind=I4B), intent(in) :: Value (:) Return Value class(keyValue_),\n  POINTER private function Constructor_10 (Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name type(String), intent(in) :: Key integer(kind=I4B), intent(in) :: Value (:) Return Value class(keyValue_),\n  POINTER private function Constructor_11 (Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Key integer(kind=I4B), intent(in) :: Value (:,:) Return Value class(keyValue_),\n  POINTER private function Constructor_12 (Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name type(String), intent(in) :: Key integer(kind=I4B), intent(in) :: Value (:,:) Return Value class(keyValue_),\n  POINTER","tags":"","loc":"interface/keyvalue_pointer.html"},{"title":"OPERATOR( .CONTAINS. ) – Fortran Program","text":"public interface OPERATOR( .CONTAINS. ) Contents Module Procedures Present1 Present2 Contains1 Contains2 Module Procedures private interface Present1 () Arguments None private interface Present2 () Arguments None private interface Contains1 () Arguments None private interface Contains2 () Arguments None","tags":"","loc":"interface/operator( .contains. ).html"},{"title":"OPERATOR( .EQ. ) – Fortran Program","text":"public interface OPERATOR( .EQ. ) Contents Module Procedures Equal1 Equal2 Equal3 Equal4 Module Procedures private interface Equal1 () Function to check equality in KeyValue_ Arguments None private interface Equal2 () Function to check equality in KeyValue_ Arguments None private interface Equal3 () Function to check equality in KeyValue_ Arguments None private interface Equal4 () Function to check equality in KeyValue_ Arguments None","tags":"","loc":"interface/operator( .eq. ).html"},{"title":"OPERATOR( .INDEX. ) – Fortran Program","text":"public interface OPERATOR( .INDEX. ) Contents Module Procedures Index1 Index2 Module Procedures private interface Index1 () Arguments None private interface Index2 () Arguments None","tags":"","loc":"interface/operator( .index. ).html"},{"title":"Present1 – Fortran Program","text":"interface private pure function Present1(Key, Obj) result(Ans) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Key type(KeyValue_), intent(in) :: Obj (:) Return Value logical(kind=LGT)","tags":"","loc":"interface/present1.html"},{"title":"Present2 – Fortran Program","text":"interface private pure function Present2(Key, Obj) result(Ans) Arguments Type Intent Optional Attributes Name type(String), intent(in) :: Key type(KeyValue_), intent(in) :: Obj (:) Return Value logical(kind=LGT)","tags":"","loc":"interface/present2.html"},{"title":"SetValue1 – Fortran Program","text":"interface Set value in KeyValue_ object private subroutine SetValue1(Obj, Value) Arguments Type Intent Optional Attributes Name class(keyValue_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Value Description This subroutine set real scalar value in KeyValue_ Usage fortran\n    Obj = 1.0_dfp","tags":"","loc":"interface/setvalue1.html"},{"title":"SetValue2 – Fortran Program","text":"interface Set value in KeyValue_ object private subroutine SetValue2(Obj, Value) Arguments Type Intent Optional Attributes Name class(keyValue_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Value (:) Description This subroutine set real vector value in KeyValue_ Usage fortran\n    Obj = vec1","tags":"","loc":"interface/setvalue2.html"},{"title":"SetValue3 – Fortran Program","text":"interface Set value in KeyValue_ object private subroutine SetValue3(Obj, Value) Arguments Type Intent Optional Attributes Name class(keyValue_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Value (:,:) Description This subroutine set real matrix value in KeyValue_ Usage fortran\n    Obj = mat","tags":"","loc":"interface/setvalue3.html"},{"title":"SetValue4 – Fortran Program","text":"interface Set value in KeyValue_ object private subroutine SetValue4(Obj, Value) Arguments Type Intent Optional Attributes Name class(keyValue_), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Value Description This subroutine set integer scalar value in KeyValue_ Usage fortran\n    Obj = intval","tags":"","loc":"interface/setvalue4.html"},{"title":"SetValue5 – Fortran Program","text":"interface Set value in KeyValue_ object private subroutine SetValue5(Obj, Value) Arguments Type Intent Optional Attributes Name class(keyValue_), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Value (:) Description This subroutine set integer vector value in KeyValue_ Usage fortran\n    Obj = intvec","tags":"","loc":"interface/setvalue5.html"},{"title":"SetValue6 – Fortran Program","text":"interface Set value in KeyValue_ object private subroutine SetValue6(Obj, Value) Arguments Type Intent Optional Attributes Name class(keyValue_), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Value (:,:) Description This subroutine set integer matrix value in KeyValue_ Usage fortran\n    Obj = intmat","tags":"","loc":"interface/setvalue6.html"},{"title":"getKey – Fortran Program","text":"public interface getKey Generic subroutine to get key from KeyValue_ Contents Module Procedures getKey1 getKey2 Module Procedures private interface getKey1 () get key from KeyValue_ Arguments None private interface getKey2 () get key from KeyValue_ Arguments None","tags":"","loc":"interface/getkey.html"},{"title":"getKey1 – Fortran Program","text":"interface get key from KeyValue_ private subroutine getKey1(Key, Obj) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: Key class(KeyValue_), intent(in) :: Obj","tags":"","loc":"interface/getkey1.html"},{"title":"getKey2 – Fortran Program","text":"interface get key from KeyValue_ private subroutine getKey2(Key, Obj) Arguments Type Intent Optional Attributes Name type(String), intent(inout) :: Key class(KeyValue_), intent(in) :: Obj","tags":"","loc":"interface/getkey2.html"},{"title":"getValue – Fortran Program","text":"public interface getValue Generic subroutine to get value from KeyValue_ Contents Module Procedures getValue1 getValue2 getValue3 getValue4 getValue5 getValue6 Module Procedures private interface getValue1 () getValue from KeyValue_ Arguments None private interface getValue2 () getValue from KeyValue_ Arguments None private interface getValue3 () getValue from KeyValue_ Arguments None private interface getValue4 () getValue from KeyValue_ Arguments None private interface getValue5 () getValue from KeyValue_ Arguments None private interface getValue6 () getValue from KeyValue_ Arguments None","tags":"","loc":"interface/getvalue.html"},{"title":"getValue1 – Fortran Program","text":"interface getValue from KeyValue_ private subroutine getValue1(Value, Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout) :: Value class(keyValue_), intent(in) :: Obj","tags":"","loc":"interface/getvalue1.html"},{"title":"getValue2 – Fortran Program","text":"interface getValue from KeyValue_ private subroutine getValue2(Value, Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: Value (:) class(keyValue_), intent(in) :: Obj","tags":"","loc":"interface/getvalue2.html"},{"title":"getValue3 – Fortran Program","text":"interface getValue from KeyValue_ private subroutine getValue3(Value, Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: Value (:,:) class(keyValue_), intent(in) :: Obj","tags":"","loc":"interface/getvalue3.html"},{"title":"getValue4 – Fortran Program","text":"interface getValue from KeyValue_ private subroutine getValue4(Value, Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout) :: Value class(keyValue_), intent(in) :: Obj","tags":"","loc":"interface/getvalue4.html"},{"title":"getValue5 – Fortran Program","text":"interface getValue from KeyValue_ private subroutine getValue5(Value, Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), ALLOCATABLE :: Value (:) class(keyValue_), intent(in) :: Obj","tags":"","loc":"interface/getvalue5.html"},{"title":"getValue6 – Fortran Program","text":"interface getValue from KeyValue_ private subroutine getValue6(Value, Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), ALLOCATABLE :: Value (:,:) class(keyValue_), intent(in) :: Obj","tags":"","loc":"interface/getvalue6.html"},{"title":"keyvalue_append – Fortran Program","text":"interface Subroutine that append keyvalue_ instance to an array of KeyValue_ type private subroutine keyvalue_append(Obj, KeyValObj) Arguments Type Intent Optional Attributes Name type(KeyValue_), intent(inout), ALLOCATABLE :: Obj (:) type(KeyValue_), intent(in) :: KeyValObj","tags":"","loc":"interface/keyvalue_append.html"},{"title":"keyvalue_deallocate – Fortran Program","text":"interface private subroutine keyvalue_deallocate(Obj) Arguments Type Intent Optional Attributes Name class(KeyValue_), intent(inout) :: Obj","tags":"","loc":"interface/keyvalue_deallocate.html"},{"title":"keyvalue_display – Fortran Program","text":"interface This subroutine display contents of KeyValue_ private subroutine keyvalue_display(Obj, msg, UnitNo) Arguments Type Intent Optional Attributes Name class(keyValue_), intent(in) :: Obj character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: UnitNo","tags":"","loc":"interface/keyvalue_display.html"},{"title":"mp_display – Fortran Program","text":"interface Display content of vector of KeyValue_ private subroutine mp_display(Obj, msg, UnitNo) Arguments Type Intent Optional Attributes Name type(keyvalue_), intent(in) :: Obj (:) character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: UnitNo","tags":"","loc":"interface/mp_display.html"},{"title":"setKey – Fortran Program","text":"public interface setKey Generic subroutine to set key in KeyValue_ Contents Module Procedures setKey1 setKey2 Module Procedures private interface setKey1 () Set key in KeyValue_ object Arguments None private interface setKey2 () Set key in KeyValue_ object Arguments None","tags":"","loc":"interface/setkey.html"},{"title":"setKey1 – Fortran Program","text":"interface Set key in KeyValue_ object private subroutine setKey1(Obj, Key) Arguments Type Intent Optional Attributes Name class(KeyValue_), intent(inout) :: Obj character(len=*), intent(in) :: Key Description This subroutine set key in KeyValue_ Usage fortran\n    Obj = \"hello\"","tags":"","loc":"interface/setkey1.html"},{"title":"setKey2 – Fortran Program","text":"interface Set key in KeyValue_ object private subroutine setKey2(Obj, Key) Arguments Type Intent Optional Attributes Name class(KeyValue_), intent(inout) :: Obj type(String), intent(in) :: Key Description This subroutine set key in KeyValue_ Usage fortran\n    Obj = string( \"hello\" )","tags":"","loc":"interface/setkey2.html"},{"title":"setValue – Fortran Program","text":"public interface setValue Generic subroutine to set values in KeyValue_ Contents Module Procedures SetValue1 SetValue2 SetValue3 SetValue4 SetValue5 SetValue6 Module Procedures private interface SetValue1 () Set value in KeyValue_ object Arguments None private interface SetValue2 () Set value in KeyValue_ object Arguments None private interface SetValue3 () Set value in KeyValue_ object Arguments None private interface SetValue4 () Set value in KeyValue_ object Arguments None private interface SetValue5 () Set value in KeyValue_ object Arguments None private interface SetValue6 () Set value in KeyValue_ object Arguments None","tags":"","loc":"interface/setvalue~2.html"},{"title":"AllocateData – Fortran Program","text":"public interface AllocateData Contents Module Procedures Allocate_Data Module Procedures private interface Allocate_data () This subroutine creates memeory space for the sparse matrix object Arguments None","tags":"","loc":"interface/allocatedata.html"},{"title":"Allocate_data – Fortran Program","text":"interface This subroutine creates memeory space for the sparse matrix object private subroutine Allocate_data(Obj, Dims, MatrixProp) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Dims (2) character(len=*), intent(in), optional :: MatrixProp Description This subroutine creates memory space for the sparse matrix Dims(1) denotes total number of rows\n Dims(2) denotes total number of columns\n tDOF is set to 1\n tNodes is set to Dims(1)\n nnz is set to to 0","tags":"","loc":"interface/allocate_data.html"},{"title":"ArrayValues – Fortran Program","text":"public interface ArrayValues Contents Module Procedures get_scalar_value Module Procedures private interface get_scalar_value () Arguments None","tags":"","loc":"interface/arrayvalues~2.html"},{"title":"Clean – Fortran Program","text":"public interface Clean Contents Module Procedures clean_CSR Module Procedures private interface clean_CSR () —    1 eliminate duplicates and zeros\n—    2 eliminate duplicates and perform partial ordering\n—    3 eliminate duplicates and sort entries in increasing order of\n—    col indices\n— Values  .true. work on Obj % A too, otherwise dont touch Obj % A\n— INDU contains pointers to upper triangle Arguments None","tags":"","loc":"interface/clean.html"},{"title":"ColSORT – Fortran Program","text":"public interface ColSORT Contents Module Procedures csort_CSR Module Procedures private interface csort_CSR () Arguments None","tags":"","loc":"interface/colsort.html"},{"title":"Convert – Fortran Program","text":"public interface Convert Contents Module Procedures aij_convert_dns obj_convert_dns Module Procedures private interface aij_convert_dns () This subroutine converts sparsematrix to dense storage Arguments None private interface obj_convert_dns () Arguments None","tags":"","loc":"interface/convert.html"},{"title":"Copy – Fortran Program","text":"public interface Copy Contents Module Procedures copy_CSR_CSR Module Procedures private interface copy_CSR_CSR () Arguments None","tags":"","loc":"interface/copy.html"},{"title":"CsrToDense – Fortran Program","text":"public interface CsrToDense Contents Subroutines CSRDNS Subroutines public subroutine CSRDNS(nrow, ncol, A, JA, IA, DNS, ndns, ierr) Arguments Type Intent Optional Attributes Name integer(kind=Int32), intent(in) :: nrow integer(kind=Int32), intent(in) :: ncol real(kind=Real64), intent(in) :: A (:) integer(kind=Int32), intent(in) :: JA (:) integer(kind=Int32), intent(in) :: IA (:) real(kind=Real64), intent(inout) :: DNS (:,:) integer(kind=Int32), intent(in) :: ndns integer(kind=Int32), intent(inout) :: ierr","tags":"","loc":"interface/csrtodense.html"},{"title":"DeallocateData – Fortran Program","text":"public interface DeallocateData Contents Module Procedures Deallocate_Data Module Procedures private interface Deallocate_Data () This subroutine deallocates the data Arguments None","tags":"","loc":"interface/deallocatedata~21.html"},{"title":"Deallocate_Data – Fortran Program","text":"interface This subroutine deallocates the data private subroutine Deallocate_Data(Obj) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(inout) :: Obj Description This subroutine deallocates the data stored","tags":"","loc":"interface/deallocate_data~5.html"},{"title":"Display – Fortran Program","text":"public interface Display Contents Module Procedures Display_obj Display_CSR_2 Module Procedures private interface Display_obj () This subroutine display the content of sparse matrix Arguments None private interface Display_CSR_2 () This subroutine displays the content of sparse matrix Arguments None","tags":"","loc":"interface/display~21.html"},{"title":"Display_CSR_2 – Fortran Program","text":"interface This subroutine displays the content of sparse matrix private subroutine Display_CSR_2(Obj, msg, options) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(in) :: Obj character(len=*), intent(in) :: msg integer(kind=I4B), intent(in) :: options (:) Description This subroutine displays the content of sparse matrix\n - options( 1 ) = i1\n - options( 2 ) = i2\n - options( 3 ) = 1 if values need to be printed else dont print values\n - options( 4 ) = unitno","tags":"","loc":"interface/display_csr_2.html"},{"title":"Display_obj – Fortran Program","text":"interface This subroutine display the content of sparse matrix private subroutine Display_obj(Obj, Msg, UnitNo) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(in) :: Obj character(len=*), intent(in) :: Msg integer(kind=I4B), intent(in), optional :: UnitNo Description This subroutine display the content of sparse matrix\n - In this subroutine dump routine from sparsekit lib is called","tags":"","loc":"interface/display_obj~3.html"},{"title":"Initiate – Fortran Program","text":"public interface Initiate Contents Module Procedures initiate_obj1 initiate_obj2 initiate_obj3 initiate_obj4 initiate_obj5 Module Procedures private interface initiate_obj1 () This subroutine construct the SparseMatrix_ object Arguments None private interface initiate_obj2 () This subroutine converts a dense matrix into sparse matrix Arguments None private interface initiate_obj3 () This matrix converts a dense matrix into a sparse matrix Arguments None private interface initiate_obj4 () This subroutine construct sparsematrix_ object from IA, JA, A Arguments None private interface initiate_obj5 () Arguments None","tags":"","loc":"interface/initiate~15.html"},{"title":"MatVec – Fortran Program","text":"public interface MatVec Contents Module Procedures matvec_CSR_amux Module Procedures private interface matvec_CSR_amux () Arguments None","tags":"","loc":"interface/matvec.html"},{"title":"Matmul – Fortran Program","text":"public interface Matmul Contents Module Procedures matmul_CSR Module Procedures private interface matmul_CSR () Arguments None","tags":"","loc":"interface/matmul.html"},{"title":"RemoveDuplicates – Fortran Program","text":"public interface RemoveDuplicates Contents Module Procedures remove_duplicates_csr Module Procedures private interface remove_duplicates_csr () Arguments None","tags":"","loc":"interface/removeduplicates.html"},{"title":"Shape – Fortran Program","text":"public interface Shape Contents Module Procedures get_shape Module Procedures private interface get_shape () This function returns the shape of sparse matrix Arguments None","tags":"","loc":"interface/shape~4.html"},{"title":"Size – Fortran Program","text":"public interface Size Contents Module Procedures get_size Module Procedures private interface get_size () This function returns the size of sparse matrix Arguments None","tags":"","loc":"interface/size~4.html"},{"title":"SparseKit_ILUT – Fortran Program","text":"public interface SparseKit_ILUT Contents Module Procedures ilut_csr Module Procedures private interface ilut_csr () Arguments None","tags":"","loc":"interface/sparsekit_ilut.html"},{"title":"SparseKit_ilud – Fortran Program","text":"public interface SparseKit_ilud Contents Module Procedures ilud_csr Module Procedures private interface ilud_csr () Arguments None","tags":"","loc":"interface/sparsekit_ilud.html"},{"title":"SparseKit_iludp – Fortran Program","text":"public interface SparseKit_iludp Contents Module Procedures iludp_csr Module Procedures private interface iludp_csr () Arguments None","tags":"","loc":"interface/sparsekit_iludp.html"},{"title":"SparseKit_ilutp – Fortran Program","text":"public interface SparseKit_ilutp Contents Module Procedures ilutp_csr Module Procedures private interface ilutp_csr () Arguments None","tags":"","loc":"interface/sparsekit_ilutp.html"},{"title":"Sparsekit_LSolve – Fortran Program","text":"public interface Sparsekit_LSolve Contents Module Procedures lsol_csr Module Procedures private interface lsol_csr () — Solve Lx = y by forward elimination technique will be used Arguments None","tags":"","loc":"interface/sparsekit_lsolve.html"},{"title":"Sparsekit_LUSOLVE – Fortran Program","text":"public interface Sparsekit_LUSOLVE Contents Module Procedures lusol_alu Module Procedures private interface lusol_alu () Arguments None","tags":"","loc":"interface/sparsekit_lusolve.html"},{"title":"Sparsekit_LUTSOLVE – Fortran Program","text":"public interface Sparsekit_LUTSOLVE Contents Module Procedures lutsol_alu Module Procedures private interface lutsol_alu () Arguments None","tags":"","loc":"interface/sparsekit_lutsolve.html"},{"title":"Sparsekit_USolve – Fortran Program","text":"public interface Sparsekit_USolve Contents Module Procedures usol_csr Module Procedures private interface usol_csr () — Solve Ux = y by backward elimination technique will be used Arguments None","tags":"","loc":"interface/sparsekit_usolve.html"},{"title":"Spy – Fortran Program","text":"public interface Spy Contents Module Procedures obj_spy Module Procedures private interface obj_spy () Arguments None","tags":"","loc":"interface/spy.html"},{"title":"addContribution – Fortran Program","text":"public interface addContribution Contents Module Procedures addContribution_1 Module Procedures private interface addContribution_1 () Arguments None","tags":"","loc":"interface/addcontribution~2.html"},{"title":"addContributionInternally – Fortran Program","text":"interface private subroutine addContributionInternally(Obj, Nptrs, Val, Scale) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Nptrs (:) real(kind=DFP), intent(in) :: Val (:,:) real(kind=DFP), intent(in) :: Scale","tags":"","loc":"interface/addcontributioninternally.html"},{"title":"addContribution_1 – Fortran Program","text":"interface private subroutine addContribution_1(Obj, Nptrs, Val, Scale, StorageFMT) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Nptrs (:) real(kind=DFP), intent(in) :: Val (:,:) real(kind=DFP), intent(in) :: Scale integer(kind=I4B), intent(in) :: StorageFMT","tags":"","loc":"interface/addcontribution_1.html"},{"title":"aij_convert_dns – Fortran Program","text":"interface This subroutine converts sparsematrix to dense storage private subroutine aij_convert_dns(A, IA, JA, mat) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: A (:) integer(kind=I4B), intent(in) :: IA (:) integer(kind=I4B), intent(in) :: JA (:) real(kind=DFP), intent(inout), ALLOCATABLE :: mat (:,:) Description This subroutine converts sparsematrix to dense storage format A(:), IA(:), JA(:) denotes CSR format.","tags":"","loc":"interface/aij_convert_dns.html"},{"title":"clean_CSR – Fortran Program","text":"interface —    1 eliminate duplicates and zeros\n—    2 eliminate duplicates and perform partial ordering\n—    3 eliminate duplicates and sort entries in increasing order of\n—    col indices\n— Values  .true. work on Obj % A too, otherwise dont touch Obj % A\n— INDU contains pointers to upper triangle private subroutine clean_CSR(Obj, Values, ExtraOption, INDU) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(inout) :: Obj logical(kind=LGT), intent(in) :: Values integer(kind=I4B), intent(in) :: ExtraOption integer(kind=I4B), intent(inout), ALLOCATABLE :: INDU (:)","tags":"","loc":"interface/clean_csr.html"},{"title":"copy_CSR_CSR – Fortran Program","text":"interface private subroutine copy_CSR_CSR(From, To, Values) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(in) :: From type(SparseMatrix_), intent(inout) :: To logical(kind=LGT), intent(in), optional :: Values","tags":"","loc":"interface/copy_csr_csr.html"},{"title":"csort_CSR – Fortran Program","text":"interface private subroutine csort_CSR(Obj, Values) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(inout) :: Obj logical(kind=LGT), intent(in), optional :: Values","tags":"","loc":"interface/csort_csr.html"},{"title":"getNNZ – Fortran Program","text":"public interface getNNZ Contents Module Procedures get_nnz Module Procedures private interface get_nnz () Return the total number of non zero entry in the matrix Arguments None","tags":"","loc":"interface/getnnz.html"},{"title":"get_nnz – Fortran Program","text":"interface Return the total number of non zero entry in the matrix private pure function get_nnz(Obj) result(Ans) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(in) :: Obj Return Value integer(kind=I4B) Description This function return the total number of non-zero entry in the sparse matrix","tags":"","loc":"interface/get_nnz.html"},{"title":"get_scalar_value – Fortran Program","text":"interface private function get_scalar_value(Obj, i, j, Sorted) result(Ans) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(in) :: Obj integer(kind=I4B), intent(in) :: i integer(kind=I4B), intent(in) :: j logical(kind=LGT), intent(in), optional :: Sorted Return Value real(kind=DFP)","tags":"","loc":"interface/get_scalar_value.html"},{"title":"get_shape – Fortran Program","text":"interface This function returns the shape of sparse matrix private pure function get_shape(Obj) result(Ans) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(in) :: Obj Return Value integer(kind=I4B)\n  (2) Description This function returns the shape of sparse matrix","tags":"","loc":"interface/get_shape~2.html"},{"title":"get_size – Fortran Program","text":"interface This function returns the size of sparse matrix private pure function get_size(Obj, Dims) result(Ans) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(in) :: Obj integer(kind=I4B), intent(in), optional :: Dims Return Value integer(kind=I4B) Description This function returns the size of sparse matrix\n If Dims equal to 1 then total number of rows are returned\n If Dims is equal to 2 then total number of columns are return\n If Dims is absent then nrow*ncol are returned","tags":"","loc":"interface/get_size~2.html"},{"title":"ilud_csr – Fortran Program","text":"interface private subroutine ilud_csr(Obj, alu, jlu, ju, ierr, alpha, droptol) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(in) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: alu (:) integer(kind=I4B), intent(inout), ALLOCATABLE :: jlu (:) integer(kind=I4B), intent(inout), ALLOCATABLE :: ju (:) integer(kind=I4B), intent(inout) :: ierr real(kind=DFP), intent(in), optional :: alpha real(kind=DFP), intent(in), optional :: droptol","tags":"","loc":"interface/ilud_csr.html"},{"title":"iludp_csr – Fortran Program","text":"interface private subroutine iludp_csr(Obj, alu, jlu, ju, iperm, ierr, droptol, permtol, alpha, mbloc) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(inout) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: alu (:) integer(kind=I4B), intent(inout), ALLOCATABLE :: jlu (:) integer(kind=I4B), intent(inout), ALLOCATABLE :: ju (:) integer(kind=I4B), intent(inout), ALLOCATABLE :: iperm (:) integer(kind=I4B), intent(inout) :: ierr real(kind=DFP), intent(in), optional :: droptol real(kind=DFP), intent(in), optional :: permtol real(kind=DFP), intent(in), optional :: alpha integer(kind=I4B), intent(in), optional :: mbloc","tags":"","loc":"interface/iludp_csr.html"},{"title":"ilut_csr – Fortran Program","text":"interface private subroutine ilut_csr(Obj, alu, jlu, ju, ierr, droptol, lfil) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(in) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: alu (:) integer(kind=I4B), intent(inout), ALLOCATABLE :: jlu (:) integer(kind=I4B), intent(inout), ALLOCATABLE :: ju (:) integer(kind=I4B), intent(inout) :: ierr real(kind=DFP), intent(in), optional :: droptol integer(kind=I4B), intent(in), optional :: lfil","tags":"","loc":"interface/ilut_csr.html"},{"title":"ilutp_csr – Fortran Program","text":"interface private subroutine ilutp_csr(Obj, alu, jlu, ju, iperm, ierr, droptol, permtol, lfil, mbloc) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(inout) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: alu (:) integer(kind=I4B), intent(inout), ALLOCATABLE :: jlu (:) integer(kind=I4B), intent(inout), ALLOCATABLE :: ju (:) integer(kind=I4B), intent(inout), ALLOCATABLE :: iperm (:) integer(kind=I4B), intent(inout) :: ierr real(kind=DFP), intent(in), optional :: droptol real(kind=DFP), intent(in), optional :: permtol integer(kind=I4B), intent(in), optional :: lfil integer(kind=I4B), intent(in), optional :: mbloc","tags":"","loc":"interface/ilutp_csr.html"},{"title":"initiate_obj1 – Fortran Program","text":"interface This subroutine construct the SparseMatrix_ object private subroutine initiate_obj1(Obj, tDOF, tNodes, MatrixProp, StorageFMT) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(inout) :: Obj integer(kind=I4B), intent(in) :: tDOF Total number of degrees of freedom integer(kind=I4B), intent(in) :: tNodes (:) Total nunber of spatial nodes (size of vec) of each dof character(len=*), intent(in), optional :: MatrixProp Matrix is SYM , UNSYM integer(kind=I4B), intent(in), optional :: StorageFMT Description This subroutine construct the sparsematrix_ object","tags":"","loc":"interface/initiate_obj1.html"},{"title":"initiate_obj2 – Fortran Program","text":"interface This subroutine converts a dense matrix into sparse matrix private subroutine initiate_obj2(Obj, Val, MatrixProp) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val (:,:) character(len=*), intent(in), optional :: MatrixProp Description This subroutine converts a dense matrix into a sparse matrix","tags":"","loc":"interface/initiate_obj2.html"},{"title":"initiate_obj3 – Fortran Program","text":"interface This matrix converts a dense matrix into a sparse matrix private subroutine initiate_obj3(Obj, Val, MatrixProp) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(inout) :: Obj type(RealMatrix_), intent(in) :: Val character(len=*), intent(in), optional :: MatrixProp Description This matrix converts a dense matrix into a sparse matrix","tags":"","loc":"interface/initiate_obj3.html"},{"title":"initiate_obj4 – Fortran Program","text":"interface This subroutine construct sparsematrix_ object from IA, JA, A private subroutine initiate_obj4(Obj, A, IA, JA, MatrixProp) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(inout) :: Obj real(kind=DFP), intent(in) :: A (:) integer(kind=I4B), intent(in) :: IA (:) integer(kind=I4B), intent(in) :: JA (:) character(len=*), intent(in), optional :: MatrixProp Description This subroutine constructs sparsematrix_ object from IA, JA, and A","tags":"","loc":"interface/initiate_obj4.html"},{"title":"initiate_obj5 – Fortran Program","text":"interface private subroutine initiate_obj5(Obj, IA, JA, MatrixProp) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(inout) :: Obj integer(kind=I4B), intent(in) :: IA (:) integer(kind=I4B), intent(in) :: JA (:) character(len=*), intent(in), optional :: MatrixProp","tags":"","loc":"interface/initiate_obj5.html"},{"title":"lsol_csr – Fortran Program","text":"interface — Solve Lx = y by forward elimination technique will be used private subroutine lsol_csr(Obj, x, y) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(in) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: x (:) real(kind=DFP), intent(in) :: y (:)","tags":"","loc":"interface/lsol_csr.html"},{"title":"lusol_alu – Fortran Program","text":"interface private subroutine lusol_alu(x, y, alu, jlu, ju) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: x (:) real(kind=DFP), intent(in) :: y (:) real(kind=DFP), intent(in) :: alu (:) integer(kind=I4B), intent(in) :: jlu (:) integer(kind=I4B), intent(in) :: ju (:)","tags":"","loc":"interface/lusol_alu.html"},{"title":"lutsol_alu – Fortran Program","text":"interface private subroutine lutsol_alu(x, y, alu, jlu, ju) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: x (:) real(kind=DFP), intent(in) :: y (:) real(kind=DFP), intent(in) :: alu (:) integer(kind=I4B), intent(in) :: jlu (:) integer(kind=I4B), intent(in) :: ju (:)","tags":"","loc":"interface/lutsol_alu.html"},{"title":"matmul_CSR – Fortran Program","text":"interface private function matmul_CSR(Obj, x, matvectype) result(Ans) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(in) :: Obj real(kind=DFP), intent(in) :: x (:) character(len=*), intent(in) :: matvectype Return Value real(kind=DFP)\n  (SIZE(x))","tags":"","loc":"interface/matmul_csr.html"},{"title":"matvec_CSR_amux – Fortran Program","text":"interface private subroutine matvec_CSR_amux(Obj, x, y, matvectype) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(in) :: Obj real(kind=DFP), intent(in) :: x (:) real(kind=DFP), intent(inout), ALLOCATABLE :: y (:) character(len=*), intent(in) :: matvectype","tags":"","loc":"interface/matvec_csr_amux.html"},{"title":"obj_convert_dns – Fortran Program","text":"interface private subroutine obj_convert_dns(From, To) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(in) :: From real(kind=DFP), intent(inout), ALLOCATABLE :: To (:,:)","tags":"","loc":"interface/obj_convert_dns.html"},{"title":"obj_spy – Fortran Program","text":"interface private subroutine obj_spy(Obj, PFE, ScriptLang, Values) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(in) :: Obj type(String), intent(in) :: PFE (3) character(len=*), intent(in) :: ScriptLang logical(kind=LGT), intent(in) :: Values","tags":"","loc":"interface/obj_spy.html"},{"title":"remove_duplicates_csr – Fortran Program","text":"interface private subroutine remove_duplicates_csr(Obj, Values) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(inout) :: Obj logical(kind=LGT), intent(in), optional :: Values","tags":"","loc":"interface/remove_duplicates_csr.html"},{"title":"setSparsity – Fortran Program","text":"public interface setSparsity Contents Module Procedures setSparsity_1 setSparsity_2 setSparsity_3 Module Procedures private interface setSparsity_1 () This subroutine set the sparsity pattern of a given row Arguments None private interface setSparsity_2 () This subroutine set the sparsity pattern of a given row Arguments None private interface setSparsity_3 () This subroutine set sparsity pattern of sparsematrix_ Arguments None","tags":"","loc":"interface/setsparsity~2.html"},{"title":"setSparsity_1 – Fortran Program","text":"interface This subroutine set the sparsity pattern of a given row private subroutine setSparsity_1(Obj, Row, Col) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Row integer(kind=I4B), intent(in) :: Col (:) Description This subroutine set the sparsity pattern of a given row\n  - If obj%tdof is equal to 1, then Col is sorted in increasing order,\n and appended to Obj%Row(Row) - If obj%tdof is not equal  to 1, then based on the storage format and Col connectivity information is generated.","tags":"","loc":"interface/setsparsity_1~2.html"},{"title":"setSparsity_2 – Fortran Program","text":"interface This subroutine set the sparsity pattern of a given row private subroutine setSparsity_2(Obj, Row, Col) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Row (:) type(IntVector_), intent(in) :: Col (:) Description This subroutine sets the sparsity pattern of a given row\n This subroutine calls setSparsity_1","tags":"","loc":"interface/setsparsity_2.html"},{"title":"setSparsity_3 – Fortran Program","text":"interface This subroutine set sparsity pattern of sparsematrix_ private subroutine setSparsity_3(Obj) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(inout) :: Obj Description This subroutine set sparsity pattern of sparsematrix_ This will finally set the data into\n - Obj % A(:) - Obj % IA(:) ,\n - Obj % JA(:) in CSR format. This routine also set data inside Obj % ColSize(:) and Obj % RowSize(:) , and Obj % DiagIndx(:)","tags":"","loc":"interface/setsparsity_3.html"},{"title":"setValue – Fortran Program","text":"public interface setValue Contents Module Procedures setValue_1 setValue_2 Module Procedures private interface setValue_1 () This subroutine set the value in sparse matrix Arguments None private interface setValue_2 () This subroutine set all values of SparseMatrix_ to given scalar value Arguments None","tags":"","loc":"interface/setvalue~3.html"},{"title":"setValueInternally – Fortran Program","text":"interface This subroutine set the value in sparsematrix_ private subroutine setValueInternally(Obj, Nptrs, Val) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Nptrs (:) real(kind=DFP), intent(in) :: Val (:,:) Description This subroutine sets the value in sparsematrix_ - Shape( Val ) = [SIZE(Nptrs) tdof, SIZE(Nptrs) tdof]\n - Usually Val denotes the element matrix\n - Symbolic we are performing following task Obj(Nptrs, Nptrs)=Val","tags":"","loc":"interface/setvalueinternally.html"},{"title":"setValue_1 – Fortran Program","text":"interface This subroutine set the value in sparse matrix private subroutine setValue_1(Obj, Nptrs, Val, StorageFMT) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Nptrs (:) real(kind=DFP), intent(in) :: Val (:,:) integer(kind=I4B), intent(in) :: StorageFMT Description This subroutine sets the values in sparse matrix\n - Usually Val(:,:) represents the elemental finite element matrix\n - StorageFMT denotes the storage format of Val; Nodes_FMT or DOF_FMT - Usually finite element matrix is stored with DOF_FMT ### Usage fortran\n program main\n   use easifem\n   implicit none\n   type( sparsematrix_ ) :: obj\n   real( dfp ), allocatable :: val( :, : )\n   call initiate( obj = obj, tdof = 2, tnodes = [8], storageFMT=DOF_FMT )\n   call setsparsity( obj = obj, row = 1, col = [1,2,7] )\n   call setsparsity( obj = obj, row = 2, col = [2,1,3,6,7,8] )\n   call setsparsity( obj = obj, row = 3, col = [3, 2, 4, 8] )\n   call setsparsity( obj = obj, row = 4, col = [4,3,5,8] )\n   call setsparsity( obj = obj, row = 5, col = [5,4,6,8] )\n   call setsparsity( obj = obj, row = 6, col = [6,2,5,7,8] )\n   call setsparsity( obj = obj, row = 7, col = [7,1,2,6] )\n   call setsparsity( obj = obj, row = 8, col = [8,2,3,4,5,6] )\n   call setsparsity( obj = obj )\n   allocate( val( 6, 6 ) )\n   call RANDOM_NUMBER( val )\n   call display( val, \"val\")\n   call setValue( obj=obj, nptrs=[1,2,7], val=val, storageFMT=DOF_FMT )\n   call display( obj, \"obj\" )\n end program main","tags":"","loc":"interface/setvalue_1.html"},{"title":"setValue_2 – Fortran Program","text":"interface This subroutine set all values of SparseMatrix_ to given scalar value private subroutine setValue_2(Obj, Val) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val Description This subroutine set all values of SparseMatrix_ to a given scalar value","tags":"","loc":"interface/setvalue_2.html"},{"title":"usol_csr – Fortran Program","text":"interface — Solve Ux = y by backward elimination technique will be used private subroutine usol_csr(Obj, x, y) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(in) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: x (:) real(kind=DFP), intent(in) :: y (:)","tags":"","loc":"interface/usol_csr.html"},{"title":"BoundingBox – Fortran Program","text":"public interface BoundingBox Contents Module Procedures Constructor1 Constructor2 Constructor3 Module Procedures private interface Constructor1 () Arguments None private interface Constructor2 () Arguments None private interface Constructor3 () Return the bouding box for a given set of coordinates Arguments None","tags":"","loc":"interface/boundingbox~2.html"},{"title":"BoundingBox_Pointer – Fortran Program","text":"public interface BoundingBox_Pointer Contents Module Procedures Constructor_1 Constructor_2 Module Procedures private interface Constructor_1 () Arguments None private interface Constructor_2 () Arguments None","tags":"","loc":"interface/boundingbox_pointer.html"},{"title":"Center – Fortran Program","text":"public interface Center Contents Module Procedures get_Center Module Procedures private interface get_Center () Arguments None","tags":"","loc":"interface/center.html"},{"title":"Constructor1 – Fortran Program","text":"interface private pure function Constructor1(nsd, lim) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: nsd real(kind=DFP), intent(in) :: lim (6) Return Value type(BoundingBox_)","tags":"","loc":"interface/constructor1~10.html"},{"title":"Constructor2 – Fortran Program","text":"interface private pure function Constructor2(AnotherObj) result(Ans) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(in) :: AnotherObj Return Value type(BoundingBox_)","tags":"","loc":"interface/constructor2~5.html"},{"title":"Constructor3 – Fortran Program","text":"interface Return the bouding box for a given set of coordinates private pure function Constructor3(xij) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: xij (:,:) Nodal coordinates xij( 1:nsd, 1:tnodes ) Return Value type(BoundingBox_) Description Return the bouding box for a given set of coordinates Usage fortran\n    bbox = BoundingBox( XiJ )","tags":"","loc":"interface/constructor3.html"},{"title":"Constructor_1 – Fortran Program","text":"interface private function Constructor_1(nsd, lim) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: nsd real(kind=DFP), intent(in) :: lim (6) Return Value class(BoundingBox_),\n  POINTER","tags":"","loc":"interface/constructor_1~2.html"},{"title":"Constructor_2 – Fortran Program","text":"interface private function Constructor_2(AnotherObj) result(Ans) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(in) :: AnotherObj Return Value class(BoundingBox_),\n  POINTER","tags":"","loc":"interface/constructor_2.html"},{"title":"Display – Fortran Program","text":"public interface Display Contents Module Procedures display_obj Module Procedures private interface display_obj () Arguments None","tags":"","loc":"interface/display~22.html"},{"title":"Initiate – Fortran Program","text":"public interface Initiate Contents Module Procedures initiate_1 initiate_2 Module Procedures private interface initiate_1 () Arguments None private interface initiate_2 () Arguments None","tags":"","loc":"interface/initiate~16.html"},{"title":"Intersection – Fortran Program","text":"public interface Intersection Contents Module Procedures get_intersection Module Procedures private interface get_intersection () Arguments None","tags":"","loc":"interface/intersection.html"},{"title":"OPERATOR( .Intersection. ) – Fortran Program","text":"public interface OPERATOR( .Intersection. ) Contents Module Procedures get_intersection Module Procedures private interface get_intersection () Arguments None","tags":"","loc":"interface/operator( .intersection. ).html"},{"title":"OPERATOR( .Nptrs. ) – Fortran Program","text":"public interface OPERATOR( .Nptrs. ) Contents Module Procedures get_nptrs Module Procedures private interface get_nptrs () Arguments None","tags":"","loc":"interface/operator( .nptrs. ).html"},{"title":"OPERATOR( .isInside. ) – Fortran Program","text":"public interface OPERATOR( .isInside. ) Contents Module Procedures is_Inside Module Procedures private interface is_Inside () Arguments None","tags":"","loc":"interface/operator( .isinside. ).html"},{"title":"OPERATOR(.Center.) – Fortran Program","text":"public interface OPERATOR(.Center.) Contents Module Procedures get_Center Module Procedures private interface get_Center () Arguments None","tags":"","loc":"interface/operator(.center.).html"},{"title":"OPERATOR(.UNION.) – Fortran Program","text":"public interface OPERATOR(.UNION.) Contents Module Procedures get_Union Module Procedures private interface get_Union () Arguments None","tags":"","loc":"interface/operator(.union.).html"},{"title":"Operator( .Xmax. ) – Fortran Program","text":"public interface Operator( .Xmax. ) Contents Module Procedures getXmax Module Procedures private interface getXmax () Arguments None","tags":"","loc":"interface/operator( .xmax. ).html"},{"title":"Operator( .Xmin. ) – Fortran Program","text":"public interface Operator( .Xmin. ) Contents Module Procedures getXmin Module Procedures private interface getXmin () Arguments None","tags":"","loc":"interface/operator( .xmin. ).html"},{"title":"Operator( .Ymax. ) – Fortran Program","text":"public interface Operator( .Ymax. ) Contents Module Procedures getYmax Module Procedures private interface getYmax () Arguments None","tags":"","loc":"interface/operator( .ymax. ).html"},{"title":"Operator( .Ymin. ) – Fortran Program","text":"public interface Operator( .Ymin. ) Contents Module Procedures getYmin Module Procedures private interface getYmin () Arguments None","tags":"","loc":"interface/operator( .ymin. ).html"},{"title":"Operator( .Zmax. ) – Fortran Program","text":"public interface Operator( .Zmax. ) Contents Module Procedures getZmax Module Procedures private interface getZmax () Arguments None","tags":"","loc":"interface/operator( .zmax. ).html"},{"title":"Operator( .Zmin. ) – Fortran Program","text":"public interface Operator( .Zmin. ) Contents Module Procedures getZmin Module Procedures private interface getZmin () Arguments None","tags":"","loc":"interface/operator( .zmin. ).html"},{"title":"Operator( .isIntersect. ) – Fortran Program","text":"public interface Operator( .isIntersect. ) Contents Module Procedures is_intersect Module Procedures private interface is_intersect () Arguments None","tags":"","loc":"interface/operator( .isintersect. ).html"},{"title":"Union – Fortran Program","text":"public interface Union Contents Module Procedures get_Union Module Procedures private interface get_Union () Arguments None","tags":"","loc":"interface/union.html"},{"title":"display_obj – Fortran Program","text":"interface private subroutine display_obj(Obj, msg, unitNo) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(in) :: Obj character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitNo","tags":"","loc":"interface/display_obj~3.html"},{"title":"getXmax – Fortran Program","text":"interface private pure function getXmax(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(in) :: Obj Return Value real(kind=DFP)","tags":"","loc":"interface/getxmax.html"},{"title":"getXmin – Fortran Program","text":"interface private pure function getXmin(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(in) :: Obj Return Value real(kind=DFP)","tags":"","loc":"interface/getxmin.html"},{"title":"getYmax – Fortran Program","text":"interface private pure function getYmax(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(in) :: Obj Return Value real(kind=DFP)","tags":"","loc":"interface/getymax.html"},{"title":"getYmin – Fortran Program","text":"interface private pure function getYmin(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(in) :: Obj Return Value real(kind=DFP)","tags":"","loc":"interface/getymin.html"},{"title":"getZmax – Fortran Program","text":"interface private pure function getZmax(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(in) :: Obj Return Value real(kind=DFP)","tags":"","loc":"interface/getzmax.html"},{"title":"getZmin – Fortran Program","text":"interface private pure function getZmin(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(in) :: Obj Return Value real(kind=DFP)","tags":"","loc":"interface/getzmin.html"},{"title":"get_Center – Fortran Program","text":"interface private pure function get_Center(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(in) :: Obj Return Value real(kind=DFP)\n  (3)","tags":"","loc":"interface/get_center.html"},{"title":"get_Union – Fortran Program","text":"interface private pure function get_Union(Obj, Obj2) result(Ans) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(in) :: Obj class(BoundingBox_), intent(in) :: Obj2 Return Value type(BoundingBox_)","tags":"","loc":"interface/get_union.html"},{"title":"get_intersection – Fortran Program","text":"interface private pure function get_intersection(Obj, Obj2) result(Ans) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(in) :: Obj class(BoundingBox_), intent(in) :: Obj2 Return Value type(BoundingBox_)","tags":"","loc":"interface/get_intersection.html"},{"title":"get_nptrs – Fortran Program","text":"interface private pure function get_nptrs(Obj, xij) result(Ans) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(in) :: Obj real(kind=DFP), intent(in) :: xij (:,:) Return Value integer(kind=I4B),\n  ALLOCATABLE,(:)","tags":"","loc":"interface/get_nptrs~2.html"},{"title":"initiate_1 – Fortran Program","text":"interface private subroutine initiate_1(Obj, NSD, lim) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(inout) :: Obj integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in) :: lim (6)","tags":"","loc":"interface/initiate_1.html"},{"title":"initiate_2 – Fortran Program","text":"interface private subroutine initiate_2(Obj, AnotherObj) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(inout) :: Obj class(BoundingBox_), intent(in) :: AnotherObj","tags":"","loc":"interface/initiate_2.html"},{"title":"isInside – Fortran Program","text":"public interface isInside Contents Module Procedures is_Inside Module Procedures private interface is_Inside () Arguments None","tags":"","loc":"interface/isinside.html"},{"title":"isIntersect – Fortran Program","text":"public interface isIntersect Contents Module Procedures is_intersect Module Procedures private interface is_intersect () Arguments None","tags":"","loc":"interface/isintersect.html"},{"title":"isIntersectInX – Fortran Program","text":"public interface isIntersectInX Contents Module Procedures is_intersect_in_X Module Procedures private interface is_intersect_in_X () Arguments None","tags":"","loc":"interface/isintersectinx.html"},{"title":"isIntersectInY – Fortran Program","text":"public interface isIntersectInY Contents Module Procedures is_intersect_in_Y Module Procedures private interface is_intersect_in_Y () Arguments None","tags":"","loc":"interface/isintersectiny.html"},{"title":"isIntersectInZ – Fortran Program","text":"public interface isIntersectInZ Contents Module Procedures is_intersect_in_Z Module Procedures private interface is_intersect_in_Z () Arguments None","tags":"","loc":"interface/isintersectinz.html"},{"title":"is_Inside – Fortran Program","text":"interface private pure function is_Inside(Obj, Val) result(Ans) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(in) :: Obj real(kind=DFP), intent(in) :: Val (:) Return Value logical(kind=LGT)","tags":"","loc":"interface/is_inside.html"},{"title":"is_intersect – Fortran Program","text":"interface private pure function is_intersect(Obj, Obj2) result(Ans) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(in) :: Obj class(BoundingBox_), intent(in) :: Obj2 Return Value logical(kind=LGT)","tags":"","loc":"interface/is_intersect.html"},{"title":"is_intersect_in_X – Fortran Program","text":"interface private pure function is_intersect_in_X(Obj, Obj2) result(Ans) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(in) :: Obj class(BoundingBox_), intent(in) :: Obj2 Return Value logical(kind=LGT)","tags":"","loc":"interface/is_intersect_in_x.html"},{"title":"is_intersect_in_Y – Fortran Program","text":"interface private pure function is_intersect_in_Y(Obj, Obj2) result(Ans) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(in) :: Obj class(BoundingBox_), intent(in) :: Obj2 Return Value logical(kind=LGT)","tags":"","loc":"interface/is_intersect_in_y.html"},{"title":"is_intersect_in_Z – Fortran Program","text":"interface private pure function is_intersect_in_Z(Obj, Obj2) result(Ans) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(in) :: Obj class(BoundingBox_), intent(in) :: Obj2 Return Value logical(kind=LGT)","tags":"","loc":"interface/is_intersect_in_z.html"},{"title":"setXmax – Fortran Program","text":"interface private subroutine setXmax(Obj, Val) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val","tags":"","loc":"interface/setxmax.html"},{"title":"setXmin – Fortran Program","text":"interface private subroutine setXmin(Obj, Val) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val","tags":"","loc":"interface/setxmin.html"},{"title":"setYmax – Fortran Program","text":"interface private subroutine setYmax(Obj, Val) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val","tags":"","loc":"interface/setymax.html"},{"title":"setYmin – Fortran Program","text":"interface private subroutine setYmin(Obj, Val) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val","tags":"","loc":"interface/setymin.html"},{"title":"setZmax – Fortran Program","text":"interface private subroutine setZmax(Obj, Val) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val","tags":"","loc":"interface/setzmax.html"},{"title":"setZmin – Fortran Program","text":"interface private subroutine setZmin(Obj, Val) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val","tags":"","loc":"interface/setzmin.html"},{"title":"reference_Hexahedron_Pointer – Fortran Program","text":"private pure function reference_Hexahedron_Pointer(NSD, XiJ) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:) Return Value class(ReferenceHexahedron_),\n  POINTER Contents Source Code reference_Hexahedron_Pointer Source Code PURE FUNCTION reference_Hexahedron_Pointer ( NSD , XiJ ) RESULT ( Obj ) INTEGER ( I4B ), INTENT ( IN ) :: NSD REAL ( DFP ), INTENT ( IN ), OPTIONAL :: XiJ (:,:) CLASS ( ReferenceHexahedron_ ), POINTER :: Obj ALLOCATE ( Obj ) IF ( PRESENT ( XiJ ) ) THEN CALL Initiate ( Obj , NSD , XiJ ) ELSE CALL Initiate ( Obj , NSD ) END IF END FUNCTION reference_Hexahedron_Pointer","tags":"","loc":"proc/reference_hexahedron_pointer.html"},{"title":"reference_Line_Pointer – Fortran Program","text":"private pure function reference_Line_Pointer(NSD, XiJ) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:) Return Value class(ReferenceLine_),\n  POINTER Contents Source Code reference_Line_Pointer Source Code PURE FUNCTION reference_Line_Pointer ( NSD , XiJ ) RESULT ( Obj ) INTEGER ( I4B ), INTENT ( IN ) :: NSD REAL ( DFP ), INTENT ( IN ), OPTIONAL :: XiJ (:,:) CLASS ( ReferenceLine_ ), POINTER :: Obj ALLOCATE ( Obj ) IF ( PRESENT ( XiJ ) ) THEN CALL Initiate ( Obj , NSD , XiJ ) ELSE CALL Initiate ( Obj , NSD ) END IF END FUNCTION reference_Line_Pointer","tags":"","loc":"proc/reference_line_pointer.html"},{"title":"reference_Prism_Pointer – Fortran Program","text":"private pure function reference_Prism_Pointer(NSD, XiJ) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:) Return Value class(ReferencePrism_),\n  POINTER Contents Source Code reference_Prism_Pointer Source Code PURE FUNCTION reference_Prism_Pointer ( NSD , XiJ ) RESULT ( Obj ) INTEGER ( I4B ), INTENT ( IN ) :: NSD REAL ( DFP ), INTENT ( IN ), OPTIONAL :: XiJ (:,:) CLASS ( ReferencePrism_ ), POINTER :: Obj ALLOCATE ( Obj ) IF ( PRESENT ( XiJ ) ) THEN CALL Initiate ( Obj , NSD , XiJ ) ELSE CALL Initiate ( Obj , NSD ) END IF END FUNCTION reference_Prism_Pointer","tags":"","loc":"proc/reference_prism_pointer.html"},{"title":"reference_Pyramid_Pointer – Fortran Program","text":"private pure function reference_Pyramid_Pointer(NSD, XiJ) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:) Return Value class(ReferencePyramid_),\n  POINTER Contents Source Code reference_Pyramid_Pointer Source Code PURE FUNCTION reference_Pyramid_Pointer ( NSD , XiJ ) RESULT ( Obj ) INTEGER ( I4B ), INTENT ( IN ) :: NSD REAL ( DFP ), INTENT ( IN ), OPTIONAL :: XiJ (:,:) CLASS ( ReferencePyramid_ ), POINTER :: Obj ALLOCATE ( Obj ) IF ( PRESENT ( XiJ ) ) THEN CALL Initiate ( Obj , NSD , XiJ ) ELSE CALL Initiate ( Obj , NSD ) END IF END FUNCTION reference_Pyramid_Pointer","tags":"","loc":"proc/reference_pyramid_pointer.html"},{"title":"reference_Quadrangle_Pointer – Fortran Program","text":"private pure function reference_Quadrangle_Pointer(NSD, XiJ) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:) Return Value class(ReferenceQuadrangle_),\n  POINTER Contents Source Code reference_Quadrangle_Pointer Source Code PURE FUNCTION reference_Quadrangle_Pointer ( NSD , XiJ ) RESULT ( Obj ) INTEGER ( I4B ), INTENT ( IN ) :: NSD REAL ( DFP ), INTENT ( IN ), OPTIONAL :: XiJ (:,:) CLASS ( ReferenceQuadrangle_ ), POINTER :: Obj ALLOCATE ( Obj ) IF ( PRESENT ( XiJ ) ) THEN CALL Initiate ( Obj , NSD , XiJ ) ELSE CALL Initiate ( Obj , NSD ) END IF END FUNCTION reference_Quadrangle_Pointer","tags":"","loc":"proc/reference_quadrangle_pointer.html"},{"title":"reference_Tetrahedron_Pointer – Fortran Program","text":"private pure function reference_Tetrahedron_Pointer(NSD, XiJ) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:) Return Value class(ReferenceTetrahedron_),\n  POINTER Contents Source Code reference_Tetrahedron_Pointer Source Code PURE FUNCTION reference_Tetrahedron_Pointer ( NSD , XiJ ) RESULT ( Obj ) INTEGER ( I4B ), INTENT ( IN ) :: NSD REAL ( DFP ), INTENT ( IN ), OPTIONAL :: XiJ (:,:) CLASS ( ReferenceTetrahedron_ ), POINTER :: Obj ALLOCATE ( Obj ) IF ( PRESENT ( XiJ ) ) THEN CALL Initiate ( Obj , NSD , XiJ ) ELSE CALL Initiate ( Obj , NSD ) END IF END FUNCTION reference_Tetrahedron_Pointer","tags":"","loc":"proc/reference_tetrahedron_pointer.html"},{"title":"reference_Triangle_Pointer – Fortran Program","text":"private pure function reference_Triangle_Pointer(NSD, XiJ) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:) Return Value class(ReferenceTriangle_),\n  POINTER Contents Source Code reference_Triangle_Pointer Source Code PURE FUNCTION reference_Triangle_Pointer ( NSD , XiJ ) RESULT ( Obj ) INTEGER ( I4B ), INTENT ( IN ) :: NSD REAL ( DFP ), INTENT ( IN ), OPTIONAL :: XiJ (:,:) CLASS ( ReferenceTriangle_ ), POINTER :: Obj ALLOCATE ( Obj ) IF ( PRESENT ( XiJ ) ) THEN CALL Initiate ( Obj , NSD , XiJ ) ELSE CALL Initiate ( Obj , NSD ) END IF END FUNCTION reference_Triangle_Pointer","tags":"","loc":"proc/reference_triangle_pointer.html"},{"title":"ASSIGNMENT( = ) – Fortran Program","text":"public interface ASSIGNMENT( = ) Contents Module Procedures init_refelem Module Procedures private interface init_refelem () Arguments None","tags":"","loc":"interface/assignment( = )~5.html"},{"title":"Angles – Fortran Program","text":"public interface Angles Contents Module Procedures triangle_angles Module Procedures private interface triangle_angles () Arguments None","tags":"","loc":"interface/angles.html"},{"title":"Area – Fortran Program","text":"public interface Area Contents Module Procedures triangle_area Module Procedures private interface triangle_area () Arguments None","tags":"","loc":"interface/area.html"},{"title":"AreaVector – Fortran Program","text":"public interface AreaVector Contents Module Procedures triangle_areaVector Module Procedures private interface triangle_areaVector () Arguments None","tags":"","loc":"interface/areavector.html"},{"title":"Barycentric – Fortran Program","text":"public interface Barycentric Contents Module Procedures triangle_barycentric Module Procedures private interface triangle_barycentric () Arguments None","tags":"","loc":"interface/barycentric.html"},{"title":"Centroid – Fortran Program","text":"public interface Centroid Contents Module Procedures triangle_centroid Module Procedures private interface triangle_centroid () Arguments None","tags":"","loc":"interface/centroid.html"},{"title":"CircumCenter – Fortran Program","text":"public interface CircumCenter Contents Module Procedures triangle_circumcentre Module Procedures private interface triangle_circumcentre () Arguments None","tags":"","loc":"interface/circumcenter.html"},{"title":"CircumCircle – Fortran Program","text":"public interface CircumCircle Contents Module Procedures triangle_circumcircle Module Procedures private interface triangle_circumcircle () Arguments None","tags":"","loc":"interface/circumcircle.html"},{"title":"CircumRadius – Fortran Program","text":"public interface CircumRadius Contents Module Procedures triangle_circumradius Module Procedures private interface triangle_circumradius () Arguments None","tags":"","loc":"interface/circumradius.html"},{"title":"ContainsLine – Fortran Program","text":"public interface ContainsLine Contents Module Procedures triangle_contains_line Module Procedures private interface triangle_contains_line () Arguments None","tags":"","loc":"interface/containsline.html"},{"title":"ContainsPoint – Fortran Program","text":"public interface ContainsPoint Contents Module Procedures contains_point Module Procedures private interface contains_point () Arguments None","tags":"","loc":"interface/containspoint.html"},{"title":"DeallocateData – Fortran Program","text":"public interface DeallocateData Contents Module Procedures deallocatedata_ref_topology Module Procedures private interface deallocatedata_ref_topology () Arguments None","tags":"","loc":"interface/deallocatedata~22.html"},{"title":"DeallocateData – Fortran Program","text":"private interface DeallocateData Contents Module Procedures deallocatedata_ref_elem Module Procedures private interface deallocatedata_ref_elem () Arguments None","tags":"","loc":"interface/deallocatedata~23.html"},{"title":"Display – Fortran Program","text":"public interface Display Contents Module Procedures display_ref_elem display_ref_topo Module Procedures private interface display_ref_elem () Arguments None private interface display_ref_topo () Arguments None","tags":"","loc":"interface/display~23.html"},{"title":"DistanceFromPoint – Fortran Program","text":"public interface DistanceFromPoint Contents Module Procedures triangle_point_dist Module Procedures private interface triangle_point_dist () Arguments None","tags":"","loc":"interface/distancefrompoint.html"},{"title":"EdgeLength – Fortran Program","text":"public interface EdgeLength Contents Module Procedures triangle_edge_length Module Procedures private interface triangle_edge_length () Arguments None","tags":"","loc":"interface/edgelength.html"},{"title":"Elem_Topology – Fortran Program","text":"interface private pure function Elem_Topology(ElemType) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ElemType Return Value integer(kind=I4B)","tags":"","loc":"interface/elem_topology.html"},{"title":"Elem_XiDimension – Fortran Program","text":"interface private pure function Elem_XiDimension(ElemType) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ElemType Return Value integer(kind=I4B)","tags":"","loc":"interface/elem_xidimension.html"},{"title":"ElementName – Fortran Program","text":"public interface ElementName Contents Module Procedures Element_Name Module Procedures private interface Element_Name () Arguments None","tags":"","loc":"interface/elementname.html"},{"title":"ElementOrder – Fortran Program","text":"public interface ElementOrder Contents Module Procedures Element_Order_RefElem Element_Order Module Procedures private interface Element_Order_RefElem () Arguments None private interface Element_Order () Arguments None","tags":"","loc":"interface/elementorder.html"},{"title":"ElementQuality – Fortran Program","text":"public interface ElementQuality Contents Module Procedures Element_Quality Module Procedures private interface Element_Quality () Arguments None","tags":"","loc":"interface/elementquality.html"},{"title":"ElementTopology – Fortran Program","text":"public interface ElementTopology Contents Module Procedures Elem_Topology Module Procedures private interface Elem_Topology () Arguments None","tags":"","loc":"interface/elementtopology.html"},{"title":"ElementType – Fortran Program","text":"public interface ElementType Contents Module Procedures Element_Type Module Procedures private interface Element_Type () Arguments None","tags":"","loc":"interface/elementtype.html"},{"title":"Element_Name – Fortran Program","text":"interface private pure function Element_Name(ElemType) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ElemType Return Value character(len=50)","tags":"","loc":"interface/element_name.html"},{"title":"Element_Order – Fortran Program","text":"interface private pure function Element_Order(ElemType) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ElemType Return Value integer(kind=I4B)","tags":"","loc":"interface/element_order.html"},{"title":"Element_Order_RefElem – Fortran Program","text":"interface private pure function Element_Order_RefElem(RefElem) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceElement_), intent(in) :: RefElem Return Value integer(kind=I4B)","tags":"","loc":"interface/element_order_refelem.html"},{"title":"Element_Quality – Fortran Program","text":"interface private function Element_Quality(refelem, xij, measure) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceElement_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) integer(kind=I4B), intent(in) :: measure Return Value real(kind=DFP)","tags":"","loc":"interface/element_quality.html"},{"title":"Element_Type – Fortran Program","text":"interface private pure function Element_Type(ElemName) result(Ans) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: ElemName Return Value integer(kind=I4B)","tags":"","loc":"interface/element_type.html"},{"title":"EquidistanceLIP_Hexahedron – Fortran Program","text":"interface private pure function EquidistanceLIP_Hexahedron(RefElem, Order) result(NodeCoord) Arguments Type Intent Optional Attributes Name class(ReferenceHexahedron_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:)","tags":"","loc":"interface/equidistancelip_hexahedron.html"},{"title":"EquidistanceLIP_Line – Fortran Program","text":"interface private pure function EquidistanceLIP_Line(RefElem, Order) result(NodeCoord) Arguments Type Intent Optional Attributes Name class(ReferenceLine_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:)","tags":"","loc":"interface/equidistancelip_line.html"},{"title":"EquidistanceLIP_Prism – Fortran Program","text":"interface private pure function EquidistanceLIP_Prism(RefElem, Order) result(NodeCoord) Arguments Type Intent Optional Attributes Name class(ReferencePrism_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:)","tags":"","loc":"interface/equidistancelip_prism.html"},{"title":"EquidistanceLIP_Pyramid – Fortran Program","text":"interface private pure function EquidistanceLIP_Pyramid(RefElem, Order) result(NodeCoord) Arguments Type Intent Optional Attributes Name class(ReferencePyramid_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:)","tags":"","loc":"interface/equidistancelip_pyramid.html"},{"title":"EquidistanceLIP_Quadrangle – Fortran Program","text":"interface private pure function EquidistanceLIP_Quadrangle(RefElem, Order) result(NodeCoord) Arguments Type Intent Optional Attributes Name class(ReferenceQuadrangle_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:)","tags":"","loc":"interface/equidistancelip_quadrangle.html"},{"title":"EquidistanceLIP_Tetrahedron – Fortran Program","text":"interface private pure function EquidistanceLIP_Tetrahedron(RefElem, Order) result(NodeCoord) Arguments Type Intent Optional Attributes Name class(ReferenceTetrahedron_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:)","tags":"","loc":"interface/equidistancelip_tetrahedron.html"},{"title":"EquidistanceLIP_Triangle – Fortran Program","text":"interface private pure function EquidistanceLIP_Triangle(RefElem, Order) result(NodeCoord) Arguments Type Intent Optional Attributes Name class(ReferenceTriangle_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:)","tags":"","loc":"interface/equidistancelip_triangle.html"},{"title":"FacetMatrix – Fortran Program","text":"public interface FacetMatrix Contents Module Procedures Facet_Matrix_RefElem Module Procedures private interface Facet_Matrix_RefElem () Arguments None","tags":"","loc":"interface/facetmatrix.html"},{"title":"Facet_Matrix_RefElem – Fortran Program","text":"interface private pure function Facet_Matrix_RefElem(RefElem) result(FM) Arguments Type Intent Optional Attributes Name class(ReferenceElement_), intent(in) :: RefElem Return Value integer(kind=I4B),\n  ALLOCATABLE,(:,:)","tags":"","loc":"interface/facet_matrix_refelem.html"},{"title":"Hexahedron_quality – Fortran Program","text":"interface private function Hexahedron_quality(refelem, xij, measure) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceHexahedron_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) integer(kind=I4B), intent(in) :: measure Return Value real(kind=DFP)","tags":"","loc":"interface/hexahedron_quality.html"},{"title":"Incenter – Fortran Program","text":"public interface Incenter Contents Module Procedures triangle_incenter Module Procedures private interface triangle_incenter () Arguments None","tags":"","loc":"interface/incenter.html"},{"title":"Incircle – Fortran Program","text":"public interface Incircle Contents Module Procedures triangle_incircle Module Procedures private interface triangle_incircle () Arguments None","tags":"","loc":"interface/incircle.html"},{"title":"Initiate – Fortran Program","text":"public interface Initiate Contents Module Procedures init_refelem Module Procedures private interface init_refelem () Arguments None","tags":"","loc":"interface/initiate~17.html"},{"title":"Initiate – Fortran Program","text":"private interface Initiate Contents Module Procedures initiate_ref_Line Module Procedures private interface initiate_ref_Line () Arguments None","tags":"","loc":"interface/initiate~18.html"},{"title":"Initiate – Fortran Program","text":"private interface Initiate Contents Module Procedures initiate_ref_Triangle Module Procedures private interface initiate_ref_Triangle () Arguments None","tags":"","loc":"interface/initiate~19.html"},{"title":"Initiate – Fortran Program","text":"private interface Initiate Contents Module Procedures initiate_ref_Quadrangle Module Procedures private interface initiate_ref_Quadrangle () Arguments None","tags":"","loc":"interface/initiate~20.html"},{"title":"Initiate – Fortran Program","text":"private interface Initiate Contents Module Procedures initiate_ref_Tetrahedron Module Procedures private interface initiate_ref_Tetrahedron () Arguments None","tags":"","loc":"interface/initiate~21.html"},{"title":"Initiate – Fortran Program","text":"private interface Initiate Contents Module Procedures initiate_ref_Hexahedron Module Procedures private interface initiate_ref_Hexahedron () Arguments None","tags":"","loc":"interface/initiate~22.html"},{"title":"Initiate – Fortran Program","text":"private interface Initiate Contents Module Procedures initiate_ref_Pyramid Module Procedures private interface initiate_ref_Pyramid () Arguments None","tags":"","loc":"interface/initiate~23.html"},{"title":"Initiate – Fortran Program","text":"private interface Initiate Contents Module Procedures initiate_ref_Prism Module Procedures private interface initiate_ref_Prism () Arguments None","tags":"","loc":"interface/initiate~24.html"},{"title":"Inradius – Fortran Program","text":"public interface Inradius Contents Module Procedures triangle_inradius Module Procedures private interface triangle_inradius () Arguments None","tags":"","loc":"interface/inradius.html"},{"title":"LagrangeElement – Fortran Program","text":"public interface LagrangeElement Contents Module Procedures LagrangeElement_Line Module Procedures private interface LagrangeElement_Line () Arguments None","tags":"","loc":"interface/lagrangeelement.html"},{"title":"LagrangeElement – Fortran Program","text":"private interface LagrangeElement Contents Module Procedures LagrangeElement_Triangle Module Procedures private interface LagrangeElement_Triangle () Arguments None","tags":"","loc":"interface/lagrangeelement~2.html"},{"title":"LagrangeElement – Fortran Program","text":"private interface LagrangeElement Contents Module Procedures LagrangeElement_Quadrangle Module Procedures private interface LagrangeElement_Quadrangle () Arguments None","tags":"","loc":"interface/lagrangeelement~3.html"},{"title":"LagrangeElement – Fortran Program","text":"private interface LagrangeElement Contents Module Procedures LagrangeElement_Tetrahedron Module Procedures private interface LagrangeElement_Tetrahedron () Arguments None","tags":"","loc":"interface/lagrangeelement~4.html"},{"title":"LagrangeElement – Fortran Program","text":"private interface LagrangeElement Contents Module Procedures LagrangeElement_Prism Module Procedures private interface LagrangeElement_Prism () Arguments None","tags":"","loc":"interface/lagrangeelement~5.html"},{"title":"LagrangeElement – Fortran Program","text":"private interface LagrangeElement Contents Module Procedures LagrangeElement_Pyramid Module Procedures private interface LagrangeElement_Pyramid () Arguments None","tags":"","loc":"interface/lagrangeelement~6.html"},{"title":"LagrangeElement – Fortran Program","text":"private interface LagrangeElement Contents Module Procedures LagrangeElement_Hexahedron Module Procedures private interface LagrangeElement_Hexahedron () Arguments None","tags":"","loc":"interface/lagrangeelement~7.html"},{"title":"LagrangeElement_Hexahedron – Fortran Program","text":"interface private pure function LagrangeElement_Hexahedron(RefElem, Order) result(Obj) Arguments Type Intent Optional Attributes Name class(ReferenceHexahedron_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: Order Return Value type(ReferenceHexahedron_)","tags":"","loc":"interface/lagrangeelement_hexahedron.html"},{"title":"LagrangeElement_Line – Fortran Program","text":"interface private pure function LagrangeElement_Line(RefElem, Order) result(Obj) Arguments Type Intent Optional Attributes Name class(ReferenceLine_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: Order Return Value type(ReferenceLine_)","tags":"","loc":"interface/lagrangeelement_line.html"},{"title":"LagrangeElement_Prism – Fortran Program","text":"interface private pure function LagrangeElement_Prism(RefElem, Order) result(Obj) Arguments Type Intent Optional Attributes Name class(ReferencePrism_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: Order Return Value type(ReferencePrism_)","tags":"","loc":"interface/lagrangeelement_prism.html"},{"title":"LagrangeElement_Pyramid – Fortran Program","text":"interface private pure function LagrangeElement_Pyramid(RefElem, Order) result(Obj) Arguments Type Intent Optional Attributes Name class(ReferencePyramid_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: Order Return Value type(ReferencePyramid_)","tags":"","loc":"interface/lagrangeelement_pyramid.html"},{"title":"LagrangeElement_Quadrangle – Fortran Program","text":"interface private pure function LagrangeElement_Quadrangle(RefElem, Order) result(Obj) Arguments Type Intent Optional Attributes Name class(ReferenceQuadrangle_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: Order Return Value type(ReferenceQuadrangle_)","tags":"","loc":"interface/lagrangeelement_quadrangle.html"},{"title":"LagrangeElement_Tetrahedron – Fortran Program","text":"interface private pure function LagrangeElement_Tetrahedron(RefElem, Order) result(Obj) Arguments Type Intent Optional Attributes Name class(ReferenceTetrahedron_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: Order Return Value type(ReferenceTetrahedron_)","tags":"","loc":"interface/lagrangeelement_tetrahedron.html"},{"title":"LagrangeElement_Triangle – Fortran Program","text":"interface private pure function LagrangeElement_Triangle(RefElem, Order) result(Obj) Arguments Type Intent Optional Attributes Name class(ReferenceTriangle_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: Order Return Value type(ReferenceTriangle_)","tags":"","loc":"interface/lagrangeelement_triangle.html"},{"title":"LagrangePoints – Fortran Program","text":"public interface LagrangePoints Contents Module Procedures EquidistanceLIP_Line Module Procedures private interface EquidistanceLIP_Line () Arguments None","tags":"","loc":"interface/lagrangepoints.html"},{"title":"LagrangePoints – Fortran Program","text":"private interface LagrangePoints Contents Module Procedures EquidistanceLIP_Triangle Module Procedures private interface EquidistanceLIP_Triangle () Arguments None","tags":"","loc":"interface/lagrangepoints~2.html"},{"title":"LagrangePoints – Fortran Program","text":"private interface LagrangePoints Contents Module Procedures EquidistanceLIP_Quadrangle Module Procedures private interface EquidistanceLIP_Quadrangle () Arguments None","tags":"","loc":"interface/lagrangepoints~3.html"},{"title":"LagrangePoints – Fortran Program","text":"private interface LagrangePoints Contents Module Procedures EquidistanceLIP_Tetrahedron Module Procedures private interface EquidistanceLIP_Tetrahedron () Arguments None","tags":"","loc":"interface/lagrangepoints~4.html"},{"title":"LagrangePoints – Fortran Program","text":"private interface LagrangePoints Contents Module Procedures EquidistanceLIP_Prism Module Procedures private interface EquidistanceLIP_Prism () Arguments None","tags":"","loc":"interface/lagrangepoints~5.html"},{"title":"LagrangePoints – Fortran Program","text":"private interface LagrangePoints Contents Module Procedures EquidistanceLIP_Pyramid Module Procedures private interface EquidistanceLIP_Pyramid () Arguments None","tags":"","loc":"interface/lagrangepoints~6.html"},{"title":"LagrangePoints – Fortran Program","text":"private interface LagrangePoints Contents Module Procedures EquidistanceLIP_Hexahedron Module Procedures private interface EquidistanceLIP_Hexahedron () Arguments None","tags":"","loc":"interface/lagrangepoints~7.html"},{"title":"LocalNodeCoord – Fortran Program","text":"public interface LocalNodeCoord Contents Module Procedures Local_NodeCoord_RefElem Module Procedures private interface Local_NodeCoord_RefElem () Arguments None","tags":"","loc":"interface/localnodecoord.html"},{"title":"Local_NodeCoord – Fortran Program","text":"interface private subroutine Local_NodeCoord(NodeCoord, ElemType) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: NodeCoord (:,:) integer(kind=I4B), intent(in) :: ElemType","tags":"","loc":"interface/local_nodecoord.html"},{"title":"Local_NodeCoord_RefElem – Fortran Program","text":"interface private pure function Local_NodeCoord_RefElem(RefElem) result(NodeCoord) Arguments Type Intent Optional Attributes Name class(ReferenceElement_), intent(in) :: RefElem Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:)","tags":"","loc":"interface/local_nodecoord_refelem.html"},{"title":"MeasureSimplex – Fortran Program","text":"public interface MeasureSimplex Contents Module Procedures Measure_Simplex Module Procedures private interface Measure_Simplex () Arguments None","tags":"","loc":"interface/measuresimplex.html"},{"title":"Measure_Simplex – Fortran Program","text":"interface private pure function Measure_Simplex(RefElem, XiJ) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceElement_), intent(in) :: RefElem real(kind=DFP), intent(in) :: XiJ (:,:) Return Value real(kind=DFP)","tags":"","loc":"interface/measure_simplex.html"},{"title":"Measure_Simplex_Hexahedron – Fortran Program","text":"interface private pure function Measure_Simplex_Hexahedron(RefElem, XiJ) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceHexahedron_), intent(in) :: RefElem real(kind=DFP), intent(in) :: XiJ (:,:) Return Value real(kind=DFP)","tags":"","loc":"interface/measure_simplex_hexahedron.html"},{"title":"Measure_Simplex_Line – Fortran Program","text":"interface private pure function Measure_Simplex_Line(RefElem, XiJ) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceLine_), intent(in) :: RefElem real(kind=DFP), intent(in) :: XiJ (:,:) Return Value real(kind=DFP)","tags":"","loc":"interface/measure_simplex_line.html"},{"title":"Measure_Simplex_Prism – Fortran Program","text":"interface private pure function Measure_Simplex_Prism(RefElem, XiJ) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferencePrism_), intent(in) :: RefElem real(kind=DFP), intent(in) :: XiJ (:,:) Return Value real(kind=DFP)","tags":"","loc":"interface/measure_simplex_prism.html"},{"title":"Measure_Simplex_Pyramid – Fortran Program","text":"interface private pure function Measure_Simplex_Pyramid(RefElem, XiJ) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferencePyramid_), intent(in) :: RefElem real(kind=DFP), intent(in) :: XiJ (:,:) Return Value real(kind=DFP)","tags":"","loc":"interface/measure_simplex_pyramid.html"},{"title":"Measure_Simplex_Quadrangle – Fortran Program","text":"interface private pure function Measure_Simplex_Quadrangle(RefElem, XiJ) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceQuadrangle_), intent(in) :: RefElem real(kind=DFP), intent(in) :: XiJ (:,:) Return Value real(kind=DFP)","tags":"","loc":"interface/measure_simplex_quadrangle.html"},{"title":"Measure_Simplex_Tetrahedron – Fortran Program","text":"interface private pure function Measure_Simplex_Tetrahedron(RefElem, XiJ) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceTetrahedron_), intent(in) :: RefElem real(kind=DFP), intent(in) :: XiJ (:,:) Return Value real(kind=DFP)","tags":"","loc":"interface/measure_simplex_tetrahedron.html"},{"title":"Measure_Simplex_Triangle – Fortran Program","text":"interface private pure function Measure_Simplex_Triangle(RefElem, XiJ) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceTriangle_), intent(in) :: RefElem real(kind=DFP), intent(in) :: XiJ (:,:) Return Value real(kind=DFP)","tags":"","loc":"interface/measure_simplex_triangle.html"},{"title":"NearestPoint – Fortran Program","text":"public interface NearestPoint Contents Module Procedures triangle_get_nearest_point Module Procedures private interface triangle_get_nearest_point () Arguments None","tags":"","loc":"interface/nearestpoint.html"},{"title":"OPERATOR( .NNE. ) – Fortran Program","text":"public interface OPERATOR( .NNE. ) Contents Module Procedures tNodes_RefTopo tNodes_RefElem Module Procedures private interface tNodes_RefTopo () Arguments None private interface tNodes_RefElem () Arguments None","tags":"","loc":"interface/operator( .nne. ).html"},{"title":"Orthocenter – Fortran Program","text":"public interface Orthocenter Contents Module Procedures triangle_orthocenter Module Procedures private interface triangle_orthocenter () Arguments None","tags":"","loc":"interface/orthocenter.html"},{"title":"Prism_quality – Fortran Program","text":"interface private function Prism_quality(refelem, xij, measure) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferencePrism_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) integer(kind=I4B), intent(in) :: measure Return Value real(kind=DFP)","tags":"","loc":"interface/prism_quality.html"},{"title":"Pyramid_quality – Fortran Program","text":"interface private function Pyramid_quality(refelem, xij, measure) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferencePyramid_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) integer(kind=I4B), intent(in) :: measure Return Value real(kind=DFP)","tags":"","loc":"interface/pyramid_quality.html"},{"title":"Quadrangle_quality – Fortran Program","text":"interface private function Quadrangle_quality(refelem, xij, measure) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceQuadrangle_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) integer(kind=I4B), intent(in) :: measure Return Value real(kind=DFP)","tags":"","loc":"interface/quadrangle_quality.html"},{"title":"RandomPoint – Fortran Program","text":"public interface RandomPoint Contents Module Procedures triangle_random_point Module Procedures private interface triangle_random_point () Arguments None","tags":"","loc":"interface/randompoint.html"},{"title":"ReferenceHexahedron – Fortran Program","text":"public interface ReferenceHexahedron Contents Module Procedures reference_Hexahedron Module Procedures private interface reference_Hexahedron () Arguments None","tags":"","loc":"interface/referencehexahedron.html"},{"title":"ReferenceHexahedron_Pointer – Fortran Program","text":"public interface ReferenceHexahedron_Pointer Contents Module Procedures reference_Hexahedron_Pointer Module Procedures private pure function reference_Hexahedron_Pointer (NSD, XiJ) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:) Return Value class(ReferenceHexahedron_),\n  POINTER","tags":"","loc":"interface/referencehexahedron_pointer.html"},{"title":"ReferenceLine – Fortran Program","text":"public interface ReferenceLine Contents Module Procedures reference_line Module Procedures private interface reference_line () Arguments None","tags":"","loc":"interface/referenceline.html"},{"title":"ReferenceLine_Pointer – Fortran Program","text":"public interface ReferenceLine_Pointer Contents Module Procedures reference_line_Pointer Module Procedures private pure function reference_Line_Pointer (NSD, XiJ) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:) Return Value class(ReferenceLine_),\n  POINTER","tags":"","loc":"interface/referenceline_pointer.html"},{"title":"ReferencePrism – Fortran Program","text":"public interface ReferencePrism Contents Module Procedures reference_Prism Module Procedures private interface reference_Prism () Arguments None","tags":"","loc":"interface/referenceprism.html"},{"title":"ReferencePrism_Pointer – Fortran Program","text":"public interface ReferencePrism_Pointer Contents Module Procedures reference_Prism_Pointer Module Procedures private pure function reference_Prism_Pointer (NSD, XiJ) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:) Return Value class(ReferencePrism_),\n  POINTER","tags":"","loc":"interface/referenceprism_pointer.html"},{"title":"ReferencePyramid – Fortran Program","text":"public interface ReferencePyramid Contents Module Procedures reference_Pyramid Module Procedures private interface reference_Pyramid () Arguments None","tags":"","loc":"interface/referencepyramid.html"},{"title":"ReferencePyramid_Pointer – Fortran Program","text":"public interface ReferencePyramid_Pointer Contents Module Procedures reference_Pyramid_Pointer Module Procedures private pure function reference_Pyramid_Pointer (NSD, XiJ) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:) Return Value class(ReferencePyramid_),\n  POINTER","tags":"","loc":"interface/referencepyramid_pointer.html"},{"title":"ReferenceQuadrangle – Fortran Program","text":"public interface ReferenceQuadrangle Contents Module Procedures reference_Quadrangle Module Procedures private interface reference_Quadrangle () Arguments None","tags":"","loc":"interface/referencequadrangle.html"},{"title":"ReferenceQuadrangle_Pointer – Fortran Program","text":"public interface ReferenceQuadrangle_Pointer Contents Module Procedures reference_Quadrangle_Pointer Module Procedures private pure function reference_Quadrangle_Pointer (NSD, XiJ) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:) Return Value class(ReferenceQuadrangle_),\n  POINTER","tags":"","loc":"interface/referencequadrangle_pointer.html"},{"title":"ReferenceTetrahedron – Fortran Program","text":"public interface ReferenceTetrahedron Contents Module Procedures reference_Tetrahedron Module Procedures private interface reference_Tetrahedron () Arguments None","tags":"","loc":"interface/referencetetrahedron.html"},{"title":"ReferenceTetrahedron_Pointer – Fortran Program","text":"public interface ReferenceTetrahedron_Pointer Contents Module Procedures reference_Tetrahedron_Pointer Module Procedures private pure function reference_Tetrahedron_Pointer (NSD, XiJ) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:) Return Value class(ReferenceTetrahedron_),\n  POINTER","tags":"","loc":"interface/referencetetrahedron_pointer.html"},{"title":"ReferenceTopology – Fortran Program","text":"public interface ReferenceTopology Contents Module Procedures reference_topology Module Procedures private interface reference_topology () Arguments None","tags":"","loc":"interface/referencetopology.html"},{"title":"ReferenceTriangle – Fortran Program","text":"public interface ReferenceTriangle Contents Module Procedures reference_Triangle Module Procedures private interface reference_Triangle () Arguments None","tags":"","loc":"interface/referencetriangle.html"},{"title":"ReferenceTriangle_Pointer – Fortran Program","text":"public interface ReferenceTriangle_Pointer Contents Module Procedures reference_Triangle_Pointer Module Procedures private pure function reference_Triangle_Pointer (NSD, XiJ) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:) Return Value class(ReferenceTriangle_),\n  POINTER","tags":"","loc":"interface/referencetriangle_pointer.html"},{"title":"TotalNodesInElement – Fortran Program","text":"public interface TotalNodesInElement Contents Module Procedures Total_Nodes_In_Element Module Procedures private interface Total_Nodes_In_Element () Arguments None","tags":"","loc":"interface/totalnodesinelement.html"},{"title":"Total_Nodes_In_Element – Fortran Program","text":"interface private pure function Total_Nodes_In_Element(ElemType) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ElemType Return Value integer(kind=I4B)","tags":"","loc":"interface/total_nodes_in_element.html"},{"title":"XiDimension – Fortran Program","text":"public interface XiDimension Contents Module Procedures Elem_XiDimension Module Procedures private interface Elem_XiDimension () Arguments None","tags":"","loc":"interface/xidimension.html"},{"title":"contains_point – Fortran Program","text":"interface private function contains_point(refelem, xij, x) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceElement_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) real(kind=DFP), intent(in) :: x (:) Return Value logical(kind=LGT)","tags":"","loc":"interface/contains_point.html"},{"title":"deallocatedata_ref_elem – Fortran Program","text":"interface private subroutine deallocatedata_ref_elem(Obj) Arguments Type Intent Optional Attributes Name class(ReferenceElement_), intent(inout) :: Obj","tags":"","loc":"interface/deallocatedata_ref_elem.html"},{"title":"deallocatedata_ref_topology – Fortran Program","text":"interface private subroutine deallocatedata_ref_topology(Obj) Arguments Type Intent Optional Attributes Name class(ReferenceTopology_), intent(inout) :: Obj","tags":"","loc":"interface/deallocatedata_ref_topology.html"},{"title":"diameter – Fortran Program","text":"public interface diameter Contents Module Procedures triangle_diameter Module Procedures private interface triangle_diameter () Arguments None","tags":"","loc":"interface/diameter.html"},{"title":"display_ref_elem – Fortran Program","text":"interface private subroutine display_ref_elem(Obj, msg, unitno) Arguments Type Intent Optional Attributes Name class(ReferenceElement_), intent(in) :: Obj character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitno","tags":"","loc":"interface/display_ref_elem.html"},{"title":"display_ref_topo – Fortran Program","text":"interface private subroutine display_ref_topo(Obj, msg, unitno) Arguments Type Intent Optional Attributes Name class(ReferenceTopology_), intent(in) :: Obj character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitno","tags":"","loc":"interface/display_ref_topo.html"},{"title":"getVTKelementType – Fortran Program","text":"public interface getVTKelementType Contents Module Procedures get_vtk_elemType Module Procedures private interface get_vtk_elemType () Arguments None","tags":"","loc":"interface/getvtkelementtype.html"},{"title":"get_vtk_elemType – Fortran Program","text":"interface private subroutine get_vtk_elemType(ElemType, vtk_type, nptrs) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ElemType integer(kind=Int8), intent(out) :: vtk_type integer(kind=I4B), intent(inout), ALLOCATABLE :: nptrs (:)","tags":"","loc":"interface/get_vtk_elemtype.html"},{"title":"init_refelem – Fortran Program","text":"interface private subroutine init_refelem(Obj, AnotherObj) Arguments Type Intent Optional Attributes Name class(ReferenceElement_), intent(inout) :: Obj class(ReferenceElement_), intent(in) :: AnotherObj","tags":"","loc":"interface/init_refelem.html"},{"title":"initiate_ref_Hexahedron – Fortran Program","text":"interface private subroutine initiate_ref_Hexahedron(Obj, NSD, XiJ) Arguments Type Intent Optional Attributes Name class(ReferenceHexahedron_), intent(inout) :: Obj integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:)","tags":"","loc":"interface/initiate_ref_hexahedron.html"},{"title":"initiate_ref_Line – Fortran Program","text":"interface private subroutine initiate_ref_Line(Obj, NSD, XiJ) Arguments Type Intent Optional Attributes Name class(ReferenceLine_), intent(inout) :: Obj integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:)","tags":"","loc":"interface/initiate_ref_line.html"},{"title":"initiate_ref_Prism – Fortran Program","text":"interface private subroutine initiate_ref_Prism(Obj, NSD, XiJ) Arguments Type Intent Optional Attributes Name class(ReferencePrism_), intent(inout) :: Obj integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:)","tags":"","loc":"interface/initiate_ref_prism.html"},{"title":"initiate_ref_Pyramid – Fortran Program","text":"interface private subroutine initiate_ref_Pyramid(Obj, NSD, XiJ) Arguments Type Intent Optional Attributes Name class(ReferencePyramid_), intent(inout) :: Obj integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:)","tags":"","loc":"interface/initiate_ref_pyramid.html"},{"title":"initiate_ref_Quadrangle – Fortran Program","text":"interface private subroutine initiate_ref_Quadrangle(Obj, NSD, XiJ) Arguments Type Intent Optional Attributes Name class(ReferenceQuadrangle_), intent(inout) :: Obj integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:)","tags":"","loc":"interface/initiate_ref_quadrangle.html"},{"title":"initiate_ref_Tetrahedron – Fortran Program","text":"interface private subroutine initiate_ref_Tetrahedron(Obj, NSD, XiJ) Arguments Type Intent Optional Attributes Name class(ReferenceTetrahedron_), intent(inout) :: Obj integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:)","tags":"","loc":"interface/initiate_ref_tetrahedron.html"},{"title":"initiate_ref_Triangle – Fortran Program","text":"interface private subroutine initiate_ref_Triangle(Obj, NSD, XiJ) Arguments Type Intent Optional Attributes Name class(ReferenceTriangle_), intent(inout) :: Obj integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:)","tags":"","loc":"interface/initiate_ref_triangle.html"},{"title":"isHexahedron – Fortran Program","text":"interface public pure function isHexahedron(ElemType) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ElemType Return Value logical(kind=LGT)","tags":"","loc":"interface/ishexahedron.html"},{"title":"isLine – Fortran Program","text":"interface public pure function isLine(ElemType) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ElemType Return Value logical(kind=LGT)","tags":"","loc":"interface/isline.html"},{"title":"isPoint – Fortran Program","text":"interface public pure function isPoint(ElemType) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ElemType Return Value logical(kind=LGT)","tags":"","loc":"interface/ispoint.html"},{"title":"isPrism – Fortran Program","text":"interface public pure function isPrism(ElemType) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ElemType Return Value logical(kind=LGT)","tags":"","loc":"interface/isprism.html"},{"title":"isPyramid – Fortran Program","text":"interface public pure function isPyramid(ElemType) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ElemType Return Value logical(kind=LGT)","tags":"","loc":"interface/ispyramid.html"},{"title":"isQuadrangle – Fortran Program","text":"interface public pure function isQuadrangle(ElemType) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ElemType Return Value logical(kind=LGT)","tags":"","loc":"interface/isquadrangle.html"},{"title":"isSerendipityElement – Fortran Program","text":"interface public pure function isSerendipityElement(ElemType) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ElemType Return Value logical(kind=LGT)","tags":"","loc":"interface/isserendipityelement.html"},{"title":"isSurface – Fortran Program","text":"interface public pure function isSurface(ElemType) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ElemType Return Value logical(kind=LGT)","tags":"","loc":"interface/issurface.html"},{"title":"isTetrahedron – Fortran Program","text":"interface public pure function isTetrahedron(ElemType) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ElemType Return Value logical(kind=LGT)","tags":"","loc":"interface/istetrahedron.html"},{"title":"isTriangle – Fortran Program","text":"interface public pure function isTriangle(ElemType) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ElemType Return Value logical(kind=LGT)","tags":"","loc":"interface/istriangle.html"},{"title":"isVolume – Fortran Program","text":"interface public pure function isVolume(ElemType) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ElemType Return Value logical(kind=LGT)","tags":"","loc":"interface/isvolume.html"},{"title":"line_quality – Fortran Program","text":"interface private function line_quality(refelem, xij, measure) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceLine_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) integer(kind=I4B), intent(in) :: measure Return Value real(kind=DFP)","tags":"","loc":"interface/line_quality.html"},{"title":"reference_Hexahedron – Fortran Program","text":"interface private pure function reference_Hexahedron(NSD, XiJ) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:) Return Value type(ReferenceHexahedron_)","tags":"","loc":"interface/reference_hexahedron.html"},{"title":"reference_Prism – Fortran Program","text":"interface private pure function reference_Prism(NSD, XiJ) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:) Return Value type(ReferencePrism_)","tags":"","loc":"interface/reference_prism.html"},{"title":"reference_Pyramid – Fortran Program","text":"interface private pure function reference_Pyramid(NSD, XiJ) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:) Return Value type(ReferencePyramid_)","tags":"","loc":"interface/reference_pyramid.html"},{"title":"reference_Quadrangle – Fortran Program","text":"interface private pure function reference_Quadrangle(NSD, XiJ) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:) Return Value type(ReferenceQuadrangle_)","tags":"","loc":"interface/reference_quadrangle.html"},{"title":"reference_Tetrahedron – Fortran Program","text":"interface private pure function reference_Tetrahedron(NSD, XiJ) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:) Return Value type(ReferenceTetrahedron_)","tags":"","loc":"interface/reference_tetrahedron.html"},{"title":"reference_Triangle – Fortran Program","text":"interface private pure function reference_Triangle(NSD, XiJ) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:) Return Value type(ReferenceTriangle_)","tags":"","loc":"interface/reference_triangle.html"},{"title":"reference_line – Fortran Program","text":"interface private pure function reference_line(NSD, XiJ) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:) Return Value type(ReferenceLine_)","tags":"","loc":"interface/reference_line.html"},{"title":"reference_topology – Fortran Program","text":"interface private pure function reference_topology(Nptrs, Name) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Nptrs (:) integer(kind=I4B), intent(in) :: Name Return Value type(ReferenceTopology_)","tags":"","loc":"interface/reference_topology.html"},{"title":"tNodes_RefElem – Fortran Program","text":"interface private pure function tNodes_RefElem(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceElement_), intent(in) :: Obj Return Value integer(kind=I4B)","tags":"","loc":"interface/tnodes_refelem.html"},{"title":"tNodes_RefTopo – Fortran Program","text":"interface private pure function tNodes_RefTopo(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceTopology_), intent(in) :: Obj Return Value integer(kind=I4B)","tags":"","loc":"interface/tnodes_reftopo.html"},{"title":"tetrahedron_quality – Fortran Program","text":"interface private function tetrahedron_quality(refelem, xij, measure) result(Ans) Arguments Type Intent Optional Attributes Name class(Referencetetrahedron_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) integer(kind=I4B), intent(in) :: measure Return Value real(kind=DFP)","tags":"","loc":"interface/tetrahedron_quality.html"},{"title":"triangle_angles – Fortran Program","text":"interface private function triangle_angles(refelem, xij) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceTriangle_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) Return Value real(kind=DFP)\n  (3)","tags":"","loc":"interface/triangle_angles.html"},{"title":"triangle_area – Fortran Program","text":"interface private function triangle_area(refelem, xij) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceTriangle_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) Return Value real(kind=DFP)","tags":"","loc":"interface/triangle_area.html"},{"title":"triangle_areaVector – Fortran Program","text":"interface private function triangle_areaVector(refelem, xij) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceTriangle_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) Return Value real(kind=DFP)\n  (3)","tags":"","loc":"interface/triangle_areavector.html"},{"title":"triangle_barycentric – Fortran Program","text":"interface private function triangle_barycentric(refelem, xij, x) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceTriangle_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) real(kind=DFP), intent(in) :: x (:) Return Value real(kind=DFP)\n  (3)","tags":"","loc":"interface/triangle_barycentric.html"},{"title":"triangle_centroid – Fortran Program","text":"interface private function triangle_centroid(refelem, xij) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceTriangle_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) Return Value real(kind=DFP)\n  (3)","tags":"","loc":"interface/triangle_centroid.html"},{"title":"triangle_circumcentre – Fortran Program","text":"interface private function triangle_circumcentre(refelem, xij) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceTriangle_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) Return Value real(kind=DFP)\n  (3)","tags":"","loc":"interface/triangle_circumcentre.html"},{"title":"triangle_circumcircle – Fortran Program","text":"interface private function triangle_circumcircle(refelem, xij) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceTriangle_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) Return Value real(kind=DFP)\n  (4) Ans(1) = radius and Ans(2:4) center","tags":"","loc":"interface/triangle_circumcircle.html"},{"title":"triangle_circumradius – Fortran Program","text":"interface private function triangle_circumradius(refelem, xij) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceTriangle_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) Return Value real(kind=DFP)","tags":"","loc":"interface/triangle_circumradius.html"},{"title":"triangle_contains_line – Fortran Program","text":"interface private subroutine triangle_contains_line(refelem, xij, x1, x2, parametricLine, inside, xint) Arguments Type Intent Optional Attributes Name class(ReferenceTriangle_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) real(kind=DFP), intent(in) :: x1 (3) real(kind=DFP), intent(in) :: x2 (3) logical(kind=LGT), intent(in) :: parametricLine logical(kind=LGT), intent(out) :: inside real(kind=DFP), intent(out) :: xint (3)","tags":"","loc":"interface/triangle_contains_line.html"},{"title":"triangle_contains_point – Fortran Program","text":"interface private function triangle_contains_point(refelem, xij, x) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceTriangle_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) real(kind=DFP), intent(in) :: x (:) Return Value logical(kind=LGT)","tags":"","loc":"interface/triangle_contains_point.html"},{"title":"triangle_diameter – Fortran Program","text":"interface private function triangle_diameter(refelem, xij) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceTriangle_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) Return Value real(kind=DFP)","tags":"","loc":"interface/triangle_diameter.html"},{"title":"triangle_edge_length – Fortran Program","text":"interface private function triangle_edge_length(refelem, xij) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceTriangle_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) Return Value real(kind=DFP)\n  (3)","tags":"","loc":"interface/triangle_edge_length.html"},{"title":"triangle_get_nearest_point – Fortran Program","text":"interface private subroutine triangle_get_nearest_point(refelem, xij, x, xn, dist) Arguments Type Intent Optional Attributes Name class(ReferenceTriangle_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) real(kind=DFP), intent(in) :: x (:) real(kind=DFP), intent(inout) :: xn (:) real(kind=DFP), intent(out) :: dist","tags":"","loc":"interface/triangle_get_nearest_point.html"},{"title":"triangle_incenter – Fortran Program","text":"interface private function triangle_incenter(refelem, xij) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceTriangle_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) Return Value real(kind=DFP)\n  (3)","tags":"","loc":"interface/triangle_incenter.html"},{"title":"triangle_incircle – Fortran Program","text":"interface private function triangle_incircle(refelem, xij) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceTriangle_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) Return Value real(kind=DFP)\n  (4)","tags":"","loc":"interface/triangle_incircle.html"},{"title":"triangle_inradius – Fortran Program","text":"interface private function triangle_inradius(refelem, xij) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceTriangle_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) Return Value real(kind=DFP)","tags":"","loc":"interface/triangle_inradius.html"},{"title":"triangle_orthocenter – Fortran Program","text":"interface private function triangle_orthocenter(refelem, xij) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceTriangle_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) Return Value real(kind=DFP)\n  (3)","tags":"","loc":"interface/triangle_orthocenter.html"},{"title":"triangle_point_dist – Fortran Program","text":"interface private function triangle_point_dist(refelem, xij, x) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceTriangle_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) real(kind=DFP), intent(in) :: x (:) Return Value real(kind=DFP)","tags":"","loc":"interface/triangle_point_dist.html"},{"title":"triangle_quality – Fortran Program","text":"interface private function triangle_quality(refelem, xij, measure) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceTriangle_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) integer(kind=I4B), intent(in) :: measure Return Value real(kind=DFP)","tags":"","loc":"interface/triangle_quality.html"},{"title":"triangle_random_point – Fortran Program","text":"interface private function triangle_random_point(refelem, xij, n, seed) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceTriangle_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) integer(kind=I4B) :: n integer(kind=I4B) :: seed Return Value real(kind=DFP)\n  (3,n)","tags":"","loc":"interface/triangle_random_point.html"},{"title":"ASSIGNMENT( = ) – Fortran Program","text":"public interface ASSIGNMENT( = ) Contents Module Procedures rank2_equal_mat mat_equal_rank2 Module Procedures private interface rank2_equal_mat () Arguments None private interface mat_equal_rank2 () Arguments None","tags":"","loc":"interface/assignment( = )~6.html"},{"title":"AXPY – Fortran Program","text":"public interface AXPY Contents Module Procedures axpy_a1_a2 Module Procedures private interface axpy_a1_a2 () Arguments None","tags":"","loc":"interface/axpy~2.html"},{"title":"Contraction – Fortran Program","text":"public interface Contraction Contents Module Procedures r2_contract_r2 r2_contract_voigt_r2 voigt_r2_contract_r2 voigt_r2_contract_voigt_r2 Module Procedures private interface r2_contract_r2 () Arguments None private interface r2_contract_voigt_r2 () Arguments None private interface voigt_r2_contract_r2 () Arguments None private interface voigt_r2_contract_voigt_r2 () Arguments None","tags":"","loc":"interface/contraction.html"},{"title":"Convert – Fortran Program","text":"public interface Convert Contents Module Procedures mat_to_rank2 rank2_to_mat Module Procedures private interface mat_to_rank2 () Arguments None private interface rank2_to_mat () Arguments None","tags":"","loc":"interface/convert~2.html"},{"title":"Det – Fortran Program","text":"public interface Det Contents Module Procedures Det_obj Module Procedures private interface det_obj () Arguments None","tags":"","loc":"interface/det~2.html"},{"title":"Deviatoric – Fortran Program","text":"public interface Deviatoric Contents Module Procedures dev_part_obj Module Procedures private interface dev_part_obj () Arguments None","tags":"","loc":"interface/deviatoric.html"},{"title":"Display – Fortran Program","text":"public interface Display Contents Module Procedures display_obj Module Procedures private interface display_obj () Arguments None","tags":"","loc":"interface/display~24.html"},{"title":"Eigen – Fortran Program","text":"public interface Eigen Contents Module Procedures spectral_r2t Module Procedures private interface spectral_r2t () Arguments None","tags":"","loc":"interface/eigen.html"},{"title":"IdentityTensor – Fortran Program","text":"public interface IdentityTensor Contents Module Procedures identity_rank2 Module Procedures private interface identity_rank2 () Arguments None","tags":"","loc":"interface/identitytensor.html"},{"title":"Initiate – Fortran Program","text":"public interface Initiate Contents Module Procedures init_by_mat init_by_vec Module Procedures private interface init_by_mat () Arguments None private interface init_by_vec () Arguments None","tags":"","loc":"interface/initiate~25.html"},{"title":"Invariants – Fortran Program","text":"public interface Invariants Contents Module Procedures invariants_rank2 Module Procedures private interface invariants_rank2 () Arguments None","tags":"","loc":"interface/invariants.html"},{"title":"Isotropic – Fortran Program","text":"public interface Isotropic Contents Module Procedures iso_part_obj Module Procedures private interface iso_part_obj () Arguments None","tags":"","loc":"interface/isotropic.html"},{"title":"IsotropicTensor – Fortran Program","text":"public interface IsotropicTensor Contents Module Procedures isotropic_rank2 Module Procedures private interface isotropic_rank2 () Arguments None","tags":"","loc":"interface/isotropictensor.html"},{"title":"J2 – Fortran Program","text":"public interface J2 Contents Module Procedures j2_obj Module Procedures private interface j2_obj () Arguments None","tags":"","loc":"interface/j2.html"},{"title":"J3 – Fortran Program","text":"public interface J3 Contents Module Procedures j3_obj Module Procedures private interface j3_obj () Arguments None","tags":"","loc":"interface/j3.html"},{"title":"LeftPolarDecomp – Fortran Program","text":"public interface LeftPolarDecomp Contents Module Procedures right_pd_r2t Module Procedures private interface right_pd_r2t () Arguments None","tags":"","loc":"interface/leftpolardecomp.html"},{"title":"LodeAngle – Fortran Program","text":"public interface LodeAngle Contents Module Procedures theta_obj theta_obj_j2j3 Module Procedures private interface theta_obj () Arguments None private interface theta_obj_j2j3 () Arguments None","tags":"","loc":"interface/lodeangle.html"},{"title":"OPERATOR( + ) – Fortran Program","text":"public interface OPERATOR( + ) Contents Module Procedures obj_add_obj obj_add_mat mat_add_obj obj_add_scalar scalar_add_obj Module Procedures private interface obj_add_obj () Arguments None private interface obj_add_mat () Arguments None private interface mat_add_obj () Arguments None private interface obj_add_scalar () Arguments None private interface scalar_add_obj () Arguments None","tags":"","loc":"interface/operator( + ).html"},{"title":"OPERATOR( - ) – Fortran Program","text":"public interface OPERATOR( - ) Contents Module Procedures obj_minus_obj obj_minus_mat mat_minus_obj obj_minus_scalar scalar_minus_obj Module Procedures private interface obj_minus_obj () Arguments None private interface obj_minus_mat () Arguments None private interface mat_minus_obj () Arguments None private interface obj_minus_scalar () Arguments None private interface scalar_minus_obj () Arguments None","tags":"","loc":"interface/operator( - ).html"},{"title":"Ones – Fortran Program","text":"public interface Ones Contents Module Procedures Ones_rank2 Module Procedures private interface Ones_rank2 () Arguments None","tags":"","loc":"interface/ones.html"},{"title":"Ones_rank2 – Fortran Program","text":"interface private subroutine Ones_rank2(Obj) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(inout) :: Obj","tags":"","loc":"interface/ones_rank2.html"},{"title":"Rank2Tensor – Fortran Program","text":"public interface Rank2Tensor Contents Module Procedures r2t_by_mat r2t_by_voigtvec Module Procedures private interface r2t_by_mat () Arguments None private interface r2t_by_voigtvec () Arguments None","tags":"","loc":"interface/rank2tensor.html"},{"title":"Rank2Tensor_Pointer – Fortran Program","text":"public interface Rank2Tensor_Pointer Contents Module Procedures r2tp_by_mat r2tp_by_voigtvec Module Procedures private interface r2tp_by_mat () Arguments None private interface r2tp_by_voigtvec () Arguments None","tags":"","loc":"interface/rank2tensor_pointer.html"},{"title":"RightPolarDecomp – Fortran Program","text":"public interface RightPolarDecomp Contents Module Procedures right_pd_r2t Module Procedures private interface right_pd_r2t () Arguments None","tags":"","loc":"interface/rightpolardecomp.html"},{"title":"SkewSym – Fortran Program","text":"public interface SkewSym Contents Module Procedures Skewsym_r2t Module Procedures private interface Skewsym_r2t () Arguments None","tags":"","loc":"interface/skewsym.html"},{"title":"Skewsym_r2t – Fortran Program","text":"interface private pure function Skewsym_r2t(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: Obj Return Value type(Rank2Tensor_)","tags":"","loc":"interface/skewsym_r2t.html"},{"title":"Sym – Fortran Program","text":"public interface Sym Contents Module Procedures sym_r2t Module Procedures private interface sym_r2t () Arguments None","tags":"","loc":"interface/sym.html"},{"title":"SymEigen – Fortran Program","text":"public interface SymEigen Contents Module Procedures sym_spectral_r2t Module Procedures private interface sym_spectral_r2t () Arguments None","tags":"","loc":"interface/symeigen.html"},{"title":"Trace – Fortran Program","text":"public interface Trace Contents Module Procedures trace_obj Module Procedures private interface trace_obj () Arguments None","tags":"","loc":"interface/trace.html"},{"title":"Zeros – Fortran Program","text":"public interface Zeros Contents Module Procedures Zeros_rank2 Module Procedures private interface Zeros_rank2 () Arguments None","tags":"","loc":"interface/zeros.html"},{"title":"Zeros_rank2 – Fortran Program","text":"interface private subroutine Zeros_rank2(Obj) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(inout) :: Obj","tags":"","loc":"interface/zeros_rank2.html"},{"title":"axpy_a1_a2 – Fortran Program","text":"interface private subroutine axpy_a1_a2(a1, Obj1, a2, Obj2) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a1 class(Rank2Tensor_), intent(inout) :: Obj1 real(kind=DFP), intent(in) :: a2 class(Rank2Tensor_), intent(in) :: Obj2","tags":"","loc":"interface/axpy_a1_a2.html"},{"title":"det_obj – Fortran Program","text":"interface private pure function det_obj(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: Obj Return Value real(kind=DFP)","tags":"","loc":"interface/det_obj.html"},{"title":"dev_part_obj – Fortran Program","text":"interface private pure function dev_part_obj(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: Obj Return Value type(Rank2Tensor_)","tags":"","loc":"interface/dev_part_obj.html"},{"title":"display_obj – Fortran Program","text":"interface private subroutine display_obj(Obj, Msg, UnitNo) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: Obj character(len=*), intent(in) :: Msg integer(kind=I4B), intent(in), optional :: UnitNo","tags":"","loc":"interface/display_obj~4.html"},{"title":"identity_rank2 – Fortran Program","text":"interface private subroutine identity_rank2(Obj) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(inout) :: Obj","tags":"","loc":"interface/identity_rank2.html"},{"title":"init_by_mat – Fortran Program","text":"interface private subroutine init_by_mat(Obj, Mat) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Mat (3,3)","tags":"","loc":"interface/init_by_mat.html"},{"title":"init_by_vec – Fortran Program","text":"interface private subroutine init_by_vec(Obj, Vec, VoigtType) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Vec (:) integer(kind=I4B), intent(in) :: VoigtType","tags":"","loc":"interface/init_by_vec.html"},{"title":"invariants_rank2 – Fortran Program","text":"interface private pure function invariants_rank2(Obj, isDeviatoric) result(Ans) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: Obj logical(kind=LGT), intent(in) :: isDeviatoric Return Value real(kind=DFP)\n  (3)","tags":"","loc":"interface/invariants_rank2.html"},{"title":"iso_part_obj – Fortran Program","text":"interface private pure function iso_part_obj(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: Obj Return Value type(Rank2Tensor_)","tags":"","loc":"interface/iso_part_obj.html"},{"title":"isotropic_rank2 – Fortran Program","text":"interface private subroutine isotropic_rank2(Obj, Lambda) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Lambda","tags":"","loc":"interface/isotropic_rank2.html"},{"title":"j2_obj – Fortran Program","text":"interface private pure function j2_obj(Obj, isDeviatoric) result(Ans) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: Obj logical(kind=LGT), intent(in) :: isDeviatoric Return Value real(kind=DFP)","tags":"","loc":"interface/j2_obj.html"},{"title":"j3_obj – Fortran Program","text":"interface private pure function j3_obj(Obj, isDeviatoric) result(Ans) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: Obj logical(kind=LGT), intent(in) :: isDeviatoric Return Value real(kind=DFP)","tags":"","loc":"interface/j3_obj.html"},{"title":"left_pd_r2t – Fortran Program","text":"interface private subroutine left_pd_r2t(Obj, V, R) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: Obj class(Rank2Tensor_), intent(inout) :: V class(Rank2Tensor_), intent(inout) :: R","tags":"","loc":"interface/left_pd_r2t.html"},{"title":"mat_add_obj – Fortran Program","text":"interface private pure function mat_add_obj(Obj1, Obj2) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Obj1 (3,3) class(Rank2Tensor_), intent(in) :: Obj2 Return Value type(Rank2Tensor_)","tags":"","loc":"interface/mat_add_obj.html"},{"title":"mat_equal_rank2 – Fortran Program","text":"interface private subroutine mat_equal_rank2(Mat, Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout) :: Mat (3,3) class(Rank2Tensor_), intent(in) :: Obj","tags":"","loc":"interface/mat_equal_rank2.html"},{"title":"mat_minus_obj – Fortran Program","text":"interface private pure function mat_minus_obj(Obj1, Obj2) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Obj1 (3,3) class(Rank2Tensor_), intent(in) :: Obj2 Return Value type(Rank2Tensor_)","tags":"","loc":"interface/mat_minus_obj.html"},{"title":"mat_to_rank2 – Fortran Program","text":"interface private subroutine mat_to_rank2(From, To) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: From (3,3) class(Rank2Tensor_), intent(inout) :: To","tags":"","loc":"interface/mat_to_rank2.html"},{"title":"obj_add_mat – Fortran Program","text":"interface private pure function obj_add_mat(Obj1, Obj2) result(Ans) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: Obj1 real(kind=DFP), intent(in) :: Obj2 (3,3) Return Value type(Rank2Tensor_)","tags":"","loc":"interface/obj_add_mat.html"},{"title":"obj_add_obj – Fortran Program","text":"interface private pure function obj_add_obj(Obj1, Obj2) result(Ans) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: Obj1 class(Rank2Tensor_), intent(in) :: Obj2 Return Value type(Rank2Tensor_)","tags":"","loc":"interface/obj_add_obj.html"},{"title":"obj_add_scalar – Fortran Program","text":"interface private pure function obj_add_scalar(Obj1, Obj2) result(Ans) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: Obj1 real(kind=DFP), intent(in) :: Obj2 Return Value type(Rank2Tensor_)","tags":"","loc":"interface/obj_add_scalar.html"},{"title":"obj_minus_mat – Fortran Program","text":"interface private pure function obj_minus_mat(Obj1, Obj2) result(Ans) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: Obj1 real(kind=DFP), intent(in) :: Obj2 (3,3) Return Value type(Rank2Tensor_)","tags":"","loc":"interface/obj_minus_mat.html"},{"title":"obj_minus_obj – Fortran Program","text":"interface private pure function obj_minus_obj(Obj1, Obj2) result(Ans) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: Obj1 class(Rank2Tensor_), intent(in) :: Obj2 Return Value type(Rank2Tensor_)","tags":"","loc":"interface/obj_minus_obj.html"},{"title":"obj_minus_scalar – Fortran Program","text":"interface private pure function obj_minus_scalar(Obj1, Obj2) result(Ans) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: Obj1 real(kind=DFP), intent(in) :: Obj2 Return Value type(Rank2Tensor_)","tags":"","loc":"interface/obj_minus_scalar.html"},{"title":"r2_contract_r2 – Fortran Program","text":"interface private pure function r2_contract_r2(Obj1, Obj2) result(Ans) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: Obj1 class(Rank2Tensor_), intent(in) :: Obj2 Return Value real(kind=DFP)","tags":"","loc":"interface/r2_contract_r2.html"},{"title":"r2_contract_voigt_r2 – Fortran Program","text":"interface private pure function r2_contract_voigt_r2(Obj1, Obj2) result(Ans) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: Obj1 class(VoigtRank2Tensor_), intent(in) :: Obj2 Return Value real(kind=DFP)","tags":"","loc":"interface/r2_contract_voigt_r2.html"},{"title":"r2t_by_mat – Fortran Program","text":"interface private pure function r2t_by_mat(Mat) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Mat (3,3) Return Value type(Rank2Tensor_)","tags":"","loc":"interface/r2t_by_mat.html"},{"title":"r2t_by_voigtvec – Fortran Program","text":"interface private pure function r2t_by_voigtvec(VoigtVec, VoigtType) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: VoigtVec (:) integer(kind=I4B), intent(in) :: VoigtType Return Value type(Rank2Tensor_)","tags":"","loc":"interface/r2t_by_voigtvec.html"},{"title":"r2tp_by_mat – Fortran Program","text":"interface private pure function r2tp_by_mat(Mat) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Mat (3,3) Return Value class(Rank2Tensor_),\n  POINTER","tags":"","loc":"interface/r2tp_by_mat.html"},{"title":"r2tp_by_voigtvec – Fortran Program","text":"interface private pure function r2tp_by_voigtvec(VoigtVec, VoigtType) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: VoigtVec (:) integer(kind=I4B), intent(in) :: VoigtType Return Value class(Rank2Tensor_),\n  POINTER","tags":"","loc":"interface/r2tp_by_voigtvec.html"},{"title":"rank2_equal_mat – Fortran Program","text":"interface private subroutine rank2_equal_mat(Obj, Mat) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Mat (3,3)","tags":"","loc":"interface/rank2_equal_mat.html"},{"title":"rank2_to_mat – Fortran Program","text":"interface private subroutine rank2_to_mat(From, To) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: From real(kind=DFP), intent(inout) :: To (3,3)","tags":"","loc":"interface/rank2_to_mat.html"},{"title":"right_pd_r2t – Fortran Program","text":"interface private subroutine right_pd_r2t(Obj, R, U) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: Obj class(Rank2Tensor_), intent(inout) :: R class(Rank2Tensor_), intent(inout) :: U","tags":"","loc":"interface/right_pd_r2t.html"},{"title":"scalar_add_obj – Fortran Program","text":"interface private pure function scalar_add_obj(Obj1, Obj2) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Obj1 class(Rank2Tensor_), intent(in) :: Obj2 Return Value type(Rank2Tensor_)","tags":"","loc":"interface/scalar_add_obj.html"},{"title":"scalar_minus_obj – Fortran Program","text":"interface private pure function scalar_minus_obj(Obj1, Obj2) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Obj1 class(Rank2Tensor_), intent(in) :: Obj2 Return Value type(Rank2Tensor_)","tags":"","loc":"interface/scalar_minus_obj.html"},{"title":"spectral_r2t – Fortran Program","text":"interface private subroutine spectral_r2t(Obj, Q, W) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: Obj complex(kind=DFP), intent(inout) :: Q (3,3) complex(kind=DFP), intent(inout) :: W (3)","tags":"","loc":"interface/spectral_r2t.html"},{"title":"sym_r2t – Fortran Program","text":"interface private pure function sym_r2t(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: Obj Return Value type(Rank2Tensor_)","tags":"","loc":"interface/sym_r2t.html"},{"title":"sym_spectral_r2t – Fortran Program","text":"interface private subroutine sym_spectral_r2t(Obj, Q, W) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: Obj real(kind=DFP), intent(inout) :: Q (3,3) real(kind=DFP), intent(inout) :: W (3)","tags":"","loc":"interface/sym_spectral_r2t.html"},{"title":"theta_obj – Fortran Program","text":"interface private pure function theta_obj(Obj, LodeType, isDeviatoric) result(Ans) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: Obj integer(kind=I4B), intent(in) :: LodeType logical(kind=LGT), intent(in) :: isDeviatoric Return Value real(kind=DFP)","tags":"","loc":"interface/theta_obj.html"},{"title":"theta_obj_j2j3 – Fortran Program","text":"interface private pure function theta_obj_j2j3(Obj, LodeType, J2J3) result(Ans) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: Obj integer(kind=I4B), intent(in) :: LodeType real(kind=DFP), intent(in), optional :: J2J3 (2) Return Value real(kind=DFP)","tags":"","loc":"interface/theta_obj_j2j3.html"},{"title":"trace_obj – Fortran Program","text":"interface private pure function trace_obj(Obj, Power) result(Ans) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: Obj integer(kind=I4B), intent(in) :: Power Return Value real(kind=DFP)","tags":"","loc":"interface/trace_obj.html"},{"title":"voigt_r2_contract_r2 – Fortran Program","text":"interface private pure function voigt_r2_contract_r2(Obj1, Obj2) result(Ans) Arguments Type Intent Optional Attributes Name class(VoigtRank2Tensor_), intent(in) :: Obj1 class(Rank2Tensor_), intent(in) :: Obj2 Return Value real(kind=DFP)","tags":"","loc":"interface/voigt_r2_contract_r2.html"},{"title":"voigt_r2_contract_voigt_r2 – Fortran Program","text":"interface private pure function voigt_r2_contract_voigt_r2(Obj1, Obj2) result(Ans) Arguments Type Intent Optional Attributes Name class(VoigtRank2Tensor_), intent(in) :: Obj1 class(VoigtRank2Tensor_), intent(in) :: Obj2 Return Value real(kind=DFP)","tags":"","loc":"interface/voigt_r2_contract_voigt_r2.html"},{"title":"Convert – Fortran Program","text":"public interface Convert Contents Module Procedures voigt_to_mat voigt_to_vec voigt_to_tensor tensor_to_voigt Module Procedures private interface voigt_to_mat () Arguments None private interface voigt_to_vec () Arguments None private interface voigt_to_tensor () Arguments None private interface tensor_to_voigt () Arguments None","tags":"","loc":"interface/convert~3.html"},{"title":"Display – Fortran Program","text":"public interface Display Contents Module Procedures display_obj Module Procedures private interface display_obj () Arguments None","tags":"","loc":"interface/display~25.html"},{"title":"Initiate – Fortran Program","text":"public interface Initiate Contents Module Procedures init_from_vec init_from_r2tensor init_from_mat Module Procedures private interface init_from_vec () Arguments None private interface init_from_r2tensor () Arguments None private interface init_from_mat () Arguments None","tags":"","loc":"interface/initiate~26.html"},{"title":"VoigtRank2Tensor – Fortran Program","text":"public interface VoigtRank2Tensor Contents Module Procedures constructor1 Module Procedures private interface constructor1 () Arguments None","tags":"","loc":"interface/voigtrank2tensor.html"},{"title":"VoigtRank2Tensor_Pointer – Fortran Program","text":"public interface VoigtRank2Tensor_Pointer Contents Module Procedures constructor_1 Module Procedures private interface constructor_1 () Arguments None","tags":"","loc":"interface/voigtrank2tensor_pointer.html"},{"title":"constructor1 – Fortran Program","text":"interface private pure function constructor1(Vec, VoigtType) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Vec (:) integer(kind=I4B), intent(in) :: VoigtType Return Value type(VoigtRank2Tensor_)","tags":"","loc":"interface/constructor1.html"},{"title":"constructor_1 – Fortran Program","text":"interface private pure function constructor_1(Vec, VoigtType) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Vec (:) integer(kind=I4B), intent(in) :: VoigtType Return Value class(VoigtRank2Tensor_),\n  POINTER","tags":"","loc":"interface/constructor_1.html"},{"title":"display_obj – Fortran Program","text":"interface private subroutine display_obj(Obj, Msg, UnitNo) Arguments Type Intent Optional Attributes Name class(VoigtRank2Tensor_), intent(in) :: Obj character(len=*), intent(in) :: Msg integer(kind=I4B), intent(in), optional :: UnitNo","tags":"","loc":"interface/display_obj~5.html"},{"title":"init_from_mat – Fortran Program","text":"interface private subroutine init_from_mat(Obj, T, VoigtType) Arguments Type Intent Optional Attributes Name class(VoigtRank2Tensor_), intent(inout) :: Obj real(kind=DFP), intent(in) :: T (3,3) integer(kind=I4B), intent(in) :: VoigtType","tags":"","loc":"interface/init_from_mat.html"},{"title":"init_from_r2tensor – Fortran Program","text":"interface private subroutine init_from_r2tensor(Obj, T, VoigtType) Arguments Type Intent Optional Attributes Name class(VoigtRank2Tensor_), intent(inout) :: Obj class(Rank2Tensor_), intent(in) :: T integer(kind=I4B), intent(in) :: VoigtType","tags":"","loc":"interface/init_from_r2tensor.html"},{"title":"init_from_vec – Fortran Program","text":"interface private subroutine init_from_vec(Obj, Vec, VoigtType) Arguments Type Intent Optional Attributes Name class(VoigtRank2Tensor_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Vec (:) integer(kind=I4B), intent(in) :: VoigtType","tags":"","loc":"interface/init_from_vec.html"},{"title":"tensor_to_voigt – Fortran Program","text":"interface private subroutine tensor_to_voigt(From, To, VoigtType) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: From class(VoigtRank2Tensor_), intent(inout) :: To integer(kind=I4B), intent(in) :: VoigtType","tags":"","loc":"interface/tensor_to_voigt.html"},{"title":"voigt_to_mat – Fortran Program","text":"interface private subroutine voigt_to_mat(From, To) Arguments Type Intent Optional Attributes Name class(VoigtRank2Tensor_), intent(in) :: From real(kind=DFP), intent(inout) :: To (3,3)","tags":"","loc":"interface/voigt_to_mat.html"},{"title":"voigt_to_tensor – Fortran Program","text":"interface private subroutine voigt_to_tensor(From, To) Arguments Type Intent Optional Attributes Name class(VoigtRank2Tensor_), intent(in) :: From class(Rank2Tensor_), intent(inout) :: To","tags":"","loc":"interface/voigt_to_tensor.html"},{"title":"voigt_to_vec – Fortran Program","text":"interface private subroutine voigt_to_vec(From, To) Arguments Type Intent Optional Attributes Name class(VoigtRank2Tensor_), intent(in) :: From real(kind=DFP), intent(inout) :: To (:)","tags":"","loc":"interface/voigt_to_vec.html"},{"title":"Initiate – Fortran Program","text":"public interface Initiate Contents Module Procedures initRandom Module Procedures private interface initRandom () Arguments None","tags":"","loc":"interface/initiate~27.html"},{"title":"RandomValue – Fortran Program","text":"public interface RandomValue Contents Module Procedures getRandom Module Procedures private interface getRandom () Arguments None","tags":"","loc":"interface/randomvalue.html"},{"title":"RandomValue – Fortran Program","text":"private interface RandomValue Contents Module Procedures uniformRandom Module Procedures public interface uniformRandom () Arguments None","tags":"","loc":"interface/randomvalue~2.html"},{"title":"RandomValue – Fortran Program","text":"private interface RandomValue Contents Module Procedures getRandomInteger Module Procedures private interface getRandomInteger () Arguments None","tags":"","loc":"interface/randomvalue~3.html"},{"title":"RandomValue – Fortran Program","text":"private interface RandomValue Contents Module Procedures select_random_int_from_vec select_random_int_from_array select_random_real_from_vec select_random_real_from_array Module Procedures private interface select_random_int_from_vec () Arguments None private interface select_random_int_from_array () Arguments None private interface select_random_real_from_vec () Arguments None private interface select_random_real_from_array () Arguments None","tags":"","loc":"interface/randomvalue~4.html"},{"title":"SaveRandom – Fortran Program","text":"interface public subroutine SaveRandom(Obj) Arguments Type Intent Optional Attributes Name class(Random_), intent(inout) :: Obj","tags":"","loc":"interface/saverandom.html"},{"title":"getRandom – Fortran Program","text":"interface private function getRandom(Obj, distribution) result(Ans) Arguments Type Intent Optional Attributes Name class(Random_), intent(in) :: Obj character(len=*), intent(in), optional :: distribution Return Value real(kind=DFP)","tags":"","loc":"interface/getrandom.html"},{"title":"getRandomInteger – Fortran Program","text":"interface private function getRandomInteger(Obj, From, To) result(Ans) Arguments Type Intent Optional Attributes Name class(Random_), intent(in) :: Obj integer(kind=I4B), intent(in) :: From integer(kind=I4B), intent(in) :: To Return Value integer(kind=I4B)","tags":"","loc":"interface/getrandominteger.html"},{"title":"initRandom – Fortran Program","text":"interface private subroutine initRandom(Obj) Arguments Type Intent Optional Attributes Name class(Random_), intent(inout) :: Obj","tags":"","loc":"interface/initrandom.html"},{"title":"select_random_int_from_array – Fortran Program","text":"interface private function select_random_int_from_array(Obj, Val) result(Ans) Arguments Type Intent Optional Attributes Name class(Random_), intent(in) :: Obj integer(kind=I4B), intent(in) :: Val (:,:) Return Value integer(kind=I4B)","tags":"","loc":"interface/select_random_int_from_array.html"},{"title":"select_random_int_from_vec – Fortran Program","text":"interface private function select_random_int_from_vec(Obj, Val) result(Ans) Arguments Type Intent Optional Attributes Name class(Random_), intent(in) :: Obj integer(kind=I4B), intent(in) :: Val (:) Return Value integer(kind=I4B)","tags":"","loc":"interface/select_random_int_from_vec.html"},{"title":"select_random_real_from_array – Fortran Program","text":"interface private function select_random_real_from_array(Obj, Val) result(Ans) Arguments Type Intent Optional Attributes Name class(Random_), intent(in) :: Obj real(kind=DFP), intent(in) :: Val (:,:) Return Value real(kind=DFP)","tags":"","loc":"interface/select_random_real_from_array.html"},{"title":"select_random_real_from_vec – Fortran Program","text":"interface private function select_random_real_from_vec(Obj, Val) result(Ans) Arguments Type Intent Optional Attributes Name class(Random_), intent(in) :: Obj real(kind=DFP), intent(in) :: Val (:) Return Value real(kind=DFP)","tags":"","loc":"interface/select_random_real_from_vec.html"},{"title":"uniformRandom – Fortran Program","text":"interface public function uniformRandom(Obj, From, To) result(Ans) Arguments Type Intent Optional Attributes Name class(Random_), intent(in) :: Obj real(kind=DFP), intent(in) :: From real(kind=DFP), intent(in) :: To Return Value real(kind=DFP)","tags":"","loc":"interface/uniformrandom.html"},{"title":"AllocateData – Fortran Program","text":"public interface AllocateData Contents Module Procedures Allocate_Data Module Procedures private interface Allocate_Data () Arguments None","tags":"","loc":"interface/allocatedata~2.html"},{"title":"Allocate_Data – Fortran Program","text":"interface private subroutine Allocate_Data(Obj, Dims) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Dims","tags":"","loc":"interface/allocate_data~2.html"},{"title":"Append – Fortran Program","text":"public interface Append Contents Module Procedures Append_1 Append_2 Append_3 Module Procedures private interface Append_1 () Arguments None private interface Append_2 () Arguments None private interface Append_3 () Arguments None","tags":"","loc":"interface/append~3.html"},{"title":"Append_1 – Fortran Program","text":"interface private subroutine Append_1(Obj, Value) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Value","tags":"","loc":"interface/append_1.html"},{"title":"Append_2 – Fortran Program","text":"interface private subroutine Append_2(Obj, Value) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Value (:)","tags":"","loc":"interface/append_2.html"},{"title":"Append_3 – Fortran Program","text":"interface private subroutine Append_3(Obj, AnotherObj) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(inout) :: Obj class( IntVector_ ), intent(in) :: AnotherObj","tags":"","loc":"interface/append_3.html"},{"title":"ArrayPointer – Fortran Program","text":"public interface ArrayPointer Contents Module Procedures f_getPointer_self f_getPointer_Int Module Procedures private interface f_getPointer_self () Arguments None private interface f_getPointer_Int () Arguments None","tags":"","loc":"interface/arraypointer.html"},{"title":"ArrayValues – Fortran Program","text":"public interface ArrayValues Contents Module Procedures f_getValues_self f_getSectionValues_self f_getValuesFromTriplet_self f_getARRAYValues_self f_getARRAYSectionValues_self f_getARRAYValuesFromTriplet_self Module Procedures private interface f_getValues_self () Arguments None private interface f_getSectionValues_self () Arguments None private interface f_getValuesFromTriplet_self () Arguments None private interface f_getARRAYValues_self () Arguments None private interface f_getARRAYSectionValues_self () Arguments None private interface f_getARRAYValuesFromTriplet_self () Arguments None","tags":"","loc":"interface/arrayvalues~3.html"},{"title":"ArrayValues – Fortran Program","text":"private interface ArrayValues Contents Module Procedures f_getValues_Int f_getSectionValues_Int f_getValuesFromTriplet_Int f_getARRAYValues_Int f_getARRAYSectionValues_Int f_getARRAYValuesFromTriplet_Int Module Procedures private interface f_getValues_Int () Arguments None private interface f_getSectionValues_Int () Arguments None private interface f_getValuesFromTriplet_Int () Arguments None private interface f_getARRAYValues_Int () Arguments None private interface f_getARRAYSectionValues_Int () Arguments None private interface f_getARRAYValuesFromTriplet_Int () Arguments None","tags":"","loc":"interface/arrayvalues~4.html"},{"title":"Constructor1 – Fortran Program","text":"interface private pure function Constructor1(tSize) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: tSize Return Value type( IntVector_ )","tags":"","loc":"interface/constructor1~11.html"},{"title":"ConstructorInt – Fortran Program","text":"interface private pure function ConstructorInt(Val) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Val (:) Return Value type( IntVector_ )","tags":"","loc":"interface/constructorint.html"},{"title":"ConstructorReal – Fortran Program","text":"interface private pure function ConstructorReal(Val) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Val (:) Return Value type( IntVector_ )","tags":"","loc":"interface/constructorreal.html"},{"title":"Constructor_1 – Fortran Program","text":"interface private pure function Constructor_1(tSize) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: tSize Return Value class( IntVector_ ),\n  POINTER","tags":"","loc":"interface/constructor_1~3.html"},{"title":"Constructor_Int – Fortran Program","text":"interface private pure function Constructor_Int(Val) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Val (:) Return Value class( IntVector_ ),\n  POINTER","tags":"","loc":"interface/constructor_int.html"},{"title":"Constructor_Real – Fortran Program","text":"interface private pure function Constructor_Real(Val) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Val (:) Return Value class( IntVector_ ),\n  POINTER","tags":"","loc":"interface/constructor_real.html"},{"title":"Convert – Fortran Program","text":"public interface Convert Contents Module Procedures obj_convert_int Module Procedures private interface obj_convert_int () Arguments None","tags":"","loc":"interface/convert~4.html"},{"title":"DeallocateData – Fortran Program","text":"public interface DeallocateData Contents Module Procedures Deallocate_Data Module Procedures private interface Deallocate_Data () Arguments None","tags":"","loc":"interface/deallocatedata~24.html"},{"title":"Deallocate_Data – Fortran Program","text":"interface private subroutine Deallocate_Data(Obj) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(inout) :: Obj","tags":"","loc":"interface/deallocate_data~6.html"},{"title":"Display – Fortran Program","text":"public interface Display Contents Module Procedures IntVectorDisplay IntscalarDisplay Module Procedures private interface IntVectorDisplay () Arguments None private interface IntscalarDisplay () Arguments None","tags":"","loc":"interface/display~26.html"},{"title":"IndexOF – Fortran Program","text":"public interface IndexOF Contents Module Procedures IndexOf_1 IndexOf_2 IndexOf_3 IndexOf_4 Module Procedures private interface IndexOf_1 () Arguments None private interface IndexOf_2 () Arguments None private interface IndexOf_3 () Arguments None private interface IndexOf_4 () Arguments None","tags":"","loc":"interface/indexof.html"},{"title":"IndexOf_1 – Fortran Program","text":"interface private pure function IndexOf_1(Obj, Value) result(Ans) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Value Return Value integer(kind=I4B)","tags":"","loc":"interface/indexof_1.html"},{"title":"IndexOf_2 – Fortran Program","text":"interface private pure function IndexOf_2(Obj, Value) result(Ans) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Value (:) Return Value integer(kind=I4B),\n  ALLOCATABLE,(:)","tags":"","loc":"interface/indexof_2.html"},{"title":"IndexOf_3 – Fortran Program","text":"interface private pure function IndexOf_3(Obj, Value) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Obj (:) integer(kind=I4B), intent(in) :: Value Return Value integer(kind=I4B)","tags":"","loc":"interface/indexof_3.html"},{"title":"IndexOf_4 – Fortran Program","text":"interface private pure function IndexOf_4(Obj, Value) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Obj (:) integer(kind=I4B), intent(in) :: Value (:) Return Value integer(kind=I4B),\n  ALLOCATABLE,(:)","tags":"","loc":"interface/indexof_4.html"},{"title":"Initiate – Fortran Program","text":"public interface Initiate Contents Module Procedures initiate_obj initiate_obj_vector initiate_obj_ab Module Procedures private interface initiate_obj () Arguments None private interface initiate_obj_vector () Arguments None private interface initiate_obj_ab () Arguments None","tags":"","loc":"interface/initiate~28.html"},{"title":"IntIntrinsicDisplay – Fortran Program","text":"interface private subroutine IntIntrinsicDisplay(Val, msg, UnitNo) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Val (:) character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: UnitNo","tags":"","loc":"interface/intintrinsicdisplay.html"},{"title":"IntVector – Fortran Program","text":"public interface IntVector Contents Module Procedures Constructor1 Module Procedures private interface Constructor1 () Arguments None","tags":"","loc":"interface/intvector.html"},{"title":"IntVector – Fortran Program","text":"private interface IntVector Contents Module Procedures ConstructorInt Module Procedures private interface ConstructorInt () Arguments None","tags":"","loc":"interface/intvector~2.html"},{"title":"IntVector – Fortran Program","text":"private interface IntVector Contents Module Procedures ConstructorReal Module Procedures private interface ConstructorReal () Arguments None","tags":"","loc":"interface/intvector~3.html"},{"title":"IntVectorDisplay – Fortran Program","text":"interface private subroutine IntVectorDisplay(Obj, msg, UnitNo) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(in) :: Obj (:) character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: UnitNo","tags":"","loc":"interface/intvectordisplay.html"},{"title":"IntVector_Pointer – Fortran Program","text":"public interface IntVector_Pointer Contents Module Procedures Constructor_1 Module Procedures private interface Constructor_1 () Arguments None","tags":"","loc":"interface/intvector_pointer.html"},{"title":"IntVector_Pointer – Fortran Program","text":"private interface IntVector_Pointer Contents Module Procedures Constructor_Int Module Procedures private interface Constructor_Int () Arguments None","tags":"","loc":"interface/intvector_pointer~2.html"},{"title":"IntVector_Pointer – Fortran Program","text":"private interface IntVector_Pointer Contents Module Procedures Constructor_Real Module Procedures private interface Constructor_Real () Arguments None","tags":"","loc":"interface/intvector_pointer~3.html"},{"title":"IntscalarDisplay – Fortran Program","text":"interface private subroutine IntscalarDisplay(Obj, msg, UnitNo) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(in) :: Obj character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: UnitNo","tags":"","loc":"interface/intscalardisplay.html"},{"title":"LOC – Fortran Program","text":"public interface LOC Contents Module Procedures IndexOf_1 IndexOf_2 IndexOf_3 IndexOf_4 Module Procedures private interface IndexOf_1 () Arguments None private interface IndexOf_2 () Arguments None private interface IndexOf_3 () Arguments None private interface IndexOf_4 () Arguments None","tags":"","loc":"interface/loc.html"},{"title":"RemoveDuplicates – Fortran Program","text":"public interface RemoveDuplicates Contents Module Procedures remove_duplicates remove_dupl_intvec Module Procedures private interface remove_duplicates () Arguments None private interface remove_dupl_intvec () Arguments None","tags":"","loc":"interface/removeduplicates~2.html"},{"title":"Repeat – Fortran Program","text":"public interface Repeat Contents Module Procedures repeat_int repeat_obj Module Procedures private interface repeat_int () Arguments None private interface repeat_obj () Arguments None","tags":"","loc":"interface/repeat.html"},{"title":"SIZE – Fortran Program","text":"public interface SIZE Contents Module Procedures get_size Module Procedures private interface get_size () Arguments None","tags":"","loc":"interface/size~5.html"},{"title":"SetValue – Fortran Program","text":"public interface SetValue Contents Module Procedures setValue_1 Module Procedures private interface setValue_1 () Arguments None","tags":"","loc":"interface/setvalue.html"},{"title":"Shape – Fortran Program","text":"public interface Shape Contents Module Procedures get_shape Module Procedures private interface get_shape () Arguments None","tags":"","loc":"interface/shape~5.html"},{"title":"f_getARRAYSectionValues_Int – Fortran Program","text":"interface private pure function f_getARRAYSectionValues_Int(Obj, Indx, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(in) :: Obj (:) integer(kind=I4B), intent(in) :: Indx (:) integer(kind=I4B), intent(in) :: DataType Return Value integer(kind=I4B),\n  ALLOCATABLE,(:)","tags":"","loc":"interface/f_getarraysectionvalues_int.html"},{"title":"f_getARRAYSectionValues_self – Fortran Program","text":"interface private pure function f_getARRAYSectionValues_self(Obj, Indx, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(in) :: Obj (:) integer(kind=I4B), intent(in) :: Indx (:) type( IntVector_ ), intent(in) :: DataType Return Value type( IntVector_ )","tags":"","loc":"interface/f_getarraysectionvalues_self.html"},{"title":"f_getARRAYValuesFromTriplet_Int – Fortran Program","text":"interface private pure function f_getARRAYValuesFromTriplet_Int(Obj, iStart, iEnd, Stride, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(in) :: Obj (:) integer(kind=I4B), intent(in) :: iStart integer(kind=I4B), intent(in) :: iEnd integer(kind=I4B), intent(in) :: Stride integer(kind=I4B), intent(in) :: DataType Return Value integer(kind=I4B),\n  ALLOCATABLE,(:)","tags":"","loc":"interface/f_getarrayvaluesfromtriplet_int.html"},{"title":"f_getARRAYValuesFromTriplet_self – Fortran Program","text":"interface private pure function f_getARRAYValuesFromTriplet_self(Obj, iStart, iEnd, Stride, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(in) :: Obj (:) integer(kind=I4B), intent(in) :: iStart integer(kind=I4B), intent(in) :: iEnd integer(kind=I4B), intent(in) :: Stride type( IntVector_ ), intent(in) :: DataType Return Value type( IntVector_ )","tags":"","loc":"interface/f_getarrayvaluesfromtriplet_self.html"},{"title":"f_getARRAYValues_Int – Fortran Program","text":"interface private pure function f_getARRAYValues_Int(Obj, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(in) :: Obj (:) integer(kind=I4B), intent(in) :: DataType Return Value integer(kind=I4B),\n  ALLOCATABLE,(:)","tags":"","loc":"interface/f_getarrayvalues_int.html"},{"title":"f_getARRAYValues_self – Fortran Program","text":"interface private pure function f_getARRAYValues_self(Obj, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(in) :: Obj (:) type( IntVector_ ), intent(in) :: DataType Return Value type( IntVector_ )","tags":"","loc":"interface/f_getarrayvalues_self.html"},{"title":"f_getPointer_Int – Fortran Program","text":"interface private function f_getPointer_Int(Obj, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(in), TARGET :: Obj integer(kind=I4B), intent(in) :: DataType Return Value integer(kind=I4B),\n  POINTER,(:)","tags":"","loc":"interface/f_getpointer_int.html"},{"title":"f_getPointer_self – Fortran Program","text":"interface private function f_getPointer_self(Obj, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(in), TARGET :: Obj type( IntVector_ ), intent(in) :: DataType Return Value type( IntVector_ ),\n  POINTER","tags":"","loc":"interface/f_getpointer_self.html"},{"title":"f_getSectionValues_Int – Fortran Program","text":"interface private pure function f_getSectionValues_Int(Obj, Indx, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Indx (:) integer(kind=I4B), intent(in) :: DataType Return Value integer(kind=I4B),\n  ALLOCATABLE,(:)","tags":"","loc":"interface/f_getsectionvalues_int.html"},{"title":"f_getSectionValues_self – Fortran Program","text":"interface private pure function f_getSectionValues_self(Obj, Indx, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Indx (:) type( IntVector_ ), intent(in) :: DataType Return Value type( IntVector_ )","tags":"","loc":"interface/f_getsectionvalues_self.html"},{"title":"f_getValuesFromTriplet_Int – Fortran Program","text":"interface private pure function f_getValuesFromTriplet_Int(Obj, iStart, iEnd, Stride, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: iStart integer(kind=I4B), intent(in) :: iEnd integer(kind=I4B), intent(in) :: Stride integer(kind=I4B), intent(in) :: DataType Return Value integer(kind=I4B),\n  ALLOCATABLE,(:)","tags":"","loc":"interface/f_getvaluesfromtriplet_int.html"},{"title":"f_getValuesFromTriplet_self – Fortran Program","text":"interface private pure function f_getValuesFromTriplet_self(Obj, iStart, iEnd, Stride, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: iStart integer(kind=I4B), intent(in) :: iEnd integer(kind=I4B), intent(in) :: Stride type( IntVector_ ), intent(in) :: DataType Return Value type( IntVector_ )","tags":"","loc":"interface/f_getvaluesfromtriplet_self.html"},{"title":"f_getValues_Int – Fortran Program","text":"interface private pure function f_getValues_Int(Obj, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: DataType Return Value integer(kind=I4B),\n  ALLOCATABLE,(:)","tags":"","loc":"interface/f_getvalues_int.html"},{"title":"f_getValues_self – Fortran Program","text":"interface private pure function f_getValues_self(Obj, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(in) :: Obj type( IntVector_ ), intent(in) :: DataType Return Value type( IntVector_ )","tags":"","loc":"interface/f_getvalues_self.html"},{"title":"getValues – Fortran Program","text":"public interface getValues Contents Module Procedures f_getValues_self f_getSectionValues_self f_getValuesFromTriplet_self f_getARRAYValues_self f_getARRAYSectionValues_self f_getARRAYValuesFromTriplet_self Module Procedures private interface f_getValues_self () Arguments None private interface f_getSectionValues_self () Arguments None private interface f_getValuesFromTriplet_self () Arguments None private interface f_getARRAYValues_self () Arguments None private interface f_getARRAYSectionValues_self () Arguments None private interface f_getARRAYValuesFromTriplet_self () Arguments None","tags":"","loc":"interface/getvalues.html"},{"title":"getValues – Fortran Program","text":"private interface getValues Contents Module Procedures f_getValues_Int f_getSectionValues_Int f_getValuesFromTriplet_Int f_getARRAYValues_Int f_getARRAYSectionValues_Int f_getARRAYValuesFromTriplet_Int Module Procedures private interface f_getValues_Int () Arguments None private interface f_getSectionValues_Int () Arguments None private interface f_getValuesFromTriplet_Int () Arguments None private interface f_getARRAYValues_Int () Arguments None private interface f_getARRAYSectionValues_Int () Arguments None private interface f_getARRAYValuesFromTriplet_Int () Arguments None","tags":"","loc":"interface/getvalues~2.html"},{"title":"get_shape – Fortran Program","text":"interface private pure function get_shape(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(in) :: Obj Return Value integer(kind=I4B)\n  (1)","tags":"","loc":"interface/get_shape~3.html"},{"title":"get_size – Fortran Program","text":"interface private pure function get_size(Obj, Dims) result(Ans) Arguments Type Intent Optional Attributes Name type( IntVector_ ), intent(in) :: Obj integer(kind=I4B), intent(in), optional :: Dims Return Value integer(kind=I4B)","tags":"","loc":"interface/get_size~3.html"},{"title":"initiate_obj – Fortran Program","text":"interface private subroutine initiate_obj(Obj, tSize) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: tSize","tags":"","loc":"interface/initiate_obj~5.html"},{"title":"initiate_obj_ab – Fortran Program","text":"interface private subroutine initiate_obj_ab(Obj, a, b) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: a integer(kind=I4B), intent(in) :: b","tags":"","loc":"interface/initiate_obj_ab.html"},{"title":"initiate_obj_vector – Fortran Program","text":"interface private subroutine initiate_obj_vector(Obj, tSize) Arguments Type Intent Optional Attributes Name type( IntVector_ ), intent(inout), ALLOCATABLE :: Obj (:) integer(kind=I4B), intent(in) :: tSize (:)","tags":"","loc":"interface/initiate_obj_vector.html"},{"title":"isPresent – Fortran Program","text":"public interface isPresent Contents Module Procedures isPresent_1 isPresent_2 Module Procedures private interface isPresent_1 () Arguments None private interface isPresent_2 () Arguments None","tags":"","loc":"interface/ispresent.html"},{"title":"isPresent_1 – Fortran Program","text":"interface private pure function isPresent_1(Obj, Value) result(Ans) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Value Return Value logical(kind=LGT)","tags":"","loc":"interface/ispresent_1.html"},{"title":"isPresent_2 – Fortran Program","text":"interface private pure function isPresent_2(Obj, Value) result(Ans) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Value (:) Return Value logical(kind=LGT),\n  ALLOCATABLE,(:)","tags":"","loc":"interface/ispresent_2.html"},{"title":"obj_convert_int – Fortran Program","text":"interface private subroutine obj_convert_int(From, To) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(in) :: From integer(kind=I4B), intent(inout), ALLOCATABLE :: To (:)","tags":"","loc":"interface/obj_convert_int.html"},{"title":"remove_dupl_intvec – Fortran Program","text":"interface private subroutine remove_dupl_intvec(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), ALLOCATABLE :: Obj (:)","tags":"","loc":"interface/remove_dupl_intvec.html"},{"title":"remove_duplicates – Fortran Program","text":"interface private subroutine remove_duplicates(Obj) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(inout) :: Obj","tags":"","loc":"interface/remove_duplicates.html"},{"title":"repeat_int – Fortran Program","text":"interface private pure function repeat_int(Val, rtimes) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Val (:) integer(kind=I4B), intent(in) :: rtimes Return Value integer(kind=I4B)\n  (SIZE(Val)*rtimes)","tags":"","loc":"interface/repeat_int.html"},{"title":"repeat_obj – Fortran Program","text":"interface private pure function repeat_obj(Obj, rtimes) result(Ans) Arguments Type Intent Optional Attributes Name type( IntVector_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: rtimes Return Value integer(kind=I4B)\n  (SIZE(Obj%Val)*rtimes)","tags":"","loc":"interface/repeat_obj.html"},{"title":"setValue_1 – Fortran Program","text":"interface private subroutine setValue_1(Obj, Indx, Value) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Indx (:) integer(kind=I4B), intent(in) :: Value (:)","tags":"","loc":"interface/setvalue_1~2.html"},{"title":"ASUM – Fortran Program","text":"public interface ASUM Contents Module Procedures ASUMScalar ASUMvector ASUMIntrinsic Module Procedures private interface ASUMScalar () Arguments None private interface ASUMvector () Arguments None private interface ASUMIntrinsic () Arguments None","tags":"","loc":"interface/asum~2.html"},{"title":"ASUMIntrinsic – Fortran Program","text":"interface private pure function ASUMIntrinsic(Val) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Val (:) Return Value real(kind=DFP)","tags":"","loc":"interface/asumintrinsic.html"},{"title":"ASUMScalar – Fortran Program","text":"interface private pure function ASUMScalar(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj Return Value real(kind=DFP)","tags":"","loc":"interface/asumscalar.html"},{"title":"ASUMvector – Fortran Program","text":"interface private pure function ASUMvector(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj (:) Return Value real(kind=DFP)","tags":"","loc":"interface/asumvector.html"},{"title":"AXPY – Fortran Program","text":"public interface AXPY Contents Module Procedures scalarAXPYscalar vectorAXPYvector scalarAXPYintrinsic intrinsicAXPYintrinsic Module Procedures private interface scalarAXPYscalar () Arguments None private interface vectorAXPYvector () Arguments None private interface scalarAXPYintrinsic () Arguments None private interface intrinsicAXPYintrinsic () Arguments None","tags":"","loc":"interface/axpy~3.html"},{"title":"AllocateData – Fortran Program","text":"public interface AllocateData Contents Module Procedures Allocate_Data Module Procedures private interface Allocate_Data () Arguments None","tags":"","loc":"interface/allocatedata~3.html"},{"title":"Allocate_Data – Fortran Program","text":"interface private subroutine Allocate_Data(Obj, Dims) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Dims","tags":"","loc":"interface/allocate_data~3.html"},{"title":"Append – Fortran Program","text":"public interface Append Contents Module Procedures Append_1 Append_2 Append_3 Module Procedures private interface Append_1 () Arguments None private interface Append_2 () Arguments None private interface Append_3 () Arguments None","tags":"","loc":"interface/append~4.html"},{"title":"Append_1 – Fortran Program","text":"interface private subroutine Append_1(Obj, Value) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(inout) :: Obj real(kind=DFP), intent(in) :: Value","tags":"","loc":"interface/append_1~2.html"},{"title":"Append_2 – Fortran Program","text":"interface private subroutine Append_2(Obj, Value) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(inout) :: Obj real(kind=DFP), intent(in) :: Value (:)","tags":"","loc":"interface/append_2~2.html"},{"title":"Append_3 – Fortran Program","text":"interface private subroutine Append_3(Obj, AnotherObj) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(inout) :: Obj class( RealVector_ ), intent(in) :: AnotherObj","tags":"","loc":"interface/append_3~2.html"},{"title":"ArrayPointer – Fortran Program","text":"public interface ArrayPointer Contents Module Procedures f_getPointer_self f_getPointer_Real64 Module Procedures private interface f_getPointer_self () Arguments None private interface f_getPointer_Real64 () Arguments None","tags":"","loc":"interface/arraypointer~2.html"},{"title":"ArrayValues – Fortran Program","text":"public interface ArrayValues Contents Module Procedures f_getValues_self f_getSectionValues_self f_getValuesFromTriplet_self f_getARRAYValues_self f_getARRAYSectionValues_self f_getARRAYValuesFromTriplet_self Module Procedures private interface f_getValues_self () Arguments None private interface f_getSectionValues_self () Arguments None private interface f_getValuesFromTriplet_self () Arguments None private interface f_getARRAYValues_self () Arguments None private interface f_getARRAYSectionValues_self () Arguments None private interface f_getARRAYValuesFromTriplet_self () Arguments None","tags":"","loc":"interface/arrayvalues~5.html"},{"title":"ArrayValues – Fortran Program","text":"private interface ArrayValues Contents Module Procedures f_getValues_Int f_getSectionValues_Int f_getValuesFromTriplet_Int f_getARRAYValues_Int f_getARRAYValuesFromTriplet_Int Module Procedures private interface f_getValues_Int () Arguments None private interface f_getSectionValues_Int () Arguments None private interface f_getValuesFromTriplet_Int () Arguments None private interface f_getARRAYValues_Int () Arguments None private interface f_getARRAYValuesFromTriplet_Int () Arguments None","tags":"","loc":"interface/arrayvalues~6.html"},{"title":"ArrayValues – Fortran Program","text":"private interface ArrayValues Contents Module Procedures f_getValues_Real f_getSectionValues_Real f_getValuesFromTriplet_Real f_getARRAYValues_Real f_getARRAYSectionValues_Real f_getARRAYValuesFromTriplet_Real Module Procedures private interface f_getValues_Real () Arguments None private interface f_getSectionValues_Real () Arguments None private interface f_getValuesFromTriplet_Real () Arguments None private interface f_getARRAYValues_Real () Arguments None private interface f_getARRAYSectionValues_Real () Arguments None private interface f_getARRAYValuesFromTriplet_Real () Arguments None","tags":"","loc":"interface/arrayvalues~7.html"},{"title":"COPY – Fortran Program","text":"public interface COPY Contents Module Procedures intrinsicCOPYintrinsic scalarCOPYscalar vectorCOPYvector scalarCOPYvector scalarCOPYintrinsic Module Procedures private interface intrinsicCOPYintrinsic () Arguments None private interface scalarCOPYscalar () Arguments None private interface vectorCOPYvector () Arguments None private interface scalarCOPYvector () Arguments None private interface scalarCOPYintrinsic () Arguments None","tags":"","loc":"interface/copy~2.html"},{"title":"Constructor1 – Fortran Program","text":"interface private pure function Constructor1(tSize) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: tSize Return Value type( RealVector_ )","tags":"","loc":"interface/constructor1~12.html"},{"title":"ConstructorInt16 – Fortran Program","text":"interface private pure function ConstructorInt16(Val) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=Int16), intent(in) :: Val (:) Return Value type( RealVector_ )","tags":"","loc":"interface/constructorint16.html"},{"title":"ConstructorInt32 – Fortran Program","text":"interface private pure function ConstructorInt32(Val) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=Int32), intent(in) :: Val (:) Return Value type( RealVector_ )","tags":"","loc":"interface/constructorint32.html"},{"title":"ConstructorInt64 – Fortran Program","text":"interface private pure function ConstructorInt64(Val) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=Int64), intent(in) :: Val (:) Return Value type( RealVector_ )","tags":"","loc":"interface/constructorint64.html"},{"title":"ConstructorInt8 – Fortran Program","text":"interface private pure function ConstructorInt8(Val) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=Int8), intent(in) :: Val (:) Return Value type( RealVector_ )","tags":"","loc":"interface/constructorint8.html"},{"title":"ConstructorReal32 – Fortran Program","text":"interface private pure function ConstructorReal32(Val) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=Real32), intent(in) :: Val (:) Return Value type( RealVector_ )","tags":"","loc":"interface/constructorreal32.html"},{"title":"ConstructorReal64 – Fortran Program","text":"interface private pure function ConstructorReal64(Val) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=Real64), intent(in) :: Val (:) Return Value type( RealVector_ )","tags":"","loc":"interface/constructorreal64.html"},{"title":"Constructor_1 – Fortran Program","text":"interface private pure function Constructor_1(tSize) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: tSize Return Value class( RealVector_ ),\n  POINTER","tags":"","loc":"interface/constructor_1~4.html"},{"title":"Constructor_Int16 – Fortran Program","text":"interface private pure function Constructor_Int16(Val) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=Int16), intent(in) :: Val (:) Return Value class( RealVector_ ),\n  POINTER","tags":"","loc":"interface/constructor_int16.html"},{"title":"Constructor_Int32 – Fortran Program","text":"interface private pure function Constructor_Int32(Val) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=Int32), intent(in) :: Val (:) Return Value class( RealVector_ ),\n  POINTER","tags":"","loc":"interface/constructor_int32.html"},{"title":"Constructor_Int64 – Fortran Program","text":"interface private pure function Constructor_Int64(Val) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=Int64), intent(in) :: Val (:) Return Value class( RealVector_ ),\n  POINTER","tags":"","loc":"interface/constructor_int64.html"},{"title":"Constructor_Int8 – Fortran Program","text":"interface private pure function Constructor_Int8(Val) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=Int8), intent(in) :: Val (:) Return Value class( RealVector_ ),\n  POINTER","tags":"","loc":"interface/constructor_int8.html"},{"title":"Constructor_Real32 – Fortran Program","text":"interface private pure function Constructor_Real32(Val) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=Real32), intent(in) :: Val (:) Return Value class( RealVector_ ),\n  POINTER","tags":"","loc":"interface/constructor_real32.html"},{"title":"Constructor_Real64 – Fortran Program","text":"interface private pure function Constructor_Real64(Val) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=Real64), intent(in) :: Val (:) Return Value class( RealVector_ ),\n  POINTER","tags":"","loc":"interface/constructor_real64.html"},{"title":"DOT – Fortran Program","text":"public interface DOT Contents Module Procedures scalarDOTscalar vectorDOTvector vectorDOTscalar scalarDOTvector intrinsicDOTintrinsic scalarDOTintrinsic Module Procedures private interface scalarDOTscalar () Arguments None private interface vectorDOTvector () Arguments None private interface vectorDOTscalar () Arguments None private interface scalarDOTvector () Arguments None private interface intrinsicDOTintrinsic () Arguments None private interface scalarDOTintrinsic () Arguments None","tags":"","loc":"interface/dot~2.html"},{"title":"DeallocateData – Fortran Program","text":"public interface DeallocateData Contents Module Procedures Deallocate_Data Module Procedures private interface Deallocate_Data () Arguments None","tags":"","loc":"interface/deallocatedata~25.html"},{"title":"Deallocate_Data – Fortran Program","text":"interface private subroutine Deallocate_Data(Obj) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(inout) :: Obj","tags":"","loc":"interface/deallocate_data~7.html"},{"title":"Display – Fortran Program","text":"public interface Display Contents Module Procedures RealVectorDisplay RealscalarDisplay Display_Vector_Real Module Procedures private interface RealVectorDisplay () Arguments None private interface RealscalarDisplay () Arguments None private interface Display_Vector_Real () Arguments None","tags":"","loc":"interface/display~27.html"},{"title":"Display_Vector_Real – Fortran Program","text":"interface private subroutine Display_Vector_Real(vec, msg, unitNo, path, filename, extension) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: vec (:) character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitNo character(len=*), intent(in), optional :: path character(len=*), intent(in), optional :: filename character(len=*), intent(in), optional :: extension","tags":"","loc":"interface/display_vector_real.html"},{"title":"IndexOF – Fortran Program","text":"public interface IndexOF Contents Module Procedures IndexOf_1 IndexOf_2 Module Procedures private interface IndexOf_1 () Arguments None private interface IndexOf_2 () Arguments None","tags":"","loc":"interface/indexof~2.html"},{"title":"IndexOf_1 – Fortran Program","text":"interface private pure function IndexOf_1(Obj, Value) result(Ans) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj real(kind=DFP), intent(in) :: Value Return Value integer(kind=I4B)","tags":"","loc":"interface/indexof_1~2.html"},{"title":"IndexOf_2 – Fortran Program","text":"interface private pure function IndexOf_2(Obj, Value) result(Ans) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj real(kind=DFP), intent(in) :: Value (:) Return Value integer(kind=I4B),\n  ALLOCATABLE,(:)","tags":"","loc":"interface/indexof_2~2.html"},{"title":"Initiate – Fortran Program","text":"public interface Initiate Contents Module Procedures initiate_obj initiate_obj_vector initiate_obj_ab Module Procedures private interface initiate_obj () This subroutine allocate the memory for RealVector_ Arguments None private interface initiate_obj_vector () This subroutine allocate the memory for a vector of type RealVector_ Arguments None private interface initiate_obj_ab () This subroutine allocate the memory for an instance of RealVector_ Arguments None","tags":"","loc":"interface/initiate~29.html"},{"title":"LOC – Fortran Program","text":"public interface LOC Contents Module Procedures IndexOf_1 IndexOf_2 Module Procedures private interface IndexOf_1 () Arguments None private interface IndexOf_2 () Arguments None","tags":"","loc":"interface/loc~2.html"},{"title":"NORM2 – Fortran Program","text":"public interface NORM2 Contents Module Procedures NRM2scalar NRM2vector Module Procedures private interface NRM2scalar () Arguments None private interface NRM2vector () Arguments None","tags":"","loc":"interface/norm2.html"},{"title":"NORM2SQR – Fortran Program","text":"public interface NORM2SQR Contents Module Procedures NRM2SQRscalar NRM2SQRvector NRM2SQRintrinsic Module Procedures private interface NRM2SQRscalar () Arguments None private interface NRM2SQRvector () Arguments None private interface NRM2SQRintrinsic () Arguments None","tags":"","loc":"interface/norm2sqr.html"},{"title":"NRM2SQRintrinsic – Fortran Program","text":"interface private pure function NRM2SQRintrinsic(Val) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Val (:) Return Value real(kind=DFP)","tags":"","loc":"interface/nrm2sqrintrinsic.html"},{"title":"NRM2SQRscalar – Fortran Program","text":"interface private pure function NRM2SQRscalar(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj Return Value real(kind=DFP)","tags":"","loc":"interface/nrm2sqrscalar.html"},{"title":"NRM2SQRvector – Fortran Program","text":"interface private pure function NRM2SQRvector(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj (:) Return Value real(kind=DFP)","tags":"","loc":"interface/nrm2sqrvector.html"},{"title":"NRM2scalar – Fortran Program","text":"interface private pure function NRM2scalar(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj Return Value real(kind=DFP)","tags":"","loc":"interface/nrm2scalar.html"},{"title":"NRM2vector – Fortran Program","text":"interface private pure function NRM2vector(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj (:) Return Value real(kind=DFP)","tags":"","loc":"interface/nrm2vector.html"},{"title":"OPERATOR( .EQ. ) – Fortran Program","text":"public interface OPERATOR( .EQ. ) Contents Module Procedures isPresent_1 isPresent_2 Module Procedures private interface isPresent_1 () Arguments None private interface isPresent_2 () Arguments None","tags":"","loc":"interface/operator( .eq. )~2.html"},{"title":"RANDOM_NUMBER – Fortran Program","text":"public interface RANDOM_NUMBER Contents Module Procedures RANDOM_NUMBER_Obj Random_number_obj_vec Module Procedures private interface RANDOM_NUMBER_Obj () Arguments None private interface Random_number_obj_vec () Arguments None","tags":"","loc":"interface/random_number.html"},{"title":"RANDOM_NUMBER_Obj – Fortran Program","text":"interface private subroutine RANDOM_NUMBER_Obj(Obj, tsize) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: tsize","tags":"","loc":"interface/random_number_obj.html"},{"title":"Random_number_obj_vec – Fortran Program","text":"interface private subroutine Random_number_obj_vec(Obj, tsize) Arguments Type Intent Optional Attributes Name type( RealVector_ ), intent(inout), ALLOCATABLE :: Obj (:) integer(kind=I4B), intent(in) :: tsize (:)","tags":"","loc":"interface/random_number_obj_vec.html"},{"title":"RealVector – Fortran Program","text":"public interface RealVector Contents Module Procedures Constructor1 Module Procedures private interface Constructor1 () Arguments None","tags":"","loc":"interface/realvector.html"},{"title":"RealVector – Fortran Program","text":"private interface RealVector Contents Module Procedures ConstructorInt8 Module Procedures private interface ConstructorInt8 () Arguments None","tags":"","loc":"interface/realvector~2.html"},{"title":"RealVector – Fortran Program","text":"private interface RealVector Contents Module Procedures ConstructorInt16 Module Procedures private interface ConstructorInt16 () Arguments None","tags":"","loc":"interface/realvector~3.html"},{"title":"RealVector – Fortran Program","text":"private interface RealVector Contents Module Procedures ConstructorInt32 Module Procedures private interface ConstructorInt32 () Arguments None","tags":"","loc":"interface/realvector~4.html"},{"title":"RealVector – Fortran Program","text":"private interface RealVector Contents Module Procedures ConstructorInt64 Module Procedures private interface ConstructorInt64 () Arguments None","tags":"","loc":"interface/realvector~5.html"},{"title":"RealVector – Fortran Program","text":"private interface RealVector Contents Module Procedures ConstructorReal32 Module Procedures private interface ConstructorReal32 () Arguments None","tags":"","loc":"interface/realvector~6.html"},{"title":"RealVector – Fortran Program","text":"private interface RealVector Contents Module Procedures ConstructorReal64 Module Procedures private interface ConstructorReal64 () Arguments None","tags":"","loc":"interface/realvector~7.html"},{"title":"RealVectorDisplay – Fortran Program","text":"interface private subroutine RealVectorDisplay(Obj, msg, UnitNo, path, filename, extension) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj (:) character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: UnitNo character(len=*), intent(in), optional :: path character(len=*), intent(in), optional :: filename character(len=*), intent(in), optional :: extension","tags":"","loc":"interface/realvectordisplay.html"},{"title":"RealVector_Pointer – Fortran Program","text":"public interface RealVector_Pointer Contents Module Procedures Constructor_1 Module Procedures private interface Constructor_1 () Arguments None","tags":"","loc":"interface/realvector_pointer.html"},{"title":"RealVector_Pointer – Fortran Program","text":"private interface RealVector_Pointer Contents Module Procedures Constructor_Int8 Module Procedures private interface Constructor_Int8 () Arguments None","tags":"","loc":"interface/realvector_pointer~2.html"},{"title":"RealVector_Pointer – Fortran Program","text":"private interface RealVector_Pointer Contents Module Procedures Constructor_Int16 Module Procedures private interface Constructor_Int16 () Arguments None","tags":"","loc":"interface/realvector_pointer~3.html"},{"title":"RealVector_Pointer – Fortran Program","text":"private interface RealVector_Pointer Contents Module Procedures Constructor_Int32 Module Procedures private interface Constructor_Int32 () Arguments None","tags":"","loc":"interface/realvector_pointer~4.html"},{"title":"RealVector_Pointer – Fortran Program","text":"private interface RealVector_Pointer Contents Module Procedures Constructor_Int64 Module Procedures private interface Constructor_Int64 () Arguments None","tags":"","loc":"interface/realvector_pointer~5.html"},{"title":"RealVector_Pointer – Fortran Program","text":"private interface RealVector_Pointer Contents Module Procedures Constructor_Real32 Module Procedures private interface Constructor_Real32 () Arguments None","tags":"","loc":"interface/realvector_pointer~6.html"},{"title":"RealVector_Pointer – Fortran Program","text":"private interface RealVector_Pointer Contents Module Procedures Constructor_Real64 Module Procedures private interface Constructor_Real64 () Arguments None","tags":"","loc":"interface/realvector_pointer~7.html"},{"title":"RealscalarDisplay – Fortran Program","text":"interface private subroutine RealscalarDisplay(Obj, msg, UnitNo, path, filename, extension) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: UnitNo character(len=*), intent(in), optional :: path character(len=*), intent(in), optional :: filename character(len=*), intent(in), optional :: extension","tags":"","loc":"interface/realscalardisplay.html"},{"title":"SCALE – Fortran Program","text":"public interface SCALE Contents Module Procedures SCALintrinsic SCALscalar SCALvector Module Procedures private interface SCALintrinsic () Arguments None private interface SCALscalar () Arguments None private interface SCALvector () Arguments None","tags":"","loc":"interface/scale.html"},{"title":"SCALintrinsic – Fortran Program","text":"interface private subroutine SCALintrinsic(alpha, Val) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: alpha real(kind=DFP), intent(inout) :: Val (:)","tags":"","loc":"interface/scalintrinsic.html"},{"title":"SCALscalar – Fortran Program","text":"interface private subroutine SCALscalar(alpha, Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: alpha class( RealVector_ ), intent(inout) :: Obj","tags":"","loc":"interface/scalscalar.html"},{"title":"SCALvector – Fortran Program","text":"interface private subroutine SCALvector(alpha, Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: alpha class( RealVector_ ), intent(inout) :: Obj (:)","tags":"","loc":"interface/scalvector.html"},{"title":"SHALLOWCOPY – Fortran Program","text":"public interface SHALLOWCOPY Contents Module Procedures intrinsicSHALLOWCOPYintrinsic scalarSHALLOWCOPYscalar vectorSHALLOWCOPYvector scalarSHALLOWCOPYvector scalarSHALLOWCOPYintrinsic Module Procedures private interface intrinsicSHALLOWCOPYintrinsic () Arguments None private interface scalarSHALLOWCOPYscalar () Arguments None private interface vectorSHALLOWCOPYvector () Arguments None private interface scalarSHALLOWCOPYvector () Arguments None private interface scalarSHALLOWCOPYintrinsic () Arguments None","tags":"","loc":"interface/shallowcopy.html"},{"title":"SIZE – Fortran Program","text":"public interface SIZE Contents Module Procedures get_size Module Procedures private interface get_size () Arguments None","tags":"","loc":"interface/size~6.html"},{"title":"SWAP – Fortran Program","text":"public interface SWAP Contents Module Procedures scalarSWAPscalar vectorSWAPvector scalarSWAPintrinsic Module Procedures private interface scalarSWAPscalar () Arguments None private interface vectorSWAPvector () Arguments None private interface scalarSWAPintrinsic () Arguments None","tags":"","loc":"interface/swap~3.html"},{"title":"SetValue – Fortran Program","text":"public interface SetValue Contents Module Procedures setValue_1 Module Procedures private interface setValue_1 () Arguments None","tags":"","loc":"interface/setvalue~2.html"},{"title":"Shape – Fortran Program","text":"public interface Shape Contents Module Procedures get_shape Module Procedures private interface get_shape () Arguments None","tags":"","loc":"interface/shape~6.html"},{"title":"f_getARRAYSectionValues_Int – Fortran Program","text":"interface private pure function f_getARRAYSectionValues_Int(Obj, Indx, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj (:) integer(kind=I4B), intent(in) :: Indx (:) integer(kind=I4B), intent(in) :: DataType Return Value integer(kind=I4B),\n  ALLOCATABLE,(:)","tags":"","loc":"interface/f_getarraysectionvalues_int~2.html"},{"title":"f_getARRAYSectionValues_Real – Fortran Program","text":"interface private pure function f_getARRAYSectionValues_Real(Obj, Indx, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj (:) integer(kind=I4B), intent(in) :: Indx (:) real(kind=DFP), intent(in) :: DataType Return Value real(kind=DFP),\n  ALLOCATABLE,(:)","tags":"","loc":"interface/f_getarraysectionvalues_real.html"},{"title":"f_getARRAYSectionValues_self – Fortran Program","text":"interface private pure function f_getARRAYSectionValues_self(Obj, Indx, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj (:) integer(kind=I4B), intent(in) :: Indx (:) type( RealVector_ ), intent(in) :: DataType Return Value type( RealVector_ )","tags":"","loc":"interface/f_getarraysectionvalues_self~2.html"},{"title":"f_getARRAYValuesFromTriplet_Int – Fortran Program","text":"interface private pure function f_getARRAYValuesFromTriplet_Int(Obj, iStart, iEnd, Stride, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj (:) integer(kind=I4B), intent(in) :: iStart integer(kind=I4B), intent(in) :: iEnd integer(kind=I4B), intent(in) :: Stride integer(kind=I4B), intent(in) :: DataType Return Value integer(kind=I4B),\n  ALLOCATABLE,(:)","tags":"","loc":"interface/f_getarrayvaluesfromtriplet_int~2.html"},{"title":"f_getARRAYValuesFromTriplet_Real – Fortran Program","text":"interface private pure function f_getARRAYValuesFromTriplet_Real(Obj, iStart, iEnd, Stride, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj (:) integer(kind=I4B), intent(in) :: iStart integer(kind=I4B), intent(in) :: iEnd integer(kind=I4B), intent(in) :: Stride real(kind=DFP), intent(in) :: DataType Return Value real(kind=DFP),\n  ALLOCATABLE,(:)","tags":"","loc":"interface/f_getarrayvaluesfromtriplet_real.html"},{"title":"f_getARRAYValuesFromTriplet_self – Fortran Program","text":"interface private pure function f_getARRAYValuesFromTriplet_self(Obj, iStart, iEnd, Stride, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj (:) integer(kind=I4B), intent(in) :: iStart integer(kind=I4B), intent(in) :: iEnd integer(kind=I4B), intent(in) :: Stride type( RealVector_ ), intent(in) :: DataType Return Value type( RealVector_ )","tags":"","loc":"interface/f_getarrayvaluesfromtriplet_self~2.html"},{"title":"f_getARRAYValues_Int – Fortran Program","text":"interface private pure function f_getARRAYValues_Int(Obj, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj (:) integer(kind=I4B), intent(in) :: DataType Return Value integer(kind=I4B),\n  ALLOCATABLE,(:)","tags":"","loc":"interface/f_getarrayvalues_int~2.html"},{"title":"f_getARRAYValues_Real – Fortran Program","text":"interface private pure function f_getARRAYValues_Real(Obj, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj (:) real(kind=DFP), intent(in) :: DataType Return Value real(kind=DFP),\n  ALLOCATABLE,(:)","tags":"","loc":"interface/f_getarrayvalues_real.html"},{"title":"f_getARRAYValues_self – Fortran Program","text":"interface private pure function f_getARRAYValues_self(Obj, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj (:) type( RealVector_ ), intent(in) :: DataType Return Value type( RealVector_ )","tags":"","loc":"interface/f_getarrayvalues_self~2.html"},{"title":"f_getPointer_Real64 – Fortran Program","text":"interface private function f_getPointer_Real64(Obj, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in), TARGET :: Obj real(kind=Real64), intent(in) :: DataType Return Value real(kind=Real64),\n  POINTER,(:)","tags":"","loc":"interface/f_getpointer_real64.html"},{"title":"f_getPointer_self – Fortran Program","text":"interface private function f_getPointer_self(Obj, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in), TARGET :: Obj type( RealVector_ ), intent(in) :: DataType Return Value type( RealVector_ ),\n  POINTER","tags":"","loc":"interface/f_getpointer_self~2.html"},{"title":"f_getSectionValues_Int – Fortran Program","text":"interface private pure function f_getSectionValues_Int(Obj, Indx, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Indx (:) integer(kind=I4B), intent(in) :: DataType Return Value integer(kind=I4B),\n  ALLOCATABLE,(:)","tags":"","loc":"interface/f_getsectionvalues_int~2.html"},{"title":"f_getSectionValues_Real – Fortran Program","text":"interface private pure function f_getSectionValues_Real(Obj, Indx, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Indx (:) real(kind=DFP), intent(in) :: DataType Return Value real(kind=DFP),\n  ALLOCATABLE,(:)","tags":"","loc":"interface/f_getsectionvalues_real~2.html"},{"title":"f_getSectionValues_self – Fortran Program","text":"interface private pure function f_getSectionValues_self(Obj, Indx, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Indx (:) type( RealVector_ ), intent(in) :: DataType Return Value type( RealVector_ )","tags":"","loc":"interface/f_getsectionvalues_self~2.html"},{"title":"f_getValuesFromTriplet_Int – Fortran Program","text":"interface private pure function f_getValuesFromTriplet_Int(Obj, iStart, iEnd, Stride, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: iStart integer(kind=I4B), intent(in) :: iEnd integer(kind=I4B), intent(in) :: Stride integer(kind=I4B), intent(in) :: DataType Return Value integer(kind=I4B),\n  ALLOCATABLE,(:)","tags":"","loc":"interface/f_getvaluesfromtriplet_int~2.html"},{"title":"f_getValuesFromTriplet_Real – Fortran Program","text":"interface private pure function f_getValuesFromTriplet_Real(Obj, iStart, iEnd, Stride, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: iStart integer(kind=I4B), intent(in) :: iEnd integer(kind=I4B), intent(in) :: Stride real(kind=DFP), intent(in) :: DataType Return Value real(kind=DFP),\n  ALLOCATABLE,(:)","tags":"","loc":"interface/f_getvaluesfromtriplet_real~2.html"},{"title":"f_getValuesFromTriplet_self – Fortran Program","text":"interface private pure function f_getValuesFromTriplet_self(Obj, iStart, iEnd, Stride, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: iStart integer(kind=I4B), intent(in) :: iEnd integer(kind=I4B), intent(in) :: Stride type( RealVector_ ), intent(in) :: DataType Return Value type( RealVector_ )","tags":"","loc":"interface/f_getvaluesfromtriplet_self~2.html"},{"title":"f_getValues_Int – Fortran Program","text":"interface private pure function f_getValues_Int(Obj, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: DataType Return Value integer(kind=I4B),\n  ALLOCATABLE,(:)","tags":"","loc":"interface/f_getvalues_int~2.html"},{"title":"f_getValues_Real – Fortran Program","text":"interface private pure function f_getValues_Real(Obj, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj real(kind=DFP), intent(in) :: DataType Return Value real(kind=DFP),\n  ALLOCATABLE,(:)","tags":"","loc":"interface/f_getvalues_real~2.html"},{"title":"f_getValues_self – Fortran Program","text":"interface private pure function f_getValues_self(Obj, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj type( RealVector_ ), intent(in) :: DataType Return Value type( RealVector_ )","tags":"","loc":"interface/f_getvalues_self~2.html"},{"title":"get_shape – Fortran Program","text":"interface private pure function get_shape(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj Return Value integer(kind=I4B)\n  (1)","tags":"","loc":"interface/get_shape~4.html"},{"title":"get_size – Fortran Program","text":"interface private pure function get_size(Obj, Dims) result(Ans) Arguments Type Intent Optional Attributes Name type( RealVector_ ), intent(in) :: Obj integer(kind=I4B), intent(in), optional :: Dims Return Value integer(kind=I4B)","tags":"","loc":"interface/get_size~4.html"},{"title":"initiate_obj – Fortran Program","text":"interface This subroutine allocate the memory for RealVector_ private subroutine initiate_obj(Obj, tSize) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: tSize Description This subroutine allocates the memeory for RealVector_ fortran\n CALL Initiate(Obj, 5)","tags":"","loc":"interface/initiate_obj.html"},{"title":"initiate_obj_ab – Fortran Program","text":"interface This subroutine allocate the memory for an instance of RealVector_ private subroutine initiate_obj_ab(Obj, a, b) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: a integer(kind=I4B), intent(in) :: b Description This subroutine allocate the memory for an instance of RealVector_ .\n User can specify the lowerbounds and upper bounds","tags":"","loc":"interface/initiate_obj_ab~2.html"},{"title":"initiate_obj_vector – Fortran Program","text":"interface This subroutine allocate the memory for a vector of type RealVector_ private subroutine initiate_obj_vector(Obj, tSize) Arguments Type Intent Optional Attributes Name type( RealVector_ ), intent(inout), ALLOCATABLE :: Obj (:) integer(kind=I4B), intent(in) :: tSize (:) Description This subroutine allocate the memory for a vector of type RealVector_ The size of Obj would be same as the size of tSize","tags":"","loc":"interface/initiate_obj_vector~2.html"},{"title":"intrinsicAXPYintrinsic – Fortran Program","text":"interface private subroutine intrinsicAXPYintrinsic(Val1, alpha, Val2) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout) :: Val1 (:) real(kind=DFP), intent(in) :: alpha real(kind=DFP), intent(in) :: Val2 (:)","tags":"","loc":"interface/intrinsicaxpyintrinsic.html"},{"title":"intrinsicCOPYintrinsic – Fortran Program","text":"interface private subroutine intrinsicCOPYintrinsic(Val1, Val2) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: Val1 (:) real(kind=DFP), intent(in) :: Val2 (:)","tags":"","loc":"interface/intrinsiccopyintrinsic.html"},{"title":"intrinsicCOPYscalar – Fortran Program","text":"interface private subroutine intrinsicCOPYscalar(Val, Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: Val (:) class( RealVector_ ), intent(in) :: Obj","tags":"","loc":"interface/intrinsiccopyscalar.html"},{"title":"intrinsicDOTintrinsic – Fortran Program","text":"interface private pure function intrinsicDOTintrinsic(Val1, Val2) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Val1 (:) real(kind=DFP), intent(in) :: Val2 (:) Return Value real(kind=DFP)","tags":"","loc":"interface/intrinsicdotintrinsic.html"},{"title":"intrinsicDOTscalar – Fortran Program","text":"interface private pure function intrinsicDOTscalar(Val, Obj) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Val (:) class( RealVector_ ), intent(in) :: Obj Return Value real(kind=DFP)","tags":"","loc":"interface/intrinsicdotscalar.html"},{"title":"intrinsicSHALLOWCOPYintrinsic – Fortran Program","text":"interface private subroutine intrinsicSHALLOWCOPYintrinsic(Val1, Val2) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: Val1 (:) real(kind=DFP), intent(in) :: Val2 (:)","tags":"","loc":"interface/intrinsicshallowcopyintrinsic.html"},{"title":"intrinsicSHALLOWCOPYscalar – Fortran Program","text":"interface private subroutine intrinsicSHALLOWCOPYscalar(Val, Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: Val (:) class( RealVector_ ), intent(in) :: Obj","tags":"","loc":"interface/intrinsicshallowcopyscalar.html"},{"title":"intrinsicSWAPintrinsic – Fortran Program","text":"interface private subroutine intrinsicSWAPintrinsic(Val1, Val2) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout) :: Val1 (:) real(kind=DFP), intent(inout) :: Val2 (:)","tags":"","loc":"interface/intrinsicswapintrinsic.html"},{"title":"intrinsicSWAPscalar – Fortran Program","text":"interface private subroutine intrinsicSWAPscalar(Val, Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout) :: Val (:) class( RealVector_ ), intent(inout) :: Obj","tags":"","loc":"interface/intrinsicswapscalar.html"},{"title":"isPresent – Fortran Program","text":"public interface isPresent Contents Module Procedures isPresent_1 isPresent_2 Module Procedures private interface isPresent_1 () Arguments None private interface isPresent_2 () Arguments None","tags":"","loc":"interface/ispresent~2.html"},{"title":"isPresent_1 – Fortran Program","text":"interface private pure function isPresent_1(Obj, Value) result(Ans) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj real(kind=DFP), intent(in) :: Value Return Value logical(kind=LGT)","tags":"","loc":"interface/ispresent_1~2.html"},{"title":"isPresent_2 – Fortran Program","text":"interface private pure function isPresent_2(Obj, Value) result(Ans) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj real(kind=DFP), intent(in) :: Value (:) Return Value logical(kind=LGT),\n  ALLOCATABLE,(:)","tags":"","loc":"interface/ispresent_2~2.html"},{"title":"scalarAXPYintrinsic – Fortran Program","text":"interface private subroutine scalarAXPYintrinsic(Obj, alpha, Val) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(inout) :: Obj real(kind=DFP), intent(in) :: alpha real(kind=DFP), intent(in) :: Val (:)","tags":"","loc":"interface/scalaraxpyintrinsic.html"},{"title":"scalarAXPYscalar – Fortran Program","text":"interface private subroutine scalarAXPYscalar(Obj1, alpha, Obj2) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(inout) :: Obj1 real(kind=DFP), intent(in) :: alpha class( RealVector_ ), intent(in) :: Obj2","tags":"","loc":"interface/scalaraxpyscalar.html"},{"title":"scalarCOPYintrinsic – Fortran Program","text":"interface private subroutine scalarCOPYintrinsic(Obj, Val) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val (:)","tags":"","loc":"interface/scalarcopyintrinsic.html"},{"title":"scalarCOPYscalar – Fortran Program","text":"interface private subroutine scalarCOPYscalar(Obj1, Obj2) Arguments Type Intent Optional Attributes Name type( RealVector_ ), intent(inout) :: Obj1 class( RealVector_ ), intent(in) :: Obj2","tags":"","loc":"interface/scalarcopyscalar.html"},{"title":"scalarCOPYvector – Fortran Program","text":"interface private subroutine scalarCOPYvector(Obj1, Obj2) Arguments Type Intent Optional Attributes Name type( RealVector_ ), intent(inout) :: Obj1 class( RealVector_ ), intent(in) :: Obj2 (:)","tags":"","loc":"interface/scalarcopyvector.html"},{"title":"scalarDOTintrinsic – Fortran Program","text":"interface private pure function scalarDOTintrinsic(Obj, Val) result(Ans) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj real(kind=DFP), intent(in) :: Val (:) Return Value real(kind=DFP)","tags":"","loc":"interface/scalardotintrinsic.html"},{"title":"scalarDOTscalar – Fortran Program","text":"interface private pure function scalarDOTscalar(Obj1, Obj2) result(Ans) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj1 class( RealVector_ ), intent(in) :: Obj2 Return Value real(kind=DFP)","tags":"","loc":"interface/scalardotscalar.html"},{"title":"scalarDOTvector – Fortran Program","text":"interface private pure function scalarDOTvector(Obj1, Obj2) result(Ans) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj1 class( RealVector_ ), intent(in) :: Obj2 (:) Return Value real(kind=DFP)","tags":"","loc":"interface/scalardotvector.html"},{"title":"scalarSHALLOWCOPYintrinsic – Fortran Program","text":"interface private subroutine scalarSHALLOWCOPYintrinsic(Obj, Val) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val (:)","tags":"","loc":"interface/scalarshallowcopyintrinsic.html"},{"title":"scalarSHALLOWCOPYscalar – Fortran Program","text":"interface private subroutine scalarSHALLOWCOPYscalar(Obj1, Obj2) Arguments Type Intent Optional Attributes Name type( RealVector_ ), intent(inout) :: Obj1 class( RealVector_ ), intent(in) :: Obj2","tags":"","loc":"interface/scalarshallowcopyscalar.html"},{"title":"scalarSHALLOWCOPYvector – Fortran Program","text":"interface private subroutine scalarSHALLOWCOPYvector(Obj1, Obj2) Arguments Type Intent Optional Attributes Name type( RealVector_ ), intent(inout) :: Obj1 class( RealVector_ ), intent(in) :: Obj2 (:)","tags":"","loc":"interface/scalarshallowcopyvector.html"},{"title":"scalarSWAPintrinsic – Fortran Program","text":"interface private subroutine scalarSWAPintrinsic(Obj, Val) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(inout) :: Obj real(kind=DFP), intent(inout) :: Val (:)","tags":"","loc":"interface/scalarswapintrinsic.html"},{"title":"scalarSWAPscalar – Fortran Program","text":"interface private subroutine scalarSWAPscalar(Obj1, Obj2) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(inout) :: Obj1 class( RealVector_ ), intent(inout) :: Obj2","tags":"","loc":"interface/scalarswapscalar.html"},{"title":"setValue_1 – Fortran Program","text":"interface private subroutine setValue_1(Obj, Indx, Value) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Indx (:) real(kind=DFP), intent(in) :: Value (:)","tags":"","loc":"interface/setvalue_1~3.html"},{"title":"vectorAXPYvector – Fortran Program","text":"interface private subroutine vectorAXPYvector(Obj1, alpha, Obj2) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(inout) :: Obj1 (:) real(kind=DFP), intent(in) :: alpha class( RealVector_ ), intent(in) :: Obj2 (:)","tags":"","loc":"interface/vectoraxpyvector.html"},{"title":"vectorCOPYvector – Fortran Program","text":"interface private subroutine vectorCOPYvector(Obj1, Obj2) Arguments Type Intent Optional Attributes Name type( RealVector_ ), intent(inout), ALLOCATABLE :: Obj1 (:) class( RealVector_ ), intent(in) :: Obj2 (:)","tags":"","loc":"interface/vectorcopyvector.html"},{"title":"vectorDOTscalar – Fortran Program","text":"interface private pure function vectorDOTscalar(Obj1, Obj2) result(Ans) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj1 (:) class( RealVector_ ), intent(in) :: Obj2 Return Value real(kind=DFP)","tags":"","loc":"interface/vectordotscalar.html"},{"title":"vectorDOTvector – Fortran Program","text":"interface private pure function vectorDOTvector(Obj1, Obj2) result(Ans) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj1 (:) class( RealVector_ ), intent(in) :: Obj2 (:) Return Value real(kind=DFP)","tags":"","loc":"interface/vectordotvector.html"},{"title":"vectorSHALLOWCOPYvector – Fortran Program","text":"interface private subroutine vectorSHALLOWCOPYvector(Obj1, Obj2) Arguments Type Intent Optional Attributes Name type( RealVector_ ), intent(inout), ALLOCATABLE :: Obj1 (:) class( RealVector_ ), intent(in) :: Obj2 (:)","tags":"","loc":"interface/vectorshallowcopyvector.html"},{"title":"vectorSWAPvector – Fortran Program","text":"interface private subroutine vectorSWAPvector(Obj1, Obj2) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(inout) :: Obj1 (:) class( RealVector_ ), intent(inout) :: Obj2 (:)","tags":"","loc":"interface/vectorswapvector.html"},{"title":"AllocateData – Fortran Program","text":"public interface AllocateData Contents Module Procedures initiate_obj Module Procedures private interface initiate_obj () This subroutine allocate the memory for various matrices in the object Arguments None","tags":"","loc":"interface/allocatedata~4.html"},{"title":"DeallocateData – Fortran Program","text":"public interface DeallocateData Contents Module Procedures deallocate_data Module Procedures private interface deallocate_data () this subroutine deallocates the data stored inside ElemShapeData_ Arguments None","tags":"","loc":"interface/deallocatedata~26.html"},{"title":"Display – Fortran Program","text":"public interface Display Contents Module Procedures display_obj Module Procedures private interface display_obj () This subroutine display the content of object Arguments None","tags":"","loc":"interface/display~28.html"},{"title":"H1_Lagrange – Fortran Program","text":"interface private subroutine H1_Lagrange(Obj, Quad, RefElem, ContinuityType, InterpolType) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(inout) :: Obj class(QuadraturePoint_), intent(in) :: Quad class(ReferenceElement_), intent(in) :: RefElem class(H1_), intent(in) :: ContinuityType class(LagrangeInterpolation_), intent(in) :: InterpolType","tags":"","loc":"interface/h1_lagrange.html"},{"title":"Hexahedron_H1_Lagrange – Fortran Program","text":"interface private subroutine Hexahedron_H1_Lagrange(Obj, Quad, RefElem, ContinuityType, InterpolType) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(inout) :: Obj class(QuadraturePoint_), intent(in) :: Quad class(ReferenceHexahedron_), intent(in) :: RefElem class(H1_), intent(in) :: ContinuityType class(LagrangeInterpolation_), intent(in) :: InterpolType","tags":"","loc":"interface/hexahedron_h1_lagrange.html"},{"title":"Initiate – Fortran Program","text":"public interface Initiate Contents Module Procedures stsd_initiate Module Procedures private interface stsd_initiate () This subroutine initiate time shape function data in STElemShapeData_ Arguments None","tags":"","loc":"interface/initiate~30.html"},{"title":"Initiate – Fortran Program","text":"private interface Initiate Contents Module Procedures H1_Lagrange Module Procedures private interface H1_Lagrange () Arguments None","tags":"","loc":"interface/initiate~31.html"},{"title":"Interpolation – Fortran Program","text":"public interface Interpolation Contents Module Procedures interpol_scalar interpol_vector interpol_matrix Module Procedures private interface interpol_scalar () This function returns the interpolation of a scalar Arguments None private interface interpol_vector () This function returns the interpolation of vector Arguments None private interface interpol_matrix () This function returns the interpolation of matrix Arguments None","tags":"","loc":"interface/interpolation.html"},{"title":"Line_H1_Lagrange – Fortran Program","text":"interface This subroutine computes the shape functions given by Lagrange polynomials !! over reference line element private subroutine Line_H1_Lagrange(Obj, Quad, RefElem, ContinuityType, InterpolType) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(inout) :: Obj class(QuadraturePoint_), intent(in) :: Quad Quadrature points where shapefunctions will be evaluated class(ReferenceLine_), intent(in) :: RefElem Reference element where shape functions will be defined class(H1_), intent(in) :: ContinuityType H1 (nodal) Continuity type class(LagrangeInterpolation_), intent(in) :: InterpolType Lagrange polynomial will be used for interpolation Description This subroutine computes shape functions, lagrange polynomials, over\n reference line element\n The interpolation functions are defined inside the reference element itself\n The order of shape functions are also included inside the refelem","tags":"","loc":"interface/line_h1_lagrange.html"},{"title":"Prism_H1_Lagrange – Fortran Program","text":"interface private subroutine Prism_H1_Lagrange(Obj, Quad, RefElem, ContinuityType, InterpolType) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(inout) :: Obj class(QuadraturePoint_), intent(in) :: Quad class(ReferencePrism_), intent(in) :: RefElem class(H1_), intent(in) :: ContinuityType class(LagrangeInterpolation_), intent(in) :: InterpolType","tags":"","loc":"interface/prism_h1_lagrange.html"},{"title":"Pyramid_H1_Lagrange – Fortran Program","text":"interface private subroutine Pyramid_H1_Lagrange(Obj, Quad, RefElem, ContinuityType, InterpolType) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(inout) :: Obj class(QuadraturePoint_), intent(in) :: Quad class(ReferencePyramid_), intent(in) :: RefElem class(H1_), intent(in) :: ContinuityType class(LagrangeInterpolation_), intent(in) :: InterpolType","tags":"","loc":"interface/pyramid_h1_lagrange.html"},{"title":"Quadrangle_H1_Lagrange – Fortran Program","text":"interface private subroutine Quadrangle_H1_Lagrange(Obj, Quad, RefElem, ContinuityType, InterpolType) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(inout) :: Obj class(QuadraturePoint_), intent(in) :: Quad class(ReferenceQuadrangle_), intent(in) :: RefElem class(H1_), intent(in) :: ContinuityType class(LagrangeInterpolation_), intent(in) :: InterpolType","tags":"","loc":"interface/quadrangle_h1_lagrange.html"},{"title":"STInterpolation – Fortran Program","text":"private interface STInterpolation Contents Module Procedures stsd_interpol_scalar stsd_interpol_vector stsd_interpol_matrix Module Procedures private interface stsd_interpol_scalar () This function performs interpolations of scalar Arguments None private interface stsd_interpol_vector () This function performs interpolations of vector Arguments None private interface stsd_interpol_matrix () This function performs interpolations of matrix Arguments None","tags":"","loc":"interface/stinterpolation.html"},{"title":"Tetrahedron_H1_Lagrange – Fortran Program","text":"interface private subroutine Tetrahedron_H1_Lagrange(Obj, Quad, RefElem, ContinuityType, InterpolType) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(inout) :: Obj class(QuadraturePoint_), intent(in) :: Quad class(ReferenceTetrahedron_), intent(in) :: RefElem class(H1_), intent(in) :: ContinuityType class(LagrangeInterpolation_), intent(in) :: InterpolType","tags":"","loc":"interface/tetrahedron_h1_lagrange.html"},{"title":"Triangle_H1_Lagrange – Fortran Program","text":"interface This subroutine computes the shape functions given by Lagrange polynomials !! over reference triangle element private subroutine Triangle_H1_Lagrange(Obj, Quad, RefElem, ContinuityType, InterpolType) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(inout) :: Obj class(QuadraturePoint_), intent(in) :: Quad class(ReferenceTriangle_), intent(in) :: RefElem class(H1_), intent(in) :: ContinuityType class(LagrangeInterpolation_), intent(in) :: InterpolType Description This subroutine computes shape functions, lagrange polynomials, over\n reference triangle element","tags":"","loc":"interface/triangle_h1_lagrange.html"},{"title":"deallocate_data – Fortran Program","text":"interface this subroutine deallocates the data stored inside ElemShapeData_ private subroutine deallocate_data(Obj) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(inout) :: Obj Description This subroutine deallocates the data stored inside ElemShapeData_ and STElemShapeData_","tags":"","loc":"interface/deallocate_data~3.html"},{"title":"display_obj – Fortran Program","text":"interface This subroutine display the content of object private subroutine display_obj(Obj, Msg, UnitNo) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Obj character(len=*), intent(in) :: Msg integer(kind=I4B), intent(in), optional :: UnitNo Description This subroutine displays the content of ElemShapeData_ and STElemShapeData_","tags":"","loc":"interface/display_obj~6.html"},{"title":"getInterpolation – Fortran Program","text":"public interface getInterpolation Contents Module Procedures get_interpol_scalar get_interpol_vector get_interpol_matrix get_interpol_fevar_scalar get_interpol_fevar_matrix Module Procedures private interface get_interpol_scalar () This subroutine performs interpolations Arguments None private interface get_interpol_vector () This subroutine performs interpolation of a vector Arguments None private interface get_interpol_matrix () This subroutine performs interpolation of matrix Arguments None private interface get_interpol_fevar_scalar () Arguments None private interface get_interpol_fevar_matrix () This subroutine performs interpolation of matrix Arguments None","tags":"","loc":"interface/getinterpolation.html"},{"title":"getInterpolation – Fortran Program","text":"private interface getInterpolation Contents Module Procedures stsd_get_interpol_scalar stsd_get_interpol_vector stsd_get_interpol_matrix stsd_get_interpol_fevar_scalar stsd_get_interpol_fevar_matrix Module Procedures private interface stsd_get_interpol_scalar () This subroutine performs interpolations of scalar Arguments None private interface stsd_get_interpol_vector () This subroutine performs interpolation of a vector Arguments None private interface stsd_get_interpol_matrix () This subroutine performs interpolation of matrix Arguments None private interface stsd_get_interpol_fevar_scalar () Arguments None private interface stsd_get_interpol_fevar_matrix () Arguments None","tags":"","loc":"interface/getinterpolation~2.html"},{"title":"getLocalGradient – Fortran Program","text":"private interface getLocalGradient Contents Module Procedures getLocalGradient_scalar getLocalGradient_vector stsd_getLocalGradient_scalar stsd_getLocalGradient_vector Module Procedures private interface getLocalGradient_scalar () This subroutine returns the local gradient of a scalar Arguments None private interface getLocalGradient_vector () This subroutine returns the local gradient of a vector Arguments None private interface stsd_getLocalGradient_scalar () This subroutine returns the local gradient of a scalar Arguments None private interface stsd_getLocalGradient_vector () This subroutine returns the local gradient of a vector Arguments None","tags":"","loc":"interface/getlocalgradient.html"},{"title":"getLocalGradient_scalar – Fortran Program","text":"interface This subroutine returns the local gradient of a scalar private subroutine getLocalGradient_scalar(Obj, dPhidXi, Val) Arguments Type Intent Optional Attributes Name class(ElemShapeData_), intent(in) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: dPhidXi (:,:) real(kind=DFP), intent(in) :: Val (:) Space nodal values of scalar Description This subroutine returns the local gradient of a scalar from space\n nodal values \\frac{\\partial \\phi }{\\partial \\xi_{i} } =\\phi_{I} \\frac{\\partial N&#94;{I}}\n {\\partial \\xi_{i} }","tags":"","loc":"interface/getlocalgradient_scalar.html"},{"title":"getLocalGradient_vector – Fortran Program","text":"interface This subroutine returns the local gradient of a vector private subroutine getLocalGradient_vector(Obj, dVdXi, Val) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: dVdXi (:,:,:) local gradient at integration points real(kind=DFP), intent(in) :: Val (:,:) nodal values of vector in xiJ format Description This subroutine returns the local gradient of a vector","tags":"","loc":"interface/getlocalgradient_vector.html"},{"title":"getProjectionOfdNTdXt – Fortran Program","text":"public interface getProjectionOfdNTdXt Contents Module Procedures getProjectionOfdNTdXt_constvector getProjectionOfdNTdXt_fevar Module Procedures private interface getProjectionOfdNTdXt_constvector () This subroutine computes the projection of dNTdXt on a vector Arguments None private interface getProjectionOfdNTdXt_fevar () This subroutine computes the projection of dNTdXt on a vector Arguments None","tags":"","loc":"interface/getprojectionofdntdxt.html"},{"title":"getProjectionOfdNTdXt_constvector – Fortran Program","text":"interface This subroutine computes the projection of dNTdXt on a vector private subroutine getProjectionOfdNTdXt_constvector(Obj, cdNTdXt, Val) Arguments Type Intent Optional Attributes Name class(STElemshapeData_), intent(in) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: cdNTdXt (:,:,:) returned $c_{i}\\frac{\\partial N&#94;{I} T_a}{\\partial x_{i}}$ real(kind=DFP), intent(in) :: Val (:) constant value of vector Description This subroutine computes the projcetion cdNTdXt on the vector Val Here the vector Val is constant in space and time P&#94;{I,a}=c_{i}\\frac{\\partial N&#94;{I} T_a}{\\partial x_{i}}","tags":"","loc":"interface/getprojectionofdntdxt_constvector.html"},{"title":"getProjectionOfdNTdXt_fevar – Fortran Program","text":"interface This subroutine computes the projection of dNTdXt on a vector private subroutine getProjectionOfdNTdXt_fevar(Obj, cdNTdXt, Val) Arguments Type Intent Optional Attributes Name class(STElemshapeData_), intent(in) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: cdNTdXt (:,:,:) returned $c_{i}\\frac{\\partial N&#94;{I} T_a}{\\partial x_{i}}$ type(FEVariable_), intent(in) :: Val constant value of vector Description This subroutine computes the projcetion cdNTdXt on the vector Val Here the vector Val is constant in space and time P&#94;{I,a}=c_{i}\\frac{\\partial N&#94;{I} T_a}{\\partial x_{i}}","tags":"","loc":"interface/getprojectionofdntdxt_fevar.html"},{"title":"getProjectionOfdNdXt – Fortran Program","text":"public interface getProjectionOfdNdXt Contents Module Procedures getProjectionOfdNdXt_spacevalues getProjectionOfdNdXt_fevar Module Procedures private interface getProjectionOfdNdXt_spacevalues () This subroutine computes the projection of dNdXt on a vector Arguments None private interface getProjectionOfdNdXt_fevar () This subroutine computes the projection of dNdXt on a vector Arguments None","tags":"","loc":"interface/getprojectionofdndxt.html"},{"title":"getProjectionOfdNdXt_fevar – Fortran Program","text":"interface This subroutine computes the projection of dNdXt on a vector private subroutine getProjectionOfdNdXt_fevar(Obj, cdNdXt, Val) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: cdNdXt (:,:) returned $c_{i}\\frac{\\partial N&#94;{I}}{\\partial x_{i}}$ class(FEVariable_), intent(in) :: Val constant value of vector Description This subroutine computes the projcetion cdNdXt on the vector Val Here the vector Val is constant in space and time P&#94;{I}=c_{i}\\frac{\\partial N&#94;{I}}{\\partial x_{i}}","tags":"","loc":"interface/getprojectionofdndxt_fevar.html"},{"title":"getProjectionOfdNdXt_spacevalues – Fortran Program","text":"interface This subroutine computes the projection of dNdXt on a vector private subroutine getProjectionOfdNdXt_spacevalues(Obj, cdNdXt, Val) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: cdNdXt (:,:) returned $c_{i}\\frac{\\partial N&#94;{I}}{\\partial x_{i}}$ real(kind=DFP), intent(in) :: Val (:) constant value of vector Description This subroutine computes the projcetion cdNdXt on the vector Val Here the vector Val is constant in space and time P&#94;{I}=c_{i}\\frac{\\partial N&#94;{I}}{\\partial x_{i}}","tags":"","loc":"interface/getprojectionofdndxt_spacevalues.html"},{"title":"getSpatialGradient – Fortran Program","text":"public interface getSpatialGradient Contents Module Procedures getSpatialGradient_scalar getSpatialGradient_vector stsd_getSpatialGradient_scalar stsd_getSpatialGradient_vector Module Procedures private interface getSpatialGradient_scalar () This subroutine returns the spatial gradient of scalar Arguments None private interface getSpatialGradient_vector () This subroutine returns the spatial gradient of vector Arguments None private interface stsd_getSpatialGradient_scalar () This subroutine returns the spatial gradient of scalar Arguments None private interface stsd_getSpatialGradient_vector () This subroutine returns the spatial gradient of vector Arguments None","tags":"","loc":"interface/getspatialgradient.html"},{"title":"getSpatialGradient_scalar – Fortran Program","text":"interface This subroutine returns the spatial gradient of scalar private subroutine getSpatialGradient_scalar(Obj, dPhidXt, Val) Arguments Type Intent Optional Attributes Name class(ElemShapeData_), intent(in) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: dPhidXt (:,:) Spatial gradient of scalar real(kind=DFP), intent(in) :: Val (:) Nodal values of scalar Description This subroutine returns the spatial gradient of scalar","tags":"","loc":"interface/getspatialgradient_scalar.html"},{"title":"getSpatialGradient_vector – Fortran Program","text":"interface This subroutine returns the spatial gradient of vector private subroutine getSpatialGradient_vector(Obj, dVdXt, Val) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: dVdXt (:,:,:) spatial gradient of val at integration points real(kind=DFP), intent(in) :: Val (:,:) nodal values of vector in xiJ format Description This subroutine returns the spatial gradient of a vector","tags":"","loc":"interface/getspatialgradient_vector.html"},{"title":"getUnitNormal – Fortran Program","text":"public interface getUnitNormal Contents Module Procedures getUnitNormal_vector getUnitNormal_scalar Module Procedures private interface getUnitNormal_vector () Arguments None private interface getUnitNormal_scalar () This subroutine can be used in SUPG formulation Arguments None","tags":"","loc":"interface/getunitnormal.html"},{"title":"getUnitNormal_scalar – Fortran Program","text":"interface This subroutine can be used in SUPG formulation private subroutine getUnitNormal_scalar(Obj, R, Val) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: R (:,:) real(kind=DFP), intent(in) :: Val (:) Description This routine can be used in the SUPG formulation \\nabla \\vert phi \\vert / \\vert (\\nabla \\vert phi \\vert) \\vert","tags":"","loc":"interface/getunitnormal_scalar.html"},{"title":"getUnitNormal_vector – Fortran Program","text":"interface private subroutine getUnitNormal_vector(Obj, R, Val) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(inout) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: R (:,:) real(kind=DFP), intent(in) :: Val (:,:)","tags":"","loc":"interface/getunitnormal_vector.html"},{"title":"get_interpol_fevar_matrix – Fortran Program","text":"interface This subroutine performs interpolation of matrix private subroutine get_interpol_fevar_matrix(Obj, Interpol, Val) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Obj real(kind=DFP), intent(inout) :: Interpol (:,:,:) type(FEVariable_), intent(in) :: Val Description This subroutine performs interpolation of matrix","tags":"","loc":"interface/get_interpol_fevar_matrix.html"},{"title":"get_interpol_fevar_scalar – Fortran Program","text":"interface private subroutine get_interpol_fevar_scalar(Obj, Interpol, Val) Arguments Type Intent Optional Attributes Name class(ElemShapeData_), intent(in) :: Obj real(kind=DFP), intent(inout) :: Interpol (:) type(FEVariable_), intent(in) :: Val","tags":"","loc":"interface/get_interpol_fevar_scalar.html"},{"title":"get_interpol_matrix – Fortran Program","text":"interface This subroutine performs interpolation of matrix private subroutine get_interpol_matrix(Obj, Interpol, Val) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: Interpol (:,:,:) real(kind=DFP), intent(in) :: Val (:,:,:) nodal value of matrix Description This subroutine performs interpolation of matrix","tags":"","loc":"interface/get_interpol_matrix.html"},{"title":"get_interpol_scalar – Fortran Program","text":"interface This subroutine performs interpolations private subroutine get_interpol_scalar(Obj, Interpol, Val) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: Interpol (:) Interpolation value of val at integration points real(kind=DFP), intent(in) :: Val (:) spatial nodal values of scalar Description This subroutine performs interpolation of a scalar from its spatial nodal\n values. u=u_{I}N&#94;{I}","tags":"","loc":"interface/get_interpol_scalar.html"},{"title":"get_interpol_vector – Fortran Program","text":"interface This subroutine performs interpolation of a vector private subroutine get_interpol_vector(Obj, Interpol, Val) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: Interpol (:,:) Interpol(:,ips) => interpolation value at integration points real(kind=DFP), intent(in) :: Val (:,:) nodal values of vector in xiJ format Description This subroutine performs interpolation of a vector from its spatial\n nodal values u_{i}=u_{iI}N&#94;{I}","tags":"","loc":"interface/get_interpol_vector.html"},{"title":"initiate_obj – Fortran Program","text":"interface This subroutine allocate the memory for various matrices in the object private subroutine initiate_obj(Obj, nsd, xidim, nns, nips) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(inout) :: Obj object to be returned integer(kind=I4B), intent(in) :: nsd spatial dimension integer(kind=I4B), intent(in) :: xidim xidimension integer(kind=I4B), intent(in) :: nns number of nodes in element integer(kind=I4B), intent(in) :: nips number of integration points Description This subroutine allocates the memory for various arrays in & ElemShapeData_ object","tags":"","loc":"interface/initiate_obj~6.html"},{"title":"interpol_matrix – Fortran Program","text":"interface This function returns the interpolation of matrix private pure function interpol_matrix(Obj, Val) result(Interpol) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Obj real(kind=DFP), intent(in) :: Val (:,:,:) Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:,:) Description This function returns the interpolation of matrix","tags":"","loc":"interface/interpol_matrix.html"},{"title":"interpol_scalar – Fortran Program","text":"interface This function returns the interpolation of a scalar private pure function interpol_scalar(Obj, Val) result(Interpol) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Obj real(kind=DFP), intent(in) :: Val (:) Return Value real(kind=DFP),\n  ALLOCATABLE,(:) Description This function returns interpolation of scalar","tags":"","loc":"interface/interpol_scalar.html"},{"title":"interpol_vector – Fortran Program","text":"interface This function returns the interpolation of vector private pure function interpol_vector(Obj, Val) result(Interpol) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Obj real(kind=DFP), intent(in) :: Val (:,:) Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:) Description This function returns the interpolation of vectors","tags":"","loc":"interface/interpol_vector.html"},{"title":"setBarycentricCoord – Fortran Program","text":"public interface setBarycentricCoord Contents Module Procedures set_coord stsd_set_coord Module Procedures private interface set_coord () This subroutine set the Barycentric coordinates Arguments None private interface stsd_set_coord () This subroutine set the Barycentric coordinates Arguments None","tags":"","loc":"interface/setbarycentriccoord.html"},{"title":"setJacobian – Fortran Program","text":"public interface setJacobian Contents Module Procedures set_jacobian stsd_set_jacobian Module Procedures private interface set_jacobian () This subroutine set the jacobian Arguments None private interface stsd_set_jacobian () This subroutine set the jacobian using space-time nodal coords Arguments None","tags":"","loc":"interface/setjacobian.html"},{"title":"setJs – Fortran Program","text":"public interface setJs Contents Module Procedures set_Js Module Procedures private interface set_Js () This subroutine set the determinent of jacobian Arguments None","tags":"","loc":"interface/setjs.html"},{"title":"setNormal – Fortran Program","text":"public interface setNormal Contents Module Procedures set_normal Module Procedures private interface set_normal () Arguments None","tags":"","loc":"interface/setnormal.html"},{"title":"setThickness – Fortran Program","text":"public interface setThickness Contents Module Procedures set_thickness stsd_set_thickness Module Procedures private interface set_thickness () This subroutine set the thickness field Arguments None private interface stsd_set_thickness () This subroutine set the thickness field Arguments None","tags":"","loc":"interface/setthickness.html"},{"title":"setValue – Fortran Program","text":"public interface setValue Contents Module Procedures set_value stsd_set_value Module Procedures private interface set_value () This subroutine set parameters defined on physical element Arguments None private interface stsd_set_value () This subroutine set parameters defined on physical element Arguments None","tags":"","loc":"interface/setvalue~4.html"},{"title":"set_Js – Fortran Program","text":"interface This subroutine set the determinent of jacobian private subroutine set_Js(Obj) Arguments Type Intent Optional Attributes Name class(ElemShapeData_), intent(inout) :: Obj Description This subroutine will internally set the value of jacobian","tags":"","loc":"interface/set_js.html"},{"title":"set_coord – Fortran Program","text":"interface This subroutine set the Barycentric coordinates private subroutine set_coord(Obj, Val, N) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val (:,:) Nodal coordinates in xiJ format real(kind=DFP), intent(in) :: N (:,:) When element is not an isoparametric we can supply N. Description This subroutine set the barycentric coordinates x_i = x_{iI} N&#94;{I}","tags":"","loc":"interface/set_coord.html"},{"title":"set_dNdXt_internally – Fortran Program","text":"interface This subroutine set $\\frac{d N}{d X_t}$ internally private subroutine set_dNdXt_internally(Obj) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(inout) :: Obj Description This subroutine will internally set dNdXt .\n It use the inverse of jacobian stored internally, so make sure jacobian is\n set before calling this  subroutine.","tags":"","loc":"interface/set_dndxt_internally.html"},{"title":"set_jacobian – Fortran Program","text":"interface This subroutine set the jacobian private subroutine set_jacobian(Obj, Val, dNdXi) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val (:,:) nodal coordinates in xiJ format real(kind=DFP), intent(in) :: dNdXi (:,:,:) Description This subroutine set the jacobian by using the nodal coordinates \\frac{d x_i}{d \\xi_j} = x_{iI}\\frac{d N&#94;I}{d \\xi_j}","tags":"","loc":"interface/set_jacobian.html"},{"title":"set_normal – Fortran Program","text":"interface private subroutine set_normal(Obj) Arguments Type Intent Optional Attributes Name class(ElemShapeData_), intent(inout) :: Obj","tags":"","loc":"interface/set_normal.html"},{"title":"set_thickness – Fortran Program","text":"interface This subroutine set the thickness field private subroutine set_thickness(Obj, Val, N) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val (:) Nodal values of thickness real(kind=DFP), intent(in) :: N (:,:) Nodal values of thickness Description This subroutine set the thickness field\n Here Val denotes the nodal value of thickeness d = d_{I} N&#94;{I}","tags":"","loc":"interface/set_thickness.html"},{"title":"set_value – Fortran Program","text":"interface This subroutine set parameters defined on physical element private subroutine set_value(Obj, Val, N, dNdXi) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val (:,:) Spatial nodal coordinates real(kind=DFP), intent(in) :: N (:,:) Shape function for geometry real(kind=DFP), intent(in) :: dNdXi (:,:,:) Local derivative of shape functions for geometry Description This subroutine set parameters defined on physical element Val denotes nodal coordinates of element in xiJ format This subroutine will call setJacobian setJs setdNdXt setBarycentricCoord The facility of N and dNdXi allow us to handle non-isoparametric\n elements Note In case Obj is instance of STElemShapeData_ then val will denotes\n coordinates of spatial nodes at some time in [tn, tn+1]","tags":"","loc":"interface/set_value.html"},{"title":"setdNTdXt – Fortran Program","text":"public interface setdNTdXt Contents Module Procedures stsd_set_dNTdXt_internally Module Procedures private interface stsd_set_dNTdXt_internally () This subroutine set dNTdXt by using internal data Arguments None","tags":"","loc":"interface/setdntdxt.html"},{"title":"setdNTdt – Fortran Program","text":"public interface setdNTdt Contents Module Procedures stsd_set_dNTdt Module Procedures private interface stsd_set_dNTdt () This subroutine set dNTdt by using the space-time nodal values Arguments None","tags":"","loc":"interface/setdntdt.html"},{"title":"setdNdXt – Fortran Program","text":"public interface setdNdXt Contents Module Procedures set_dNdXt_internally Module Procedures private interface set_dNdXt_internally () This subroutine set $\\frac{d N}{d X_t}$ internally Arguments None","tags":"","loc":"interface/setdndxt.html"},{"title":"stsd_getLocalGradient_scalar – Fortran Program","text":"interface This subroutine returns the local gradient of a scalar private subroutine stsd_getLocalGradient_scalar(Obj, dPhidXi, Val) Arguments Type Intent Optional Attributes Name class(STElemShapeData_), intent(in) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: dPhidXi (:,:) local gradient of scalar real(kind=DFP), intent(in) :: Val (:,:) space-time nodal values Description This subroutine returns the local gradient of a scalar from space\n time nodal values \\frac{\\partial \\phi }{\\partial \\xi_{i} } =\\phi&#94;{a}_{I} T_{a}\\frac\n{\\partial N&#94;{I}}{\\partial \\xi_{i} }","tags":"","loc":"interface/stsd_getlocalgradient_scalar.html"},{"title":"stsd_getLocalGradient_vector – Fortran Program","text":"interface This subroutine returns the local gradient of a vector private subroutine stsd_getLocalGradient_vector(Obj, dVdXi, Val) Arguments Type Intent Optional Attributes Name class(STElemshapeData_), intent(in) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: dVdXi (:,:,:) local gradient at integration points real(kind=DFP), intent(in) :: Val (:,:,:) space-time nodal values of vector in xiJa format Description This subroutine returns the local gradient of a vector using space-time\n nodal coordinates","tags":"","loc":"interface/stsd_getlocalgradient_vector.html"},{"title":"stsd_getSpatialGradient_scalar – Fortran Program","text":"interface This subroutine returns the spatial gradient of scalar private subroutine stsd_getSpatialGradient_scalar(Obj, dPhidXt, Val) Arguments Type Intent Optional Attributes Name class(STElemShapeData_), intent(in) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: dPhidXt (:,:) Spatial gradient of scalar real(kind=DFP), intent(in) :: Val (:,:) space-time Nodal values of scalar Description This subroutine returns the spatial gradient of scalar","tags":"","loc":"interface/stsd_getspatialgradient_scalar.html"},{"title":"stsd_getSpatialGradient_vector – Fortran Program","text":"interface This subroutine returns the spatial gradient of vector private subroutine stsd_getSpatialGradient_vector(Obj, dVdXt, Val) Arguments Type Intent Optional Attributes Name class(STElemshapeData_), intent(in) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: dVdXt (:,:,:) spatial gradient of val at integration points real(kind=DFP), intent(in) :: Val (:,:,:) space-time nodal values of vector in xiJa format Description This subroutine returns the spatial gradient of a vector from its\n space-time nodal values","tags":"","loc":"interface/stsd_getspatialgradient_vector.html"},{"title":"stsd_get_interpol_fevar_matrix – Fortran Program","text":"interface private subroutine stsd_get_interpol_fevar_matrix(Obj, Interpol, Val) Arguments Type Intent Optional Attributes Name class(STElemShapeData_), intent(in) :: Obj (:) real(kind=DFP), intent(inout) :: Interpol (:,:,:,:) type(FEVariable_), intent(in) :: Val","tags":"","loc":"interface/stsd_get_interpol_fevar_matrix.html"},{"title":"stsd_get_interpol_fevar_scalar – Fortran Program","text":"interface private subroutine stsd_get_interpol_fevar_scalar(Obj, Interpol, Val) Arguments Type Intent Optional Attributes Name class(STElemShapeData_), intent(in) :: Obj (:) real(kind=DFP), intent(inout) :: Interpol (:,:) type(FEVariable_), intent(in) :: Val","tags":"","loc":"interface/stsd_get_interpol_fevar_scalar.html"},{"title":"stsd_get_interpol_matrix – Fortran Program","text":"interface This subroutine performs interpolation of matrix private subroutine stsd_get_interpol_matrix(Obj, Interpol, Val) Arguments Type Intent Optional Attributes Name class(STElemshapeData_), intent(in) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: Interpol (:,:,:) real(kind=DFP), intent(in) :: Val (:,:,:,:) nodal value of matrix Description This subroutine performs interpolation of matrix from its space-time\n nodal values","tags":"","loc":"interface/stsd_get_interpol_matrix.html"},{"title":"stsd_get_interpol_scalar – Fortran Program","text":"interface This subroutine performs interpolations of scalar private subroutine stsd_get_interpol_scalar(Obj, Interpol, Val) Arguments Type Intent Optional Attributes Name class(STElemshapeData_), intent(in) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: Interpol (:) Interpolation value of val at integration points real(kind=DFP), intent(in) :: Val (:,:) spatial nodal values of scalar Description This subroutine performs interpolation of a scalar from its space-time nodal\n values. u=u&#94;{a}_{I}N&#94;{I}T_{a}","tags":"","loc":"interface/stsd_get_interpol_scalar.html"},{"title":"stsd_get_interpol_vector – Fortran Program","text":"interface This subroutine performs interpolation of a vector private subroutine stsd_get_interpol_vector(Obj, Interpol, Val) Arguments Type Intent Optional Attributes Name class(STElemshapeData_), intent(in) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: Interpol (:,:) Interpol(:,ips) => interpolation value at integration points real(kind=DFP), intent(in) :: Val (:,:,:) space-time nodal values of vector in xiJa format Description This subroutine performs interpolation of a vector from its space-time\n nodal values u_{i}=u&#94;{a}_{iI}N&#94;{I}T_{a}","tags":"","loc":"interface/stsd_get_interpol_vector.html"},{"title":"stsd_initiate – Fortran Program","text":"interface This subroutine initiate time shape function data in STElemShapeData_ private subroutine stsd_initiate(Obj, elemsd) Arguments Type Intent Optional Attributes Name type(STElemShapeData_), intent(inout), ALLOCATABLE :: Obj (:) type(ElemShapeData_), intent(in) :: elemsd Description This subroutine initiate time shape function data in STElemShapeData_ .\n To do so effeciently we construct local shape function for time element\n externally by using ElemShapeData_ , and supply this information. This subroutine set T , dTdTheta , Jt , Wt , Theta it will allocate Obj the size of Obj will be equal to total number of integration points in\n   in time domain","tags":"","loc":"interface/stsd_initiate.html"},{"title":"stsd_interpol_matrix – Fortran Program","text":"interface This function performs interpolations of matrix private pure function stsd_interpol_matrix(Obj, Val) result(Interpol) Arguments Type Intent Optional Attributes Name class(STElemshapeData_), intent(in) :: Obj real(kind=DFP), intent(in) :: Val (:,:,:,:) spatial nodal values of matrix Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:,:) Interpolation value of val at integration points Description This function performs interpolation of a matrix from its space-time nodal\n values. u=u&#94;{a}_{I}N&#94;{I}T_{a}","tags":"","loc":"interface/stsd_interpol_matrix.html"},{"title":"stsd_interpol_scalar – Fortran Program","text":"interface This function performs interpolations of scalar private pure function stsd_interpol_scalar(Obj, Val) result(Interpol) Arguments Type Intent Optional Attributes Name class(STElemshapeData_), intent(in) :: Obj real(kind=DFP), intent(in) :: Val (:,:) space-time nodal values of scalar Return Value real(kind=DFP),\n  ALLOCATABLE,(:) Interpolation value of val at integration points Description This function performs interpolation of a scalar from its space-time nodal\n values. u=u&#94;{a}_{I}N&#94;{I}T_{a}","tags":"","loc":"interface/stsd_interpol_scalar.html"},{"title":"stsd_interpol_vector – Fortran Program","text":"interface This function performs interpolations of vector private pure function stsd_interpol_vector(Obj, Val) result(Interpol) Arguments Type Intent Optional Attributes Name class(STElemshapeData_), intent(in) :: Obj real(kind=DFP), intent(in) :: Val (:,:,:) spatial nodal values of vector Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:) Interpolation value of val at integration points Description This function performs interpolation of a vector from its space-time nodal\n values. u=u&#94;{a}_{I}N&#94;{I}T_{a}","tags":"","loc":"interface/stsd_interpol_vector.html"},{"title":"stsd_set_coord – Fortran Program","text":"interface This subroutine set the Barycentric coordinates private subroutine stsd_set_coord(Obj, Val, N, T) Arguments Type Intent Optional Attributes Name class(STElemshapeData_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val (:,:,:) space-time Nodal coordinates in xiJ format real(kind=DFP), intent(in) :: N (:,:) N and T are required to handle non isoparametric elements real(kind=DFP), intent(in) :: T (:) N and T are required to handle non isoparametric elements Description This subroutine set the barycentric coordinates by using\n space-time nodal coordinates x=x_{I}&#94;{a} N&#94;I T_a","tags":"","loc":"interface/stsd_set_coord.html"},{"title":"stsd_set_dNTdXt_internally – Fortran Program","text":"interface This subroutine set dNTdXt by using internal data private subroutine stsd_set_dNTdXt_internally(Obj) Arguments Type Intent Optional Attributes Name class(STElemShapeData_), intent(inout) :: Obj Space-time nodal values Description This subroutine set dNTdXt by using internal data\n This subroutine uses inverse of Jacobian, therefore, before calling\n this subroutine make sure to set jacobian \\frac{\\partial N&#94;{I\\  }T_{a}}{\\partial x_{i\\  }}\n =\\frac{\\partial N&#94;{I}T_{a}}{\\partial \\xi_{j} } \\frac{\\partial \\xi_{j} }\n {\\partial x_{i}}","tags":"","loc":"interface/stsd_set_dntdxt_internally.html"},{"title":"stsd_set_dNTdt – Fortran Program","text":"interface This subroutine set dNTdt by using the space-time nodal values private subroutine stsd_set_dNTdt(Obj, Val) Arguments Type Intent Optional Attributes Name class(STElemShapeData_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val (:,:,:) Space-time nodal values Description This subroutine set dNTdt by using space-time nodal values It is important to note that dNTdXt should be allocated before calling This subroutine uses following formula \\frac{\\partial N&#94;{I\\  }T_{a}}{\\partial t} =N&#94;{I}\\frac{\\partial T_{a}}\n {\\partial \\theta } J&#94;{-1}_{t}-\\frac{\\partial N&#94;{I}T_{a}}{\\partial x_{k}}\n \\hat{v}_{k}","tags":"","loc":"interface/stsd_set_dntdt.html"},{"title":"stsd_set_jacobian – Fortran Program","text":"interface This subroutine set the jacobian using space-time nodal coords private subroutine stsd_set_jacobian(Obj, Val, dNdXi, T) Arguments Type Intent Optional Attributes Name class(STElemshapeData_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val (:,:,:) Space time nodal values of coordinates real(kind=DFP), intent(in) :: dNdXi (:,:,:) Local derivative of shape function for geometry real(kind=DFP), intent(in) :: T (:) Shape function for time element Description This subroutine set the jacobian by using space-time nodal coords, dNdXi T are used to handle non-isoparameteric elements. \\frac{d x_i}{d \\xi_j} = x_{iI}&#94;{a}T_a\\frac{d N&#94;I}{d \\xi_j}","tags":"","loc":"interface/stsd_set_jacobian.html"},{"title":"stsd_set_thickness – Fortran Program","text":"interface This subroutine set the thickness field private subroutine stsd_set_thickness(Obj, Val, N, T) Arguments Type Intent Optional Attributes Name class(STElemshapeData_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val (:,:) Space-time nodal values of thickness real(kind=DFP), intent(in) :: N (:,:) Space-time nodal values of thickness real(kind=DFP), intent(in) :: T (:) Space-time nodal values of thickness Description This subroutine set the thickness field\n Here Val denotes the space-time nodal value of thickeness d = d_{I}&#94;{a} N&#94;{I} T_{a}","tags":"","loc":"interface/stsd_set_thickness.html"},{"title":"stsd_set_value – Fortran Program","text":"interface This subroutine set parameters defined on physical element private subroutine stsd_set_value(Obj, Val, N, T, dNdXi) Arguments Type Intent Optional Attributes Name class(STElemshapeData_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val (:,:,:) Spatial nodal coordinates real(kind=DFP), intent(in) :: N (:,:) real(kind=DFP), intent(in) :: T (:) real(kind=DFP), intent(in) :: dNdXi (:,:,:) Description This subroutine set parameters defined on physical element Val denotes coordinates of the space-time element in xiJa format The facility of supplying N , T , and dNdXi allows us to handle\n non-isoparametric element This subroutine will call setJacobian uses dNdXi setJs setdNdXt setBarycentricCoord uses N and T setdNTdXt setdNTdt Note In case of STElemShapeData_ val denotes nodal coordinate at\n some intermediate space-time slab","tags":"","loc":"interface/stsd_set_value.html"},{"title":"Constructor_1 – Fortran Program","text":"private pure function Constructor_1(Dims) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Dims (2) Return Value class(RealMatrix_),\n  POINTER Contents None","tags":"","loc":"proc/constructor_1~7.html"},{"title":"ASSIGNMENT( = ) – Fortran Program","text":"public interface ASSIGNMENT( = ) Contents Module Procedures initiate_obj_val Module Procedures private interface initiate_obj_val () Initiate RealMatrix_ Arguments None","tags":"","loc":"interface/assignment( = )~7.html"},{"title":"AllocateData – Fortran Program","text":"public interface AllocateData Generic subroutine to allocate memory for RealMatrix_ Contents Module Procedures Allocate_Data Module Procedures private interface Allocate_Data () Allocate memory for RealMatrix_ Arguments None","tags":"","loc":"interface/allocatedata~5.html"},{"title":"Allocate_Data – Fortran Program","text":"interface Allocate memory for RealMatrix_ private subroutine Allocate_Data(Obj, Dims) Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Dims (2) Description This subroutine allocate memory for RealMatrix_ Usage fortran\n    call allocateData( Obj, Dims )","tags":"","loc":"interface/allocate_data.html"},{"title":"ArrayPointer – Fortran Program","text":"public interface ArrayPointer Generic function to get pointer to the values in RealMatrix_ Contents Module Procedures f_getPointer_Real Module Procedures private interface f_getPointer_Real () Get pointer to the values stored inside RealMatrix_ Arguments None","tags":"","loc":"interface/arraypointer~3.html"},{"title":"ArrayValues – Fortran Program","text":"public interface ArrayValues Generic function to get values form RealMatrix_ Contents Module Procedures f_getValues_Real f_getSectionValues_Real f_getValuesFromTriplet_Real f_getValues_self f_getSectionValues_Self f_getValuesFromTriplet_self f_getValues_1 f_getValues_2 Module Procedures private interface f_getValues_Real () Returns the values of RealMatrix_ obj in 2D array Arguments None private interface f_getSectionValues_Real () Returns the values of RealMatrix_ obj in 2D array Arguments None private interface f_getValuesFromTriplet_Real () Returns the values of RealMatrix_ obj in 2D array Arguments None private interface f_getValues_self () Returns RealMatrix_ obj from RealMatrix_ Arguments None private interface f_getSectionValues_Self () Returns RealMatrix_ obj from a section of RealMatrix_ Arguments None private interface f_getValuesFromTriplet_self () Returns RealMatrix_ obj from a section of RealMatrix_ Arguments None private interface f_getValues_1 () Returns values in 2D fortran array from RealMatrix_ Read more… Arguments None private interface f_getValues_2 () Returns values in 2D fortran array from RealMatrix_ Read more… Arguments None","tags":"","loc":"interface/arrayvalues~8.html"},{"title":"CONVERT – Fortran Program","text":"private interface CONVERT Generic method to convert data to and from RealMatrix_ Contents Module Procedures Copy_Obj_to_Val Copy_Obj_to_Obj Copy_Val_to_Obj Module Procedures private interface Copy_Obj_to_Val () Copy from RealMatrix_ to 2D fortran array Arguments None private interface Copy_Obj_to_Obj () Copy from RealMatrix_ to another RealMatrix_ Arguments None private interface Copy_Val_to_Obj () Copy from 2D fortran array to RealMatrix_ Arguments None","tags":"","loc":"interface/convert.html"},{"title":"COPY – Fortran Program","text":"public interface COPY Generic method to copy data to and from RealMatrix_ Contents Module Procedures Copy_Obj_to_Val Copy_Obj_to_Obj Copy_Val_to_Obj Module Procedures private interface Copy_Obj_to_Val () Copy from RealMatrix_ to 2D fortran array Arguments None private interface Copy_Obj_to_Obj () Copy from RealMatrix_ to another RealMatrix_ Arguments None private interface Copy_Val_to_Obj () Copy from 2D fortran array to RealMatrix_ Arguments None","tags":"","loc":"interface/copy~3.html"},{"title":"Constructor1 – Fortran Program","text":"interface Fucntion that will initiate RealMatrix_ private pure function Constructor1(Dims) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Dims (2) Return Value type(RealMatrix_) Description function that return RealMatrix_ of specified dimensions Usage fortran\n    obj = RealMatrix( [2,2] )","tags":"","loc":"interface/constructor1~2.html"},{"title":"Convert – Fortran Program","text":"public interface Convert Generic subroutine for covertsion Contents Module Procedures convert_DofToNodes realmat_convert_doftonodes Module Procedures private interface convert_DofToNodes () Rearrange the dofs in finite element matrix Arguments None private interface realmat_convert_doftonodes () Rearrange the dofs in finite element matrix Arguments None","tags":"","loc":"interface/convert~5.html"},{"title":"Convert – Fortran Program","text":"private interface Convert Contents Module Procedures convert_mat4_to_mat2 Module Procedures private interface convert_mat4_to_mat2 () This subroutine converts rank4  matrix to rank2 matrix Arguments None","tags":"","loc":"interface/convert~6.html"},{"title":"Copy_Obj_to_Obj – Fortran Program","text":"interface Copy from RealMatrix_ to another RealMatrix_ private subroutine Copy_Obj_to_Obj(From, To) Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(in) :: From type(RealMatrix_), intent(inout) :: To Description This subroutine copy the contents of RealMatrix_ object to another RealMatrix_ object","tags":"","loc":"interface/copy_obj_to_obj.html"},{"title":"Copy_Obj_to_Val – Fortran Program","text":"interface Copy from RealMatrix_ to 2D fortran array private subroutine Copy_Obj_to_Val(From, To) Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(in) :: From real(kind=DFP), intent(inout), ALLOCATABLE :: To (:,:) Description This subroutine copy the contents of RealMatrix_ object into a 2D\n fortran array","tags":"","loc":"interface/copy_obj_to_val.html"},{"title":"Copy_Val_to_Obj – Fortran Program","text":"interface Copy from 2D fortran array to RealMatrix_ private subroutine Copy_Val_to_Obj(From, To) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: From (:,:) type(RealMatrix_), intent(inout) :: To Description This subroutine copy the contents of a 2D\n fortran array to RealMatrix_ object","tags":"","loc":"interface/copy_val_to_obj.html"},{"title":"DeallocateData – Fortran Program","text":"public interface DeallocateData Generic interface to deallocate RealMatrix_ Contents Module Procedures Deallocate_Data Module Procedures private interface Deallocate_Data () Deallocate data in RealMatrix_ Arguments None","tags":"","loc":"interface/deallocatedata~27.html"},{"title":"Deallocate_Data – Fortran Program","text":"interface Deallocate data in RealMatrix_ private subroutine Deallocate_Data(Obj) Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(inout) :: Obj Description This routine deallocates data stored in Obj Usage fortran\n    call deallocateData( Obj )","tags":"","loc":"interface/deallocate_data~2.html"},{"title":"Display – Fortran Program","text":"public interface Display Generic interface to display content of RealMatrix_ Contents Module Procedures Display_obj Display_obj_vec Module Procedures private interface Display_obj () Display content of RealMatrix_ Arguments None private interface Display_obj_vec () Display content of RealMatrix_ Arguments None","tags":"","loc":"interface/display~29.html"},{"title":"Display_obj – Fortran Program","text":"interface Display content of RealMatrix_ private subroutine Display_obj(Obj, Msg, UnitNo) Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(in) :: Obj character(len=*), intent(in) :: Msg integer(kind=I4B), intent(in), optional :: UnitNo Description This subroutine displays content of RealMatrix_ Usage fortran\n    call display( obj, 'mat', stdout )","tags":"","loc":"interface/display_obj.html"},{"title":"Display_obj_vec – Fortran Program","text":"interface Display content of RealMatrix_ private subroutine Display_obj_vec(Obj, Msg, UnitNo) Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(in) :: Obj (:) character(len=*), intent(in) :: Msg integer(kind=I4B), intent(in), optional :: UnitNo Description This subroutine displays content of RealMatrix_ Usage fortran\n    call display( obj, 'mat', stdout )","tags":"","loc":"interface/display_obj_vec.html"},{"title":"Eye – Fortran Program","text":"public interface Eye Generic interface for obtaining identity matrix in array or RealMatrix_ Contents Module Procedures eye_int eye_obj eye_real eye_real_b Module Procedures private interface eye_int () Return identity matrix of integers Arguments None private interface eye_obj () Return identity matrix of type RealMatrix_ Arguments None private interface eye_real () Return identity matrix of real numbers Arguments None private interface eye_real_b () Return identity matrix of real number Arguments None","tags":"","loc":"interface/eye.html"},{"title":"Initiate – Fortran Program","text":"public interface Initiate Generic interface to initiate RealMatrix_ Contents Module Procedures initiate_obj_vector_a initiate_obj_vector_b initiate_obj initiate_obj_val Module Procedures private interface initiate_obj_vector_a () Initiate RealMatrix_ Arguments None private interface initiate_obj_vector_b () Initiate RealMatrix_ Arguments None private interface initiate_obj () Initiate RealMatrix_ Arguments None private interface initiate_obj_val () Initiate RealMatrix_ Arguments None","tags":"","loc":"interface/initiate~32.html"},{"title":"JacobiMethod – Fortran Program","text":"public interface JacobiMethod Generic subroutine for computing eigen value of a symmetric matrix Contents Module Procedures eig_jacobi_method Module Procedures private interface eig_jacobi_method () Returns all the eigenvalues of symmetric matrix Arguments None","tags":"","loc":"interface/jacobimethod.html"},{"title":"MakeDiagonalCopies – Fortran Program","text":"public interface MakeDiagonalCopies Generic subroutine to make diagonal copies of RealMatrix_ and 2d arrays Contents Module Procedures realmat_make_diag_copy1 realmat_make_diag_copy2 realmat_make_diag_copy3 realmat_make_diag_copy4 Module Procedures private interface realmat_make_diag_copy1 () Make diagonal copies of Matrix Arguments None private interface realmat_make_diag_copy2 () Make diagonal copies of Matrix Arguments None private interface realmat_make_diag_copy3 () Make diagonal copies of RealMatrix_ Arguments None private interface realmat_make_diag_copy4 () Make diagonal copies of Matrix Arguments None","tags":"","loc":"interface/makediagonalcopies.html"},{"title":"MatMul_1 – Fortran Program","text":"interface private pure function MatMul_1(Obj1, Obj2) result(Ans) Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(in) :: Obj1 type(RealMatrix_), intent(in) :: Obj2 Return Value type(RealMatrix_)","tags":"","loc":"interface/matmul_1.html"},{"title":"MatMul_2 – Fortran Program","text":"interface private pure function MatMul_2(Obj, Vec) result(Ans) Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(in) :: Obj real(kind=DFP), intent(in) :: Vec (:) Return Value real(kind=DFP),\n  ALLOCATABLE,(:)","tags":"","loc":"interface/matmul_2.html"},{"title":"MatMul_3 – Fortran Program","text":"interface private pure function MatMul_3(Obj, Vec) result(Ans) Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(in) :: Obj type(RealVector_), intent(in) :: Vec Return Value type(RealVector_)","tags":"","loc":"interface/matmul_3.html"},{"title":"Matmul – Fortran Program","text":"public interface Matmul Contents Module Procedures MatMul_1 MatMul_2 MatMul_3 Module Procedures private interface MatMul_1 () Arguments None private interface MatMul_2 () Arguments None private interface MatMul_3 () Arguments None","tags":"","loc":"interface/matmul~2.html"},{"title":"RANDOM_NUMBER – Fortran Program","text":"public interface RANDOM_NUMBER Contents Module Procedures realmat_random_number Module Procedures private interface realmat_random_number () Set a values in RealMatrix_ obj to random values Arguments None","tags":"","loc":"interface/random_number~2.html"},{"title":"RealMatrix – Fortran Program","text":"public interface RealMatrix Generic function to construct RealMatrix_ Contents Module Procedures Constructor1 Module Procedures private interface Constructor1 () Fucntion that will initiate RealMatrix_ Arguments None","tags":"","loc":"interface/realmatrix.html"},{"title":"RealMatrix_Pointer – Fortran Program","text":"public interface RealMatrix_Pointer Generic function to get pointer to RealMatrix_ Contents Module Procedures Constructor_1 Module Procedures private pure function Constructor_1 (Dims) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Dims (2) Return Value class(RealMatrix_),\n  POINTER","tags":"","loc":"interface/realmatrix_pointer.html"},{"title":"SYM – Fortran Program","text":"public interface SYM Generic interface for getting symmetric part of RealMatrix_ Contents Module Procedures sym_obj sym_array Module Procedures private interface sym_obj () Return sym(Obj) = 0.5*(Obj + transpose( Obj ) ) Arguments None private interface sym_array () Return sym(Obj) = 0.5*(Obj + transpose( Obj ) ) Arguments None","tags":"","loc":"interface/sym.html"},{"title":"Shape – Fortran Program","text":"public interface Shape Generic interface to get shape of RealMatrix_ Contents Module Procedures get_shape Module Procedures private interface get_shape () Return shape of RealMatrix_ Arguments None","tags":"","loc":"interface/shape~7.html"},{"title":"Size – Fortran Program","text":"public interface Size Generic interface to get size of RealMatrix_ Contents Module Procedures get_size Module Procedures private interface get_size () Return size of RealMatrix_ Arguments None","tags":"","loc":"interface/size~5.html"},{"title":"SkewSym – Fortran Program","text":"public interface SkewSym Generic interface for getting SkewSymmetric part of RealMatrix_ Contents Module Procedures SkewSym_obj SkewSym_array Module Procedures private interface SkewSym_obj () Return SkewSym(Obj) = 0.5*(Obj + transpose( Obj ) ) Arguments None private interface SkewSym_array () Return SkewSym(Obj) = 0.5*(Obj + transpose( Obj ) ) Arguments None","tags":"","loc":"interface/skewsym~2.html"},{"title":"SkewSym_array – Fortran Program","text":"interface Return SkewSym(Obj) = 0.5*(Obj + transpose( Obj ) ) private pure function SkewSym_array(Obj) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Obj (:,:) Two dimensiona array Return Value real(kind=DFP)\n  (SIZE(Obj,1),SIZE(Obj,2)) SkewSymmetric array Description Return SkewSymmetric part of Obj Usage fortran\n    realMat = SkewSym( Obj )","tags":"","loc":"interface/skewsym_array.html"},{"title":"SkewSym_obj – Fortran Program","text":"interface Return SkewSym(Obj) = 0.5*(Obj + transpose( Obj ) ) private pure function SkewSym_obj(Obj) result(Ans) Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(in) :: Obj Real matrix Return Value type(RealMatrix_) SkewSymmetric real matrix Description Return SkewSymmetric part of Obj Usage fortran\n    realMat = SkewSym( Obj )","tags":"","loc":"interface/skewsym_obj.html"},{"title":"addContribution – Fortran Program","text":"public interface addContribution Contents Module Procedures realmat_addVal_1 realmat_addVal_2 realmat_addVal_3 realmat_addVal_4 realmat_addVal_5 Module Procedures private interface realmat_addVal_1 () Add contribution in values of RealMatrix_ Arguments None private interface realmat_addVal_2 () Add contribution in values of RealMatrix_ Arguments None private interface realmat_addVal_3 () Add contribution in values of RealMatrix_ Arguments None private interface realmat_addVal_4 () Add contribution in values of RealMatrix_ Arguments None private interface realmat_addVal_5 () Add contribution in values of RealMatrix_ Arguments None","tags":"","loc":"interface/addcontribution~3.html"},{"title":"convert_DofToNodes – Fortran Program","text":"interface Rearrange the dofs in finite element matrix private subroutine convert_DofToNodes(From, To, Conversion, nns, tdof) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: From (:,:) Matrix in one format real(kind=DFP), intent(inout), ALLOCATABLE :: To (:,:) Matrix is desired format integer(kind=I4B), intent(in) :: Conversion Conversion can be NodesToDOF or DOFToNodes integer(kind=I4B), intent(in), optional :: nns integer(kind=I4B), intent(in), optional :: tdof Description This subroutine changes the storage pattern of a two-d matrix\n  - Usually element matrix in easifem are stored in FMT_DOF - Global matrices/tanmat, however, are stored in FMT_Nodes - This subroutine is, therefore, in settings or adding values in SparseMatrix_ . This subroutine converts changes the storage format of dense matrix.\n Usually, elemental finite element matrix is stored in DOF_FMT , and global ! matrix/ tanmat, may be stored in Nodes_FMT . Usage fortran\n    call Convert( From, To, DOFToNodes, nns, tdof )","tags":"","loc":"interface/convert_doftonodes.html"},{"title":"convert_mat4_to_mat2 – Fortran Program","text":"interface This subroutine converts rank4  matrix to rank2 matrix private subroutine convert_mat4_to_mat2(From, To) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: From (:,:,:,:) real(kind=DFP), intent(inout), ALLOCATABLE :: To (:,:) Description This subroutine converts a rank4 matrix to rank2 matrix","tags":"","loc":"interface/convert_mat4_to_mat2.html"},{"title":"eig_jacobi_method – Fortran Program","text":"interface Returns all the eigenvalues of symmetric matrix private subroutine eig_jacobi_method(Mat, EigenValues, EigenVectors, MaxIter) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout) :: Mat (:,:) real(kind=DFP), intent(inout) :: EigenValues (:) real(kind=DFP), intent(inout) :: EigenVectors (:,:) integer(kind=I4B), intent(in) :: MaxIter Description This subroutine computes all eigenvalues and eigenvectors of a real\n symmetric N × N matrix A.\n -  On output, elements of A above the diagonal are destroyed.\n - d is a vector of length N that returns the eigenvalues of A .\n - V is an N × N matrix whose columns contain on output, the normalized\n  eigenvectors of A.\n - tRot returns the number of Jacobi rotations that were required. ### Reference:: Numerical Reciepe in Fortran, Page 1225","tags":"","loc":"interface/eig_jacobi_method.html"},{"title":"eye_int – Fortran Program","text":"interface Return identity matrix of integers private pure function eye_int(m, DataType) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: m integer(kind=I4B), intent(in) :: DataType Return Value integer(kind=I4B)\n  (m,m) Description This function return identity matrix of integer Usage fortran\n    i = eye( 2, 1_I4B )","tags":"","loc":"interface/eye_int.html"},{"title":"eye_obj – Fortran Program","text":"interface Return identity matrix of type RealMatrix_ private pure function eye_obj(m, DataType) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: m type(RealMatrix_), intent(in) :: DataType Return Value type(RealMatrix_) Description This function returns identity matrix of type RealMatrix_ Usage fortran\n    obj = eye( 3, typeRealMatrix )","tags":"","loc":"interface/eye_obj.html"},{"title":"eye_real – Fortran Program","text":"interface Return identity matrix of real numbers private pure function eye_real(m, DataType) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: m real(kind=DFP), intent(in) :: DataType Return Value real(kind=DFP)\n  (m,m) Description This function returns identity matrux of reals Usage fortran\n    e = eye( 5, 1.0_dfp )","tags":"","loc":"interface/eye_real.html"},{"title":"eye_real_b – Fortran Program","text":"interface Return identity matrix of real number private pure function eye_real_b(m) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: m Return Value real(kind=DFP)\n  (m,m) Description This function returns the identity matrix of real numbers Usage fortran\n    e = eye( 4 )","tags":"","loc":"interface/eye_real_b.html"},{"title":"f_getPointer_Real – Fortran Program","text":"interface Get pointer to the values stored inside RealMatrix_ private function f_getPointer_Real(Obj, DataType) result(Ans) Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(in), TARGET :: Obj real(kind=DFP), intent(in) :: DataType Return Value real(kind=DFP),\n  POINTER,(:,:) Description This function returns the pointer to the values stored inside the RealMatrix_","tags":"","loc":"interface/f_getpointer_real.html"},{"title":"f_getSectionValues_Real – Fortran Program","text":"interface Returns the values of RealMatrix_ obj in 2D array private pure function f_getSectionValues_Real(Obj, RIndx, CIndx, DataType) result(Ans) Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(in) :: Obj integer(kind=I4B), intent(in) :: RIndx (:) integer(kind=I4B), intent(in) :: CIndx (:) real(kind=DFP), intent(in) :: DataType Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:) Description This function returns a section of Obj % Val in a 2D fortran array. This\n is equivalent to Val = Obj % Val(RIndx, CIndx) Usage fortran\n integer( i4b ) :: r( 2 ), c( 2 )\n type( RealMatrix_ ) :: Obj\n call initiate( Obj, [4,4] )\n call random_number( obj ); r=[1,2]; c=[2,3]\n Val = ArrayValues( Obj, R, C, 1.0_dfp ) The above call will return Obj%Val[1:2, 2:3]","tags":"","loc":"interface/f_getsectionvalues_real.html"},{"title":"f_getSectionValues_Self – Fortran Program","text":"interface Returns RealMatrix_ obj from a section of RealMatrix_ private pure function f_getSectionValues_Self(Obj, RIndx, CIndx, DataType) result(Ans) Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(in) :: Obj integer(kind=I4B), intent(in) :: RIndx (:) integer(kind=I4B), intent(in) :: CIndx (:) type(RealMatrix_), intent(in) :: DataType Return Value type(RealMatrix_) Description This function is essentially copy method Ans=Obj(RIndx, CIndx)","tags":"","loc":"interface/f_getsectionvalues_self.html"},{"title":"f_getValuesFromTriplet_Real – Fortran Program","text":"interface Returns the values of RealMatrix_ obj in 2D array private pure function f_getValuesFromTriplet_Real(Obj, iStart, iEnd, Stride, DataType) result(Ans) Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(in) :: Obj integer(kind=I4B), intent(in) :: iStart integer(kind=I4B), intent(in) :: iEnd integer(kind=I4B), intent(in) :: Stride real(kind=DFP), intent(in) :: DataType Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:) Description This function returns a section of Obj % Val in a 2D fortran array. This\n is equivalent to Val = Obj % Val(is:ie:s, is:ie:s) Usage fortran\n integer( i4b ) :: r( 2 ), c( 2 )\n type( RealMatrix_ ) :: Obj\n call initiate( Obj, [4,4] )\n call random_number( obj )\n Val = ArrayValues( Obj, 1, 2, 1, 1.0_dfp ) The above call will return Obj%Val[1:2:1, 1:2:1]","tags":"","loc":"interface/f_getvaluesfromtriplet_real.html"},{"title":"f_getValuesFromTriplet_self – Fortran Program","text":"interface Returns RealMatrix_ obj from a section of RealMatrix_ private pure function f_getValuesFromTriplet_self(Obj, iStart, iEnd, Stride, DataType) result(Ans) Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(in) :: Obj integer(kind=I4B), intent(in) :: iStart integer(kind=I4B), intent(in) :: iEnd integer(kind=I4B), intent(in) :: Stride type(RealMatrix_), intent(in) :: DataType Return Value type(RealMatrix_) Description This function is essentially copy method Ans=Obj(is:ie, is:ie)","tags":"","loc":"interface/f_getvaluesfromtriplet_self~3.html"},{"title":"f_getValues_1 – Fortran Program","text":"interface Returns values in 2D fortran array from RealMatrix_ Returns RealMatrix_ object from a 2D array of RealMatrix_ private pure function f_getValues_1(Obj, DataType) result(Ans) Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(in) :: Obj (:,:) real(kind=DFP), intent(in) :: DataType Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:) Description This function combines all RealMatrix_ value of Obj and\n returns a 2D fortrn array","tags":"","loc":"interface/f_getvalues_1.html"},{"title":"f_getValues_2 – Fortran Program","text":"interface Returns values in 2D fortran array from RealMatrix_ Returns RealMatrix_ object from a 2D array of RealMatrix_ private pure function f_getValues_2(Obj, DataType) result(Ans) Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(in) :: Obj (:,:) type(RealMatrix_), intent(in) :: DataType Return Value type(RealMatrix_) Description This function combines all RealMatrix_ value of Obj and\n returns a RealMatrix_ object","tags":"","loc":"interface/f_getvalues_2.html"},{"title":"f_getValues_Real – Fortran Program","text":"interface Returns the values of RealMatrix_ obj in 2D array private pure function f_getValues_Real(Obj, DataType) result(Ans) Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(in) :: Obj real(kind=DFP), intent(in) :: DataType Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:) Description This function returns the value stored in Obj % Val in a 2D fortran array Usage fortran\n    Val = ArrayValues( Obj, 1.0_dfp )","tags":"","loc":"interface/f_getvalues_real.html"},{"title":"f_getValues_self – Fortran Program","text":"interface Returns RealMatrix_ obj from RealMatrix_ private pure function f_getValues_self(Obj, DataType) result(Ans) Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(in) :: Obj type(RealMatrix_), intent(in) :: DataType Return Value type(RealMatrix_) Description This function is essentially copy method Ans=Obj","tags":"","loc":"interface/f_getvalues_self~3.html"},{"title":"get_shape – Fortran Program","text":"interface Return shape of RealMatrix_ private pure function get_shape(Obj) result(Ans) Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(in) :: Obj Return Value integer(kind=I4B)\n  (2) Description This function return space of RealMatrix_ Usage fortran\n    s = Shape( Obj )","tags":"","loc":"interface/get_shape.html"},{"title":"get_size – Fortran Program","text":"interface Return size of RealMatrix_ private pure function get_size(Obj, Dims) result(Ans) Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(in) :: Obj integer(kind=I4B), intent(in), optional :: Dims Return Value integer(kind=I4B) Description This function return size of RealMatrix_ - If Dims is present and equal to 1 then total number of rows (m)\n - If Dims is present and equal to 2 then total number of cols (n)\n - If Dimes is absent then Ans = m * n Usage fortran\n    trow = SIZE( Obj, 1 )\n tcol = SIZE( Obj, 2 )\n t = SIZE( Obj )","tags":"","loc":"interface/get_size.html"},{"title":"initiate_obj – Fortran Program","text":"interface Initiate RealMatrix_ private subroutine initiate_obj(Obj, Dims) Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Dims (2) Description This subroutine initiate Obj with shape Dims Usage fortran\n    call initiate( obj, [2,3] ) The above call will initiate a matrix of shape (2,3)","tags":"","loc":"interface/initiate_obj~2.html"},{"title":"initiate_obj_val – Fortran Program","text":"interface Initiate RealMatrix_ private subroutine initiate_obj_val(Obj, Val) Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val (:,:) Description This subroutine performs Obj % Val = Val , i.e., initiate Obj with Val Usage fortran\n    call initiate( obj, val )","tags":"","loc":"interface/initiate_obj_val.html"},{"title":"initiate_obj_vector_a – Fortran Program","text":"interface Initiate RealMatrix_ private subroutine initiate_obj_vector_a(Obj, Dims) Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(inout) :: Obj (:) integer(kind=I4B), intent(in) :: Dims (2) Description This subroutine initiate vector of RealMatrix_ with shape Dims Usage type ( realmatrix_ ) :: obj ( 4 ) call initiate ( obj , [ 2 , 3 ] ) The above call will initiate obj vector of matrices of shape (2,3)","tags":"","loc":"interface/initiate_obj_vector_a.html"},{"title":"initiate_obj_vector_b – Fortran Program","text":"interface Initiate RealMatrix_ private subroutine initiate_obj_vector_b(Obj, Dims) Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(inout) :: Obj (:) integer(kind=I4B), intent(in) :: Dims (:,:) Description This subroutine initiate vector of RealMatrix_ with matrices of\n different shapes given in Dims - Dims has two columns; the first column denotes the number of rows, and\n second column denotes the number of columns in a matrix\n - irow of Dims corresponds to the shape of Obj(irow) - in this way SIZE(obj) should be equal to the SIZE(Dims, 1) Usage type ( realmatrix_ ) :: obj ( 3 ) integer ( i4b ) :: Dims ( 3 , 2 ) Dims ( 1 , : ) = [ 2 , 2 ] Dims ( 2 , : ) = [ 4 , 4 ] Dims ( 3 , : ) = [ 4 , 4 ] call initiate ( obj , Dims ) The above call will initiate a obj( 1 ) with shape (2,2) The above call will initiate a obj( 2 ) with shape (4,4) The above call will initiate a obj( 3 ) with shape (4,4)","tags":"","loc":"interface/initiate_obj_vector_b.html"},{"title":"realmat_addVal_1 – Fortran Program","text":"interface Add contribution in values of RealMatrix_ private subroutine realmat_addVal_1(Obj, Val, Scale, Op) Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val (:,:) Scaling for Val real(kind=DFP), intent(in) :: Scale Scaling for Val character(len=1), intent(in) :: Op operator symbol; +, -, *, / Description This subroutine adds contribution in values of Obj % Val fortran\n obj % val = obj % val *Op* scale * val","tags":"","loc":"interface/realmat_addval_1.html"},{"title":"realmat_addVal_2 – Fortran Program","text":"interface Add contribution in values of RealMatrix_ private subroutine realmat_addVal_2(Obj, Val, Row, Col, Scale, Op) Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val integer(kind=I4B), intent(in) :: Row integer(kind=I4B), intent(in) :: Col real(kind=DFP), intent(in) :: Scale character(len=1), intent(in) :: Op Description This subroutine adds contribution in values of Obj % Val fortran\n obj % val = obj % val *Op* scale * val","tags":"","loc":"interface/realmat_addval_2.html"},{"title":"realmat_addVal_3 – Fortran Program","text":"interface Add contribution in values of RealMatrix_ private subroutine realmat_addVal_3(Obj, Val, Row, Col, Scale, Op) Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val (:,:) integer(kind=I4B), intent(in) :: Row (:) integer(kind=I4B), intent(in) :: Col (:) real(kind=DFP), intent(in) :: Scale character(len=1), intent(in) :: Op Description This subroutine adds contribution in values of Obj % Val fortran\n obj % val = obj % val *Op* scale * val","tags":"","loc":"interface/realmat_addval_3.html"},{"title":"realmat_addVal_4 – Fortran Program","text":"interface Add contribution in values of RealMatrix_ private subroutine realmat_addVal_4(Obj, Val, Indx, ExtraOption, Scale, Op) Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val (:) integer(kind=I4B), intent(in) :: Indx integer(kind=I4B), intent(in) :: ExtraOption real(kind=DFP), intent(in) :: Scale character(len=1), intent(in) :: Op Description This subroutine adds contribution in values of Obj % Val fortran\n obj % val = obj % val *Op* scale * val","tags":"","loc":"interface/realmat_addval_4.html"},{"title":"realmat_addVal_5 – Fortran Program","text":"interface Add contribution in values of RealMatrix_ private subroutine realmat_addVal_5(Obj, Val, Indx, ExtraOption, Scale, Op) Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val (:,:) integer(kind=I4B), intent(in) :: Indx (:) integer(kind=I4B), intent(in) :: ExtraOption real(kind=DFP), intent(in) :: Scale character(len=1), intent(in) :: Op Description This subroutine adds contribution in values of Obj % Val fortran\n obj % val = obj % val *Op* scale * val","tags":"","loc":"interface/realmat_addval_5.html"},{"title":"realmat_convert_doftonodes – Fortran Program","text":"interface Rearrange the dofs in finite element matrix private subroutine realmat_convert_doftonodes(From, To, Conversion, nns, tdof) Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(in) :: From Matrix in one format type(RealMatrix_), intent(inout) :: To Matrix in one format integer(kind=I4B), intent(in) :: Conversion Conversion can be NodesToDOF or DOFToNodes integer(kind=I4B), intent(in), optional :: nns integer(kind=I4B), intent(in), optional :: tdof Description This subroutine changes the storage pattern of a two-d matrix\n  - Usually element matrix in easifem are stored in FMT_DOF - Global matrices/tanmat, however, are stored in FMT_Nodes - This subroutine is, therefore, in settings or adding values in SparseMatrix_ . This subroutine converts changes the storage format of dense matrix.\n Usually, elemental finite element matrix is stored in DOF_FMT , and global ! matrix/ tanmat, may be stored in Nodes_FMT . Usage fortran\n    call Convert( From, To, DOFToNodes, nns, tdof )","tags":"","loc":"interface/realmat_convert_doftonodes.html"},{"title":"realmat_make_diag_copy1 – Fortran Program","text":"interface Make diagonal copies of Matrix private subroutine realmat_make_diag_copy1(Mat, nCopy) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: Mat (:,:) integer(kind=I4B), intent(in) :: nCopy Description This subroutine makes ncopy diagonal copies of Mat - The size of Mat on return is nCopy * SIZE( Mat, 1 ) Usage fortran\n    call MakeDiagonalCopies( Mat, nCopy )","tags":"","loc":"interface/realmat_make_diag_copy1.html"},{"title":"realmat_make_diag_copy2 – Fortran Program","text":"interface Make diagonal copies of Matrix private subroutine realmat_make_diag_copy2(From, To, nCopy) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: From (:,:) real(kind=DFP), intent(inout), ALLOCATABLE :: To (:,:) integer(kind=I4B), intent(in) :: nCopy Description This subroutine makes ncopy diagonal copies of Mat Usage fortran\n    call MakeDiagonalCopies( From = Mat, To = anotherMat, nCopy = nCopy )","tags":"","loc":"interface/realmat_make_diag_copy2.html"},{"title":"realmat_make_diag_copy3 – Fortran Program","text":"interface Make diagonal copies of RealMatrix_ private subroutine realmat_make_diag_copy3(Mat, ncopy) Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(inout) :: Mat integer(kind=I4B), intent(in) :: ncopy Description This subroutine makes ncopy diagonal copies of Mat - The size of Mat on return is nCopy * SIZE( Mat, 1 ) Usage fortran\n    call MakeDiagonalCopies( Mat, nCopy )","tags":"","loc":"interface/realmat_make_diag_copy3.html"},{"title":"realmat_make_diag_copy4 – Fortran Program","text":"interface Make diagonal copies of Matrix private subroutine realmat_make_diag_copy4(From, To, nCopy) Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(in) :: From type(RealMatrix_), intent(inout) :: To integer(kind=I4B), intent(in) :: nCopy Description This subroutine makes ncopy diagonal copies of Mat Usage fortran\n    call MakeDiagonalCopies( From = Mat, To = anotherMat, nCopy = nCopy )","tags":"","loc":"interface/realmat_make_diag_copy4.html"},{"title":"realmat_random_number – Fortran Program","text":"interface Set a values in RealMatrix_ obj to random values private subroutine realmat_random_number(Obj, m, n) Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(inout) :: Obj integer(kind=I4B), intent(in), optional :: m integer(kind=I4B), intent(in), optional :: n Description This subroutine set values in Obj%Val to random\n - This subroutine calls RANDOM_NUMBER() function from Fortran","tags":"","loc":"interface/realmat_random_number.html"},{"title":"realmat_setValues_1 – Fortran Program","text":"interface Add values in RealMatrix_ private subroutine realmat_setValues_1(Obj, Val) Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val (:,:) Description This subroutine set Obj % Val to Val","tags":"","loc":"interface/realmat_setvalues_1.html"},{"title":"realmat_setValues_2 – Fortran Program","text":"interface Set values in RealMatrix_ private subroutine realmat_setValues_2(Obj, Val, Row, Col) Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val integer(kind=I4B), intent(in) :: Row integer(kind=I4B), intent(in) :: Col Description This subroutine set values in Obj % Val Obj % Val( i, j ) = Val","tags":"","loc":"interface/realmat_setvalues_2.html"},{"title":"realmat_setValues_3 – Fortran Program","text":"interface Set values in RealMatrix_ private subroutine realmat_setValues_3(Obj, Val, Row, Col) Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val (:,:) integer(kind=I4B), intent(in) :: Row (:) integer(kind=I4B), intent(in) :: Col (:) Description This subroutine set values in Obj % Val","tags":"","loc":"interface/realmat_setvalues_3.html"},{"title":"realmat_setValues_4 – Fortran Program","text":"interface Set values in RealMatrix_ private subroutine realmat_setValues_4(Obj, Val, Indx, ExtraOption) Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val (:) integer(kind=I4B), intent(in) :: Indx integer(kind=I4B), intent(in) :: ExtraOption Description This subroutine set values in Obj % val - If ExtraOption=0 then diagonal values are set; and Indx denotes\n   diagonal number with 0 being the main diagonal\n - If Extraoption=1 then row values are set; Indx then denotes row number\n - If Extraoption=2 then col values are set; Indx then denotes col number","tags":"","loc":"interface/realmat_setvalues_4.html"},{"title":"realmat_setValues_5 – Fortran Program","text":"interface Set values in RealMatrix_ private subroutine realmat_setValues_5(Obj, Val, Indx, ExtraOption) Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val (:,:) integer(kind=I4B), intent(in) :: Indx (:) integer(kind=I4B), intent(in) :: ExtraOption Description This subroutine set values in Obj % val - If ExtraOption=0 then diagonal values are set; and Indx denotes\n   diagonal number with 0 being the main diagonal\n - If Extraoption=1 then row values are set; Indx then denotes row number\n - If Extraoption=2 then col values are set; Indx then denotes col number","tags":"","loc":"interface/realmat_setvalues_5.html"},{"title":"setValues – Fortran Program","text":"public interface setValues Contents Module Procedures realmat_setValues_1 realmat_setValues_2 realmat_setValues_3 realmat_setValues_4 realmat_setValues_5 Module Procedures private interface realmat_setValues_1 () Add values in RealMatrix_ Arguments None private interface realmat_setValues_2 () Set values in RealMatrix_ Arguments None private interface realmat_setValues_3 () Set values in RealMatrix_ Arguments None private interface realmat_setValues_4 () Set values in RealMatrix_ Arguments None private interface realmat_setValues_5 () Set values in RealMatrix_ Arguments None","tags":"","loc":"interface/setvalues.html"},{"title":"sym_array – Fortran Program","text":"interface Return sym(Obj) = 0.5*(Obj + transpose( Obj ) ) private pure function sym_array(Obj) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Obj (:,:) Two dimensiona array Return Value real(kind=DFP)\n  (SIZE(Obj,1),SIZE(Obj,2)) Symmetric array Description Return symmetric part of Obj Usage fortran\n    realMat = Sym( Obj )","tags":"","loc":"interface/sym_array.html"},{"title":"sym_obj – Fortran Program","text":"interface Return sym(Obj) = 0.5*(Obj + transpose( Obj ) ) private pure function sym_obj(Obj) result(Ans) Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(in) :: Obj Real matrix Return Value type(RealMatrix_) Symmetric real matrix Description Return symmetric part of Obj Usage fortran\n    realMat = Sym( Obj )","tags":"","loc":"interface/sym_obj.html"},{"title":"DeallocateData – Fortran Program","text":"public interface DeallocateData Contents Module Procedures fe_deallocate Module Procedures private interface fe_deallocate () Arguments None","tags":"","loc":"interface/deallocatedata~28.html"},{"title":"Display – Fortran Program","text":"public interface Display Contents Module Procedures Display_Obj Module Procedures private interface Display_Obj () Arguments None","tags":"","loc":"interface/display~30.html"},{"title":"Display_Obj – Fortran Program","text":"interface private subroutine Display_Obj(Obj, Msg, UnitNo) Arguments Type Intent Optional Attributes Name type(FEVariable_), intent(in) :: Obj character(len=*), intent(in) :: Msg integer(kind=I4B), intent(in), optional :: UnitNo","tags":"","loc":"interface/display_obj.html"},{"title":"Matrix_Constant – Fortran Program","text":"interface private pure function Matrix_Constant(Obj, Rank, VarType) result(Val) Arguments Type Intent Optional Attributes Name class(FEVariable_), intent(in) :: Obj type(FEVariableMatrix_), intent(in) :: Rank type(FEVariableConstant_), intent(in) :: VarType Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:)","tags":"","loc":"interface/matrix_constant.html"},{"title":"Matrix_Space – Fortran Program","text":"interface private pure function Matrix_Space(Obj, Rank, VarType) result(Val) Arguments Type Intent Optional Attributes Name class(FEVariable_), intent(in) :: Obj type(FEVariableMatrix_), intent(in) :: Rank type(FEVariableSpace_), intent(in) :: VarType Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:,:)","tags":"","loc":"interface/matrix_space.html"},{"title":"Matrix_SpaceTime – Fortran Program","text":"interface private pure function Matrix_SpaceTime(Obj, Rank, VarType) result(Val) Arguments Type Intent Optional Attributes Name class(FEVariable_), intent(in) :: Obj type(FEVariableMatrix_), intent(in) :: Rank type(FEVariableSpaceTime_), intent(in) :: VarType Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:,:,:)","tags":"","loc":"interface/matrix_spacetime.html"},{"title":"NodalVariable – Fortran Program","text":"public interface NodalVariable Contents Module Procedures Nodal_Scalar_Constant Module Procedures private interface Nodal_Scalar_Constant () Arguments None","tags":"","loc":"interface/nodalvariable.html"},{"title":"NodalVariable – Fortran Program","text":"private interface NodalVariable Contents Module Procedures Nodal_Scalar_Space Module Procedures private interface Nodal_Scalar_Space () Arguments None","tags":"","loc":"interface/nodalvariable~2.html"},{"title":"NodalVariable – Fortran Program","text":"private interface NodalVariable Contents Module Procedures Nodal_Scalar_SpaceTime Module Procedures private interface Nodal_Scalar_SpaceTime () Arguments None","tags":"","loc":"interface/nodalvariable~3.html"},{"title":"NodalVariable – Fortran Program","text":"private interface NodalVariable Contents Module Procedures Nodal_Vector_Constant Module Procedures private interface Nodal_Vector_Constant () Arguments None","tags":"","loc":"interface/nodalvariable~4.html"},{"title":"NodalVariable – Fortran Program","text":"private interface NodalVariable Contents Module Procedures Nodal_Vector_Space Module Procedures private interface Nodal_Vector_Space () Arguments None","tags":"","loc":"interface/nodalvariable~5.html"},{"title":"NodalVariable – Fortran Program","text":"private interface NodalVariable Contents Module Procedures Nodal_Vector_SpaceTime Module Procedures private interface Nodal_Vector_SpaceTime () Arguments None","tags":"","loc":"interface/nodalvariable~6.html"},{"title":"NodalVariable – Fortran Program","text":"private interface NodalVariable Contents Module Procedures Nodal_Matrix_Constant Module Procedures private interface Nodal_Matrix_Constant () Arguments None","tags":"","loc":"interface/nodalvariable~7.html"},{"title":"NodalVariable – Fortran Program","text":"private interface NodalVariable Contents Module Procedures Nodal_Matrix_Space Module Procedures private interface Nodal_Matrix_Space () Arguments None","tags":"","loc":"interface/nodalvariable~8.html"},{"title":"NodalVariable – Fortran Program","text":"private interface NodalVariable Contents Module Procedures Nodal_Matrix_SpaceTime Module Procedures private interface Nodal_Matrix_SpaceTime () Arguments None","tags":"","loc":"interface/nodalvariable~9.html"},{"title":"Nodal_Matrix_Constant – Fortran Program","text":"interface private pure function Nodal_Matrix_Constant(Val, Rank, VarType) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Val (:,:) type(FEVariableMatrix_), intent(in) :: Rank type(FEVariableConstant_), intent(in) :: VarType Return Value type(FEVariable_)","tags":"","loc":"interface/nodal_matrix_constant.html"},{"title":"Nodal_Matrix_Space – Fortran Program","text":"interface private pure function Nodal_Matrix_Space(Val, Rank, VarType) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Val (:,:,:) type(FEVariableMatrix_), intent(in) :: Rank type(FEVariableSpace_), intent(in) :: VarType Return Value type(FEVariable_)","tags":"","loc":"interface/nodal_matrix_space.html"},{"title":"Nodal_Matrix_SpaceTime – Fortran Program","text":"interface private pure function Nodal_Matrix_SpaceTime(Val, Rank, VarType) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Val (:,:,:,:) type(FEVariableMatrix_), intent(in) :: Rank type(FEVariableSpaceTime_), intent(in) :: VarType Return Value type(FEVariable_)","tags":"","loc":"interface/nodal_matrix_spacetime.html"},{"title":"Nodal_Scalar_Constant – Fortran Program","text":"interface private pure function Nodal_Scalar_Constant(Val, Rank, VarType) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Val class(FEVariableScalar_), intent(in) :: Rank class(FEVariableConstant_), intent(in) :: VarType Return Value type(FEVariable_)","tags":"","loc":"interface/nodal_scalar_constant.html"},{"title":"Nodal_Scalar_Space – Fortran Program","text":"interface private pure function Nodal_Scalar_Space(Val, Rank, VarType) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Val (:) type(FEVariableScalar_), intent(in) :: Rank type(FEVariableSpace_), intent(in) :: VarType Return Value type(FEVariable_)","tags":"","loc":"interface/nodal_scalar_space.html"},{"title":"Nodal_Scalar_SpaceTime – Fortran Program","text":"interface private pure function Nodal_Scalar_SpaceTime(Val, Rank, VarType) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Val (:,:) type(FEVariableScalar_), intent(in) :: Rank type(FEVariableSpaceTime_), intent(in) :: VarType Return Value type(FEVariable_)","tags":"","loc":"interface/nodal_scalar_spacetime.html"},{"title":"Nodal_Vector_Constant – Fortran Program","text":"interface private pure function Nodal_Vector_Constant(Val, Rank, VarType) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Val (:) type(FEVariableVector_), intent(in) :: Rank type(FEVariableConstant_), intent(in) :: VarType Return Value type(FEVariable_)","tags":"","loc":"interface/nodal_vector_constant.html"},{"title":"Nodal_Vector_Space – Fortran Program","text":"interface private pure function Nodal_Vector_Space(Val, Rank, VarType) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Val (:,:) type(FEVariableVector_), intent(in) :: Rank type(FEVariableSpace_), intent(in) :: VarType Return Value type(FEVariable_)","tags":"","loc":"interface/nodal_vector_space.html"},{"title":"Nodal_Vector_SpaceTime – Fortran Program","text":"interface private pure function Nodal_Vector_SpaceTime(Val, Rank, VarType) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Val (:,:,:) type(FEVariableVector_), intent(in) :: Rank type(FEVariableSpaceTime_), intent(in) :: VarType Return Value type(FEVariable_)","tags":"","loc":"interface/nodal_vector_spacetime.html"},{"title":"QuadratureVariable – Fortran Program","text":"public interface QuadratureVariable Contents Module Procedures Quadrature_Scalar_Constant Module Procedures private interface Quadrature_Scalar_Constant () Arguments None","tags":"","loc":"interface/quadraturevariable.html"},{"title":"QuadratureVariable – Fortran Program","text":"private interface QuadratureVariable Contents Module Procedures Quadrature_Scalar_Space Module Procedures private interface Quadrature_Scalar_Space () Arguments None","tags":"","loc":"interface/quadraturevariable~2.html"},{"title":"QuadratureVariable – Fortran Program","text":"private interface QuadratureVariable Contents Module Procedures Quadrature_Scalar_SpaceTime Module Procedures private interface Quadrature_Scalar_SpaceTime () Arguments None","tags":"","loc":"interface/quadraturevariable~3.html"},{"title":"QuadratureVariable – Fortran Program","text":"private interface QuadratureVariable Contents Module Procedures Quadrature_Vector_Constant Module Procedures private interface Quadrature_Vector_Constant () Arguments None","tags":"","loc":"interface/quadraturevariable~4.html"},{"title":"QuadratureVariable – Fortran Program","text":"private interface QuadratureVariable Contents Module Procedures Quadrature_Vector_Space Module Procedures private interface Quadrature_Vector_Space () Arguments None","tags":"","loc":"interface/quadraturevariable~5.html"},{"title":"QuadratureVariable – Fortran Program","text":"private interface QuadratureVariable Contents Module Procedures Quadrature_Vector_SpaceTime Module Procedures private interface Quadrature_Vector_SpaceTime () Arguments None","tags":"","loc":"interface/quadraturevariable~6.html"},{"title":"QuadratureVariable – Fortran Program","text":"private interface QuadratureVariable Contents Module Procedures Quadrature_Matrix_Constant Module Procedures private interface Quadrature_Matrix_Constant () Arguments None","tags":"","loc":"interface/quadraturevariable~7.html"},{"title":"QuadratureVariable – Fortran Program","text":"private interface QuadratureVariable Contents Module Procedures Quadrature_Matrix_Space Module Procedures private interface Quadrature_Matrix_Space () Arguments None","tags":"","loc":"interface/quadraturevariable~8.html"},{"title":"QuadratureVariable – Fortran Program","text":"private interface QuadratureVariable Contents Module Procedures Quadrature_Matrix_SpaceTime Module Procedures private interface Quadrature_Matrix_SpaceTime () Arguments None","tags":"","loc":"interface/quadraturevariable~9.html"},{"title":"Quadrature_Matrix_Constant – Fortran Program","text":"interface private pure function Quadrature_Matrix_Constant(Val, Rank, VarType) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Val (:,:) type(FEVariableMatrix_), intent(in) :: Rank type(FEVariableConstant_), intent(in) :: VarType Return Value type(FEVariable_)","tags":"","loc":"interface/quadrature_matrix_constant.html"},{"title":"Quadrature_Matrix_Space – Fortran Program","text":"interface private pure function Quadrature_Matrix_Space(Val, Rank, VarType) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Val (:,:,:) type(FEVariableMatrix_), intent(in) :: Rank type(FEVariableSpace_), intent(in) :: VarType Return Value type(FEVariable_)","tags":"","loc":"interface/quadrature_matrix_space.html"},{"title":"Quadrature_Matrix_SpaceTime – Fortran Program","text":"interface private pure function Quadrature_Matrix_SpaceTime(Val, Rank, VarType) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Val (:,:,:,:) type(FEVariableMatrix_), intent(in) :: Rank type(FEVariableSpaceTime_), intent(in) :: VarType Return Value type(FEVariable_)","tags":"","loc":"interface/quadrature_matrix_spacetime.html"},{"title":"Quadrature_Scalar_Constant – Fortran Program","text":"interface private pure function Quadrature_Scalar_Constant(Val, Rank, VarType) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Val type(FEVariableScalar_), intent(in) :: Rank type(FEVariableConstant_), intent(in) :: VarType Return Value type(FEVariable_)","tags":"","loc":"interface/quadrature_scalar_constant.html"},{"title":"Quadrature_Scalar_Space – Fortran Program","text":"interface private pure function Quadrature_Scalar_Space(Val, Rank, VarType) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Val (:) type(FEVariableScalar_), intent(in) :: Rank type(FEVariableSpace_), intent(in) :: VarType Return Value type(FEVariable_)","tags":"","loc":"interface/quadrature_scalar_space.html"},{"title":"Quadrature_Scalar_SpaceTime – Fortran Program","text":"interface private pure function Quadrature_Scalar_SpaceTime(Val, Rank, VarType) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Val (:,:) type(FEVariableScalar_), intent(in) :: Rank type(FEVariableSpaceTime_), intent(in) :: VarType Return Value type(FEVariable_)","tags":"","loc":"interface/quadrature_scalar_spacetime.html"},{"title":"Quadrature_Vector_Constant – Fortran Program","text":"interface private pure function Quadrature_Vector_Constant(Val, Rank, VarType) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Val (:) type(FEVariableVector_), intent(in) :: Rank type(FEVariableConstant_), intent(in) :: VarType Return Value type(FEVariable_)","tags":"","loc":"interface/quadrature_vector_constant.html"},{"title":"Quadrature_Vector_Space – Fortran Program","text":"interface private pure function Quadrature_Vector_Space(Val, Rank, VarType) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Val (:,:) type(FEVariableVector_), intent(in) :: Rank type(FEVariableSpace_), intent(in) :: VarType Return Value type(FEVariable_)","tags":"","loc":"interface/quadrature_vector_space.html"},{"title":"Quadrature_Vector_SpaceTime – Fortran Program","text":"interface private pure function Quadrature_Vector_SpaceTime(Val, Rank, VarType) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Val (:,:,:) type(FEVariableVector_), intent(in) :: Rank type(FEVariableSpaceTime_), intent(in) :: VarType Return Value type(FEVariable_)","tags":"","loc":"interface/quadrature_vector_spacetime.html"},{"title":"SIZE – Fortran Program","text":"public interface SIZE Contents Module Procedures Size_Obj Module Procedures private interface Size_obj () Arguments None","tags":"","loc":"interface/size~7.html"},{"title":"Scalar_Constant – Fortran Program","text":"interface private pure function Scalar_Constant(Obj, Rank, VarType) result(Val) Arguments Type Intent Optional Attributes Name class(FEVariable_), intent(in) :: Obj type(FEVariableScalar_), intent(in) :: Rank type(FEVariableConstant_), intent(in) :: VarType Return Value real(kind=DFP)","tags":"","loc":"interface/scalar_constant.html"},{"title":"Scalar_Space – Fortran Program","text":"interface private pure function Scalar_Space(Obj, Rank, VarType) result(Val) Arguments Type Intent Optional Attributes Name class(FEVariable_), intent(in) :: Obj type(FEVariableScalar_), intent(in) :: Rank type(FEVariableSpace_), intent(in) :: VarType Return Value real(kind=DFP),\n  ALLOCATABLE,(:)","tags":"","loc":"interface/scalar_space.html"},{"title":"Scalar_SpaceTime – Fortran Program","text":"interface private pure function Scalar_SpaceTime(Obj, Rank, VarType) result(Val) Arguments Type Intent Optional Attributes Name class(FEVariable_), intent(in) :: Obj type(FEVariableScalar_), intent(in) :: Rank type(FEVariableSpaceTime_), intent(in) :: VarType Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:)","tags":"","loc":"interface/scalar_spacetime.html"},{"title":"Shape – Fortran Program","text":"public interface Shape Contents Module Procedures Shape_Obj Module Procedures private interface Shape_obj () Arguments None","tags":"","loc":"interface/shape~8.html"},{"title":"Shape_obj – Fortran Program","text":"interface private pure function Shape_obj(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class(FEVariable_), intent(in) :: Obj Return Value integer(kind=I4B),\n  ALLOCATABLE,(:)","tags":"","loc":"interface/shape_obj.html"},{"title":"Size_obj – Fortran Program","text":"interface private pure function Size_obj(Obj, Dim) result(Ans) Arguments Type Intent Optional Attributes Name class(FEVariable_), intent(in) :: Obj integer(kind=I4B), intent(in) :: Dim Return Value integer(kind=I4B)","tags":"","loc":"interface/size_obj.html"},{"title":"Vector_Constant – Fortran Program","text":"interface private pure function Vector_Constant(Obj, Rank, VarType) result(Val) Arguments Type Intent Optional Attributes Name class(FEVariable_), intent(in) :: Obj type(FEVariableVector_), intent(in) :: Rank type(FEVariableConstant_), intent(in) :: VarType Return Value real(kind=DFP),\n  ALLOCATABLE,(:)","tags":"","loc":"interface/vector_constant.html"},{"title":"Vector_Space – Fortran Program","text":"interface private pure function Vector_Space(Obj, Rank, VarType) result(Val) Arguments Type Intent Optional Attributes Name class(FEVariable_), intent(in) :: Obj type(FEVariableVector_), intent(in) :: Rank type(FEVariableSpace_), intent(in) :: VarType Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:)","tags":"","loc":"interface/vector_space.html"},{"title":"Vector_SpaceTime – Fortran Program","text":"interface private pure function Vector_SpaceTime(Obj, Rank, VarType) result(Val) Arguments Type Intent Optional Attributes Name class(FEVariable_), intent(in) :: Obj type(FEVariableVector_), intent(in) :: Rank type(FEVariableSpaceTime_), intent(in) :: VarType Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:,:)","tags":"","loc":"interface/vector_spacetime.html"},{"title":"fe_deallocate – Fortran Program","text":"interface private subroutine fe_deallocate(Obj) Arguments Type Intent Optional Attributes Name type(FEVariable_), intent(inout) :: Obj","tags":"","loc":"interface/fe_deallocate.html"},{"title":"getValues – Fortran Program","text":"public interface getValues Contents Module Procedures Scalar_Constant Module Procedures private interface Scalar_Constant () Arguments None","tags":"","loc":"interface/getvalues~3.html"},{"title":"getValues – Fortran Program","text":"private interface getValues Contents Module Procedures Scalar_Space Module Procedures private interface Scalar_Space () Arguments None","tags":"","loc":"interface/getvalues~4.html"},{"title":"getValues – Fortran Program","text":"private interface getValues Contents Module Procedures Scalar_SpaceTime Module Procedures private interface Scalar_SpaceTime () Arguments None","tags":"","loc":"interface/getvalues~5.html"},{"title":"getValues – Fortran Program","text":"private interface getValues Contents Module Procedures Vector_Constant Module Procedures private interface Vector_Constant () Arguments None","tags":"","loc":"interface/getvalues~6.html"},{"title":"getValues – Fortran Program","text":"private interface getValues Contents Module Procedures Vector_Space Module Procedures private interface Vector_Space () Arguments None","tags":"","loc":"interface/getvalues~7.html"},{"title":"getValues – Fortran Program","text":"private interface getValues Contents Module Procedures Vector_SpaceTime Module Procedures private interface Vector_SpaceTime () Arguments None","tags":"","loc":"interface/getvalues~8.html"},{"title":"getValues – Fortran Program","text":"private interface getValues Contents Module Procedures Matrix_Constant Module Procedures private interface Matrix_Constant () Arguments None","tags":"","loc":"interface/getvalues~9.html"},{"title":"getValues – Fortran Program","text":"private interface getValues Contents Module Procedures Matrix_Space Module Procedures private interface Matrix_Space () Arguments None","tags":"","loc":"interface/getvalues~10.html"},{"title":"getValues – Fortran Program","text":"private interface getValues Contents Module Procedures Matrix_SpaceTime Module Procedures private interface Matrix_SpaceTime () Arguments None","tags":"","loc":"interface/getvalues~11.html"},{"title":"Append – Fortran Program","text":"public interface Append Contents Module Procedures buffer_append_str Module Procedures private interface buffer_append_str () Arguments None","tags":"","loc":"interface/append~5.html"},{"title":"buffer_append_str – Fortran Program","text":"interface private subroutine buffer_append_str(Obj, Entry) Arguments Type Intent Optional Attributes Name type(Buffer_), intent(inout) :: Obj type(String), intent(in), TARGET :: Entry","tags":"","loc":"interface/buffer_append_str.html"},{"title":"lag_elem_refHexahedron – Fortran Program","text":"module procedure lag_elem_refHexahedron module function lag_elem_refHexahedron(Obj, Order) result(Ans) Interface → Arguments Type Intent Optional Attributes Name class( ReferenceHexahedron_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value class( ReferenceElement_ ),\n  POINTER Contents None","tags":"","loc":"proc/lag_elem_refhexahedron.html"},{"title":"lag_elem_refLine – Fortran Program","text":"module procedure lag_elem_refLine module function lag_elem_refLine(Obj, Order) result(Ans) Interface → Arguments Type Intent Optional Attributes Name class( ReferenceLine_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value class( ReferenceElement_ ),\n  POINTER Contents None","tags":"","loc":"proc/lag_elem_refline.html"},{"title":"lag_elem_refPrism – Fortran Program","text":"module procedure lag_elem_refPrism module function lag_elem_refPrism(Obj, Order) result(Ans) Interface → Arguments Type Intent Optional Attributes Name class( ReferencePrism_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value class( ReferenceElement_ ),\n  POINTER Contents None","tags":"","loc":"proc/lag_elem_refprism.html"},{"title":"lag_elem_refPyramid – Fortran Program","text":"module procedure lag_elem_refPyramid module function lag_elem_refPyramid(Obj, Order) result(Ans) Interface → Arguments Type Intent Optional Attributes Name class( ReferencePyramid_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value class( ReferenceElement_ ),\n  POINTER Contents None","tags":"","loc":"proc/lag_elem_refpyramid.html"},{"title":"lag_elem_refQuadrangle – Fortran Program","text":"module procedure lag_elem_refQuadrangle module function lag_elem_refQuadrangle(Obj, Order) result(Ans) Interface → Arguments Type Intent Optional Attributes Name class( ReferenceQuadrangle_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value class( ReferenceElement_ ),\n  POINTER Contents None","tags":"","loc":"proc/lag_elem_refquadrangle.html"},{"title":"lag_elem_refTetrahedron – Fortran Program","text":"module procedure lag_elem_refTetrahedron module function lag_elem_refTetrahedron(Obj, Order) result(Ans) Interface → Arguments Type Intent Optional Attributes Name class( ReferenceTetrahedron_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value class( ReferenceElement_ ),\n  POINTER Contents None","tags":"","loc":"proc/lag_elem_reftetrahedron.html"},{"title":"lag_elem_refTriangle – Fortran Program","text":"module procedure lag_elem_refTriangle module function lag_elem_refTriangle(Obj, Order) result(Ans) Interface → Arguments Type Intent Optional Attributes Name class( ReferenceTriangle_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value class( ReferenceElement_ ),\n  POINTER Contents None","tags":"","loc":"proc/lag_elem_reftriangle.html"},{"title":"lag_elem_refelem – Fortran Program","text":"module procedure lag_elem_refelem module function lag_elem_refelem(Obj, Order) result(Ans) Interface → Arguments Type Intent Optional Attributes Name class( ReferenceElement_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value class( ReferenceElement_ ),\n  POINTER Contents None","tags":"","loc":"proc/lag_elem_refelem.html"},{"title":"lp_refelem – Fortran Program","text":"module procedure lp_refelem pure module function lp_refelem(Obj, Order) result(Ans) Interface → Arguments Type Intent Optional Attributes Name class( ReferenceElement_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:) Contents None","tags":"","loc":"proc/lp_refelem.html"},{"title":"lp_refelem_Hexahedron – Fortran Program","text":"module procedure lp_refelem_Hexahedron pure module function lp_refelem_Hexahedron(Obj, Order) result(Ans) Interface → Arguments Type Intent Optional Attributes Name class( ReferenceHexahedron_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:) Contents None","tags":"","loc":"proc/lp_refelem_hexahedron.html"},{"title":"lp_refelem_Prism – Fortran Program","text":"module procedure lp_refelem_Prism pure module function lp_refelem_Prism(Obj, Order) result(Ans) Interface → Arguments Type Intent Optional Attributes Name class( ReferencePrism_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:) Contents None","tags":"","loc":"proc/lp_refelem_prism.html"},{"title":"lp_refelem_Pyramid – Fortran Program","text":"module procedure lp_refelem_Pyramid pure module function lp_refelem_Pyramid(Obj, Order) result(Ans) Interface → Arguments Type Intent Optional Attributes Name class( ReferencePyramid_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:) Contents None","tags":"","loc":"proc/lp_refelem_pyramid.html"},{"title":"lp_refelem_Quadrangle – Fortran Program","text":"module procedure lp_refelem_Quadrangle pure module function lp_refelem_Quadrangle(Obj, Order) result(Ans) Interface → Arguments Type Intent Optional Attributes Name class( ReferenceQuadrangle_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:) Contents None","tags":"","loc":"proc/lp_refelem_quadrangle.html"},{"title":"lp_refelem_Tetrahedron – Fortran Program","text":"module procedure lp_refelem_Tetrahedron pure module function lp_refelem_Tetrahedron(Obj, Order) result(Ans) Interface → Arguments Type Intent Optional Attributes Name class( ReferenceTetrahedron_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:) Contents None","tags":"","loc":"proc/lp_refelem_tetrahedron.html"},{"title":"lp_refelem_Triangle – Fortran Program","text":"module procedure lp_refelem_Triangle pure module function lp_refelem_Triangle(Obj, Order) result(Ans) Interface → Arguments Type Intent Optional Attributes Name class( ReferenceTriangle_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:) Contents None","tags":"","loc":"proc/lp_refelem_triangle.html"},{"title":"lp_refelem_line – Fortran Program","text":"module procedure lp_refelem_line pure module function lp_refelem_line(Obj, Order) result(Ans) Interface → Arguments Type Intent Optional Attributes Name class( ReferenceLine_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE,(:,:) Contents None","tags":"","loc":"proc/lp_refelem_line.html"},{"title":"EASIFEM – Fortran Program","text":"Uses BaseType BaseMethod easifemClasses mod_functional ogpf Contents None","tags":"","loc":"module/easifem.html"},{"title":"easifemClasses – Fortran Program","text":"Uses FE Mesh_Class MeshData_Class MeshConnectivity_Class Domain_Class QuadratureVariables_Class gmsh_Class gmshMesh_Class vtkType LinSolver_Class Material_Class StdMaterials ThermCondModel_Class VolHeatCapModel_Class SFCCModel_Class Contents None","tags":"","loc":"module/easifemclasses.html"},{"title":"MeshData_Class – Fortran Program","text":"This module defines Mesh data class Uses BaseType GlobalData Mesh_Class FE Contents Variables TypeMeshData Interfaces BoundingBox DeallocateData Deallocate_meshdata Initiate MeshData MeshData_Pointer get_Bbox get_bndy_elem get_elem_elems_1 get_elem_elems_2 get_elem_nodes get_facet_elements get_node_nodes get_tbndy_elems get_tbndy_nodes get_tint_nodes get_total_nodes global_from_local global_from_local_scalar init_bndy_data init_elem_nodes init_element_elements init_int_bndydata init_int_nptrs init_meshdata_1 init_node_elements init_node_nodes is_bndy_elem is_bndy_nptrs is_boundarydata is_element_elements_initiated is_element_nodes_initiated is_int_bndy_data is_internalnptrs is_local_nptrs is_node_elements_initiated is_node_nodes_initiated is_node_present local_from_global local_from_global_scalar mc_connect_facet_cell md_findelement md_quality meshdata_1 node_elements setSparsity setSparsity_1 Derived Types MeshDataPointer_ MeshData_ Functions meshdata_ptr_1 Variables Type Visibility Attributes Name Initial type( MeshData_ ), public, parameter :: TypeMeshData = MeshData_(MaxNptrs=0, MinNptrs=0, tNodes=0, isInitiated=.FALSE., LBndyIndex=NULL(), Nptrs=NULL(), BoundaryNptrs=NULL(), InternalNptrs=NULL(), Local_Nptrs=NULL(), NodeToElem=NULL(), ElemToElem=NULL(), NTN=NULL(), ElemToNode=NULL(), BoundaryData=NULL(), InternalBndyElemNum=NULL(), InternalBoundaryData=NULL()) Interfaces public interface BoundingBox Generic method for obtaining bounding box for a mesh private interface get_Bbox () Return the boundinb box of mesh Arguments None public interface DeallocateData Generic subroutine to deallocate data stored inside MeshData_ private interface Deallocate_meshdata () Deallocate data stored inside MeshData_ Arguments None interface Deallocate data stored inside MeshData_ private subroutine Deallocate_meshdata(Obj) Deallocate data stored inside MeshData_ Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(inout) :: Obj mesh data object public interface Initiate private interface init_meshdata_1 () Initiate MeshData_ object Arguments None public interface MeshData Generic function to construct MeshData_ private interface meshdata_1 () MeshData() function to construct mesh data Arguments None public interface MeshData_Pointer Generic function that Returns pointer to MeshData_ object private function meshdata_ptr_1 (MeshObj) result(Ans) Function that returns pointer to the MeshData_ object Read more… Arguments Type Intent Optional Attributes Name class(Mesh_), intent(inout) :: MeshObj Mesh_ Object Return Value class( MeshData_ ),\n  POINTER MeshData_ object interface Return the boundinb box of mesh private pure function get_Bbox(Obj, nodes) result(Ans) Return the bounding box of mesh Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj mesh data object real(kind=DFP), intent(in) :: nodes (:,:) nodal coordinates in xiJ format Return Value type(BoundingBox_) bounding box for mesh interface Returns boundary element data private pure function get_bndy_elem(Obj, iel) result(Ans) If element is a boundary element then it Returns a integer vector\n containing the id of local facets which is boundary of mesh\n otherwise it will return [0] Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj mesh data integer(kind=I4B), intent(in) :: iel element number Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) boundary data interface Return element to element connectivity information private pure function get_elem_elems_1(Obj, iel) result(Ans) Return element to element connectivity information for a given element\n number iel - This routine return full information about elements surrounding\n element iel - Rows of Ans denote the element to which iel is connected to\n - Column-1 of Ans denotes element number\n - Column-2 denotes the local face number of element iel , and\n - Column-3 denotes the local face number of element whose element number is\n given in the column-1 Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj mesh data integer(kind=I4B), intent(in) :: iel element number Return Value integer(kind=I4B),\n  ALLOCATABLE, (:,:) list of elements surrounding elements interface Return element to element connectivity information private pure function get_elem_elems_2(Obj, iel) result(Ans) Return element to element connectivity information for a given element\n number iel - iel( 2 ) denotes the extra options\n     0 —> only Return the element numbers\n     1 —> Return the full information\n - This routine return full information when iel(2)=1 about elements surrounding element iel - Rows of Ans denote the element to which iel is connected to\n - Column-1 of Ans denotes element number\n - Column-2 denotes the local face number of element iel , and\n - Column-3 denotes the local face number of element whose element number is\n given in the column-1 Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: iel (2) Return Value integer(kind=I4B),\n  ALLOCATABLE, (:,:) interface Return element to nodes data private pure function get_elem_nodes(Obj, iel) result(Ans) Return element to nodes data Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj mesh data integer(kind=I4B), intent(in) :: iel element number Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) list of elements surrounding the nodes interface This subroutine returns the mesh of facet/boundary elements of mesh obj private subroutine get_facet_elements(mdObj, Obj, facetmesh, feObj) This subroutine returns the mesh of boundary/facet elements of parent mesh Obj Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(inout) :: mdObj Mesh data of parent mesh class(Mesh_), intent(inout) :: Obj Parent mesh class(Mesh_), intent(inout) :: facetmesh facet mesh to be constructed class(Element_), intent(in) :: feObj Finite element interface Return a list of nodes surrounding a given global node number private pure function get_node_nodes(Obj, GlobalNode, IncludeSelf) result(Ans) Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj mesh data integer(kind=I4B), intent(in) :: GlobalNode global node number logical(kind=LGT), intent(in) :: IncludeSelf logical variable Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) vec of node number surrounding GlobalNode interface This function returns the total boundary elements in mesh private pure function get_tbndy_elems(Obj) result(Ans) This function returns the total bounadry elements in mesh Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj Return Value integer(kind=I4B) interface Return total number of boundary nodes private pure function get_tbndy_nodes(Obj) result(Ans) Return total number of boundary nodes Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj mesh data Return Value integer(kind=I4B) total boundary nodes interface Returns total number of internal bounary nodes private pure function get_tint_nodes(Obj) result(Ans) Returns total number of internal bounary nodes Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj mesh data Return Value integer(kind=I4B) total number of internal boundary nodes interface Return total number of nodes private pure function get_total_nodes(Obj) result(Ans) This function will Return the total number of nodes present in meshdata Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj Mesh data object Return Value integer(kind=I4B) Total number of nodes interface Convert local node number to global node number private pure function global_from_local(Obj, LocalIndx) result(Ans) Convert local node number to global node number Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj mesh data integer(kind=I4B), intent(in) :: LocalIndx (:) vec of local node number Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) vec of global node number interface Convert local node number to global node number private pure function global_from_local_scalar(Obj, LocalIndx) result(Ans) Convert local node number to global node number Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj mesh data integer(kind=I4B), intent(in) :: LocalIndx local node number Return Value integer(kind=I4B) global node number interface Initiate boundary data of mesh private subroutine init_bndy_data(Obj, MeshObj) Initiate boundary data of mesh Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(inout) :: Obj mesh data class(Mesh_), intent(inout) :: MeshObj mesh object interface Initiate element to node data private subroutine init_elem_nodes(Obj, MeshObj) Initiate element to node data Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(inout) :: Obj mesh data class(Mesh_), intent(inout) :: MeshObj mesh object interface Initiate element to element connectivity data private subroutine init_element_elements(Obj, MeshObj) Initiate element to element connectivity data Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(inout) :: Obj mesh data class(Mesh_), intent(inout) :: MeshObj mesh object interface Initiate internal boundary data private subroutine init_int_bndydata(Obj, MeshObj) Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(inout) :: Obj class(Mesh_), intent(inout) :: MeshObj interface Initiate internal node numbers private subroutine init_int_nptrs(Obj, MeshObj) Initiate internal node numbers Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(inout) :: Obj mesh data class(Mesh_), intent(inout) :: MeshObj mesh object interface Initiate MeshData_ object private subroutine init_meshdata_1(Obj, MeshObj) Initiate MeshData_ object Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(inout) :: Obj mesh data container class(Mesh_), intent(inout) :: MeshObj mesh object interface generate Elements surrounding a node mapping private subroutine init_node_elements(Obj, MeshObj) This subroutine generate Elements surrounding a node mapping\n - The mapping is stored in the array called NodeToElem - The size of NodeToElem array is same as Obj % Nptrs - Always use method called NodeToElements() to access this information Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(inout) :: Obj mesh data class(Mesh_), intent(inout) :: MeshObj mesh object interface Initiate node to node connectivity data private subroutine init_node_nodes(Obj, MeshObj) Initiate node to node connectivity data Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(inout) :: Obj mesh data class(Mesh_), intent(inout) :: MeshObj mesh object interface Returns .true. if a given element number iel is boundary element private pure function is_bndy_elem(Obj, iel) result(Ans) Returns .true. if a given element number iel is boundary element Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj mesh data integer(kind=I4B), intent(in) :: iel element number Return Value logical(kind=LGT) .true. if iel is a boundary element interface Returns .true. if data related to boundary nptrs is initiated. private pure function is_bndy_nptrs(Obj) result(Ans) Returns .true. if data related to boundary nptrs is initiated. Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj Return Value logical(kind=LGT) interface Returns .true. if boundary data is initiated. private pure function is_boundarydata(Obj) result(Ans) Returns .true. if boundary data is initiated. Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj Return Value logical(kind=LGT) interface Returns .true. if elem to elem connectivity data is initiated. private pure function is_element_elements_initiated(Obj) result(Ans) Returns .true. if elem to elem connectivity data is initiated. Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj Return Value logical(kind=LGT) interface Returns .true. if elem to node connectivity data is initiated. private pure function is_element_nodes_initiated(Obj) result(Ans) Returns .true. if elem to node connectivity data is initiated. Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj Return Value logical(kind=LGT) interface Returns .true. if internal bounary data is initiated private pure function is_int_bndy_data(Obj) result(Ans) Returns .true. if internal bounary data is initiated Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj Return Value logical(kind=LGT) interface Returns .true. if data related to internal nptrs is initiated. private pure function is_internalnptrs(Obj) result(Ans) Returns .true. if data related to internal nptrs is initiated. Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj Return Value logical(kind=LGT) interface Returns .true. if data local_nptrs array is initiated. private pure function is_local_nptrs(Obj) result(Ans) Returns .true. if data local_nptrs array is initiated. Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj Return Value logical(kind=LGT) interface Returns .true. if node to elem connectivity data is initiated. private pure function is_node_elements_initiated(Obj) result(Ans) Returns .true. if node to elem connectivity data is initiated. Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj Return Value logical(kind=LGT) interface Returns .true. if node to node connectivity data is initiated. private pure function is_node_nodes_initiated(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj Return Value logical(kind=LGT) interface Returns .true. if the a global node is present inside the mesh-data private pure function is_node_present(Obj, Nptrs) result(Ans) Returns .true. if the a global node is present inside the mesh-data Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj mesh data integer(kind=I4B), intent(in) :: Nptrs global node number Return Value logical(kind=LGT) Returns true if present interface Convert global node number to local node  number private pure function local_from_global(Obj, GlobalIndx) result(Ans) Convert global node number to local node  number Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj mesh data integer(kind=I4B), intent(in) :: GlobalIndx (:) vec of global node numbers Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) vec of local node number interface Convert global node numbr to local node number private pure function local_from_global_scalar(Obj, GlobalIndx) result(Ans) Convert global node numbr to local node number Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj mesh data integer(kind=I4B), intent(in) :: GlobalIndx global node number Return Value integer(kind=I4B) local node number interface Connect facet to cell elements private subroutine mc_connect_facet_cell(CellMeshData, CellMesh, FacetMesh) This subroutine connects the mesh of facet elements to the mesh of\n cell elements. Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(inout) :: CellMeshData Mesh data of cell mesh class(Mesh_), intent(inout), TARGET :: CellMesh Mesh of  cell elements class(Mesh_), intent(inout), TARGET :: FacetMesh Mesh of facet elements interface private function md_findelement(Obj, MeshObj, coord, nodes) result(Ans) Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj class(Mesh_), intent(in) :: MeshObj real(kind=DFP), intent(in) :: coord (:,:) real(kind=DFP), intent(in) :: nodes (:,:) Return Value real(kind=DFP)\n  (SIZE(coord,2)) interface private function md_quality(Obj, Meshobj, Nodes, Measure) result(Ans) Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(inout) :: Obj class(Mesh_), intent(inout), TARGET :: Meshobj real(kind=DFP), intent(in) :: Nodes (:,:) integer(kind=I4B), intent(in) :: Measure Return Value real(kind=DFP),\n  ALLOCATABLE, (:) interface MeshData() function to construct mesh data private function meshdata_1(MeshObj) result(Ans) MeshData() function to construct mesh data Read more… Arguments Type Intent Optional Attributes Name class(Mesh_), intent(inout) :: MeshObj Mesh object Return Value type( MeshData_ ) Meshdata object interface Returns the element numbers which are connected to the a global node private pure function node_elements(Obj, GlobalPt) result(Ans) Returns the element numbers which are connected to the a global node Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(in) :: Obj mesh data integer(kind=I4B), intent(in) :: GlobalPt global node number Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) vec of element number public interface setSparsity generic interfac for setting sparsity pattern in SparseMatrix_ . private interface setSparsity_1 () This routine set the sparsity pattern in SparseMatrix_ object Arguments None interface This routine set the sparsity pattern in SparseMatrix_ object private subroutine setSparsity_1(Obj, MeshObj, Mat, map) This routine set the sparsity pattern in SparseMatrix_ object Read more… Arguments Type Intent Optional Attributes Name class( MeshData_ ), intent(inout) :: Obj mesh data type(Mesh_), intent(inout) :: MeshObj mesh object type(SparseMatrix_), intent(inout) :: Mat sparsematrix object integer(kind=I4B), intent(in), optional :: map (:) Global to local node number map Derived Types type, public :: MeshDataPointer_ Contains MeshData_ pointer as its field Components Type Visibility Attributes Name Initial class( MeshData_ ), public, POINTER :: Ptr => NULL() type, public :: MeshData_ MeshData_ contains data related to a mesh Read more… Components Type Visibility Attributes Name Initial type(IntVector_), public, ALLOCATABLE :: BoundaryData (:) If iel is boundary element;\n then Vec=BoundaryData( LBndyIndex(iel) ) contains boundary data, where vec(1) is equal to iel , and vec(2:) are ids of local facets which are boundaries of mesh integer(kind=I4B), public, ALLOCATABLE :: BoundaryNptrs (:) Node number of boundary of mesh type(IntVector_), public, ALLOCATABLE :: ElemToElem (:) ElemToElem( iel ) denotes data of elements\n connected to the element iel type(IntVector_), public, ALLOCATABLE :: ElemToNode (:) ElemToNode( iel ) denotes the node numbers in element iel type(IntVector_), public, ALLOCATABLE :: InternalBndyElemNum (:) To do type(IntVector_), public, ALLOCATABLE :: InternalBoundaryData (:) To do integer(kind=I4B), public, ALLOCATABLE :: InternalNptrs (:) Node number of internal nodes integer(kind=I4B), public, ALLOCATABLE :: LBndyIndex (:) For a given element if LBndyIndex(iel) .eq. 0 then iel is not a\n a boundary element else it a boundary element which represents the\n index of iel in BoundaryData() . integer(kind=I4B), public, ALLOCATABLE :: Local_Nptrs (:) This converts a given global node into local-node which can be\n used for accessing data inside NodeToElem, NodeToNode integer(kind=I4B), public :: MaxNptrs Largest node number present inside mesh integer(kind=I4B), public :: MinNptrs Smallest node number present inside mesh type(IntVector_), public, ALLOCATABLE :: NTN (:) NTN( iLocalNode ) denotes node-ids that are connected to a node GlobalNode( iLocalNode ) type(IntVector_), public, ALLOCATABLE :: NodeToElem (:) NodeToElem( iLocalNode ) denotes indx of elems in mesh which are\n directly connected to node GlobalNptrs( iLocalNode ) integer(kind=I4B), public, ALLOCATABLE :: Nptrs (:) Node number of mesh Nptrs( minNptrs : maxNptrs ) logical(kind=LGT), public :: isInitiated .True. if MeshObj_ is initiated type(ReferenceElement_), public, POINTER :: refelem => NULL() Reference element integer(kind=I4B), public :: tNodes Total number of nodes in mesh Type-Bound Procedures procedure, public, PASS( Obj ) :: BoundaryElementData => get_bndy_elem return boundary element data of a boundary element iel if it is\n boundary element procedure, public, PASS( Obj ) :: BoundingBox => get_Bbox return boundingbox of mesh generic, public :: ElementToElements => get_elem_elems_1, get_elem_elems_2 return element to element connectivity data for iel element procedure, public, PASS( Obj ) :: ElementToNodes => get_elem_nodes return element to node connectivity data for iel element procedure, public, PASS( Obj ) :: Finalize => Deallocate_meshdata Deallocate mesh data procedure, public, PASS( Obj ) :: FindElement => md_findelement generic, public :: GlobalNptrs => global_from_local, global_from_local_scalar return global node nuber of a given local node number procedure, public, PASS( Obj ) :: Initiate => init_meshdata_1 Initiate mesh data procedure, public, PASS( Obj ) :: InitiateBoundaryData => init_bndy_data construct boundary data information procedure, public, PASS( Obj ) :: InitiateElementToElements => init_element_elements construct element to element connectivity data procedure, public, PASS( Obj ) :: InitiateElementToNodes => init_elem_nodes construct element to node connectivity data procedure, public, PASS( Obj ) :: InitiateInternalBoundaryData => init_int_bndydata construct details about the internal boundary procedure, public, PASS( Obj ) :: InitiateInternalNptrs => init_int_nptrs construct details about the internal boundary procedure, public, PASS( Obj ) :: InitiateNodeToElements => init_node_elements construct node to element connectivity data procedure, public, PASS( Obj ) :: InitiateNodeToNodes => init_node_nodes construct node to node connectivity data generic, public :: LocalNptrs => local_from_global, local_from_global_scalar return local node number of a given global node number procedure, public, PASS( Obj ) :: MeshQuality => md_quality return mesh quality procedure, public, PASS( Obj ) :: NodeToElements => node_elements return node to element connectivity data for GlobalIndx procedure, public, PASS( Obj ) :: NodeToNodes => get_node_nodes return node to node connectivity data for GlobalIndx procedure, public, PASS( Obj ) :: TotalBoundaryElements => get_tbndy_elems Rertuns total boundary elements in mesh procedure, public, PASS( Obj ) :: TotalBoundaryNodes => get_tbndy_nodes Returns total number of boundary nodes in mesh procedure, public, PASS( Obj ) :: TotalInternalNodes => get_tint_nodes Return total number of internal nodes in mesh procedure, public, PASS( Obj ) :: TotalNodes => get_total_nodes Returns total number of nodes in mesh procedure, public, PASS( CellMeshData ) :: connectFacetToCell => mc_connect_facet_cell connect facet to cell procedure, public, PASS( mdObj ) :: getFacetElements => get_facet_elements return the boundary elements procedure, public, PASS( Obj ) :: get_elem_elems_1 return element to element connectivity data for iel element procedure, public, PASS( Obj ) :: get_elem_elems_2 return element to element connectivity data for iel element procedure, public, PASS( Obj ) :: global_from_local return global node nuber of a given local node number procedure, public, PASS( Obj ) :: global_from_local_scalar return global node nuber of a given local node number procedure, public, PASS( Obj ) :: isBoundaryDataInitiated => is_boundarydata returns .true. if BoundaryData array is allocated procedure, public, PASS( Obj ) :: isBoundaryElement => is_bndy_elem return .true. if element iel is a boundary element procedure, public, PASS( Obj ) :: isBoundaryNptrsInitiated => is_bndy_nptrs procedure, public, PASS( Obj ) :: isElementToElementsInitiated => is_element_elements_initiated returns .true. if ElemToElem array is allocated procedure, public, PASS( Obj ) :: isElementToNodesInitiated => is_element_nodes_initiated returns .true. if ElemToNode array is allocated procedure, public, PASS( Obj ) :: isInternalBoundaryDataInitiated => is_int_bndy_data returns .true. if InternalBoundaryData array is allocated procedure, public, PASS( Obj ) :: isInternalNptrsInitiated => is_internalnptrs returns .true. if InternalNptrs array is allocated procedure, public, PASS( Obj ) :: isLocalNptrsInitiated => is_local_nptrs returns .true. if Local_Nptrs array is allocated procedure, public, PASS( Obj ) :: isNodePresent => is_node_present returns .true. if a given node is present in the mesh procedure, public, PASS( Obj ) :: isNodeToElementsInitiated => is_node_elements_initiated returns .true. if NodeToElem array is allocated procedure, public, PASS( Obj ) :: isNodeToNodesInitiated => is_node_nodes_initiated returns .true. if NToN array is allocated procedure, public, PASS( Obj ) :: local_from_global return local node number of a given global node number procedure, public, PASS( Obj ) :: local_from_global_scalar return local node number of a given global node number procedure, public, PASS( Obj ) :: setSparsity => setSparsity_1 set sparsity in sparseMatrix_ Functions private function meshdata_ptr_1 (MeshObj) result(Ans) Function that returns pointer to the MeshData_ object Read more… Arguments Type Intent Optional Attributes Name class(Mesh_), intent(inout) :: MeshObj Mesh_ Object Return Value class( MeshData_ ),\n  POINTER MeshData_ object","tags":"","loc":"module/meshdata_class.html"},{"title":"Mesh_Class – Fortran Program","text":"Mesh_Class module contains three data user defined data types related to\n  finite element meshes: Mesh_ , MeshData_ , and MeshConnectivity_ .\n This module contains Mesh_ MeshData_ and MeshConnectivity_ Uses BaseType GlobalData FE Contents Variables TypeMesh default_factor Interfaces Constructor1 DeallocateData Deallocate_Data Display Initiate Mesh Mesh_Pointer Set_element add_element allocateMeshSize display_mesh getElement_Pointer getNptrs get_nptrs mesh_pointer_get_nptrs remove_element setMaterialType_1 set_total_elements total_elements Derived Types MeshPointer_ Mesh_ Functions Constructor_1 Variables Type Visibility Attributes Name Initial type( Mesh_ ), public, parameter :: TypeMesh = Mesh_(Elem=NULL(), NSD=0, tElements=0, maxElements=0) real(kind=DFP), private, parameter :: default_factor = 1.5_DFP Interfaces interface Function for constructing Mesh_ private pure function Constructor1(NSD, tElements, factor) result(Ans) Function for constructing Mesh_ Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: NSD spatial dimension integer(kind=I4B), intent(in) :: tElements totat number of elements in mesh real(kind=DFP), intent(in), optional :: factor Return Value type( Mesh_ ) Mesh object public interface DeallocateData Generic subroutine for deallcating data stored in Mesh_ private interface Deallocate_Data () Deallocate data stored in Mesh_ Arguments None interface Deallocate data stored in Mesh_ private subroutine Deallocate_Data(Obj) Deallocate data stored in Mesh_ Read more… Arguments Type Intent Optional Attributes Name class( Mesh_ ), intent(inout) :: Obj mesh object public interface Display generic routine to display content of mesh private interface display_mesh () display content of Mesh_ Arguments None public interface Initiate Generic routine for constructing Mesh_ private interface allocateMeshSize () Allocate the size of the mesh Arguments None public interface Mesh Generic function for constructing Mesh_ private interface Constructor1 () Function for constructing Mesh_ Arguments None public interface Mesh_Pointer Generic function for constructing pointer to Mesh_ private function Constructor_1 (NSD, tElements, factor) result(Ans) Function for constructing pointer to Mesh_ Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: NSD integer(kind=I4B), intent(in) :: tElements real(kind=DFP), intent(in), optional :: factor Return Value class( Mesh_ ),\n  POINTER interface Set an element to a mesh private subroutine Set_element(Obj, Elem, iel) Seting element; total number of elements remain same\n Size of mesh should be sufficient while using this. Read more… Arguments Type Intent Optional Attributes Name class( Mesh_ ), intent(inout) :: Obj Mesh object class(Element_), intent(inout), TARGET :: Elem Finite element to be put in mesh integer(kind=I4B), intent(in) :: iel element number interface Add an element to mesh private subroutine add_element(Obj, Elem) Append an element, increate total elements in mesh by one Read more… Arguments Type Intent Optional Attributes Name class( Mesh_ ), intent(inout) :: Obj mesh obj class(Element_), intent(inout), TARGET :: Elem finite element to be added interface Allocate the size of the mesh private subroutine allocateMeshSize(Obj, NSD, tElements, factor) Allocate the size of the mesh. Generic name —> Initiate() Read more… Arguments Type Intent Optional Attributes Name class( Mesh_ ), intent(inout) :: Obj mesh object integer(kind=I4B), intent(in) :: NSD spatial dimension integer(kind=I4B), intent(in) :: tElements total number of elements in mesh real(kind=DFP), intent(in), optional :: factor maxLength = factor * telements interface display content of Mesh_ private subroutine display_mesh(Obj, Msg, UnitNo) Display content of Mesh_ Read more… Arguments Type Intent Optional Attributes Name class( Mesh_ ), intent(inout) :: Obj mesh object character(len=*), intent(in) :: Msg message on screen integer(kind=I4B), intent(in), optional :: UnitNo unit number of ouput file interface Return the pointer to an element Obj % Elem(iel) private function getElement_Pointer(Obj, iel) result(Ans) Return the pointer to an element Obj % Elem(iel) Read more… Arguments Type Intent Optional Attributes Name class( Mesh_ ), intent(in) :: Obj mesh object integer(kind=I4B), intent(in) :: iel element number Return Value class(Element_),\n  POINTER pointer to finite element public interface getNptrs Generic subroutine to get Nptrs in MeshPointer_ private interface mesh_pointer_get_nptrs () Returns a vec of node numbers present in a collection of MeshPointer_ Arguments None interface Returns the node numbers in mesh private subroutine get_nptrs(Obj, Nptrs) Returns the node numbers in mesh Read more… Arguments Type Intent Optional Attributes Name class( Mesh_ ), intent(inout) :: Obj mesh object integer(kind=I4B), intent(inout), ALLOCATABLE :: Nptrs (:) node numbers interface Returns a vec of node numbers present in a collection of MeshPointer_ private subroutine mesh_pointer_get_nptrs(Obj, Nptrs) Returns the vec of node numbers present in a collection of MeshPointer_ Read more… Arguments Type Intent Optional Attributes Name type( MeshPointer_ ), intent(inout) :: Obj (:) Collection of pointer to Mesh_ integer(kind=I4B), intent(inout), ALLOCATABLE :: Nptrs (:) Node present in the collection of mesh interface Remove an element from the mesh private subroutine remove_element(Obj, iel, extraoption) Remove an element from the mesh Read more… Arguments Type Intent Optional Attributes Name class( Mesh_ ), intent(inout) :: Obj mesh object integer(kind=I4B), intent(in) :: iel element number integer(kind=I4B), intent(in) :: extraoption interface Set material propertie private subroutine setMaterialType_1(Obj, MatType) set material properties of element in the mesh. Currently, this routine\n add same material property to all elements Read more… Arguments Type Intent Optional Attributes Name class( Mesh_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: MatType interface Set total elements in mesh object private subroutine set_total_elements(Obj) Set total elements in mesh object Read more… Arguments Type Intent Optional Attributes Name class( Mesh_ ), intent(inout) :: Obj mesh object interface Returns total elements in the mesh private pure function total_elements(Obj) result(Ans) Returns total elements in the mesh Read more… Arguments Type Intent Optional Attributes Name class( Mesh_ ), intent(in) :: Obj mesh object Return Value integer(kind=I4B) Derived Types type, public :: MeshPointer_ MeshPointer_ is a userdefine datatype which contains the pointer to\n a mesh Components Type Visibility Attributes Name Initial type( Mesh_ ), public, POINTER :: Ptr => NULL() type, public :: Mesh_ In EASIFEM Mesh_ datatype is simply a collection of finite elements.\n To avoid working with linked list I have encapsulated a vector of ElementPointer_ . This way, adding or removing of an element\n to existing mesh becomes simple. Read more… Components Type Visibility Attributes Name Initial type(ElementPointer_), public, ALLOCATABLE :: Elem (:) Collection of finite elements integer(kind=I4B), public :: NSD spatial dimension integer(kind=I4B), public :: maxElements maximum size of the wrapper integer(kind=I4B), public :: tElements total elements in mesh Type-Bound Procedures procedure, public, PASS( Obj ) :: Append => add_element Append an element to a mesh procedure, public, PASS( Obj ) :: ElementPointer => getElement_Pointer Get Pointer to an element in mesh procedure, public, PASS( Obj ) :: Finalize => Deallocate_Data Deallocate data procedure, public, PASS( Obj ) :: Initiate => allocateMeshSize Allocate size of a mesh procedure, public, PASS( Obj ) :: RemoveElement => remove_element Remove an element from a mesh procedure, public, PASS( Obj ) :: SIZE => total_elements Returns the total elements in a mesh procedure, public, PASS( Obj ) :: SetElement => Set_element Set an element to a mesh procedure, public, PASS( Obj ) :: SetSize => set_total_elements Set total elements in a mesh procedure, public, PASS( Obj ) :: SetTotalElements => set_total_elements Alias of SetSize procedure, public, PASS( Obj ) :: TotalElements => total_elements Alias of SIZE procedure, public, PASS( Obj ) :: getNptrs => get_nptrs Get node numbers in a mesh procedure, public, PASS( Obj ) :: setMaterialType => setMaterialType_1 Set material type of a mesh Functions private function Constructor_1 (NSD, tElements, factor) result(Ans) Function for constructing pointer to Mesh_ Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: NSD integer(kind=I4B), intent(in) :: tElements real(kind=DFP), intent(in), optional :: factor Return Value class( Mesh_ ),\n  POINTER","tags":"","loc":"module/mesh_class.html"},{"title":"MeshConnectivity_Class – Fortran Program","text":"This module defines a class for handling mesh connectivity Uses BaseType GlobalData FE Mesh_Class MeshData_Class Contents Variables TypeMeshConnectivity Interfaces DeallocateData mc_cell_of_facet mc_cells_of_facets mc_deallocate_data mc_facet_local_id_1 mc_facet_local_id_2 mc_init_cell_facet mc_init_node_node Derived Types MeshConnectivityPointer_ MeshConnectivity_ Variables Type Visibility Attributes Name Initial type( MeshConnectivity_ ), public, parameter :: TypeMeshConnectivity = MeshConnectivity_(CellFacet=NULL(), CellCell=NULL(), NodeToNodes=NULL()) Interfaces private interface DeallocateData Generic subroutine to deallocate data stored inside MeshConnectivity_ private interface mc_deallocate_data () This subroutine deallocate the data stored in MeshConnectivity_ Arguments None interface Returns cell number of given facet number private pure function mc_cell_of_facet(Obj, FacetNum) result(Ans) fortran\n    id = obj % CellNumber( facetNum ) Read more… Arguments Type Intent Optional Attributes Name class( MeshConnectivity_ ), intent(in) :: Obj Mesh connectivity data integer(kind=I4B), intent(in) :: FacetNum Facet element number Return Value integer(kind=I4B) Cell number interface Returns cell number of given facet number private pure function mc_cells_of_facets(Obj, FacetNum) result(Ans) fortran\n    id = obj % CellNumber( facetNum ) Read more… Arguments Type Intent Optional Attributes Name class( MeshConnectivity_ ), intent(in) :: Obj Mesh connectivity data integer(kind=I4B), intent(in) :: FacetNum (:) List of facet element numbers Return Value integer(kind=I4B)\n  (SIZE(FacetNum)) List of cell element numbers interface This subroutine deallocate the data stored in MeshConnectivity_ private subroutine mc_deallocate_data(Obj) This subroutine deallocate the data stored in MeshConnectivity_ Read more… Arguments Type Intent Optional Attributes Name class( MeshConnectivity_ ), intent(inout) :: Obj Mesh connectivity object interface Returns the local facet id of cell element private pure function mc_facet_local_id_1(Obj, FacetNum) result(Ans) Returns the local facet id of cell element which is in contact with\n facet element Read more… Arguments Type Intent Optional Attributes Name class( MeshConnectivity_ ), intent(in) :: Obj Mesh connectivity object integer(kind=I4B), intent(in) :: FacetNum Facet element number Return Value integer(kind=I4B) Local facet ID interface Returns the local facet id of cell element private pure function mc_facet_local_id_2(Obj, FacetNum) result(Ans) Returns the local facet id of cell element which is in contact with\n facet element Read more… Arguments Type Intent Optional Attributes Name class( MeshConnectivity_ ), intent(in) :: Obj Mesh connectivity data integer(kind=I4B), intent(in) :: FacetNum (:) List of facet element numbers Return Value integer(kind=I4B)\n  (SIZE(FacetNum)) List of local facet IDs interface Generate the connectivity matrix between cell and facet mesh. private subroutine mc_init_cell_facet(Obj, CellMesh, FacetMesh, CellMeshData) This subroutine generate the connectivity matrix called Obj % CellFacet\n between cell and facet mesh. Read more… Arguments Type Intent Optional Attributes Name class( MeshConnectivity_ ), intent(inout) :: Obj Mesh connectivity data class(Mesh_), intent(inout) :: CellMesh Mesh of cell elements class(Mesh_), intent(inout) :: FacetMesh Mesh of facet mesh class(MeshData_), intent(inout) :: CellMeshData Mesh data for CellMesh interface Generate the connectivity matrix between two meshes private subroutine mc_init_node_node(Obj, Mesh1, Mesh2, Node1, Node2, MeshData1, MeshData2) The output result will be an integer array with 2 columns\n       - first column: contains the node number of Mesh1\n       - second column: contains the node number of Mesh2 which is\n       - directly connected to the node 1 Read more… Arguments Type Intent Optional Attributes Name class( MeshConnectivity_ ), intent(inout) :: Obj mesh connectivity object class(Mesh_), intent(in) :: Mesh1 Mesh object class(Mesh_), intent(in) :: Mesh2 Mesh object real(kind=DFP), intent(in) :: Node1 (:,:) Nodal coordinates in Mesh1 real(kind=DFP), intent(in) :: Node2 (:,:) Nodal coordinate in Mesh2 class(MeshData_), intent(inout) :: MeshData1 Mesh data for mesh 1 class(MeshData_), intent(inout) :: MeshData2 Mesh data for mesh 2 Derived Types type, public :: MeshConnectivityPointer_ This data type contains the pointer of MeshConnectivity_ Components Type Visibility Attributes Name Initial class( MeshConnectivity_ ), public, POINTER :: Ptr => NULL() type, public :: MeshConnectivity_ MeshConnectivity_ contains data connectivity data between two meshobject Components Type Visibility Attributes Name Initial integer(kind=I4B), public, ALLOCATABLE :: CellCell (:,:) Cell to cell connectivity data integer(kind=I4B), public, ALLOCATABLE :: CellFacet (:,:) Cell to facet connectivity data integer(kind=I4B), public, ALLOCATABLE :: NodeToNodes (:,:) Node to nodes connectivity data Type-Bound Procedures generic, public :: CellNumber => mc_cell_of_facet, mc_cells_of_facets Return the cell numbers of given facet elements generic, public :: FacetLocalID => mc_facet_local_id_1, mc_facet_local_id_2 Return the facet local id in cell element procedure, public, PASS( Obj ) :: Finalize => mc_deallocate_data Deallocate data stored in the object procedure, public, PASS( Obj ) :: InitiateFacetToCellData => mc_init_cell_facet Initiate facet to cell connectivity data procedure, public, PASS( Obj ) :: InitiateNodeToNodeData => mc_init_node_node Initiate the node to node connectivity between two meshes procedure, public, PASS( Obj ) :: mc_cell_of_facet Return the cell number of a given facet procedure, public, PASS( Obj ) :: mc_cells_of_facets Return the cell numbers of given facet elements procedure, public, PASS( Obj ) :: mc_facet_local_id_1 Return the facet local id in cell element procedure, public, PASS( Obj ) :: mc_facet_local_id_2 Return the facet local id in cell element","tags":"","loc":"module/meshconnectivity_class.html"},{"title":"Domain_Class – Fortran Program","text":"Domain_Class module contains the collection of meshes which represent specific\n parts of domain This module defines Domain_ class Uses BaseType GlobalData Mesh_Class MeshData_Class MeshConnectivity_Class FE Contents Variables TypeDomain Interfaces DeallocateData Initiate Initiate_obj deallocate_obj mc_connect_facet_cell Derived Types DomainPointer_ Domain_ Variables Type Visibility Attributes Name Initial type( Domain_ ), public, parameter :: TypeDomain = Domain_(Omega=NULL(), Boundary=NULL(), Edge=NULL(), mdOmega=NULL(), mdBoundary=NULL(), mdEdge=NULL(), omega_name=NULL(), boundary_name=NULL(), edge_name=NULL(), NodalVelocity=NULL(), NodalAcceleration=NULL()) Interfaces public interface DeallocateData generic interface to deallocate data in Domain_ private interface deallocate_obj () Deallocate data in Domain_ object Arguments None public interface Initiate Generic routine for initiating Domain_ object private interface Initiate_obj () Initiate Domain_ object Arguments None interface Initiate Domain_ object private subroutine Initiate_obj(Obj, tOmega, tBoundary, tEdge) This routine allocate the memory for Domain_ obj.\n - allocate size of Obj % Omega( 1:tOmega ) - allocate Obj % Boundary( 1:tBoundary ) ,\n - allocate Obj % mdOmega( 1:tOmega ) - allocate Obj % mdBoundary( 1:tBoundary ) Read more… Arguments Type Intent Optional Attributes Name class( Domain_ ), intent(inout) :: Obj Domain integer(kind=I4B), intent(in), optional :: tOmega total number of $\\Omega$ domains integer(kind=I4B), intent(in), optional :: tBoundary total number of $\\Gamma$ domains integer(kind=I4B), intent(in), optional :: tEdge total number of line domains interface Deallocate data in Domain_ object private subroutine deallocate_obj(Obj) Deallocate data stored in Domain_ object Arguments Type Intent Optional Attributes Name class( Domain_ ), intent(inout) :: Obj Domain object interface Connect Mesh_ of FacetElement_ to Mesh_ of cell Element_ private subroutine mc_connect_facet_cell(Dom, OmegaIndx, BoundaryIndx) This subroutine connects the mesh of facet elements to the mesh of\n cell elements Read more… Arguments Type Intent Optional Attributes Name class( Domain_ ), intent(inout), TARGET :: Dom integer(kind=I4B), intent(in) :: OmegaIndx integer(kind=I4B), intent(in) :: BoundaryIndx Derived Types type, public :: DomainPointer_ It contains pointer to Domain_ object Components Type Visibility Attributes Name Initial class( Domain_ ), public, POINTER :: Ptr => NULL() type, public :: Domain_ Domain_ contains the collection of meshes which represent specific\n parts of domain Components Type Visibility Attributes Name Initial type(MeshPointer_), public, ALLOCATABLE :: Boundary (:) Mesh of boundary elements type(MeshPointer_), public, ALLOCATABLE :: Edge (:) Mesh of lines real(kind=DFP), public, ALLOCATABLE :: NodalAcceleration (:,:) real(kind=DFP), public, ALLOCATABLE :: NodalVelocity (:,:) real(kind=DFP), public, POINTER :: Nodes (:,:) => NULL() type(MeshPointer_), public, ALLOCATABLE :: Omega (:) Mesh of cell elements logical(kind=LGT), public :: allocateNodes = .FALSE. This indicates whether nodes are allocated inside the domain or outside type(String), public, ALLOCATABLE :: boundary_name (:) physical names of boundary type(String), public, ALLOCATABLE :: edge_name (:) physical names of edge type(MeshDataPointer_), public, ALLOCATABLE :: mdBoundary (:) Mesh data for Boundary(:) type(MeshDataPointer_), public, ALLOCATABLE :: mdEdge (:) Mesh data for Boundary(:) type(MeshDataPointer_), public, ALLOCATABLE :: mdOmega (:) Mesh data for Omega(:) type(String), public, ALLOCATABLE :: omega_name (:) Physical names of omega Type-Bound Procedures procedure, public, PASS( Dom ) :: ConnectFacetToCell => mc_connect_facet_cell procedure, public, PASS( Obj ) :: Finalize => deallocate_obj Deallocate data store inside the domain procedure, public, PASS( Obj ) :: Initiate => Initiate_obj Constructor for domain","tags":"","loc":"module/domain_class.html"},{"title":"FE – Fortran Program","text":"Uses Element_Class FacetElement_Class Contents Functions getFEPointer Functions public function getFEPointer (Obj, Nptrs, Mat_Type, RefElem) result(Ans) Arguments Type Intent Optional Attributes Name class(Element_), intent(in) :: Obj integer(kind=I4B), intent(in) :: Nptrs (:) integer(kind=I4B), intent(in) :: Mat_Type class(ReferenceElement_), intent(inout), TARGET :: RefElem Return Value class(Element_),\n  POINTER","tags":"","loc":"module/fe.html"},{"title":"Element_Class – Fortran Program","text":"Uses GlobalData BaseType Contents Variables TypeElement Interfaces Constructor1 Constructor2 Constructor3 DeallocateData Deallocate_Data Display Element Element_Pointer FreePointerToCell Initiate SetPointerToCell getCellNptrs getFacetLocalID getFacetLocalNptrs getPointerToCell get_elemsd_H1_Lagrange m_Initiate_obj m_display_Obj m_getNptrs m_initiate_from_obj m_isBoundaryElement m_setNptrs s_Initiate_obj s_display_Obj setFacetLocalID setMaterialType_1 Derived Types ElementPointer_ Element_ Functions Constructor_1 Constructor_2 Constructor_3 Variables Type Visibility Attributes Name Initial type( Element_ ), public, parameter :: TypeElement = Element_(Nptrs=NULL(), Mat_Type=0_I4B, RefElem=NULL()) Interfaces interface private function Constructor1(Nptrs, Mat_Type, RefElem) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Nptrs (:) integer(kind=I4B), intent(in) :: Mat_Type class(ReferenceElement_), intent(inout), TARGET :: RefElem Return Value type( Element_ ) interface private function Constructor2() result(Obj) Arguments None Return Value type( Element_ ) interface private function Constructor3(AnotherObj) result(Obj) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(inout), TARGET :: AnotherObj Return Value type( Element_ ) public interface DeallocateData private interface Deallocate_Data () Arguments None interface private subroutine Deallocate_Data(Obj) Arguments Type Intent Optional Attributes Name type( Element_ ), intent(inout) :: Obj public interface Display private interface s_display_Obj () Arguments None public interface Element private interface Constructor1 () Arguments None private interface Constructor2 () Arguments None private interface Constructor3 () Arguments None public interface Element_Pointer private function Constructor_1 (Nptrs, Mat_Type, RefElem) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Nptrs (:) integer(kind=I4B), intent(in) :: Mat_Type class(ReferenceElement_), intent(inout), TARGET :: RefElem Return Value class( Element_ ),\n  POINTER private function Constructor_2 () result(Obj) Arguments None Return Value class( Element_ ),\n  POINTER private function Constructor_3 (AnotherObj) result(Obj) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(inout), TARGET :: AnotherObj Return Value class( Element_ ),\n  POINTER interface private subroutine FreePointerToCell(Obj) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(inout) :: Obj public interface Initiate private interface s_Initiate_obj () Arguments None interface private subroutine SetPointerToCell(Obj, CellObj) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(inout) :: Obj class( Element_ ), intent(inout), TARGET :: CellObj interface private pure function getCellNptrs(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(in) :: Obj Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) interface private pure function getFacetLocalID(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(in) :: Obj Return Value integer(kind=I4B) interface private pure function getFacetLocalNptrs(Obj) result(Nptrs) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(in) :: Obj Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) interface private function getPointerToCell(Obj) result(CellObj) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(in), TARGET :: Obj Return Value class( Element_ ),\n  POINTER interface private subroutine get_elemsd_H1_Lagrange(Obj, ElemSD, Quad, xIJ, ContinuityType, InterpolType) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(inout) :: Obj class(ElemShapeData_), intent(inout) :: ElemSD type(QuadraturePoint_), intent(in) :: Quad real(kind=DFP), intent(in) :: xIJ (:,:) type(H1_), intent(in) :: ContinuityType type(LagrangeInterpolation_), intent(in) :: InterpolType interface private subroutine m_Initiate_obj(Obj, Nptrs, Mat_Type, RefElem) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Nptrs (:) integer(kind=I4B), intent(in) :: Mat_Type class(ReferenceElement_), intent(inout), TARGET :: RefElem interface private subroutine m_display_Obj(Obj, Msg, UnitNo, FullDisp) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(in) :: Obj character(len=*), intent(in) :: Msg integer(kind=I4B), intent(in), optional :: UnitNo logical(kind=LGT), intent(in), optional :: FullDisp interface private pure function m_getNptrs(Obj) result(Nptrs) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(in) :: Obj Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) interface private subroutine m_initiate_from_obj(Obj, AnotherObj) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(inout) :: Obj class( Element_ ), intent(inout), TARGET :: AnotherObj interface private pure function m_isBoundaryElement(Obj, NSD) result(Ans) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: NSD Return Value logical(kind=LGT) interface private subroutine m_setNptrs(Obj, Nptrs) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Nptrs (:) interface private subroutine s_Initiate_obj(Obj, Nptrs, Mat_Type, RefElem) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Nptrs (:) integer(kind=I4B), intent(in) :: Mat_Type class(ReferenceElement_), intent(inout), TARGET :: RefElem interface private subroutine s_display_Obj(Obj, Msg, UnitNo, FullDisp) Arguments Type Intent Optional Attributes Name type( Element_ ), intent(in) :: Obj character(len=*), intent(in) :: Msg integer(kind=I4B), intent(in), optional :: UnitNo logical(kind=LGT), intent(in), optional :: FullDisp interface private subroutine setFacetLocalID(Obj, Id) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Id interface private subroutine setMaterialType_1(Obj, MatType) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: MatType Derived Types type, public :: ElementPointer_ Components Type Visibility Attributes Name Initial class( Element_ ), public, POINTER :: Ptr => NULL() type, public :: Element_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: MAT_Type integer(kind=I4B), public, ALLOCATABLE :: Nptrs (:) class(ReferenceElement_), public, POINTER :: RefElem => NULL() Type-Bound Procedures procedure, public, PASS( Obj ) :: CellNptrs => getCellNptrs procedure, public, PASS( Obj ) :: CellPointer => getPointerToCell procedure, public, PASS( Obj ) :: Display => m_display_Obj procedure, public, PASS( Obj ) :: FacetLocalID => getFacetLocalID procedure, public, PASS( Obj ) :: FacetLocalNptrs => getFacetLocalNptrs procedure, public, PASS( Obj ) :: FreePointerToCell generic, public :: Initiate => m_Initiate_obj, m_initiate_from_obj generic, public :: OPERATOR( .Nptrs. ) => getNptrs procedure, public, PASS( Obj ) :: PointerToCell => getPointerToCell generic, public :: getElemShapeData => get_elemsd_H1_Lagrange procedure, public, PASS( Obj ) :: getNptrs => m_getNptrs procedure, public, PASS ( Obj ) :: get_elemsd_H1_Lagrange procedure, public, PASS( Obj ) :: isBoundaryElement => m_isBoundaryElement procedure, public, PASS( Obj ) :: m_Initiate_obj procedure, public, PASS( Obj ) :: m_initiate_from_obj procedure, public, PASS( Obj ) :: setFacetLocalID procedure, public, PASS( Obj ) :: setMaterialType => setMaterialType_1 procedure, public, PASS( Obj ) :: setNptrs => m_setNptrs procedure, public, PASS( Obj ) :: setPointerToCell => SetPointerToCell Functions private function Constructor_1 (Nptrs, Mat_Type, RefElem) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Nptrs (:) integer(kind=I4B), intent(in) :: Mat_Type class(ReferenceElement_), intent(inout), TARGET :: RefElem Return Value class( Element_ ),\n  POINTER private function Constructor_2 () result(Obj) Arguments None Return Value class( Element_ ),\n  POINTER private function Constructor_3 (AnotherObj) result(Obj) Arguments Type Intent Optional Attributes Name class( Element_ ), intent(inout), TARGET :: AnotherObj Return Value class( Element_ ),\n  POINTER","tags":"","loc":"module/element_class.html"},{"title":"FacetElement_Class – Fortran Program","text":"Uses GlobalData BaseType Element_Class Contents Variables TypeFacetElement Interfaces Constructor1 Constructor2 Constructor3 DeallocateData Deallocate_Data Display FacetElement FacetElement_Pointer FreePointerToCell SetPointerToCell getCellNptrs getFacetLocalID getFacetLocalNptrs getPointerToCell get_elemsd_H1_Lagrange m_display_Obj s_display_Obj setFacetLocalID Derived Types FacetElementPointer_ FacetElement_ Functions Constructor_1 Constructor_2 Constructor_3 Variables Type Visibility Attributes Name Initial type( FacetElement_ ), public, parameter :: TypeFacetElement = FacetElement_(Mat_Type=0_I4B, RefElem=NULL(), LocalID=0_I4B) Interfaces interface private function Constructor1(Nptrs, Mat_Type, RefElem) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Nptrs (:) integer(kind=I4B), intent(in) :: Mat_Type class(ReferenceElement_), intent(inout), TARGET :: RefElem Return Value type( FacetElement_ ) interface private function Constructor2() result(Obj) Arguments None Return Value type( FacetElement_ ) interface private function Constructor3(AnotherObj) result(Obj) Arguments Type Intent Optional Attributes Name class(Element_), intent(inout), TARGET :: AnotherObj Return Value type( FacetElement_ ) public interface DeallocateData private interface Deallocate_Data () Arguments None interface private subroutine Deallocate_Data(Obj) Arguments Type Intent Optional Attributes Name type( FacetElement_ ), intent(inout) :: Obj public interface Display private interface s_display_Obj () Arguments None public interface FacetElement private interface Constructor1 () Arguments None private interface Constructor2 () Arguments None private interface Constructor3 () Arguments None public interface FacetElement_Pointer private function Constructor_1 (Nptrs, Mat_Type, RefElem) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Nptrs (:) integer(kind=I4B), intent(in) :: Mat_Type class(ReferenceElement_), intent(inout), TARGET :: RefElem Return Value class( FacetElement_ ),\n  POINTER private function Constructor_2 () result(Obj) Arguments None Return Value class( FacetElement_ ),\n  POINTER private function Constructor_3 (AnotherObj) result(Obj) Arguments Type Intent Optional Attributes Name class( FacetElement_ ), intent(inout), TARGET :: AnotherObj Return Value class( FacetElement_ ),\n  POINTER interface private subroutine FreePointerToCell(Obj) Arguments Type Intent Optional Attributes Name class( FacetElement_ ), intent(inout) :: Obj interface private subroutine SetPointerToCell(Obj, CellObj) Arguments Type Intent Optional Attributes Name class( FacetElement_ ), intent(inout) :: Obj class(Element_), intent(inout), TARGET :: CellObj interface private pure function getCellNptrs(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( FacetElement_ ), intent(in) :: Obj Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) interface private pure function getFacetLocalID(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( FacetElement_ ), intent(in) :: Obj Return Value integer(kind=I4B) interface private pure function getFacetLocalNptrs(Obj) result(Nptrs) Arguments Type Intent Optional Attributes Name class( FacetElement_ ), intent(in) :: Obj Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) interface private function getPointerToCell(Obj) result(CellObj) Arguments Type Intent Optional Attributes Name class( FacetElement_ ), intent(in), TARGET :: Obj Return Value class(Element_),\n  POINTER interface private subroutine get_elemsd_H1_Lagrange(Obj, ElemSD, Quad, xIJ, ContinuityType, InterpolType) Arguments Type Intent Optional Attributes Name class( FacetElement_ ), intent(inout) :: Obj class(ElemShapeData_), intent(inout) :: ElemSD type(QuadraturePoint_), intent(in) :: Quad real(kind=DFP), intent(in) :: xIJ (:,:) type(H1_), intent(in) :: ContinuityType type(LagrangeInterpolation_), intent(in) :: InterpolType interface private subroutine m_display_Obj(Obj, Msg, UnitNo, FullDisp) Arguments Type Intent Optional Attributes Name class( FacetElement_ ), intent(in) :: Obj character(len=*), intent(in) :: Msg integer(kind=I4B), intent(in), optional :: UnitNo logical(kind=LGT), intent(in), optional :: FullDisp interface private subroutine s_display_Obj(Obj, Msg, UnitNo, FullDisp) Arguments Type Intent Optional Attributes Name type( FacetElement_ ), intent(in) :: Obj character(len=*), intent(in) :: Msg integer(kind=I4B), intent(in), optional :: UnitNo logical(kind=LGT), intent(in), optional :: FullDisp interface private subroutine setFacetLocalID(Obj, Id) Arguments Type Intent Optional Attributes Name class( FacetElement_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Id Derived Types type, public :: FacetElementPointer_ Components Type Visibility Attributes Name Initial class( FacetElementPointer_ ), public, POINTER :: Ptr => NULL() type, public, EXTENDS( Element_ ) :: FacetElement_ Components Type Visibility Attributes Name Initial class(Element_), public, POINTER :: Cell => NULL() integer(kind=I4B), public :: LocalID class(Element_), public, POINTER :: OuterCell => NULL() Type-Bound Procedures procedure, public, PASS( Obj ) :: CellNptrs => getCellNptrs procedure, public, PASS( Obj ) :: Display => m_display_Obj procedure, public, PASS( Obj ) :: FacetLocalID => getFacetLocalID procedure, public, PASS( Obj ) :: FacetLocalNptrs => getFacetLocalNptrs procedure, public, PASS( Obj ) :: FreePointerToCell procedure, public, PASS( Obj ) :: PointerToCell => getPointerToCell procedure, public, PASS( Obj ) :: get_elemsd_H1_Lagrange procedure, public, PASS( Obj ) :: setFacetLocalID procedure, public, PASS( Obj ) :: setPointerToCell => SetPointerToCell Functions private function Constructor_1 (Nptrs, Mat_Type, RefElem) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Nptrs (:) integer(kind=I4B), intent(in) :: Mat_Type class(ReferenceElement_), intent(inout), TARGET :: RefElem Return Value class( FacetElement_ ),\n  POINTER private function Constructor_2 () result(Obj) Arguments None Return Value class( FacetElement_ ),\n  POINTER private function Constructor_3 (AnotherObj) result(Obj) Arguments Type Intent Optional Attributes Name class( FacetElement_ ), intent(inout), TARGET :: AnotherObj Return Value class( FacetElement_ ),\n  POINTER","tags":"","loc":"module/facetelement_class.html"},{"title":"vtkType – Fortran Program","text":"This module contains methods to write mesh data in vtk file format authors: Dr. Vikas Sharma It is a wrapper around Vtk-fortran library of https://github.com/szaghi/VTKFortran Uses GlobalData BaseType vtk_fortran Mesh_Class MeshData_Class Contents Variables TypeVTK Interfaces DeallocateData Display vtk_display vtk_final vtk_init vtk_start_write_elem_data vtk_start_write_geo vtk_start_write_node_data vtk_stop_write_elem_data vtk_stop_write_geo vtk_stop_write_node_data vtk_write_cell_data_1 vtk_write_cell_data_2 vtk_write_mesh_data_1 vtk_write_mesh_data_2 vtk_write_mesh_data_3 vtk_write_node_data_1 vtk_write_node_data_2 Derived Types vtkPointer_ vtk_ Variables Type Visibility Attributes Name Initial type( vtk_ ), public, parameter :: TypeVTK = vtk_() Interfaces public interface DeallocateData private interface vtk_final () This subroutine closes the opened vtk file Arguments None public interface Display private interface vtk_display () Arguments None interface private subroutine vtk_display(obj, msg, unitno) Arguments Type Intent Optional Attributes Name class( vtk_ ), intent(in) :: obj character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitno interface This subroutine closes the opened vtk file private subroutine vtk_final(obj) This subroutine close the open vtk file Arguments Type Intent Optional Attributes Name class( vtk_ ), intent(inout) :: obj interface This subroutine initiate the vtk object private subroutine vtk_init(obj, path, filename, extension, fmt, meshTopology, indx, nx1, nx2, ny1, ny2, nz1, nz2) This subroutine initate the vtk file object Arguments Type Intent Optional Attributes Name class( vtk_ ), intent(inout) :: obj vtk_ filename object character(len=*), intent(in) :: path path of the filename to be created character(len=*), intent(in) :: filename name of the file to be created character(len=*), intent(in) :: extension extension of the file .vtu character(len=*), intent(in) :: fmt storage format ascii, binary_append, binary character(len=*), intent(in) :: meshTopology mesh topology UnstructuredGrid integer(kind=I4B), intent(in) :: indx (:) its(1) = time-step its(2) = iteration number, if present integer(kind=I4B), intent(in), optional :: nx1 for structured grid only integer(kind=I4B), intent(in), optional :: nx2 for structured grid only integer(kind=I4B), intent(in), optional :: ny1 for structured grid only integer(kind=I4B), intent(in), optional :: ny2 for structured grid only integer(kind=I4B), intent(in), optional :: nz1 for structured grid only integer(kind=I4B), intent(in), optional :: nz2 for structured grid only interface private subroutine vtk_start_write_elem_data(obj) Arguments Type Intent Optional Attributes Name class( vtk_ ), intent(inout) :: obj interface Should be called before vtk_ call private subroutine vtk_start_write_geo(obj) This subroutine should be called before start writing the geometry\n in the <piece> tag Read more… Arguments Type Intent Optional Attributes Name class( vtk_ ), intent(inout) :: obj interface private subroutine vtk_start_write_node_data(obj) Arguments Type Intent Optional Attributes Name class( vtk_ ), intent(inout) :: obj interface private subroutine vtk_stop_write_elem_data(obj) Arguments Type Intent Optional Attributes Name class( vtk_ ), intent(inout) :: obj interface Should be called before vtk_ call private subroutine vtk_stop_write_geo(obj) This subroutine should be called after we are done writing the mesh\n information, point data and cell data. Read more… Arguments Type Intent Optional Attributes Name class( vtk_ ), intent(inout) :: obj interface private subroutine vtk_stop_write_node_data(obj) Arguments Type Intent Optional Attributes Name class( vtk_ ), intent(inout) :: obj interface This subroutine writes the cell data information in a vtk file format private subroutine vtk_write_cell_data_1(obj, val, name) This subroutine writes the cell data (single scalars) into a vtk file Arguments Type Intent Optional Attributes Name class( vtk_ ), intent(inout) :: obj real(kind=DFP), intent(in) :: val (:) size(val) should be equal to totol number of cell character(len=*), intent(in) :: name interface This subroutine writes the cell data information in a vtk file format private subroutine vtk_write_cell_data_2(obj, val, name) This subroutine writes the cell data (single vector) into a vtk file Arguments Type Intent Optional Attributes Name class( vtk_ ), intent(inout) :: obj real(kind=DFP), intent(in) :: val (:,:) size(val,2) should be equal to totol number of cell\n size(val,1) number of components character(len=*), intent(in) :: name interface This subroutine writes the mesh data information in the private subroutine vtk_write_mesh_data_1(obj, meshobj, mdobj, nodes) This subroutine writes the information of the mesh in vtkfile\n In this interface use must provide the MeshData_ object. Read more… Arguments Type Intent Optional Attributes Name class( vtk_ ), intent(inout) :: obj vtk_ file class(Mesh_), intent(inout), TARGET :: meshobj Mesh_ instance class(MeshData_), intent(inout) :: mdobj MeshData_ instance real(kind=DFP), intent(in) :: nodes (:,:) Nodal coordinates in xij format interface This subroutine writes the mesh data information in the private subroutine vtk_write_mesh_data_2(obj, meshobj, nodes) This subroutine writes the information of the mesh in vtkfile\n This subroutine should be used carefully\n We advise you to avoide using this subroutine as much as possible Arguments Type Intent Optional Attributes Name class( vtk_ ), intent(inout) :: obj vtk_ file class(Mesh_), intent(inout), TARGET :: meshobj Mesh_ instance real(kind=DFP), intent(in) :: nodes (:,:) Nodal coordinates in xij format interface This subroutine writes the mesh data information in the private subroutine vtk_write_mesh_data_3(obj, meshobj, nodes, tag, local2global, map, lb, ub) This subroutine writes the information of the mesh in vtkfile\n In this interface use must provide the MeshData_ object. Read more… Arguments Type Intent Optional Attributes Name class( vtk_ ), intent(inout) :: obj vtk_ file class(MeshPointer_), intent(inout), TARGET :: meshobj (:) Mesh_ instance real(kind=DFP), intent(in) :: nodes (:,:) Nodal coordinates in xij format integer(kind=I4B), intent(in) :: tag (:) integer(kind=I4B), intent(in) :: local2global (:) integer(kind=I4B), intent(in) :: map (lb:ub) integer(kind=I4B), intent(in) :: lb integer(kind=I4B), intent(in) :: ub interface This subroutine writes the node data information in a vtk file format private subroutine vtk_write_node_data_1(obj, x, dofobj, name, prefix) This subroutine writes the nodal values of a variable x into vtk file Read more… Arguments Type Intent Optional Attributes Name class( vtk_ ), intent(inout) :: obj real(kind=DFP), intent(in) :: x (:) type(DOF_), intent(in) :: dofobj character(len=1), intent(in) :: name character(len=*), intent(in) :: prefix It is the name of a DOF present inside dofobj; we will find this name\n and write data corresponding to that physical name interface This subroutine writes the node data information in a vtk file format private subroutine vtk_write_node_data_2(obj, x, dofobj, prefix) This subroutine writes the nodal values of a variable x into vtk file Read more… Arguments Type Intent Optional Attributes Name class( vtk_ ), intent(inout) :: obj real(kind=DFP), intent(in) :: x (:) type(DOF_), intent(in) :: dofobj character(len=*), intent(in), optional :: prefix Derived Types type, public :: vtkPointer_ Components Type Visibility Attributes Name Initial class( vtk_ ), public, POINTER :: Ptr => NULL() type, public :: vtk_ Components Type Visibility Attributes Name Initial type(vtk_file), public :: afile type(String), public :: extension type(String), public :: filename character(len=10), public :: fmt = \"ascii\" logical(kind=LGT), public :: inPiece = .FALSE. character(len=10), public :: meshTopology = \"UnstructuredGrid\" integer(kind=I4B), public :: nx1 = 0 integer(kind=I4B), public :: nx2 = 0 integer(kind=I4B), public :: ny1 = 0 integer(kind=I4B), public :: ny2 = 0 integer(kind=I4B), public :: nz1 = 0 integer(kind=I4B), public :: nz2 = 0 type(String), public :: path Type-Bound Procedures procedure, public, PASS( obj ) :: Finalize => vtk_final procedure, public, PASS( obj ) :: Initiate => vtk_init generic, public :: WriteGeometry => vtk_write_mesh_data_1, vtk_write_mesh_data_2, vtk_write_mesh_data_3 generic, public :: WriteNodeData => vtk_write_node_data_1, vtk_write_node_data_2 generic, public :: WriteQuadratureData => vtk_write_cell_data_1, vtk_write_cell_data_2 procedure, public, PASS( Obj ) :: closeElementData => vtk_stop_write_elem_data procedure, public, PASS( Obj ) :: closeNodeData => vtk_stop_write_node_data procedure, public, PASS( obj ) :: closePiece => vtk_stop_write_geo procedure, public, PASS( Obj ) :: openElementData => vtk_start_write_elem_data procedure, public, PASS( Obj ) :: openNodeData => vtk_start_write_node_data procedure, public, PASS( obj ) :: openPiece => vtk_start_write_geo procedure, public, PASS( Obj ) :: vtk_write_cell_data_1 procedure, public, PASS( Obj ) :: vtk_write_cell_data_2 procedure, public, PASS( obj ) :: vtk_write_mesh_data_1 procedure, public, PASS( obj ) :: vtk_write_mesh_data_2 procedure, public, PASS( obj ) :: vtk_write_mesh_data_3 procedure, public, PASS( obj ) :: vtk_write_node_data_1 procedure, public, PASS( obj ) :: vtk_write_node_data_2","tags":"","loc":"module/vtktype.html"},{"title":"QuadratureVariables_Class – Fortran Program","text":"This module defines a class MatProps_ which contians variables\n and parameters defined inside a finite element\n (i.e., at quadrature points) Uses BaseType GlobalData Mesh_Class Contents Variables TypeQuadratureVariables Interfaces DeallocateData Display Initiate elem_var_add_val elem_var_deallocate_data elem_var_disp elem_var_get_value elem_var_initiate elem_var_set_value Derived Types QuadratureVariablesPointer_ QuadratureVariables_ Variables Type Visibility Attributes Name Initial type( QuadratureVariables_ ), public, parameter :: TypeQuadratureVariables = QuadratureVariables_(Val=NULL(), Names=NULL()) Parameter instance of type QuadratureVariables_ Interfaces public interface DeallocateData genenric interface for deallocating data in QuadratureVariables_ private interface elem_var_deallocate_data () Deallocat data stored inside QuadratureVariables_ object Arguments None public interface Display Generic interaface to display content of QuadratureVariables_ private interface elem_var_disp () Display the content of QuadratureVariables_ Arguments None public interface Initiate Generic method to initiate QuadratureVariables_ private interface elem_var_initiate () Subroutine that initiate QuadratureVariables_ object Arguments None interface Subroutine that adds values in QuadratureVariables_ object private subroutine elem_var_add_val(Obj, ipoint, elemnum, Scale, Val, is, ie) This subroutine adds values of Obj % Val( :, ipoint, icol ) Arguments Type Intent Optional Attributes Name class( QuadratureVariables_ ), intent(inout) :: Obj Instance of QuadratureVariables_ integer(kind=I4B), intent(in) :: ipoint Quadrature point number integer(kind=I4B), intent(in) :: elemnum It represents id of element or material depending on storage type real(kind=DFP), intent(in) :: Scale Scaling used for Values real(kind=DFP), intent(in) :: Val (:) Values integer(kind=I4B), intent(in), optional :: is is starting index integer(kind=I4B), intent(in), optional :: ie ie ending index interface Deallocat data stored inside QuadratureVariables_ object private subroutine elem_var_deallocate_data(Obj) Arguments Type Intent Optional Attributes Name class( QuadratureVariables_ ), intent(inout) :: Obj interface Display the content of QuadratureVariables_ private subroutine elem_var_disp(Obj, msg, unitno) Arguments Type Intent Optional Attributes Name class( QuadratureVariables_ ), intent(in) :: Obj character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitno interface Return values stored inside QuadratureVariables_ private pure function elem_var_get_value(Obj, elemnum) result(Ans) This subroutine returns Obj % Val(:,:,elemnum) Arguments Type Intent Optional Attributes Name class( QuadratureVariables_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: elemnum Element number or material number Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) interface Subroutine that initiate QuadratureVariables_ object private subroutine elem_var_initiate(Obj, tprop, tpoint, telem, names) This subroutine initiates QuadratureVariables_ object\n - If colID=M then object stores material properties\n - In above case tpoint is not considered and set to 1 internally\n - If names are present then size( names ) == tprop - If names are not present then variables will be named as V1, V2,... Arguments Type Intent Optional Attributes Name class( QuadratureVariables_ ), intent(inout) :: Obj Instance integer(kind=I4B), intent(in) :: tprop Total number of properties integer(kind=I4B), intent(in) :: tpoint Total number of quadrature points integer(kind=I4B), intent(in) :: telem Total number of columns type(String), intent(in), optional :: names (:) Names of variables interface Subroutine that sets values in QuadratureVariables_ object private subroutine elem_var_set_value(Obj, ipoint, elemnum, Val, is, ie) This subroutine set values of Obj % Val( :, ipoint, icol ) - Obj % Val( i_s:i_e, ipoint, icol) = Val( : ) Arguments Type Intent Optional Attributes Name class( QuadratureVariables_ ), intent(inout) :: Obj Instance of QuadratureVariables_ integer(kind=I4B), intent(in) :: ipoint Quadrature point number integer(kind=I4B), intent(in) :: elemnum element number real(kind=DFP), intent(in) :: Val (:) Values integer(kind=I4B), intent(in), optional :: is is starting index integer(kind=I4B), intent(in), optional :: ie ie ending index Derived Types type, public :: QuadratureVariablesPointer_ QuadratureVariablesPointer_ contains a pointer to QuadratureVariables_ Components Type Visibility Attributes Name Initial class( QuadratureVariables_ ), public, POINTER :: Ptr => NULL() type, public :: QuadratureVariables_ authors: Dr. Vikas Sharma Read more… Components Type Visibility Attributes Name Initial type(String), public, ALLOCATABLE :: Names (:) Names of variables stored; its length should be equal to\n tprops real(kind=DFP), public, ALLOCATABLE :: Val (:,:,:) This array contains the varialbe/parameter information Val( :, i ) denotes material properties or element variables integer(kind=I4B), public :: tpoint = 0 Total number of quadrature points inside an element integer(kind=I4B), public :: tprop = 0 Total number of properties defined at a quadrature points Type-Bound Procedures procedure, public, PASS( Obj ) :: AddContribution => elem_var_add_val Subroutine that Adds contribution to the existing values procedure, public, PASS( Obj ) :: ArrayValues => elem_var_get_value Subroutine that gets element variables procedure, public, PASS( Obj ) :: Finalize => elem_var_deallocate_data deallocate data procedure, public, PASS( Obj ) :: Initiate => elem_var_initiate Subroutine that Initiates the object procedure, public, PASS( Obj ) :: setValue => elem_var_set_value Subroutine that Sets values/change values","tags":"","loc":"module/quadraturevariables_class.html"},{"title":"gmsh_Class – Fortran Program","text":"Gmsh Class Uses BaseType BaseMethod gmshModel_Class Contents Variables TypeGmsh Interfaces gmsh_from_gmsh Derived Types gmsh_ Functions gmsh_clear gmsh_final gmsh_init gmsh_merge gmsh_open gmsh_write Variables Type Visibility Attributes Name Initial type( gmsh_ ), public, parameter :: TypeGmsh = gmsh_() Interfaces interface This function generate a gmsh model from the mesh data stored inside private function gmsh_from_gmsh(Obj, gmsh, Nodes) result(Ans) This function generates a gmsh model by reading mesh data stored inside gmsh_ object. Arguments Type Intent Optional Attributes Name class( gmsh_ ), intent(inout), TARGET :: Obj Old gmsh class( gmsh_ ), intent(inout), TARGET :: gmsh new gmsh real(kind=DFP), intent(in) :: Nodes (:,:) nodes Return Value integer(kind=I4B) Derived Types type, public :: gmsh_ This a data type for prepossing and post-processing in Gmsh Read more… Components Type Visibility Attributes Name Initial type(gmshModel_), public, POINTER :: model => NULL() integer(kind=I4B), public :: nsd = 0 Type-Bound Procedures procedure, public, PASS( Obj ) :: clear => gmsh_clear Clear the content procedure, public, PASS( Obj ) :: finalize => gmsh_final Closes the gmsh engine procedure, public, PASS( Obj ) :: initialize => gmsh_init Initialize the gmsh engine procedure, public, PASS( Obj ) :: initiate => gmsh_init Initialize the gmsh engine procedure, public, PASS( Obj ) :: merge => gmsh_merge procedure, public, PASS( Obj ) :: open => gmsh_open open file to load procedure, public, PASS( Obj ) :: remesh => gmsh_from_gmsh generate new gmsh file procedure, public, PASS( Obj ) :: write => gmsh_write Write content in a file Functions private function gmsh_clear (Obj) result(Ans) This function will clear all model and option and create an blank model Arguments Type Intent Optional Attributes Name class( gmsh_ ), intent(inout) :: Obj Return Value integer(kind=I4B) private function gmsh_final (Obj) result(Ans) This function will stop the gmsh engine Read more… Arguments Type Intent Optional Attributes Name class( gmsh_ ), intent(inout) :: Obj Return Value integer(kind=I4B) private function gmsh_init (Obj, NSD) result(Ans) This function will start the gmsh engine\n It allocates obj % model Read more… Arguments Type Intent Optional Attributes Name class( gmsh_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: NSD Return Value integer(kind=I4B) private function gmsh_merge (Obj, P, F, E) result(Ans) This function will open a file and read its content\n Based upon the extension of the file it can take different actions\n IF the file represents a model file then it will merge the content to the\n current model Arguments Type Intent Optional Attributes Name class( gmsh_ ), intent(inout) :: Obj character(len=*), intent(in) :: P Path of file character(len=*), intent(in) :: F File name character(len=*), intent(in) :: E Extension Return Value integer(kind=I4B) private function gmsh_open (Obj, P, F, E) result(Ans) This function will open a file and read its content\n Based upon the extension of the file it can take different actions\n If file represents a model file then a new model will be created Arguments Type Intent Optional Attributes Name class( gmsh_ ), intent(inout) :: Obj character(len=*), intent(in) :: P Path of file character(len=*), intent(in) :: F File name character(len=*), intent(in) :: E Extension Return Value integer(kind=I4B) private function gmsh_write (Obj, P, F, E) result(Ans) This function will write the data in a file depending upon the extension\n of the file Arguments Type Intent Optional Attributes Name class( gmsh_ ), intent(inout) :: Obj character(len=*), intent(in) :: P Path of file character(len=*), intent(in) :: F File name character(len=*), intent(in) :: E Extension Return Value integer(kind=I4B)","tags":"","loc":"module/gmsh_class.html"},{"title":"gmshMesh_Class – Fortran Program","text":"Uses BaseType GlobalData mshFormat_Class mshPhysicalNames_Class mshEntity_Class mshNodes_Class mshElements_Class Mesh_Class FE Domain_Class Contents Variables TypegmshMesh Interfaces DeallocateData Display Initiate dom_init_from_gmshMesh gmshMesh gmsh_mesh_Pointer gmsh_mesh_constuctor1 gmsh_mesh_deallocatedata gmsh_mesh_display gmsh_mesh_getelements_1 gmsh_mesh_getelements_2 gmsh_mesh_getelements_2c gmsh_mesh_getelements_3 gmsh_mesh_getelements_3c gmsh_mesh_getelements_4 gmsh_mesh_getelements_4c gmsh_mesh_getnodes_array gmsh_mesh_getnodes_file gmsh_mesh_initiate gmsh_mesh_telements_1 gmsh_mesh_telements_2 gmsh_mesh_telements_3 gmsh_mesh_totalnodes gmsh_mesh_write_mesh gmsh_mesh_write_nodedata_1 gmsh_mesh_write_nodedata_2 mesh_generate mesh_write Derived Types gmshMeshPointer_ gmshMesh_ Functions gmsh_mesh_constructor_1 Variables Type Visibility Attributes Name Initial type( gmshMesh_ ), public, parameter :: TypegmshMesh = gmshMesh_(mshFile=TypeFile, Format=TypemshFormat, PhysicalNames=TypeMSHPhysicalNames, PointEntities=NULL(), CurveEntities=NULL(), SurfaceEntities=NULL(), VolumeEntities=NULL(), Nodes=TypeMshNodes, Elements=TypemshElements) Interfaces public interface DeallocateData private interface gmsh_mesh_deallocatedata () This will deallocate data Arguments None public interface Display private interface gmsh_mesh_display () This subroutine display the content of gmshmesh object Arguments None public interface Initiate private interface gmsh_mesh_initiate () This subroutine generates the gmshMesh_ object Arguments None interface This subroutine initiate Domain_ by reading gmshMesh file private subroutine dom_init_from_gmshMesh(mshobj, obj, facetmesh) This subroutine initiate Domain_ by reading gmshMesh file\n This is a high level routine Read more… Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: mshobj class(Domain_), intent(inout) :: obj type(String), intent(in), optional :: facetmesh (:,:) public interface gmshMesh private interface gmsh_mesh_constuctor1 () This function will create the gmshMesh_ object Arguments None public interface gmsh_mesh_Pointer private function gmsh_mesh_constructor_1 (Path, FileName, Extension, NSD) result(Obj) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: Path character(len=*), intent(in) :: FileName character(len=*), intent(in), optional :: Extension integer(kind=I4B), intent(in) :: NSD Return Value class( gmshMesh_ ),\n  POINTER interface This function will create the gmshMesh_ object private function gmsh_mesh_constuctor1(Path, FileName, Extension, NSD) result(Ans) This function will create the gmshMesh_ object Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Path character(len=*), intent(in) :: FileName character(len=*), intent(in) :: Extension integer(kind=I4B), intent(in) :: NSD Return Value type( gmshMesh_ ) interface This will deallocate data private subroutine gmsh_mesh_deallocatedata(obj) This subroutine deallocate data Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(inout) :: obj interface This subroutine display the content of gmshmesh object private subroutine gmsh_mesh_display(obj, msg, UnitNo) This subroutine display the content of obj Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: obj character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: UnitNo interface This subroutine returns a mesh of elements; private subroutine gmsh_mesh_getelements_1(obj, MeshObj, FEObj) This subroutine returns a single Mesh_ object containing all elements Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: obj class(Mesh_), intent(inout), TARGET :: MeshObj class(Element_), intent(in) :: FEObj interface This subroutine builds a mesh of elements with same co-dimensions private subroutine gmsh_mesh_getelements_2(obj, MeshObj, XiDim, FEObj, Offset) This subroutine builds a mesh of elements with same co-dimensions Read more… Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: obj class(Mesh_), intent(inout), TARGET :: MeshObj integer(kind=I4B), intent(in) :: XiDim class(Element_), intent(in) :: FEObj integer(kind=I4B), intent(in), optional :: Offset interface This subroutine build a Mesh_ in Domain_ by using gmshMesh_ private subroutine gmsh_mesh_getelements_2c(Obj, Dom, indx, XiDim, FEObj, Offset) This subroutine builds a mesh of elements with same co-dimensions Read more… Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: Obj class(Domain_), intent(inout), TARGET :: Dom integer(kind=I4B), intent(in) :: indx integer(kind=I4B), intent(in) :: XiDim class(Element_), intent(in) :: FEObj integer(kind=I4B), intent(in), optional :: Offset interface This subroutine returns the mesh of elements private subroutine gmsh_mesh_getelements_3(obj, MeshObj, XiDim, Tag, FEObj, Offset) This subroutine returns the mesh of elements; it applies two levels of\n filter Read more… Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: obj class(Mesh_), intent(inout), TARGET :: MeshObj integer(kind=I4B), intent(in) :: XiDim integer(kind=I4B), intent(in) :: Tag (:) class(Element_), intent(in) :: FEObj integer(kind=I4B), intent(in), optional :: Offset interface This subroutine build a Mesh_ in Domain_ by using gmshMesh_ private subroutine gmsh_mesh_getelements_3c(Obj, Dom, Indx, XiDim, Tag, FEObj, Offset) This subroutine returns the mesh of elements; it applies two levels of\n filter Read more… Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: Obj class(Domain_), intent(inout), TARGET :: Dom integer(kind=I4B), intent(in) :: Indx integer(kind=I4B), intent(in) :: XiDim integer(kind=I4B), intent(in) :: Tag (:) class(Element_), intent(in) :: FEObj integer(kind=I4B), intent(in), optional :: Offset interface This subroutine returns the mesh of elements private subroutine gmsh_mesh_getelements_4(obj, MeshObj, XiDim, TagNames, FEObj, Offset) This subroutine returns the mesh of elements; it applies two levels of\n filter Read more… Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: obj class(Mesh_), intent(inout), TARGET :: MeshObj integer(kind=I4B), intent(in) :: XiDim type(String), intent(in) :: TagNames (:) class(Element_), intent(in) :: FEObj integer(kind=I4B), intent(in), optional :: Offset interface This subroutine build a Mesh_ in Domain_ by using gmshMesh_ private subroutine gmsh_mesh_getelements_4c(Obj, Dom, Indx, XiDim, TagNames, FEObj, Offset) This subroutine returns the mesh of elements; it applies two levels of\n filter Read more… Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: Obj class(Domain_), intent(inout), TARGET :: Dom integer(kind=I4B), intent(in) :: Indx integer(kind=I4B), intent(in) :: XiDim type(String), intent(in) :: TagNames (:) class(Element_), intent(in) :: FEObj integer(kind=I4B), intent(in), optional :: Offset interface This subroutine retunr the nodal coordinates private subroutine gmsh_mesh_getnodes_array(obj, Nodes) This subroutine returns the nodal coordinates Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: obj real(kind=DFP), intent(inout), ALLOCATABLE :: Nodes (:,:) interface This subroutine retunr the nodal coordinates private subroutine gmsh_mesh_getnodes_file(obj, UnitNo, Str, EndStr) This subroutine returns the nodal coordinates Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: obj integer(kind=I4B), intent(in), optional :: UnitNo character(len=*), intent(in), optional :: Str character(len=*), intent(in), optional :: EndStr interface This subroutine generates the gmshMesh_ object private subroutine gmsh_mesh_initiate(obj, Path, FileName, Extension, NSD) This subroutine reads the .msh file and creates the object Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(inout) :: obj character(len=*), intent(in) :: Path character(len=*), intent(in) :: FileName character(len=*), intent(in) :: Extension integer(kind=I4B), intent(in) :: NSD interface This function returns the total element in the mesh private pure function gmsh_mesh_telements_1(obj) result(Ans) This function returns the total element in the mesh Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: obj Return Value integer(kind=I4B) interface This function returns the total element in the mesh private pure function gmsh_mesh_telements_2(obj, XiDim) result(Ans) This function returns the total element in the mesh\n Xidim is a codimension based filter\n Xidim=0 => Point\n Xidim=1 => Curve\n Xidim=2 => Surface\n Xidim=3 => Volume Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: obj integer(kind=I4B), intent(in) :: XiDim Return Value integer(kind=I4B) interface This function returns the total element in the mesh private pure function gmsh_mesh_telements_3(obj, XiDim, Tag) result(Ans) This function returns the total element in the mesh\n We can filter elements based on Xidim and tag Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: obj integer(kind=I4B), intent(in) :: XiDim integer(kind=I4B), intent(in) :: Tag (:) Return Value integer(kind=I4B) interface This function will return the total number of nodes in mesh private pure function gmsh_mesh_totalnodes(obj) result(Ans) This function will return the total number of nodes in mesh Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: obj Return Value integer(kind=I4B) interface private subroutine gmsh_mesh_write_mesh(obj, Path, FileName, Extension, Nodes) Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: obj character(len=*), intent(in) :: Path character(len=*), intent(in) :: FileName character(len=*), intent(in) :: Extension real(kind=DFP), intent(in) :: Nodes (:,:) interface This subroutine writes the node data information in a msh file format private subroutine gmsh_mesh_write_nodedata_1(obj, x, dofobj, name, indx, local_nptrs, nodes) This subroutine writes the nodal values of a variable x into msh file Read more… Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: obj real(kind=DFP), intent(in) :: x (:) type(DOF_), intent(in) :: dofobj character(len=1), intent(in) :: name integer(kind=I4B), intent(in) :: indx (:) integer(kind=I4B), intent(in) :: local_nptrs (:) real(kind=DFP), intent(in), optional :: nodes (:,:) interface This subroutine writes the node data information in a gmshMesh file format private subroutine gmsh_mesh_write_nodedata_2(obj, x, dofobj, indx, local_nptrs, nodes) This subroutine writes the nodal values of a variable x into gmshMesh file Read more… Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(in) :: obj real(kind=DFP), intent(in) :: x (:) type(DOF_), intent(in) :: dofobj integer(kind=I4B), intent(in) :: indx (:) integer(kind=I4B), intent(in) :: local_nptrs (:) real(kind=DFP), intent(in), optional :: nodes (:,:) interface This will add mesh generation command to .geo file private function mesh_generate(Obj, dim) result(Ans) This will add mesh generation command to .geo file Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: dim Return Value integer(kind=I4B) interface This function will dump the buffer content in to a file private function mesh_write(Obj, UnitNo) result(Ans) This function will dump the buffer content in to a file Arguments Type Intent Optional Attributes Name class( gmshMesh_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: UnitNo Return Value integer(kind=I4B) Derived Types type, public :: gmshMeshPointer_ Components Type Visibility Attributes Name Initial class( gmshMesh_ ), public, POINTER :: Ptr => NULL() type, public :: gmshMesh_ This class handles the mesh generation by gmsh\n This class can generate the mesh and reads the mesh file Components Type Visibility Attributes Name Initial type(mshEntity_), public, ALLOCATABLE :: CurveEntities (:) curve entities type(mshElements_), public :: Elements elements type(mshFormat_), public :: Format mesh format type(mshNodes_), public :: Nodes nodes type(mshPhysicalNames_), public :: PhysicalNames mesh physical groups type(mshEntity_), public, ALLOCATABLE :: PointEntities (:) point entities type(mshEntity_), public, ALLOCATABLE :: SurfaceEntities (:) surface entities type(mshEntity_), public, ALLOCATABLE :: VolumeEntities (:) volume entities type(Buffer_), public, POINTER :: buffer => NULL() buffer to recoord coommands type(File_), public :: mshFile mesh file integer(kind=I4B), public :: nsd = 0 Spatial dimension Type-Bound Procedures procedure, public, PASS( Obj ) :: Finalize => gmsh_mesh_deallocatedata deallocate the data procedure, public, PASS( Obj ) :: Initiate => gmsh_mesh_initiate initiate the object generic, public :: TotalElements => gmsh_mesh_telements_1, gmsh_mesh_telements_2, gmsh_mesh_telements_3 procedure, public, PASS( Obj ) :: TotalNodes => gmsh_mesh_totalnodes returns total nodes in mesh procedure, public, PASS( Obj ) :: WriteMesh => gmsh_mesh_write_mesh generic, public :: WriteNodeData => gmsh_mesh_write_nodedata_1, gmsh_mesh_write_nodedata_2 procedure, public, PASS( mshobj ) :: dom_init_from_gmshMesh procedure, public, PASS( Obj ) :: generate => mesh_generate generic, public :: getElements => gmsh_mesh_getelements_1, gmsh_mesh_getelements_2, gmsh_mesh_getelements_2c, gmsh_mesh_getelements_3, gmsh_mesh_getelements_3c, gmsh_mesh_getelements_4, gmsh_mesh_getelements_4c, dom_init_from_gmshMesh generic, public :: getNodes => gmsh_mesh_getnodes_array, gmsh_mesh_getnodes_file procedure, public, PASS( Obj ) :: gmsh_mesh_getelements_1 return finite element mesh procedure, public, PASS( Obj ) :: gmsh_mesh_getelements_2 procedure, public, PASS( Obj ) :: gmsh_mesh_getelements_2c procedure, public, PASS( Obj ) :: gmsh_mesh_getelements_3 procedure, public, PASS( Obj ) :: gmsh_mesh_getelements_3c procedure, public, PASS( Obj ) :: gmsh_mesh_getelements_4 procedure, public, PASS( Obj ) :: gmsh_mesh_getelements_4c procedure, private, PASS( Obj ) :: gmsh_mesh_getnodes_array returns nodes in an array procedure, private, PASS( Obj ) :: gmsh_mesh_getnodes_file writes notes to a file procedure, private, PASS( Obj ) :: gmsh_mesh_telements_1 returns total elements in mesh procedure, private, PASS( Obj ) :: gmsh_mesh_telements_2 returns total elements in mesh procedure, private, PASS( Obj ) :: gmsh_mesh_telements_3 returns total elements in mesh procedure, public, PASS( Obj ) :: gmsh_mesh_write_nodedata_1 procedure, public, PASS( Obj ) :: gmsh_mesh_write_nodedata_2 procedure, public, PASS( Obj ) :: write => mesh_write Functions private function gmsh_mesh_constructor_1 (Path, FileName, Extension, NSD) result(Obj) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: Path character(len=*), intent(in) :: FileName character(len=*), intent(in), optional :: Extension integer(kind=I4B), intent(in) :: NSD Return Value class( gmshMesh_ ),\n  POINTER","tags":"","loc":"module/gmshmesh_class.html"},{"title":"gmshCurve_Class – Fortran Program","text":"This module defines a class for gmsh points Uses GlobalData BaseType gmshEntity_Class Contents Derived Types gmshBSplinePointer_ gmshBSpline_ gmshBezierPointer_ gmshBezier_ gmshCirclePointer_ gmshCircle_ gmshCompoundBSplinePointer_ gmshCompoundBSpline_ gmshCompoundSplinePointer_ gmshCompoundSpline_ gmshCurveLoopPointer_ gmshCurveLoop_ gmshCurvePointer_ gmshCurve_ gmshEllipsePointer_ gmshEllipse_ gmshLinePointer_ gmshLine_ gmshSplinePointer_ gmshSpline_ Functions BSpline_encode Bezier_encode Circle_encode CompoundBSpline_encode CompoundSpline_encode CurveLoop_encode Ellipse_encode Spline_encode gmshBSpline_Pointer gmshBezier_Pointer gmshCircle_Pointer gmshCompoundBSpline_Pointer gmshCompoundSpline_Pointer gmshCurveLoop_Pointer gmshEllipse_Pointer gmshLine_Pointer gmshSpline_Pointer line_encode Derived Types type, public :: gmshBSplinePointer_ Components Type Visibility Attributes Name Initial class( gmshBSpline_ ), public, POINTER :: Ptr => NULL() type, public, EXTENDS( gmshCurve_ ) :: gmshBSpline_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public, ALLOCATABLE :: pointTags (:) Type-Bound Procedures procedure, public, PASS( Obj ) :: encodedStr => BSpline_encode type, public :: gmshBezierPointer_ Components Type Visibility Attributes Name Initial class( gmshBezier_ ), public, POINTER :: Ptr => NULL() type, public, EXTENDS( gmshCurve_ ) :: gmshBezier_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public, ALLOCATABLE :: pointTags (:) Type-Bound Procedures procedure, public, PASS( Obj ) :: encodedStr => Bezier_encode type, public :: gmshCirclePointer_ Components Type Visibility Attributes Name Initial class( gmshCircle_ ), public, POINTER :: Ptr => NULL() type, public, EXTENDS( gmshCurve_ ) :: gmshCircle_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: centerTag integer(kind=I4B), public :: endTag real(kind=DFP), public :: nx real(kind=DFP), public :: ny real(kind=DFP), public :: nz integer(kind=I4B), public :: startTag Type-Bound Procedures procedure, public, PASS( Obj ) :: encodedStr => Circle_encode type, public :: gmshCompoundBSplinePointer_ Components Type Visibility Attributes Name Initial class( gmshCompoundBSpline_ ), public, POINTER :: Ptr => NULL() type, public, EXTENDS( gmshCurve_ ) :: gmshCompoundBSpline_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public, ALLOCATABLE :: curveTags (:) integer(kind=I4B), public :: numIntervals Type-Bound Procedures procedure, public, PASS( Obj ) :: encodedStr => CompoundBSpline_encode type, public :: gmshCompoundSplinePointer_ Components Type Visibility Attributes Name Initial class( gmshCompoundSpline_ ), public, POINTER :: Ptr => NULL() type, public, EXTENDS( gmshCurve_ ) :: gmshCompoundSpline_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public, ALLOCATABLE :: curveTags (:) integer(kind=I4B), public :: numIntervals Type-Bound Procedures procedure, public, PASS( Obj ) :: encodedStr => CompoundSpline_encode type, public :: gmshCurveLoopPointer_ Components Type Visibility Attributes Name Initial class( gmshCurveLoop_ ), public, POINTER :: Ptr => NULL() type, public, EXTENDS( gmshCurve_ ) :: gmshCurveLoop_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public, ALLOCATABLE :: curveTags (:) Type-Bound Procedures procedure, public, PASS( Obj ) :: encodedStr => CurveLoop_encode type, public :: gmshCurvePointer_ Components Type Visibility Attributes Name Initial class( gmshCurve_ ), public, POINTER :: Ptr => Null() type, public, ABSTRACT, EXTENDS( gmshEntity_ ) :: gmshCurve_ type, public :: gmshEllipsePointer_ Components Type Visibility Attributes Name Initial class( gmshEllipse_ ), public, POINTER :: Ptr => NULL() type, public, EXTENDS( gmshCurve_ ) :: gmshEllipse_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: centerTag integer(kind=I4B), public :: endTag integer(kind=I4B), public :: majorTag real(kind=DFP), public :: nx real(kind=DFP), public :: ny real(kind=DFP), public :: nz integer(kind=I4B), public :: startTag Type-Bound Procedures procedure, public, PASS( Obj ) :: encodedStr => Ellipse_encode type, public :: gmshLinePointer_ Components Type Visibility Attributes Name Initial class( gmshLine_ ), public, POINTER :: Ptr => NULL() type, public, EXTENDS( gmshCurve_ ) :: gmshLine_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: endTag integer(kind=I4B), public :: startTag Type-Bound Procedures procedure, public, PASS( Obj ) :: encodedStr => line_encode type, public :: gmshSplinePointer_ Components Type Visibility Attributes Name Initial class( gmshSpline_ ), public, POINTER :: Ptr => NULL() type, public, EXTENDS( gmshCurve_ ) :: gmshSpline_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public, ALLOCATABLE :: pointTags (:) Type-Bound Procedures procedure, public, PASS( Obj ) :: encodedStr => Spline_encode Functions private function BSpline_encode (obj) result(ans) Arguments Type Intent Optional Attributes Name class( gmshBSpline_ ), intent(in) :: obj Return Value type(String) private function Bezier_encode (obj) result(ans) Arguments Type Intent Optional Attributes Name class( gmshBezier_ ), intent(in) :: obj Return Value type(String) private function Circle_encode (obj) result(ans) Arguments Type Intent Optional Attributes Name class( gmshCircle_ ), intent(in) :: obj Return Value type(String) private function CompoundBSpline_encode (obj) result(ans) Arguments Type Intent Optional Attributes Name class( gmshCompoundBSpline_ ), intent(in) :: obj Return Value type(String) private function CompoundSpline_encode (obj) result(ans) Arguments Type Intent Optional Attributes Name class( gmshCompoundSpline_ ), intent(in) :: obj Return Value type(String) private function CurveLoop_encode (obj) result(ans) Arguments Type Intent Optional Attributes Name class( gmshCurveLoop_ ), intent(in) :: obj Return Value type(String) private function Ellipse_encode (obj) result(ans) Arguments Type Intent Optional Attributes Name class( gmshEllipse_ ), intent(in) :: obj Return Value type(String) private function Spline_encode (obj) result(ans) Arguments Type Intent Optional Attributes Name class( gmshSpline_ ), intent(in) :: obj Return Value type(String) public function gmshBSpline_Pointer (pointTags, uid) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: pointTags (:) integer(kind=I4B), intent(in) :: uid Return Value class( gmshBSpline_ ),\n  POINTER public function gmshBezier_Pointer (pointTags, uid) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: pointTags (:) integer(kind=I4B), intent(in) :: uid Return Value class( gmshBezier_ ),\n  POINTER public function gmshCircle_Pointer (startTag, centerTag, endTag, uid, nx, ny, nz) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: startTag integer(kind=I4B), intent(in) :: centerTag integer(kind=I4B), intent(in) :: endTag integer(kind=I4B), intent(in) :: uid real(kind=DFP), intent(in) :: nx real(kind=DFP), intent(in) :: ny real(kind=DFP), intent(in) :: nz Return Value class( gmshCircle_ ),\n  POINTER public function gmshCompoundBSpline_Pointer (curveTags, uid, numIntervals) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: curveTags (:) integer(kind=I4B), intent(in) :: uid integer(kind=I4B), intent(in) :: numIntervals Return Value class( gmshCompoundBSpline_ ),\n  POINTER public function gmshCompoundSpline_Pointer (curveTags, uid, numIntervals) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: curveTags (:) integer(kind=I4B), intent(in) :: uid integer(kind=I4B), intent(in) :: numIntervals Return Value class( gmshCompoundSpline_ ),\n  POINTER public function gmshCurveLoop_Pointer (curveTags, uid) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: curveTags (:) integer(kind=I4B), intent(in) :: uid Return Value class( gmshCurveLoop_ ),\n  POINTER public function gmshEllipse_Pointer (startTag, centerTag, majorTag, endTag, uid, nx, ny, nz) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: startTag integer(kind=I4B), intent(in) :: centerTag integer(kind=I4B), intent(in) :: majorTag integer(kind=I4B), intent(in) :: endTag integer(kind=I4B), intent(in) :: uid real(kind=DFP), intent(in) :: nx real(kind=DFP), intent(in) :: ny real(kind=DFP), intent(in) :: nz Return Value class( gmshEllipse_ ),\n  POINTER public function gmshLine_Pointer (startTag, endTag, uid) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: startTag integer(kind=I4B), intent(in) :: endTag integer(kind=I4B), intent(in) :: uid Return Value class( gmshLine_ ),\n  POINTER public function gmshSpline_Pointer (pointTags, uid) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: pointTags (:) integer(kind=I4B), intent(in) :: uid Return Value class( gmshSpline_ ),\n  POINTER private function line_encode (obj) result(ans) Arguments Type Intent Optional Attributes Name class( gmshLine_ ), intent(in) :: obj Return Value type(String)","tags":"","loc":"module/gmshcurve_class.html"},{"title":"gmshVolume_Class – Fortran Program","text":"This module defines a class for gmsh Volume entities Uses GlobalData BaseType gmshEntity_Class Contents Derived Types gmshVolumePointer_ gmshVolume_ Functions Volume_encode gmshVolume_Pointer Derived Types type, public :: gmshVolumePointer_ Components Type Visibility Attributes Name Initial class( gmshVolume_ ), public, POINTER :: Ptr => Null() type, public, EXTENDS( gmshEntity_ ) :: gmshVolume_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public, ALLOCATABLE :: shellTags (:) Type-Bound Procedures procedure, public, PASS( Obj ) :: encodedStr => Volume_encode Functions private function Volume_encode (obj) result(ans) Arguments Type Intent Optional Attributes Name class( gmshVolume_ ), intent(in) :: obj Return Value type(String) public function gmshVolume_Pointer (shellTags, uid) result(Ans) Add a volume (a region) defined by one or more shells shellTags.\n The first surface loop defines the exterior boundary; additional surface\n loop define holes. If tag is positive, set the tag explicitly; otherwise a\n  new tag is selected automatically. Return the tag of the volume. Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: shellTags (:) integer(kind=I4B), intent(in) :: uid Return Value class( gmshVolume_ ),\n  POINTER","tags":"","loc":"module/gmshvolume_class.html"},{"title":"gmshSurface_Class – Fortran Program","text":"This module defines a class for gmsh Surface entities Uses GlobalData BaseType gmshEntity_Class Contents Derived Types gmshPlaneSurfacePointer_ gmshPlaneSurface_ gmshSurfaceLoopPointer_ gmshSurfaceLoop_ gmshSurfacePointer_ gmshSurface_ Functions PlaneSurface_encode SurfaceLoop_encode Surface_encode gmshPlaneSurface_Pointer gmshSurfaceLoop_Pointer gmshSurface_Pointer Derived Types type, public :: gmshPlaneSurfacePointer_ Components Type Visibility Attributes Name Initial class( gmshPlaneSurface_ ), public, POINTER :: Ptr => NULL() type, public, EXTENDS( gmshSurface_ ) :: gmshPlaneSurface_ Type-Bound Procedures procedure, public, PASS( Obj ) :: encodedStr => PlaneSurface_encode type, public :: gmshSurfaceLoopPointer_ Components Type Visibility Attributes Name Initial class( gmshSurfaceLoop_ ), public, POINTER :: Ptr => NULL() type, public, EXTENDS( gmshSurface_ ) :: gmshSurfaceLoop_ Type-Bound Procedures procedure, public, PASS( Obj ) :: encodedStr => SurfaceLoop_encode type, public :: gmshSurfacePointer_ Components Type Visibility Attributes Name Initial class( gmshSurface_ ), public, POINTER :: Ptr => Null() type, public, EXTENDS( gmshEntity_ ) :: gmshSurface_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: sphereCenterTag = -1 wireTags contains id of curve loops\n The first curve loop defines the exterior contour;\n additional curve loop define holes. integer(kind=I4B), public, ALLOCATABLE :: wireTags (:) Type-Bound Procedures procedure, public, PASS( Obj ) :: encodedStr => Surface_encode Functions private function PlaneSurface_encode (obj) result(ans) Arguments Type Intent Optional Attributes Name class( gmshPlaneSurface_ ), intent(in) :: obj Return Value type(String) private function SurfaceLoop_encode (obj) result(ans) Arguments Type Intent Optional Attributes Name class( gmshSurfaceLoop_ ), intent(in) :: obj Return Value type(String) private function Surface_encode (obj) result(ans) Arguments Type Intent Optional Attributes Name class( gmshSurface_ ), intent(in) :: obj Return Value type(String) public function gmshPlaneSurface_Pointer (wireTags, uid) result(Ans) Reference\n Creates a plane surface. The expression inside the parentheses is the plane\n surface’s tag; the expression-list on the right hand side should contain\n the tags of all the curve loops defining the surface. The first curve loop\n defines the exterior boundary of the surface; all other curve loops define\n holes in the surface. A curve loop defining a hole should not have any\n curves in common with the exterior curve loop (in which case it is not a\n hole, and the two surfaces should be defined separately). Likewise, a\n curve loop defining a hole should not have any curves in common with\n another curve loop defining a hole in the same surface (in which case the\n two curve loops should be combined). Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: wireTags (:) integer(kind=I4B), intent(in) :: uid Return Value class( gmshPlaneSurface_ ),\n  POINTER public function gmshSurfaceLoop_Pointer (wireTags, uid) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: wireTags (:) integer(kind=I4B), intent(in) :: uid Return Value class( gmshSurfaceLoop_ ),\n  POINTER public function gmshSurface_Pointer (wireTags, uid, sphereCenterTag) result(Ans) Creates a surface filling. With the built-in kernel, the first curve\n loop should be composed of either three or four curves.\n With the built-in kernel, the optional In Sphere argument forces\n the surface to be a spherical patch (the extra parameter gives the\n tag of the center of the sphere). Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: wireTags (:) integer(kind=I4B), intent(in) :: uid integer(kind=I4B), intent(in) :: sphereCenterTag Return Value class( gmshSurface_ ),\n  POINTER","tags":"","loc":"module/gmshsurface_class.html"},{"title":"gmshEntity_Class – Fortran Program","text":"This module defines an abstract class for gmshEntity_ Uses GlobalData BaseType Contents Abstract Interfaces en_encode Derived Types gmshEntity_ Abstract Interfaces abstract interface private function en_encode(obj) result(ans) Arguments Type Intent Optional Attributes Name class( gmshEntity_ ), intent(in) :: obj Return Value type(String) Derived Types type, public, ABSTRACT :: gmshEntity_ gmshEntity_ is an abstract class Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: dim = 0 Unique id of entity integer(kind=I4B), public :: uid = 0 Type-Bound Procedures procedure(en_encode), public, PASS( obj ) :: encodedStr Encode the information stored in gmshEntity_ in sring and returns","tags":"","loc":"module/gmshentity_class.html"},{"title":"gmshPoint_Class – Fortran Program","text":"This module defines a class for gmsh points Uses GlobalData BaseType gmshEntity_Class Contents Interfaces gmshPoint_Pointer Derived Types gmshPointPointer_ gmshPoint_ Functions constructor_1 point_encode Interfaces public interface gmshPoint_Pointer private function constructor_1 (x, y, z, lc, uid) result(Ans) This function gmshPoint_Pointer returns pointer to gmshPoint_ Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: x real(kind=DFP), intent(in) :: y real(kind=DFP), intent(in) :: z real(kind=DFP), intent(in) :: lc integer(kind=I4B), intent(in) :: uid Return Value class( gmshPoint_ ),\n  POINTER Derived Types type, public :: gmshPointPointer_ Components Type Visibility Attributes Name Initial class( gmshPoint_ ), public, POINTER :: Ptr => Null() type, public, EXTENDS( gmshEntity_ ) :: gmshPoint_ gmshPoint_ type represent point entities in gmsh Components Type Visibility Attributes Name Initial real(kind=DFP), public :: lc = 0.0 real(kind=DFP), public :: x = 0.0 real(kind=DFP), public :: y = 0.0 real(kind=DFP), public :: z = 0.0 Type-Bound Procedures procedure, public, PASS( Obj ) :: encodedStr => point_encode Functions private function constructor_1 (x, y, z, lc, uid) result(Ans) This function gmshPoint_Pointer returns pointer to gmshPoint_ Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: x real(kind=DFP), intent(in) :: y real(kind=DFP), intent(in) :: z real(kind=DFP), intent(in) :: lc integer(kind=I4B), intent(in) :: uid Return Value class( gmshPoint_ ),\n  POINTER private function point_encode (obj) result(ans) This function encode the information stored in gmshPoint_ in a string\n data type and return it for printing Arguments Type Intent Optional Attributes Name class( gmshPoint_ ), intent(in) :: obj Return Value type(String)","tags":"","loc":"module/gmshpoint_class.html"},{"title":"gmshGeoMesh_Class – Fortran Program","text":"Uses BaseType BaseMethod Contents Derived Types gmshGeoMesh_ Functions geoMesh_setAlgorithm geoMesh_setRecombine geoMesh_setReverse geoMesh_setSize geoMesh_setSizeFromBoundary geoMesh_setSmoothing geoMesh_setTransfiniteCurve geoMesh_setTransfiniteSurface geoMesh_setTransfiniteVolume geoMesh_write Derived Types type, public :: gmshGeoMesh_ Components Type Visibility Attributes Name Initial type(Buffer_), public, POINTER :: buffer => NULL() Type-Bound Procedures procedure, public, PASS( Obj ) :: setAlgorithm => geoMesh_setAlgorithm procedure, public, PASS( Obj ) :: setRecombine => geoMesh_setRecombine procedure, public, PASS( Obj ) :: setReverse => geoMesh_setReverse procedure, public, PASS( Obj ) :: setSize => geoMesh_setSize procedure, public, PASS( Obj ) :: setSizeFromBoundary => geoMesh_setSizeFromBoundary procedure, public, PASS( Obj ) :: setSmoothing => geoMesh_setSmoothing procedure, public, PASS( Obj ) :: setTransfiniteCurve => geoMesh_setTransfiniteCurve procedure, public, PASS( Obj ) :: setTransfiniteSurface => geoMesh_setTransfiniteSurface procedure, public, PASS( Obj ) :: setTransfiniteVolume => geoMesh_setTransfiniteVolume procedure, public, PASS( Obj ) :: write => geoMesh_write Functions private function geoMesh_setAlgorithm (Obj, dim, tag, val) result(Ans) Set the meshing algorithm on the model entity of dimension dim and tag tag.\n Currently only supported for dim == 2. Arguments Type Intent Optional Attributes Name class( gmshGeoMesh_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: dim integer(kind=I4B), intent(in) :: tag integer(kind=I4B), intent(in) :: val Return Value integer(kind=I4B) private function geoMesh_setRecombine (Obj, dim, tag, angle) result(Ans) Set a recombination meshing constraint on the model entity of dimension\n dim and tag tag. Currently only entities of dimension 2\n (to recombine triangles into quadrangles) are supporte Arguments Type Intent Optional Attributes Name class( gmshGeoMesh_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: dim integer(kind=I4B), intent(in) :: tag real(kind=DFP), intent(in), optional :: angle Return Value integer(kind=I4B) private function geoMesh_setReverse (Obj, dim, tag, val) result(Ans) Set a smoothing meshing constraint on the model entity of dimension dim\n and tag tag. val iterations of a Laplace smoother are applied. Arguments Type Intent Optional Attributes Name class( gmshGeoMesh_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: dim integer(kind=I4B), intent(in) :: tag logical(kind=LGT), intent(in) :: val Return Value integer(kind=I4B) private function geoMesh_setSize (Obj, dim, tags, meshsize) result(Ans) Set a mesh size constraint on the model entities dimTags. Currently only\n entities of dimension 0 (points) are handled. Arguments Type Intent Optional Attributes Name class( gmshGeoMesh_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: dim integer(kind=I4B), intent(in) :: tags (:) real(kind=DFP), intent(in) :: meshsize Return Value integer(kind=I4B) private function geoMesh_setSizeFromBoundary (Obj, dim, tag, val) result(Ans) Force the mesh size to be extended from the boundary, or not, for the model\n entity of dimension dim and tag tag. Currently only supported for dim == 2. Arguments Type Intent Optional Attributes Name class( gmshGeoMesh_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: dim integer(kind=I4B), intent(in) :: tag integer(kind=I4B), intent(in) :: val Return Value integer(kind=I4B) private function geoMesh_setSmoothing (Obj, dim, tag, val) result(Ans) Set a smoothing meshing constraint on the model entity of dimension dim\n and tag tag. val iterations of a Laplace smoother are applied. Arguments Type Intent Optional Attributes Name class( gmshGeoMesh_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: dim integer(kind=I4B), intent(in) :: tag integer(kind=I4B), intent(in), optional :: val Return Value integer(kind=I4B) private function geoMesh_setTransfiniteCurve (Obj, tag, nPoints, meshType, coef) result(Ans) Set a transfinite meshing constraint on the curve tag, with numNodes nodes\n distributed according to meshType and coef. Currently supported types\n are “Progres- sion” (geometrical progression with power coef) and “Bump”\n (refinement toward both extremities of the curve). Arguments Type Intent Optional Attributes Name class( gmshGeoMesh_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: tag integer(kind=I4B), intent(in) :: nPoints character(len=*), intent(in) :: meshType integer(kind=I4B), intent(in), optional :: coef Return Value integer(kind=I4B) private function geoMesh_setTransfiniteSurface (Obj, tag, arrangement, cornerTags) result(Ans) Set a transfinite meshing constraint on the surface tag. arrangement\n describes the arrangement of the triangles when the surface is not\n flagged as recombined: cur- rently supported values are “Left”, “Right”,\n “AlternateLeft” and “AlternateRight”. cornerTags can be used to specify\n the (3 or 4) corners of the transfinite interpola- tion explicitly;\n specifying the corners explicitly is mandatory if the surface has more\n that 3 or 4 points on its boundary. Arguments Type Intent Optional Attributes Name class( gmshGeoMesh_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: tag character(len=*), intent(in) :: arrangement integer(kind=I4B), intent(in) :: cornerTags (:) Return Value integer(kind=I4B) private function geoMesh_setTransfiniteVolume (Obj, tag, cornerTags) result(Ans) Set a transfinite meshing constraint on the surface tag. arrangement\n describes the arrangement of the triangles when the surface is not\n flagged as recombined: cur- rently supported values are “Left”, “Right”,\n “AlternateLeft” and “AlternateRight”. cornerTags can be used to specify\n the (3 or 4) corners of the transfinite interpola- tion explicitly;\n specifying the corners explicitly is mandatory if the surface has more\n that 3 or 4 points on its boundary. Arguments Type Intent Optional Attributes Name class( gmshGeoMesh_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: tag integer(kind=I4B), intent(in), optional :: cornerTags (:) Return Value integer(kind=I4B) private function geoMesh_write (Obj, UnitNo) result(Ans) Arguments Type Intent Optional Attributes Name class( gmshGeoMesh_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: UnitNo Return Value integer(kind=I4B)","tags":"","loc":"module/gmshgeomesh_class.html"},{"title":"gmshGeo_Class – Fortran Program","text":"This class is container for a geometry Uses BaseType BaseMethod gmshPoint_Class gmshCurve_Class gmshSurface_Class gmshVolume_Class gmshGeoMesh_Class Contents Variables def_max_Surface def_max_SurfaceLoop def_max_Volume def_max_curve def_max_curveLoop def_max_point Derived Types gmshGeo_ Functions geo_add_BSpline geo_add_Bezier geo_add_CompoundBSpline geo_add_CompoundSpline geo_add_CurveLoop geo_add_Ellipse geo_add_PlaneSurface geo_add_Spline geo_add_SurfaceFilling geo_add_SurfaceLoop geo_add_Volume geo_add_circle geo_add_line geo_add_point geo_write Variables Type Visibility Attributes Name Initial integer(kind=I4B), public, parameter :: def_max_Surface = 100 integer(kind=I4B), public, parameter :: def_max_SurfaceLoop = 100 integer(kind=I4B), public, parameter :: def_max_Volume = 100 integer(kind=I4B), public, parameter :: def_max_curve = 100 integer(kind=I4B), public, parameter :: def_max_curveLoop = 100 integer(kind=I4B), public, parameter :: def_max_point = 100 Derived Types type, public :: gmshGeo_ This class is defined to contain the elements of a geometry\n which will be constructed by Gmsh inbuilt kernel Components Type Visibility Attributes Name Initial type(gmshCurvePointer_), public, ALLOCATABLE :: Curve (:) type(gmshCurveLoopPointer_), public, ALLOCATABLE :: CurveLoop (:) type(gmshPointPointer_), public, ALLOCATABLE :: Point (:) type(gmshSurfacePointer_), public, ALLOCATABLE :: Surface (:) type(gmshSurfaceLoopPointer_), public, ALLOCATABLE :: SurfaceLoop (:) type(gmshVolumePointer_), public, ALLOCATABLE :: Volume (:) type(Buffer_), public, POINTER :: buffer => NULL() type(gmshGeoMesh_), public, POINTER :: mesh => NULL() integer(kind=I4B), public :: tCurveLoops = 0 integer(kind=I4B), public :: tCurves = 0 integer(kind=I4B), public :: tPoints = 0 integer(kind=I4B), public :: tSurfaceLoops = 0 integer(kind=I4B), public :: tSurfaces = 0 integer(kind=I4B), public :: tVolumes = 0 Type-Bound Procedures procedure, public, PASS( Obj ) :: addBSpline => geo_add_BSpline Add a BSpline entity to geometry procedure, public, PASS( Obj ) :: addBezier => geo_add_Bezier Add a Bezier entity to geometry procedure, public, PASS( Obj ) :: addCircleArc => geo_add_circle Add a Circular arc entity to geometry procedure, public, PASS( Obj ) :: addCompoundBSpline => geo_add_CompoundBSpline Add a compound BSpline entity to geometry procedure, public, PASS( Obj ) :: addCompoundSpline => geo_add_CompoundSpline Add a compound Spline entity to geometry procedure, public, PASS( Obj ) :: addCurveLoop => geo_add_CurveLoop Add a Curveloop to geometry procedure, public, PASS( Obj ) :: addEllipseArc => geo_add_Ellipse Add a Ellipse entity to geometry procedure, public, PASS( Obj ) :: addLine => geo_add_line Add a line entity to geometry procedure, public, PASS( Obj ) :: addPlaneSurface => geo_add_PlaneSurface Add a plane surface entity to geometry procedure, public, PASS( Obj ) :: addPoint => geo_add_point Add a point entitiy to geometry procedure, public, PASS( Obj ) :: addSpline => geo_add_Spline Add a Spline entity to geometry procedure, public, PASS( Obj ) :: addSurfaceFilling => geo_add_SurfaceFilling Add surfaceFilled procedure, public, PASS( Obj ) :: addSurfaceLoop => geo_add_SurfaceLoop procedure, public, PASS( Obj ) :: write => geo_write Functions private function geo_add_BSpline (Obj, pointTags, uid) result(ans) Arguments Type Intent Optional Attributes Name class( gmshGeo_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: pointTags (:) integer(kind=I4B), intent(in) :: uid Return Value integer(kind=I4B) private function geo_add_Bezier (Obj, pointTags, uid) result(ans) Arguments Type Intent Optional Attributes Name class( gmshGeo_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: pointTags (:) integer(kind=I4B), intent(in) :: uid Return Value integer(kind=I4B) private function geo_add_CompoundBSpline (Obj, curveTags, uid, numIntervals) result(ans) Arguments Type Intent Optional Attributes Name class( gmshGeo_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: curveTags (:) integer(kind=I4B), intent(in) :: uid integer(kind=I4B), optional :: numIntervals Return Value integer(kind=I4B) private function geo_add_CompoundSpline (Obj, curveTags, uid, numIntervals) result(ans) Arguments Type Intent Optional Attributes Name class( gmshGeo_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: curveTags (:) integer(kind=I4B), intent(in) :: uid integer(kind=I4B), optional :: numIntervals Return Value integer(kind=I4B) private function geo_add_CurveLoop (Obj, curveTags, uid) result(ans) Arguments Type Intent Optional Attributes Name class( gmshGeo_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: curveTags (:) integer(kind=I4B), intent(in) :: uid Return Value integer(kind=I4B) private function geo_add_Ellipse (Obj, startTag, centerTag, majorTag, endTag, uid, nx, ny, nz) result(ans) Arguments Type Intent Optional Attributes Name class( gmshGeo_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: startTag integer(kind=I4B), intent(in) :: centerTag integer(kind=I4B), intent(in) :: majorTag integer(kind=I4B), intent(in) :: endTag integer(kind=I4B), intent(in) :: uid real(kind=DFP), optional :: nx real(kind=DFP), optional :: ny real(kind=DFP), optional :: nz Return Value integer(kind=I4B) private function geo_add_PlaneSurface (Obj, wireTags, uid) result(ans) Arguments Type Intent Optional Attributes Name class( gmshGeo_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: wireTags (:) integer(kind=I4B), intent(in) :: uid Return Value integer(kind=I4B) private function geo_add_Spline (Obj, pointTags, uid) result(ans) Arguments Type Intent Optional Attributes Name class( gmshGeo_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: pointTags (:) integer(kind=I4B), intent(in) :: uid Return Value integer(kind=I4B) private function geo_add_SurfaceFilling (Obj, wireTags, uid, sphereCenterTag) result(ans) Add a surface filling the curve loops in wireTags.\n Currently only a single curve loop is supported; this curve loop should be\n composed by 3 or 4 curves only. If tag is positive, set the tag explicitly;\n otherwise a new tag is selected automatically. Return the tag of the surface. Arguments Type Intent Optional Attributes Name class( gmshGeo_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: wireTags (:) integer(kind=I4B), intent(in) :: uid integer(kind=I4B), intent(in), optional :: sphereCenterTag Return Value integer(kind=I4B) private function geo_add_SurfaceLoop (Obj, surfaceTags, uid) result(ans) Arguments Type Intent Optional Attributes Name class( gmshGeo_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: surfaceTags (:) integer(kind=I4B), intent(in) :: uid Return Value integer(kind=I4B) private function geo_add_Volume (Obj, shellTags, uid) result(ans) Arguments Type Intent Optional Attributes Name class( gmshGeo_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: shellTags (:) integer(kind=I4B), intent(in) :: uid Return Value integer(kind=I4B) private function geo_add_circle (Obj, startTag, centerTag, endTag, uid, nx, ny, nz) result(ans) Arguments Type Intent Optional Attributes Name class( gmshGeo_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: startTag integer(kind=I4B), intent(in) :: centerTag integer(kind=I4B), intent(in) :: endTag integer(kind=I4B), intent(in) :: uid real(kind=DFP), optional :: nx real(kind=DFP), optional :: ny real(kind=DFP), optional :: nz Return Value integer(kind=I4B) private function geo_add_line (Obj, startTag, endTag, uid) result(ans) Arguments Type Intent Optional Attributes Name class( gmshGeo_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: startTag integer(kind=I4B), intent(in) :: endTag integer(kind=I4B), intent(in) :: uid Return Value integer(kind=I4B) private function geo_add_point (Obj, x, y, z, lc, uid) result(ans) Arguments Type Intent Optional Attributes Name class( gmshGeo_ ), intent(inout) :: Obj real(kind=DFP), intent(in) :: x real(kind=DFP), intent(in) :: y real(kind=DFP), intent(in) :: z real(kind=DFP), intent(in) :: lc integer(kind=I4B), intent(in) :: uid Return Value integer(kind=I4B) private function geo_write (Obj, UnitNo) result(Ans) Arguments Type Intent Optional Attributes Name class( gmshGeo_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: UnitNo Return Value integer(kind=I4B)","tags":"","loc":"module/gmshgeo_class.html"},{"title":"mshFormat_Class – Fortran Program","text":"This module defines a mesh format Uses BaseType GlobalData Contents Variables TypemshFormat Interfaces DeallocateData Display fmt_deallocatedata fmt_display fmt_goto fmt_read_file fmt_write_file Derived Types mshFormatPointer_ mshFormat_ Variables Type Visibility Attributes Name Initial type( mshFormat_ ), public, parameter :: TypemshFormat = mshFormat_() Interfaces public interface DeallocateData private interface fmt_deallocatedata () This subroutine clears the content of mshFormat_ Arguments None public interface Display private interface fmt_display () This subroutine display the content of mshFormat_ Arguments None interface This subroutine clears the content of mshFormat_ private subroutine fmt_deallocatedata(Obj) This subroutine clears the content of mshFormat_ Arguments Type Intent Optional Attributes Name class( mshFormat_ ), intent(inout) :: Obj interface This subroutine display the content of mshFormat_ private subroutine fmt_display(Obj, Msg, UnitNo) Arguments Type Intent Optional Attributes Name class( mshFormat_ ), intent(in) :: Obj character(len=*), intent(in) :: Msg integer(kind=I4B), intent(in), optional :: UnitNo interface This subroutine search the mesh format tag in the mesh file private subroutine fmt_goto(Obj, mshFile, ierr) This subroutine search the mesh format tag in the mesh file Arguments Type Intent Optional Attributes Name class( mshFormat_ ), intent(in) :: Obj type(File_), intent(inout) :: mshFile logical(kind=LGT), intent(inout) :: ierr interface This subroutine reads format from .msh file private subroutine fmt_read_file(Obj, mshFile, ierr) This subroutine reads mesh format from .mshfile Arguments Type Intent Optional Attributes Name class( mshFormat_ ), intent(inout) :: Obj type(File_), intent(inout) :: mshFile logical(kind=LGT), intent(inout) :: ierr interface This subroutine writes mesh format to a .msh file private subroutine fmt_write_file(Obj, mshFile, Str, EndStr) This subroutine writes mesh format to a .msh file Arguments Type Intent Optional Attributes Name class( mshFormat_ ), intent(inout) :: Obj type(File_), intent(inout) :: mshFile character(len=*), intent(in), optional :: Str character(len=*), intent(in), optional :: EndStr Derived Types type, public :: mshFormatPointer_ Components Type Visibility Attributes Name Initial class( mshFormat_ ), public, POINTER :: Ptr => NULL() type, public :: mshFormat_ This data type stores gmsh mesh format Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: DataSize = 0 integer(kind=I4B), public :: FileType = 0 character(len=100), public :: MeshFormat = \"\" real(kind=DFP), public :: Version = 0.0_DFP logical(kind=LGT), public :: isASCII = .FALSE. Type-Bound Procedures procedure, public, PASS( Obj ) :: Finalize => fmt_deallocatedata Finalize procedure, public, PASS( Obj ) :: GotoTag => fmt_goto Goto a tag procedure, public, PASS( Obj ) :: ReadFromFile => fmt_read_file Read format from a file procedure, public, PASS( Obj ) :: WriteToFile => fmt_write_file Write content to a file","tags":"","loc":"module/mshformat_class.html"},{"title":"mshElements_Class – Fortran Program","text":"This module defines a class to handle elements in mesh file Uses BaseType GlobalData mshFormat_Class Contents Variables TypemshElements Interfaces DeallocateData Display el_deallocatedata el_display el_goto el_read_elem_line el_read_file el_telements_1 el_write_file Derived Types mshElementsPointer_ mshElements_ Variables Type Visibility Attributes Name Initial type( mshElements_ ), public, parameter :: TypemshElements = mshElements_() Interfaces public interface DeallocateData private interface el_deallocatedata () Arguments None public interface Display private interface el_display () Arguments None interface private subroutine el_deallocatedata(Obj) This subroutine deallocates the data from obj Arguments Type Intent Optional Attributes Name class( mshElements_ ), intent(inout) :: Obj interface private subroutine el_display(Obj, Msg, UnitNo) This data displays the content of mshElements_ Arguments Type Intent Optional Attributes Name class( mshElements_ ), intent(in) :: Obj character(len=*), intent(in) :: Msg integer(kind=I4B), intent(in), optional :: UnitNo interface This subroutine go the location of element in mesh file private subroutine el_goto(Obj, mshFile, ierr) This subroutine go the location of element in mesh file Arguments Type Intent Optional Attributes Name class( mshElements_ ), intent(in) :: Obj type(File_), intent(inout) :: mshFile logical(kind=LGT), intent(inout) :: ierr interface private subroutine el_read_elem_line(Obj, ElemNum, ElemType, PhysicalId, GeometryId, MeshPartitionTags, Nptrs, mshFile) Arguments Type Intent Optional Attributes Name class( mshElements_ ), intent(inout) :: Obj integer(kind=I4B), intent(inout), optional :: ElemNum integer(kind=I4B), intent(inout), optional :: ElemType integer(kind=I4B), intent(inout), optional :: PhysicalId integer(kind=I4B), intent(inout), optional :: GeometryId integer(kind=I4B), intent(inout), optional ALLOCATABLE :: MeshPartitionTags (:) integer(kind=I4B), intent(inout), optional ALLOCATABLE :: Nptrs (:) type(File_), intent(inout) :: mshFile interface private subroutine el_read_file(Obj, mshFile, mshFormat, ierr) This subroutine reads data from a file Arguments Type Intent Optional Attributes Name class( mshElements_ ), intent(inout) :: Obj type(File_), intent(inout) :: mshFile type(mshFormat_), intent(inout) :: mshFormat logical(kind=LGT), intent(inout) :: ierr interface private pure function el_telements_1(Obj) result(Ans) This function returns total number of elements Arguments Type Intent Optional Attributes Name class( mshElements_ ), intent(in) :: Obj Return Value integer(kind=I4B) interface private subroutine el_write_file(Obj, mshFile, mshFormat, Str, EndStr) This subroutine writes the data to a file Arguments Type Intent Optional Attributes Name class( mshElements_ ), intent(inout) :: Obj type(File_), intent(inout) :: mshFile type(mshFormat_), intent(inout) :: mshFormat character(len=*), intent(in), optional :: Str character(len=*), intent(in), optional :: EndStr Derived Types type, public :: mshElementsPointer_ Components Type Visibility Attributes Name Initial class( mshElements_ ), public, POINTER :: Ptr => NULL() type, public :: mshElements_ This class handles the elements present in the mesh file Components Type Visibility Attributes Name Initial logical(kind=LGT), public :: isSparse = .FALSE. integer(kind=I4B), public :: maxElementTag = 0 integer(kind=I4B), public :: minElementTag = 0 integer(kind=I4B), public :: numElements = 0 integer(kind=I4B), public :: numEntityBlocks = 0 Type-Bound Procedures procedure, public, PASS( Obj ) :: Finalize => el_deallocatedata deallocate data procedure, public, PASS( Obj ) :: GotoTag => el_goto go to the tag procedure, public, PASS( Obj ) :: ReadElementLine => el_read_elem_line Read element line procedure, public, PASS( Obj ) :: ReadFromFile => el_read_file Read data form file procedure, public, PASS( Obj ) :: TotalElements => el_telements_1 total elements procedure, public, PASS( Obj ) :: WriteToFile => el_write_file Write data to file","tags":"","loc":"module/mshelements_class.html"},{"title":"mshPhysicalNames_Class – Fortran Program","text":"This module defines a data type for handling gmsh physical names Uses BaseType GlobalData Contents Variables TypeMSHPhysicalNames Interfaces DeallocateData Display pn_Curve_names pn_Curve_tags pn_Point_tags pn_Surface_names pn_Surface_tags pn_Volume_names pn_Volume_tags pn_deallocatedata pn_display pn_get_size pn_goto pn_index_Curve pn_index_Curve_2 pn_index_Surface pn_index_Surface_2 pn_index_Volume pn_index_Volume_2 pn_index_a pn_index_b pn_index_c pn_index_d pn_index_point pn_index_point_2 pn_output_file pn_point_names pn_read_file pn_size_Curve pn_size_Surface pn_size_Volume pn_size_point pn_who_am_i pn_write_file Derived Types mshPhysicalNamesPointer_ mshPhysicalNames_ Variables Type Visibility Attributes Name Initial type( mshPhysicalNames_ ), public, parameter :: TypeMSHPhysicalNames = mshPhysicalNames_(NSD=NULL(), Tag=NULL(), numElements=NULL(), numNodes=NULL(), PhysicalName=NULL(), Entities=NULL()) Interfaces public interface DeallocateData private interface pn_deallocatedata () This subroutine deallocates the data stored in mshPhysicalNames_ Arguments None public interface Display private interface pn_display () This subroutine displays the content of mshPhysicalNames_ Arguments None interface This function returns the names of physical curves private pure function pn_Curve_names(Obj) result(Ans) This subroutine returns the names of physical curves Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj Return Value type(String),\n  ALLOCATABLE, (:) interface This function returns the physical tags of all physical curves private pure function pn_Curve_tags(Obj) result(Ans) This function returns the physical tags of all physical curves Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) interface This function returns the physical tags of all physical points private pure function pn_Point_tags(Obj) result(Ans) This function returns the physical tags of all physical points Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) interface This function returns the names of physical surfaces private pure function pn_Surface_names(Obj) result(Ans) This subroutine returns the names of physical surfaces Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj Return Value type(String),\n  ALLOCATABLE, (:) interface This function returns the physical tags of all physical surfaces private pure function pn_Surface_tags(Obj) result(Ans) This function returns the physical tags of all physical surfaces Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) interface This function returns the names of physical volumes private pure function pn_Volume_names(Obj) result(Ans) This subroutine returns the names of physical volumes Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj Return Value type(String),\n  ALLOCATABLE, (:) interface This function returns the physical tags of all physical volumes private pure function pn_Volume_tags(Obj) result(Ans) This function returns the physical tags of all physical volumes Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) interface This subroutine deallocates the data stored in mshPhysicalNames_ private subroutine pn_deallocatedata(Obj) This subroutine deallocates the data stored in mshPhysicalNames_ Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(inout) :: Obj interface This subroutine displays the content of mshPhysicalNames_ private subroutine pn_display(Obj, Msg, UnitNo) This subroutine displays the content of mshPhysicalNames_ Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj character(len=*), intent(in) :: Msg integer(kind=I4B), intent(in), optional :: UnitNo interface This function returns total number of physical entities private pure function pn_get_size(Obj) result(Ans) This function returns total number of physical entities Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj Return Value integer(kind=I4B) interface This suboutine find the tag for Physical groups in mesh private subroutine pn_goto(Obj, mshFile, ierr) This suboutine find the tag for Physical groups in mesh Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj type(File_), intent(inout) :: mshFile logical(kind=LGT), intent(inout) :: ierr interface This function return the index of physical Curve from its physical id private pure function pn_index_Curve(Obj, Tag) result(Ans) This function returns the index of physical Curve from its physical id Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Tag Return Value integer(kind=I4B) interface This function return the index of physical Curve from its physical id private pure function pn_index_Curve_2(Obj, Tag) result(Ans) This function returns the index of physical Curve from its physical id Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Tag (:) Return Value integer(kind=I4B)\n  (SIZE(Tag)) interface This function return the index of physical Surface from its physical id private pure function pn_index_Surface(Obj, Tag) result(Ans) This function returns the index of physical Surface from its physical id Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Tag Return Value integer(kind=I4B) interface private pure function pn_index_Surface_2(Obj, Tag) result(Ans) Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Tag (:) Return Value integer(kind=I4B)\n  (SIZE(Tag)) interface This function return the index of physical Volume from its physical id private pure function pn_index_Volume(Obj, Tag) result(Ans) This function returns the index of physical Volume from its physical id Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Tag Return Value integer(kind=I4B) interface This function return the index of physical Volume from its physical id private pure function pn_index_Volume_2(Obj, Tag) result(Ans) This function returns the index of physical Volume from its physical id Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Tag (:) Return Value integer(kind=I4B)\n  (SIZE(Tag)) interface This function returns index of a given physical name private pure function pn_index_a(Obj, Name) result(Ans) This function returns index of a given physical name Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj character(len=*), intent(in) :: Name Return Value integer(kind=I4B) interface private pure function pn_index_b(Obj, Name) result(Ans) Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj type(String), intent(in) :: Name (:) Return Value integer(kind=I4B)\n  (SIZE(Name)) interface This function returns index of a given physical name private pure function pn_index_c(Obj, XiDimTag) result(Ans) This function returns index of a given physical name Read more… Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: XiDimTag (2) Return Value integer(kind=I4B) interface This function returns index of a given physical name private pure function pn_index_d(Obj, XiDimTag) result(Ans) This function returns index of a given physical name Read more… Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: XiDimTag Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) interface private pure function pn_index_point(Obj, Tag) result(Ans) Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Tag Return Value integer(kind=I4B) interface private pure function pn_index_point_2(Obj, Tag) result(Ans) Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Tag (:) Return Value integer(kind=I4B)\n  (SIZE(Tag)) interface This function retunrns the name of output file private pure function pn_output_file(Obj, mshFile, indx) result(Ans) Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj type(File_), intent(in) :: mshFile integer(kind=I4B), intent(in) :: indx Return Value type(String) interface This function returns the names of physical poins private pure function pn_point_names(Obj) result(Ans) This subroutine returns the names of physical points Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj Return Value type(String),\n  ALLOCATABLE, (:) interface This subroutine reads physical groupds info from mesh file private subroutine pn_read_file(Obj, mshFile, ierr) This subroutine reads physical groupds info from mesh file Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(inout) :: Obj type(File_), intent(inout) :: mshFile logical(kind=LGT), intent(inout) :: ierr interface This function returns total number of physical curves private pure function pn_size_Curve(Obj) result(Ans) This function returns total number of physical curves Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj Return Value integer(kind=I4B) interface This function returns total number of physical surfaces private pure function pn_size_Surface(Obj) result(Ans) This function returns total number of physical surfaces Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj Return Value integer(kind=I4B) interface This function returns total number of physical volumes private pure function pn_size_Volume(Obj) result(Ans) This function returns total number of physical volumes Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj Return Value integer(kind=I4B) interface This function returns total number of physical points private pure function pn_size_point(Obj) result(Ans) This function returns total number of physical points Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj Return Value integer(kind=I4B) interface private pure function pn_who_am_i(Obj, I) result(Ans) Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: I Return Value type(String) interface This subroutine writes physical groupds info in mesh file private subroutine pn_write_file(Obj, mshFile, Str, EndStr) This subroutine writes physical groupds info in mesh file Arguments Type Intent Optional Attributes Name class( mshPhysicalNames_ ), intent(inout) :: Obj type(File_), intent(inout) :: mshFile character(len=*), intent(in), optional :: Str character(len=*), intent(in), optional :: EndStr Derived Types type, public :: mshPhysicalNamesPointer_ Components Type Visibility Attributes Name Initial class( mshPhysicalNames_ ), public, POINTER :: Ptr => NULL() type, public :: mshPhysicalNames_ This data type contains the Physical Names generate by gmsh Components Type Visibility Attributes Name Initial type(IntVector_), public, ALLOCATABLE :: Entities (:) Tags of Entities in each physical group integer(kind=I4B), public, ALLOCATABLE :: NSD (:) spatial dimension of each physical group type(String), public, ALLOCATABLE :: PhysicalName (:) Physical name of each physical group integer(kind=I4B), public, ALLOCATABLE :: Tag (:) Unit ID of each physical group integer(kind=I4B), public, ALLOCATABLE :: numElements (:) Number of elements in each physical group integer(kind=I4B), public, ALLOCATABLE :: numNodes (:) Number of nodes in each physical nodes Type-Bound Procedures procedure, public, PASS( Obj ) :: Finalize => pn_deallocatedata To deallocate data procedure, public, PASS( Obj ) :: GotoTag => pn_goto Search tag for physical group in mesh file generic, public :: IndexOfPhysicalCurve => pn_index_Curve, pn_index_Curve_2 generic, public :: IndexOfPhysicalPoint => pn_index_point, pn_index_point_2 generic, public :: IndexOfPhysicalSurface => pn_index_Surface, pn_index_Surface_2 generic, public :: IndexOfPhysicalVolume => pn_index_Volume, pn_index_Volume_2 procedure, public, PASS( Obj ) :: OutputFileName => pn_output_file procedure, public, PASS( Obj ) :: PhysicalCurveNames => pn_Curve_names Returns names of a physical curves procedure, public, PASS( Obj ) :: PhysicalCurveTags => pn_Curve_tags Returns tags of physical points procedure, public, PASS( Obj ) :: PhysicalPointNames => pn_point_names Returns the names of physical points procedure, public, PASS( Obj ) :: PhysicalPointTags => pn_Point_tags Returns tags of physical points procedure, public, PASS( Obj ) :: PhysicalSurfaceNames => pn_Surface_names Returns names of Physical surface procedure, public, PASS( Obj ) :: PhysicalSurfaceTags => pn_Surface_tags Returns tags of physical surfaces procedure, public, PASS( Obj ) :: PhysicalVolumeNames => pn_Volume_names Returns names of physical volumes procedure, public, PASS( Obj ) :: PhysicalVolumeTags => pn_Volume_tags Returns tags of physical volumes procedure, public, PASS( Obj ) :: ReadFromFile => pn_read_file Read contents from mesh file procedure, public, PASS( Obj ) :: SIZE => pn_get_size Returns total number of physical groups procedure, public, PASS( Obj ) :: TotalPhysicalCurves => pn_size_Curve Returns total number of physical curves procedure, public, PASS( Obj ) :: TotalPhysicalPoints => pn_size_point Returns total number of physical points in mesh procedure, public, PASS( Obj ) :: TotalPhysicalSurfaces => pn_size_Surface Returns total number of physical surface procedure, public, PASS( Obj ) :: TotalPhysicalVolumes => pn_size_Volume Returns total number of physical volumes procedure, public, PASS( Obj ) :: WhoAmI => pn_who_am_i Enquire about “volume, surface, curve, point’ procedure, public, PASS( Obj ) :: WriteToFile => pn_write_file Write contents to a mesh file generic, public :: getIndex => pn_index_a, pn_index_b, pn_index_c, pn_index_d procedure, private, PASS( Obj ) :: pn_index_Curve Return index of physical curve procedure, private, PASS( Obj ) :: pn_index_Curve_2 Return index of physical curve procedure, private, PASS( Obj ) :: pn_index_Surface Return index of physical surface procedure, private, PASS( Obj ) :: pn_index_Surface_2 Return index of physical surface procedure, private, PASS( Obj ) :: pn_index_Volume procedure, private, PASS( Obj ) :: pn_index_Volume_2 procedure, private, PASS( Obj ) :: pn_index_a Returns the index of a physical group procedure, private, PASS( Obj ) :: pn_index_b Returns the index of a physical group procedure, private, PASS( Obj ) :: pn_index_c Returns the index of a physical group procedure, private, PASS( Obj ) :: pn_index_d Returns the index of a physical group procedure, private, PASS( Obj ) :: pn_index_point Return index of physical points procedure, private, PASS( Obj ) :: pn_index_point_2 Return index of physical points","tags":"","loc":"module/mshphysicalnames_class.html"},{"title":"mshEntity_Class – Fortran Program","text":"This module contains a class to handle entities in mesh file Uses BaseType GlobalData Contents Variables TypeMshEntity Interfaces DeallocateData Display ent_deallocatedata ent_display ent_getIndex_a ent_goto ent_read_Curve ent_read_Surface ent_read_Volume ent_read_point ent_tBoundingtag ent_telements ent_tphysicaltag ent_write_file getIndex Derived Types mshEntityPointer_ mshEntity_ Variables Type Visibility Attributes Name Initial type( mshEntity_ ), public, parameter :: TypeMshEntity = mshEntity_(PhysicalTag=NULL(), NodeNumber=NULL(), ElemNumber=NULL(), Nptrs=NULL(), NodeCoord=NULL(), BoundingEntity=NULL()) Interfaces public interface DeallocateData private interface ent_deallocatedata () This subroutine deallocate the data from mshEntity_ Arguments None public interface Display private interface ent_display () Arguments None interface This subroutine deallocate the data from mshEntity_ private subroutine ent_deallocatedata(Obj) This subroutine deallocate the data from mshEntity_ Arguments Type Intent Optional Attributes Name class( mshEntity_ ), intent(inout) :: Obj interface private subroutine ent_display(Obj, Msg, UnitNo) This subroutine writes the content of mshEntity_ Arguments Type Intent Optional Attributes Name class( mshEntity_ ), intent(in) :: Obj character(len=*), intent(in) :: Msg integer(kind=I4B), intent(in), optional :: UnitNo interface This function finds the index of a tag/uid in list of entities private pure function ent_getIndex_a(mshEntities, Uid) result(Ans) This function finds the index of a tag/uid in the list of entities Arguments Type Intent Optional Attributes Name type( mshEntity_ ), intent(in) :: mshEntities (:) integer(kind=I4B), intent(in) :: Uid Return Value integer(kind=I4B) interface This subroutine finds the tag in the mesh file private subroutine ent_goto(Obj, mshFile, ierr) Arguments Type Intent Optional Attributes Name class( mshEntity_ ), intent(in) :: Obj type(File_), intent(inout) :: mshFile logical(kind=LGT), intent(inout) :: ierr interface This subroutine reads the entry for curve entity private subroutine ent_read_Curve(Obj, mshFile, readTag, ierr) This subroutine reads the entry for curve entity Arguments Type Intent Optional Attributes Name class( mshEntity_ ), intent(inout) :: Obj type(File_), intent(inout) :: mshFile logical(kind=LGT), intent(in) :: readTag logical(kind=LGT), intent(inout) :: ierr interface This subroutine reads the entry for surface entity private subroutine ent_read_Surface(Obj, mshFile, readTag, ierr) This subroutine reads the entry for surface entity Arguments Type Intent Optional Attributes Name class( mshEntity_ ), intent(inout) :: Obj type(File_), intent(inout) :: mshFile logical(kind=LGT), intent(in) :: readTag logical(kind=LGT), intent(inout) :: ierr interface This subroutine reads the entry for volume entity private subroutine ent_read_Volume(Obj, mshFile, readTag, ierr) This subroutine reads the entry for volume entity Arguments Type Intent Optional Attributes Name class( mshEntity_ ), intent(inout) :: Obj type(File_), intent(inout) :: mshFile logical(kind=LGT), intent(in) :: readTag logical(kind=LGT), intent(inout) :: ierr interface This subroutine reads the entry for point entity private subroutine ent_read_point(Obj, mshFile, readTag, ierr) This subroutine reads the entry for point entity Arguments Type Intent Optional Attributes Name class( mshEntity_ ), intent(inout) :: Obj type(File_), intent(inout) :: mshFile logical(kind=LGT), intent(in) :: readTag logical(kind=LGT), intent(inout) :: ierr interface This function returns the total number of bounding tags in entity private pure function ent_tBoundingtag(Obj) result(Ans) This function returns the total number of bounding tags in entity Arguments Type Intent Optional Attributes Name class( mshEntity_ ), intent(in) :: Obj Return Value integer(kind=I4B) interface This function returns the total number of elements in entity private pure function ent_telements(Obj) result(Ans) This function returns the total number of elements in entity Arguments Type Intent Optional Attributes Name class( mshEntity_ ), intent(in) :: Obj Return Value integer(kind=I4B) interface This function returns the total number of physical tags in entity private pure function ent_tphysicaltag(Obj) result(Ans) This function returns the total number of physical tags in entity Arguments Type Intent Optional Attributes Name class( mshEntity_ ), intent(in) :: Obj Return Value integer(kind=I4B) interface This subroutine write the data to a file private subroutine ent_write_file(Obj, mshFile, Str, EndStr) This subroutine write the data to a file Arguments Type Intent Optional Attributes Name class( mshEntity_ ), intent(inout) :: Obj type(File_), intent(inout) :: mshFile character(len=*), intent(in), optional :: Str character(len=*), intent(in), optional :: EndStr public interface getIndex private interface ent_getIndex_a () This function finds the index of a tag/uid in list of entities Arguments None Derived Types type, public :: mshEntityPointer_ Components Type Visibility Attributes Name Initial class( mshEntity_ ), public, POINTER :: Ptr => NULL() type, public :: mshEntity_ This class handles the mesh entities defined in msh file Components Type Visibility Attributes Name Initial integer(kind=I4B), public, ALLOCATABLE :: BoundingEntity (:) tag of bounding entity integer(kind=I4B), public, ALLOCATABLE :: ElemNumber (:) element numbers in mesh integer(kind=I4B), public :: ElemType = 0 element type in meshing real(kind=DFP), public, ALLOCATABLE :: NodeCoord (:,:) nodal coordinates in xiJ format integer(kind=I4B), public, ALLOCATABLE :: NodeNumber (:) node numbers in mesh integer(kind=I4B), public, ALLOCATABLE :: Nptrs (:,:) connectivity integer(kind=I4B), public, ALLOCATABLE :: PhysicalTag (:) Physical tags associated real(kind=DFP), public :: X = 0.0_DFP used only for point entity integer(kind=I4B), public :: XiDim = 0 for point=0, curve=1, surface = 2, volume = 3 real(kind=DFP), public :: Y = 0.0_DFP used only for point entity real(kind=DFP), public :: Z = 0.0_DFP used only for point entity real(kind=DFP), public :: maxX = 0.0_DFP bounding box of entity real(kind=DFP), public :: maxY = 0.0_DFP bounding box of entity real(kind=DFP), public :: maxZ = 0.0_DFP bounding box of entity real(kind=DFP), public :: minX = 0.0_DFP bounding box of entity real(kind=DFP), public :: minY = 0.0_DFP bounding box of entity real(kind=DFP), public :: minZ = 0.0_DFP bounding box of entity integer(kind=I4B), public :: uid = 0 unique id of entity Type-Bound Procedures procedure, public, PASS( Obj ) :: Finalize => ent_deallocatedata To deallocate data procedure, public, PASS( Obj ) :: GotoTag => ent_goto To find tag procedure, public, PASS( Obj ) :: ReadCurveEntity => ent_read_Curve Read the entry from file for curve procedure, public, PASS( Obj ) :: ReadPointEntity => ent_read_point Read the entry from file for point procedure, public, PASS( Obj ) :: ReadSurfaceEntity => ent_read_Surface Read the entry from file for surface procedure, public, PASS( Obj ) :: ReadVolumeEntity => ent_read_Volume Read the entry from file for volume procedure, public, PASS( Obj ) :: TotalBoundingTags => ent_tBoundingtag Returns the total bounding tags procedure, public, PASS( Obj ) :: TotalElements => ent_telements Returns the total elements procedure, public, PASS( Obj ) :: TotalPhysicalTags => ent_tphysicaltag Return total physical tags associated procedure, public, PASS( Obj ) :: WriteToFile => ent_write_file Write data to a file","tags":"","loc":"module/mshentity_class.html"},{"title":"mshNodes_Class – Fortran Program","text":"This module implements a class for handling nodes in mesh file Uses BaseType GlobalData mshFormat_Class Contents Variables TypeMshNodes Interfaces DeallocateData Display n_deallocatedata n_display n_goto n_read_file n_write_file Derived Types mshNodesPointer_ mshNodes_ Variables Type Visibility Attributes Name Initial type( mshNodes_ ), public, parameter :: TypeMshNodes = mshNodes_() Interfaces public interface DeallocateData private interface n_deallocatedata () This subroutine deallocate the data form the instance Arguments None public interface Display private interface n_display () This subroutine display contents of mshNodes_ Arguments None interface This subroutine deallocate the data form the instance private subroutine n_deallocatedata(Obj) This subroutine deallocate the data from instance Arguments Type Intent Optional Attributes Name class( mshNodes_ ), intent(inout) :: Obj interface This subroutine display contents of mshNodes_ private subroutine n_display(Obj, Msg, UnitNo) This subroutine displays content of mshNodes_ Arguments Type Intent Optional Attributes Name class( mshNodes_ ), intent(in) :: Obj character(len=*), intent(in) :: Msg integer(kind=I4B), intent(in), optional :: UnitNo interface This subroutine go to the position where nodes are defined private subroutine n_goto(Obj, mshFile, ierr) This subroutine go to the position where nodes are defined Arguments Type Intent Optional Attributes Name class( mshNodes_ ), intent(in) :: Obj type(File_), intent(inout) :: mshFile logical(kind=LGT), intent(inout) :: ierr interface This subroutine read data from mesh file private subroutine n_read_file(Obj, mshFile, mshFormat, ierr) This subroutine read data from mesh file Arguments Type Intent Optional Attributes Name class( mshNodes_ ), intent(inout) :: Obj type(File_), intent(inout) :: mshFile type(mshFormat_), intent(inout) :: mshFormat logical(kind=LGT), intent(inout) :: ierr interface This subroutine write data to a file private subroutine n_write_file(Obj, mshFile, mshFormat, Str, EndStr) This subroutine writes data to a file Arguments Type Intent Optional Attributes Name class( mshNodes_ ), intent(inout) :: Obj type(File_), intent(inout) :: mshFile type(mshFormat_), intent(inout) :: mshFormat character(len=*), intent(in), optional :: Str character(len=*), intent(in), optional :: EndStr Derived Types type, public :: mshNodesPointer_ Components Type Visibility Attributes Name Initial class( mshNodes_ ), public, POINTER :: Ptr => NULL() type, public :: mshNodes_ This class is defined to handle the nodes in mesh file Components Type Visibility Attributes Name Initial logical(kind=LGT), public :: isSparse = .FALSE. isSparse integer(kind=I4B), public :: maxNodeTag = 0 maximum node number integer(kind=I4B), public :: minNodeTag = 0 minimum node number integer(kind=I4B), public :: numEntityBlocks = 0 number of entity blocks integer(kind=I4B), public :: numNodes = 0 number of nodes Type-Bound Procedures procedure, public, PASS( Obj ) :: Finalize => n_deallocatedata DeallocateData From the object procedure, public, PASS( Obj ) :: GotoTag => n_goto Go to the node tag in mesh file procedure, public, PASS( Obj ) :: ReadFromFile => n_read_file read content from file procedure, public, PASS( Obj ) :: WriteToFile => n_write_file write data to file","tags":"","loc":"module/mshnodes_class.html"},{"title":"gmshModel_Class – Fortran Program","text":"This class is container for all gmsh model Uses BaseType GlobalData BaseMethod gmshGeo_Class gmshMesh_Class Contents Variables def_curve_ent2phy def_curve_phy2ent def_point_ent2phy def_point_phy2ent def_surface_ent2phy def_surface_phy2ent def_volume_ent2phy def_volume_phy2ent Derived Types gmshModel_ Functions model_add model_addPhysicalGroup model_getEntities model_getEntitiesForPhysicalGroup model_getEntityName model_getPhysicalGroups model_getPhysicalGroupsForEntity model_getPhysicalName model_setEntityName model_setPhysicalName model_write Variables Type Visibility Attributes Name Initial integer(kind=I4B), public, parameter :: def_curve_ent2phy = 100 integer(kind=I4B), public, parameter :: def_curve_phy2ent = 100 integer(kind=I4B), public, parameter :: def_point_ent2phy = 100 integer(kind=I4B), public, parameter :: def_point_phy2ent = 100 integer(kind=I4B), public, parameter :: def_surface_ent2phy = 100 integer(kind=I4B), public, parameter :: def_surface_phy2ent = 100 integer(kind=I4B), public, parameter :: def_volume_ent2phy = 100 integer(kind=I4B), public, parameter :: def_volume_phy2ent = 100 Derived Types type, public :: gmshModel_ This data type is container for all the gmsh models Components Type Visibility Attributes Name Initial type(IntVectorPointer_), public, ALLOCATABLE :: Curve_EntityToPhysical (:) type(IntVectorPointer_), public, ALLOCATABLE :: Curve_PhysicalToEntity (:) type(String), public, ALLOCATABLE :: EntityCurveName (:) type(String), public, ALLOCATABLE :: EntityPointName (:) type(String), public, ALLOCATABLE :: EntitySurfaceName (:) type(String), public, ALLOCATABLE :: EntityVolumeName (:) type(String), public, ALLOCATABLE :: PhysicalCurveName (:) integer(kind=I4B), public, ALLOCATABLE :: PhysicalCurveUID (:) type(String), public, ALLOCATABLE :: PhysicalPointName (:) integer(kind=I4B), public, ALLOCATABLE :: PhysicalPointUID (:) type(String), public, ALLOCATABLE :: PhysicalSurfaceName (:) integer(kind=I4B), public, ALLOCATABLE :: PhysicalSurfaceUID (:) type(String), public, ALLOCATABLE :: PhysicalVolumeName (:) integer(kind=I4B), public, ALLOCATABLE :: PhysicalVolumeUID (:) type(IntVectorPointer_), public, ALLOCATABLE :: Point_EntityToPhysical (:) type(IntVectorPointer_), public, ALLOCATABLE :: Point_PhysicalToEntity (:) type(IntVectorPointer_), public, ALLOCATABLE :: Surface_EntityToPhysical (:) type(IntVectorPointer_), public, ALLOCATABLE :: Surface_PhysicalToEntity (:) type(IntVectorPointer_), public, ALLOCATABLE :: Volume_EntityToPhysical (:) type(IntVectorPointer_), public, ALLOCATABLE :: Volume_PhysicalToEntity (:) type(Buffer_), public, POINTER :: buffer => NULL() type(gmshGeo_), public, POINTER :: geo => NULL() geometry due to internal kernel Read more… type(gmshMesh_), public, POINTER :: mesh => NULL() character(len=5), public :: name = \"\" We can use this file two take backups and write content of model type( gmshModel_ ), public, POINTER :: next => NULL() Pointer to the next model for linked list Type-Bound Procedures procedure, public, PASS( Obj ) :: add => model_add procedure, public, PASS( Obj ) :: addPhysicalGroup => model_addPhysicalGroup procedure, public, PASS( Obj ) :: getEntities => model_getEntities procedure, public, PASS( Obj ) :: getEntitiesForPhysicalGroup => model_getEntitiesForPhysicalGroup procedure, public, PASS( Obj ) :: getEntityName => model_getEntityName procedure, public, PASS( Obj ) :: getPhysicalGroups => model_getPhysicalGroups procedure, public, PASS( Obj ) :: getPhysicalGroupsForEntity => model_getPhysicalGroupsForEntity procedure, public, PASS( Obj ) :: getPhysicalName => model_getPhysicalName procedure, public, PASS( Obj ) :: setEntityName => model_setEntityName procedure, public, PASS( Obj ) :: setPhysicalName => model_setPhysicalName procedure, public, PASS( Obj ) :: write => model_write Functions private function model_add (Obj, Name) result(Ans) This function add the model\n Currently only one model can be added\n model_name_buffer.txt Arguments Type Intent Optional Attributes Name class( gmshModel_ ), intent(inout), TARGET :: Obj character(len=*), intent(in) :: Name Return Value integer(kind=I4B) private function model_addPhysicalGroup (Obj, dim, tags, uid) result(Ans) Add a physical group of dimension dim, grouping the model entities with\n tags tags. Return the tag of the physical group, equal to tag if tag is\n positive, or a new tag if tag < 0.\n check\n check\n If it is the first call then\n check\n check\n If it is the first call then\n check\n check\n If it is the first call then\n check\n check\n If it is the first call then Arguments Type Intent Optional Attributes Name class( gmshModel_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: dim integer(kind=I4B), intent(in) :: tags (:) integer(kind=I4B), intent(in) :: uid Return Value integer(kind=I4B) private function model_getEntities (Obj, dim) result(Ans) Get all the entities in the current model. If dim is >= 0, return only\n the entities of the specified dimension (e.g. points if dim == 0).\n The entities are returned as a vector of (dim, tag) integer pairs. Arguments Type Intent Optional Attributes Name class( gmshModel_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: dim Return Value integer(kind=I4B),\n  ALLOCATABLE, (:,:) private function model_getEntitiesForPhysicalGroup (Obj, dim, tag) result(Ans) Get the tags of the model entities making up the physical group of\n dimension dim and tag tag. Arguments Type Intent Optional Attributes Name class( gmshModel_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: dim integer(kind=I4B), intent(in) :: tag Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) private function model_getEntityName (Obj, dim, tag) result(Ans) get the name of the entity of dimension dim and tag tag Arguments Type Intent Optional Attributes Name class( gmshModel_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: dim integer(kind=I4B), intent(in) :: tag Return Value type(String) private function model_getPhysicalGroups (Obj, dim) result(Ans) Get all the physical groups in the current model. If dim is >= 0, return\n only the entities of the specified dimension (e.g. physical points\n if dim == 0). The entities are returned as a vector of (dim, tag)\n integer pairs. Arguments Type Intent Optional Attributes Name class( gmshModel_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: dim Return Value integer(kind=I4B),\n  ALLOCATABLE, (:,:) private function model_getPhysicalGroupsForEntity (Obj, dim, tag) result(Ans) Get the tags of the physical groups (if any) to which the model entity of\n dimension dim and tag tag belongs. Arguments Type Intent Optional Attributes Name class( gmshModel_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: dim integer(kind=I4B), intent(in) :: tag Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) private function model_getPhysicalName (Obj, dim, tag) result(Ans) Arguments Type Intent Optional Attributes Name class( gmshModel_ ), intent(in) :: Obj integer(kind=I4B) :: dim integer(kind=I4B) :: tag Return Value type(String) private function model_setEntityName (Obj, dim, tag, name) result(Ans) Set the name of the entity of dimension dim and tag tag Arguments Type Intent Optional Attributes Name class( gmshModel_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: dim integer(kind=I4B), intent(in) :: tag character(len=*), intent(in) :: name Return Value integer(kind=I4B) private function model_setPhysicalName (Obj, dim, tag, name) result(Ans) Set the name of the physical group of dimension dim and tag tag. Arguments Type Intent Optional Attributes Name class( gmshModel_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: dim integer(kind=I4B), intent(in) :: tag character(len=*), intent(in) :: name Return Value integer(kind=I4B) private function model_write (Obj, UnitNo) result(Ans) Arguments Type Intent Optional Attributes Name class( gmshModel_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: UnitNo Return Value integer(kind=I4B)","tags":"","loc":"module/gmshmodel_class.html"},{"title":"SFCCModel_Class – Fortran Program","text":"This module consists of volumetric heat capacity model for porous media Uses GlobalData Contents Variables SOIL_COARSE_GRAINED SOIL_FINE_GRAINED SOIL_PEAT STATE_FROZEN STATE_UNFROZEN TypeExpSFCC TypeUserSFCC Interfaces ExpSFCC_PhaseInfo ExpSFCC_Pointer ExpSFCC_get_slope ExpSFCC_get_val UserSFCC_Pointer Derived Types ExpSFCC_ SFCCModelPointer_ SFCCModel_ UserSFCC_ Variables Type Visibility Attributes Name Initial integer(kind=I4B), private, parameter :: SOIL_COARSE_GRAINED = 200 integer(kind=I4B), private, parameter :: SOIL_FINE_GRAINED = 100 integer(kind=I4B), private, parameter :: SOIL_PEAT = 300 integer(kind=I4B), private, parameter :: STATE_FROZEN = 1 integer(kind=I4B), private, parameter :: STATE_UNFROZEN = 2 type( ExpSFCC_ ), public, parameter :: TypeExpSFCC = ExpSFCC_() type( UserSFCC_ ), public, parameter :: TypeUserSFCC = UserSFCC_() Interfaces interface private pure function ExpSFCC_PhaseInfo(Obj, Temp) result(Ans) Arguments Type Intent Optional Attributes Name class( SFCCModel_ ), intent(in) :: Obj real(kind=DFP), intent(in) :: Temp Return Value character(len=1) interface public function ExpSFCC_Pointer(Theta_r, Theta_w, Temp_l, Temp_s, Coeff) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Theta_r real(kind=DFP), intent(in) :: Theta_w real(kind=DFP), intent(in) :: Temp_l real(kind=DFP), intent(in) :: Temp_s real(kind=DFP), intent(in), optional :: Coeff Return Value class( ExpSFCC_ ),\n  POINTER interface private pure function ExpSFCC_get_slope(Obj, Temp) result(Ans) Arguments Type Intent Optional Attributes Name class( SFCCModel_ ), intent(in) :: Obj real(kind=DFP), intent(in) :: Temp Return Value real(kind=DFP) interface private pure function ExpSFCC_get_val(Obj, Temp) result(Ans) Arguments Type Intent Optional Attributes Name class( SFCCModel_ ), intent(in) :: Obj real(kind=DFP), intent(in) :: Temp Return Value real(kind=DFP) interface public function UserSFCC_Pointer() result(Ans) Arguments None Return Value class( UserSFCC_ ),\n  POINTER Derived Types type, public, EXTENDS( SFCCModel_ ) :: ExpSFCC_ Components Type Visibility Attributes Name Initial real(kind=DFP), public :: Coeff = 1.0_DFP exponent real(kind=DFP), public :: Temp_l = 0.0_DFP Freezing temp liquid side real(kind=DFP), public :: Temp_s = 0.0_DFP Freezing temp solid dide real(kind=DFP), public :: Theta_r = 0.0_DFP residual real(kind=DFP), public :: Theta_w = 0.0_DFP TotalWater content type, public :: SFCCModelPointer_ Components Type Visibility Attributes Name Initial class( SFCCModel_ ), public, POINTER :: Ptr => NULL() type, public, ABSTRACT :: SFCCModel_ Components Type Visibility Attributes Name Initial procedure( ExpSFCC_PhaseInfo ), public, POINTER, PASS( Obj ) :: PhaseInfo => NULL() procedure( ExpSFCC_get_slope ), public, POINTER, PASS( Obj ) :: getSlope => NULL() procedure( ExpSFCC_get_val ), public, POINTER, PASS( Obj ) :: getValue => NULL() type, public, EXTENDS( SFCCModel_ ) :: UserSFCC_","tags":"","loc":"module/sfccmodel_class.html"},{"title":"VolHeatCapModel_Class – Fortran Program","text":"This module consists of volumetric heat capacity model for porous media Uses GlobalData Contents Variables SOIL_COARSE_GRAINED SOIL_FINE_GRAINED SOIL_PEAT STATE_FROZEN STATE_UNFROZEN TypeUserVolHeatCap TypeVolHeatCap Interfaces MixVolHeatCap_Pointer UserVolHeatCap_Pointer mixvolheatcap_getval userVolHeatCap_getval Derived Types MixVolHeatCap_ UserVolHeatCap_ VolHeatCapModelPointer_ VolHeatCapModel_ Variables Type Visibility Attributes Name Initial integer(kind=I4B), private, parameter :: SOIL_COARSE_GRAINED = 200 integer(kind=I4B), private, parameter :: SOIL_FINE_GRAINED = 100 integer(kind=I4B), private, parameter :: SOIL_PEAT = 300 integer(kind=I4B), private, parameter :: STATE_FROZEN = 1 integer(kind=I4B), private, parameter :: STATE_UNFROZEN = 2 type( UserVolHeatCap_ ), public, parameter :: TypeUserVolHeatCap = UserVolHeatCap_() type( MixVolHeatCap_ ), public, parameter :: TypeVolHeatCap = MixVolHeatCap_() Interfaces interface public function MixVolHeatCap_Pointer(volHeatCap_solid, SoilState) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), optional :: volHeatCap_solid integer(kind=I4B), optional :: SoilState Return Value class( MixVolHeatCap_ ),\n  POINTER interface public function UserVolHeatCap_Pointer() result(Ans) Arguments None Return Value class( UserVolHeatCap_ ),\n  POINTER interface This function returns the volumetric heat capacity values private pure function mixvolheatcap_getval(Obj, volFrac_solid, volFrac_water, volFrac_ice, volFrac_air, Temp, x, y, z) result(Ans) Arguments Type Intent Optional Attributes Name class( VolHeatCapModel_ ), intent(in) :: Obj real(kind=DFP), intent(in), optional :: volFrac_solid real(kind=DFP), intent(in), optional :: volFrac_water real(kind=DFP), intent(in), optional :: volFrac_ice real(kind=DFP), intent(in), optional :: volFrac_air real(kind=DFP), intent(in), optional :: Temp real(kind=DFP), intent(in), optional :: x real(kind=DFP), intent(in), optional :: y real(kind=DFP), intent(in), optional :: z Return Value real(kind=DFP) interface This function returns the volumetric heat capacity values private pure function userVolHeatCap_getval(Obj, volFrac_solid, volFrac_water, volFrac_ice, volFrac_air, Temp, x, y, z) result(Ans) Arguments Type Intent Optional Attributes Name class( VolHeatCapModel_ ), intent(in) :: Obj real(kind=DFP), intent(in), optional :: volFrac_solid real(kind=DFP), intent(in), optional :: volFrac_water real(kind=DFP), intent(in), optional :: volFrac_ice real(kind=DFP), intent(in), optional :: volFrac_air real(kind=DFP), intent(in), optional :: Temp real(kind=DFP), intent(in), optional :: x real(kind=DFP), intent(in), optional :: y real(kind=DFP), intent(in), optional :: z Return Value real(kind=DFP) Derived Types type, public, EXTENDS( VolHeatCapModel_ ) :: MixVolHeatCap_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: Frozen = STATE_FROZEN integer(kind=I4B), public :: State = STATE_UNFROZEN integer(kind=I4B), public :: Unfrozen = STATE_UNFROZEN type, private, EXTENDS( volHeatCapModel_ ) :: UserVolHeatCap_ type, public :: VolHeatCapModelPointer_ Components Type Visibility Attributes Name Initial class( VolHeatCapModel_ ), public, POINTER :: Ptr => NULL() type, public, ABSTRACT :: VolHeatCapModel_ Components Type Visibility Attributes Name Initial real(kind=DFP), public :: ConstVolHeatCapVal = 0.0_DFP procedure( mixvolheatcap_getval ), public, POINTER, PASS( Obj ) :: getValue => NULL() logical(kind=LGT), public :: is_volHeatCap_solid_given = .FALSE. real(kind=DFP), public :: volHeatCap_solid = 2650.0_DFP*733.0_DFP","tags":"","loc":"module/volheatcapmodel_class.html"},{"title":"ThermCondModel_Class – Fortran Program","text":"This module consists of several thermal conductivity model for porous\n medium Uses GlobalData Contents Variables SOIL_COARSE_GRAINED SOIL_FINE_GRAINED SOIL_PEAT STATE_FROZEN STATE_UNFROZEN TypeJohansenThermCond TypeUserThermCond Interfaces JohansenThermCond_Pointer UserThermCond_Pointer UserThermCond_getval johansen_getval Derived Types JohansenThermCond_ ThermCondModelPointer_ ThermCondModel_ UserThermCond_ Variables Type Visibility Attributes Name Initial integer(kind=I4B), private, parameter :: SOIL_COARSE_GRAINED = 200 integer(kind=I4B), private, parameter :: SOIL_FINE_GRAINED = 100 integer(kind=I4B), private, parameter :: SOIL_PEAT = 300 integer(kind=I4B), private, parameter :: STATE_FROZEN = 1 integer(kind=I4B), private, parameter :: STATE_UNFROZEN = 2 type( JohansenThermCond_ ), public, parameter :: TypeJohansenThermCond = JohansenThermCond_() type( UserThermCond_ ), public, parameter :: TypeUserThermCond = UserThermCond_() Interfaces interface public function JohansenThermCond_Pointer(Lambda_Sat, Lambda_Dry, Lambda_e, Gamma_d, QuartzContent, SoilState, SoilType) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), optional :: Lambda_Sat real(kind=DFP), optional :: Lambda_Dry real(kind=DFP), optional :: Lambda_e real(kind=DFP), optional :: Gamma_d real(kind=DFP), optional :: QuartzContent integer(kind=I4B), optional :: SoilState integer(kind=I4B), optional :: SoilType Return Value class( JohansenThermCond_ ),\n  POINTER interface public function UserThermCond_Pointer() result(Ans) Arguments None Return Value class( UserThermCond_ ),\n  POINTER interface This function returns the thermal conductivity values private pure function UserThermCond_getval(Obj, volFrac_solid, volFrac_water, volFrac_ice, volFrac_air, Temp, x, y, z) result(Ans) This function returns the thermal conductivity values\n - volFrac contains volumetric fraction of solid, water, ice, air Arguments Type Intent Optional Attributes Name class( ThermCondModel_ ), intent(in) :: Obj real(kind=DFP), intent(in), optional :: volFrac_solid real(kind=DFP), intent(in), optional :: volFrac_water real(kind=DFP), intent(in), optional :: volFrac_ice real(kind=DFP), intent(in), optional :: volFrac_air real(kind=DFP), intent(in), optional :: Temp real(kind=DFP), intent(in), optional :: x real(kind=DFP), intent(in), optional :: y real(kind=DFP), intent(in), optional :: z Return Value real(kind=DFP) interface This function returns the thermal conductivity values private pure function johansen_getval(Obj, volFrac_solid, volFrac_water, volFrac_ice, volFrac_air, Temp, x, y, z) result(Ans) This function returns the thermal conductivity values\n - volFrac contains volumetric fraction of solid, water, ice, air Arguments Type Intent Optional Attributes Name class( ThermCondModel_ ), intent(in) :: Obj real(kind=DFP), intent(in), optional :: volFrac_solid real(kind=DFP), intent(in), optional :: volFrac_water real(kind=DFP), intent(in), optional :: volFrac_ice real(kind=DFP), intent(in), optional :: volFrac_air real(kind=DFP), intent(in), optional :: Temp real(kind=DFP), intent(in), optional :: x real(kind=DFP), intent(in), optional :: y real(kind=DFP), intent(in), optional :: z Return Value real(kind=DFP) Derived Types type, public, EXTENDS( ThermCondModel_ ) :: JohansenThermCond_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: CoarseGrained = SOIL_COARSE_GRAINED integer(kind=I4B), public :: FineGrained = SOIL_FINE_GRAINED integer(kind=I4B), public :: Frozen = STATE_FROZEN real(kind=DFP), public :: Gamma_d = 1600.0_DFP real(kind=DFP), public :: Lambda_Dry = 0.0_DFP real(kind=DFP), public :: Lambda_Sat = 0.0_DFP real(kind=DFP), public :: Lambda_e = 0.0_DFP real(kind=DFP), public :: Lambda_s = 0.0_DFP integer(kind=I4B), public :: Peat = SOIL_PEAT real(kind=DFP), public :: QuartzContent = 1.0_DFP integer(kind=I4B), public :: SoilType = SOIL_COARSE_GRAINED integer(kind=I4B), public :: State = STATE_UNFROZEN integer(kind=I4B), public :: Unfrozen = STATE_UNFROZEN logical, public :: isLambda_dry_given = .FALSE. logical, public :: isLambda_e_given = .FALSE. logical, public :: isLambda_sat_given = .FALSE. type, public :: ThermCondModelPointer_ Components Type Visibility Attributes Name Initial class( ThermCondModel_ ), public, POINTER :: Ptr => NULL() type, public, ABSTRACT :: ThermCondModel_ Components Type Visibility Attributes Name Initial real(kind=DFP), public :: ConstThermCondVal = 0.0_DFP procedure( johansen_getval ), public, POINTER, PASS( Obj ) :: getValue => NULL() type, public, EXTENDS( ThermCondModel_ ) :: UserThermCond_","tags":"","loc":"module/thermcondmodel_class.html"},{"title":"LinSolver_Class – Fortran Program","text":"This module defines an abstract class for a linear solver Uses GlobalData BaseType Contents Variables TypeLIS TypeSparsekit lis_bcg lis_bcgstab lis_bcgstabl lis_bicg lis_bicgsafe lis_bicgstab lis_bicgstabl lis_bicr lis_bicrsafe lis_bicrstab lis_cg lis_cgn lis_cgnr lis_cgs lis_cocg lis_cocr lis_cr lis_crs lis_dbcg lis_dqgmres lis_fgmres lis_fom lis_gmr lis_gmres lis_gpbicg lis_gpbicr lis_gs lis_idr1 lis_idrs lis_jacobi lis_minres lis_omn lis_orthomin lis_sor lis_tfqmr p_hybrid p_ilu0 p_iluc p_ilud p_iludp p_iluk p_ilut p_ilutp p_is p_jacobi p_none p_saamg p_sainv p_ssor Interfaces DeallocateData DeallocateData Display Display Initiate Initiate lis_deallocatedata lis_display lis_initiate lis_setDBC_1 lis_setDBC_2 lis_set_sparsity lis_setmatrix lis_setprecond lis_solve_1 lis_write_res_his skit_deallocatedata skit_display skit_initiate skit_setDBC_1 skit_setDBC_2 skit_set_sparsity skit_setmatrix skit_setprecond skit_solve skit_write_res_his Abstract Interfaces ls_deallocate ls_display ls_init ls_set_dbc_1 ls_set_dbc_2 ls_set_matrix ls_set_precon ls_set_sparsity ls_solve ls_w_res Derived Types LIS_ LinSolverPointer_ LinSolver_ LisPointer_ SparsekitPointer_ Sparsekit_ Variables Type Visibility Attributes Name Initial type( LIS_ ), public, parameter :: TypeLIS = LIS_(A=NULL(), IA=NULL(), JA=NULL(), dbcNptrs=NULL(), dbcIndx=NULL(), dbcJA=NULL(), dbcIA=NULL()) type( Sparsekit_ ), public, parameter :: TypeSparsekit = Sparsekit_(dbcNptrs=NULL(), dbcIndx=NULL(), dbcJA=NULL(), dbcIA=NULL(), JLU=null(), JU=null(), IPERM=null(), JW=NULL(), ALU=null(), WK=null(), W=null(), RES=null()) integer(kind=I4B), public, parameter :: lis_bcg = 2 integer(kind=I4B), public, parameter :: lis_bcgstab = 4 integer(kind=I4B), public, parameter :: lis_bcgstabl = 5 integer(kind=I4B), public, parameter :: lis_bicg = 2 integer(kind=I4B), public, parameter :: lis_bicgsafe = 13 integer(kind=I4B), public, parameter :: lis_bicgstab = 4 integer(kind=I4B), public, parameter :: lis_bicgstabl = 5 integer(kind=I4B), public, parameter :: lis_bicr = 15 integer(kind=I4B), public, parameter :: lis_bicrsafe = 19 integer(kind=I4B), public, parameter :: lis_bicrstab = 17 integer(kind=I4B), public, parameter :: lis_cg = 1 integer(kind=I4B), public, parameter :: lis_cgn = 26 integer(kind=I4B), public, parameter :: lis_cgnr = 26 integer(kind=I4B), public, parameter :: lis_cgs = 3 integer(kind=I4B), public, parameter :: lis_cocg = 24 integer(kind=I4B), public, parameter :: lis_cocr = 25 integer(kind=I4B), public, parameter :: lis_cr = 14 integer(kind=I4B), public, parameter :: lis_crs = 16 integer(kind=I4B), public, parameter :: lis_dbcg = 27 integer(kind=I4B), public, parameter :: lis_dqgmres = 28 integer(kind=I4B), public, parameter :: lis_fgmres = 20 integer(kind=I4B), public, parameter :: lis_fom = 8 integer(kind=I4B), public, parameter :: lis_gmr = 9 integer(kind=I4B), public, parameter :: lis_gmres = 9 integer(kind=I4B), public, parameter :: lis_gpbicg = 6 integer(kind=I4B), public, parameter :: lis_gpbicr = 18 integer(kind=I4B), public, parameter :: lis_gs = 11 integer(kind=I4B), public, parameter :: lis_idr1 = 22 integer(kind=I4B), public, parameter :: lis_idrs = 21 integer(kind=I4B), public, parameter :: lis_jacobi = 10 integer(kind=I4B), public, parameter :: lis_minres = 23 integer(kind=I4B), public, parameter :: lis_omn = 8 integer(kind=I4B), public, parameter :: lis_orthomin = 8 integer(kind=I4B), public, parameter :: lis_sor = 12 integer(kind=I4B), public, parameter :: lis_tfqmr = 7 integer(kind=I4B), public, parameter :: p_hybrid = 4 integer(kind=I4B), public, parameter :: p_ilu0 = 13 integer(kind=I4B), public, parameter :: p_iluc = 8 integer(kind=I4B), public, parameter :: p_ilud = 11 integer(kind=I4B), public, parameter :: p_iludp = 12 integer(kind=I4B), public, parameter :: p_iluk = 2 integer(kind=I4B), public, parameter :: p_ilut = 9 integer(kind=I4B), public, parameter :: p_ilutp = 10 integer(kind=I4B), public, parameter :: p_is = 5 integer(kind=I4B), public, parameter :: p_jacobi = 1 integer(kind=I4B), public, parameter :: p_none = 0 integer(kind=I4B), public, parameter :: p_saamg = 7 integer(kind=I4B), public, parameter :: p_sainv = 6 integer(kind=I4B), public, parameter :: p_ssor = 3 Interfaces public interface DeallocateData private interface skit_deallocatedata () Arguments None private interface DeallocateData private interface lis_deallocatedata () Arguments None public interface Display private interface skit_display () Arguments None private interface Display private interface lis_display () Arguments None public interface Initiate Generic subroutine to initiate Sparsekit_ private interface skit_initiate () Initiate Sparsekit_ Arguments None private interface Initiate private interface lis_initiate () — fpar( 1 ) : contains value of omega Arguments None interface private subroutine lis_deallocatedata(Obj) Arguments Type Intent Optional Attributes Name class( LIS_ ), intent(inout) :: Obj interface private subroutine lis_display(Obj, msg, unitno) Arguments Type Intent Optional Attributes Name class( LIS_ ), intent(in) :: Obj character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitno interface — fpar( 1 ) : contains value of omega private subroutine lis_initiate(Obj, SolverName, MaxIter, Tol, diagScale, ipar, fpar) Arguments Type Intent Optional Attributes Name class( LIS_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: SolverName integer(kind=I4B), intent(in) :: MaxIter real(kind=DFP), intent(in) :: Tol integer(kind=I4B), intent(in), optional :: diagScale integer(kind=I4B), intent(in), optional :: ipar (:) real(kind=DFP), intent(in), optional :: fpar (:) interface private subroutine lis_setDBC_1(Obj, Nptrs, dofs) Arguments Type Intent Optional Attributes Name class( LIS_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Nptrs (:) integer(kind=I4B), intent(in) :: dofs (:) interface private subroutine lis_setDBC_2(Obj, Nptrs, dofs) Arguments Type Intent Optional Attributes Name class( LIS_ ), intent(inout) :: Obj type(IntVector_), intent(in) :: Nptrs (:) integer(kind=I4B), intent(in) :: dofs (:) interface — set all values of lis_rhs and lis_sol to zero\n— set csr private subroutine lis_set_sparsity(From, To) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(in), TARGET :: From class( LIS_ ), intent(inout) :: To interface private subroutine lis_setmatrix(From, To) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(in), TARGET :: From class( LIS_ ), intent(inout) :: To interface private subroutine lis_setprecond(Obj, precondtype, ipar, fpar) Arguments Type Intent Optional Attributes Name class( LIS_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: precondtype integer(kind=I4B), intent(in), optional :: ipar (:) real(kind=DFP), intent(in), optional :: fpar (:) interface private subroutine lis_solve_1(Obj, sol, rhs) Arguments Type Intent Optional Attributes Name class( LIS_ ), intent(inout) :: Obj real(kind=DFP), intent(inout) :: sol (:) real(kind=DFP), intent(inout) :: rhs (:) interface private subroutine lis_write_res_his(Obj, path, prefix, fmt, iter) Arguments Type Intent Optional Attributes Name class( LIS_ ), intent(in) :: Obj character(len=*), intent(in) :: path character(len=*), intent(in) :: prefix character(len=*), intent(in) :: fmt integer(kind=I4B), intent(in), optional :: iter interface private subroutine skit_deallocatedata(Obj) Arguments Type Intent Optional Attributes Name class( Sparsekit_ ), intent(inout) :: Obj interface private subroutine skit_display(Obj, msg, Unitno) Arguments Type Intent Optional Attributes Name class( Sparsekit_ ), intent(in) :: Obj character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: Unitno interface Initiate Sparsekit_ private subroutine skit_initiate(Obj, SolverName, MaxIter, Tol, diagScale, ipar, fpar) This subroutine initiate the Sparsekit_ object Read more… Arguments Type Intent Optional Attributes Name class( Sparsekit_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: SolverName integer(kind=I4B), intent(in) :: MaxIter real(kind=DFP), intent(in) :: Tol integer(kind=I4B), intent(in), optional :: diagScale integer(kind=I4B), intent(in), optional :: ipar (:) real(kind=DFP), intent(in), optional :: fpar (:) interface set Dirichlet boundary condition information private subroutine skit_setDBC_1(Obj, Nptrs, dofs) This subroutine set the Dirichlet boundary condition in the linear solver\n In this case all DOFs have the same dirichlet nodes pointers Nptrs denotes the dirichlet node numbers storageFMT can be DOF_FMT or Nodes_FMT Arguments Type Intent Optional Attributes Name class( Sparsekit_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Nptrs (:) integer(kind=I4B), intent(in) :: dofs (:) interface set Dirichlet boundary condition information private subroutine skit_setDBC_2(Obj, Nptrs, dofs) Arguments Type Intent Optional Attributes Name class( Sparsekit_ ), intent(inout) :: Obj type(IntVector_), intent(in) :: Nptrs (:) integer(kind=I4B), intent(in) :: dofs (:) interface Set sparsity pattern in Sparsekit_ private subroutine skit_set_sparsity(From, To) This subroutine set the sparsity pattern in Sparsekit_ Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(in), TARGET :: From class( Sparsekit_ ), intent(inout) :: To interface set Matrix private subroutine skit_setmatrix(From, To) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(in), TARGET :: From class( Sparsekit_ ), intent(inout) :: To interface Set preconditioners in Sparsekit_ private subroutine skit_setprecond(Obj, precondtype, ipar, fpar) This subroutine set the preconditioner required to solve system of\n linear equations by using the Read more… Arguments Type Intent Optional Attributes Name class( Sparsekit_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: precondtype integer(kind=I4B), intent(in), optional :: ipar (:) real(kind=DFP), intent(in), optional :: fpar (:) interface private subroutine skit_solve(Obj, sol, rhs) Arguments Type Intent Optional Attributes Name class( Sparsekit_ ), intent(inout) :: Obj real(kind=DFP), intent(inout) :: sol (:) real(kind=DFP), intent(inout) :: rhs (:) interface private subroutine skit_write_res_his(Obj, path, prefix, fmt, iter) Arguments Type Intent Optional Attributes Name class( Sparsekit_ ), intent(in) :: Obj character(len=*), intent(in) :: path character(len=*), intent(in) :: prefix character(len=*), intent(in) :: fmt integer(kind=I4B), intent(in), optional :: iter Abstract Interfaces abstract interface private subroutine ls_deallocate(Obj) Arguments Type Intent Optional Attributes Name class( LinSolver_ ), intent(inout) :: Obj abstract interface private subroutine ls_display(Obj, msg, Unitno) Arguments Type Intent Optional Attributes Name class( LinSolver_ ), intent(in) :: Obj character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: Unitno abstract interface private subroutine ls_init(Obj, SolverName, MaxIter, Tol, diagScale, ipar, fpar) Arguments Type Intent Optional Attributes Name class( LinSolver_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: SolverName integer(kind=I4B), intent(in) :: MaxIter real(kind=DFP), intent(in) :: Tol integer(kind=I4B), intent(in), optional :: diagScale integer(kind=I4B), intent(in), optional :: ipar (:) real(kind=DFP), intent(in), optional :: fpar (:) abstract interface private subroutine ls_set_dbc_1(Obj, Nptrs, dofs) Arguments Type Intent Optional Attributes Name class( LinSolver_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Nptrs (:) integer(kind=I4B), intent(in) :: dofs (:) abstract interface private subroutine ls_set_dbc_2(Obj, Nptrs, dofs) Arguments Type Intent Optional Attributes Name class( LinSolver_ ), intent(inout) :: Obj type(IntVector_), intent(in) :: Nptrs (:) integer(kind=I4B), intent(in) :: dofs (:) abstract interface private subroutine ls_set_matrix(From, To) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(in), TARGET :: From class( LinSolver_ ), intent(inout) :: To abstract interface private subroutine ls_set_precon(Obj, precondtype, ipar, fpar) Arguments Type Intent Optional Attributes Name class( LinSolver_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: precondtype integer(kind=I4B), intent(in), optional :: ipar (:) real(kind=DFP), intent(in), optional :: fpar (:) abstract interface private subroutine ls_set_sparsity(From, To) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(in), TARGET :: From class( LinSolver_ ), intent(inout) :: To abstract interface private subroutine ls_solve(Obj, sol, rhs) Arguments Type Intent Optional Attributes Name class( LinSolver_ ), intent(inout) :: Obj real(kind=DFP), intent(inout) :: sol (:) real(kind=DFP), intent(inout) :: rhs (:) abstract interface private subroutine ls_w_res(Obj, path, prefix, fmt, iter) Arguments Type Intent Optional Attributes Name class( LinSolver_ ), intent(in) :: Obj character(len=*), intent(in) :: path character(len=*), intent(in) :: prefix character(len=*), intent(in) :: fmt integer(kind=I4B), intent(in), optional :: iter Derived Types type, public, EXTENDS( LinSolver_ ) :: LIS_ Components Type Visibility Attributes Name Initial real(kind=DFP), public, ALLOCATABLE :: A (:) integer(kind=I4B), public, ALLOCATABLE :: IA (:) integer(kind=I4B), public, ALLOCATABLE :: JA (:) integer(kind=I4B), public, ALLOCATABLE :: dbcIA (:) integer(kind=I4B), public, ALLOCATABLE :: dbcIndx (:) integer(kind=I4B), public, ALLOCATABLE :: dbcJA (:) integer(kind=I4B), public, ALLOCATABLE :: dbcNptrs (:) type(integer), public :: lis_mat = 0 type(integer), public :: lis_precon = 0 type(integer), public :: lis_res = 0 type(integer), public :: lis_rhs = 0 type(integer), public :: lis_sol = 0 type(integer), public :: lis_solver = 0 Type-Bound Procedures procedure, public, PASS( Obj ) :: DeallocateData => lis_deallocatedata Deallocate Data procedure, public, PASS( Obj ) :: Display => lis_display Display the contents procedure, public, PASS( Obj ) :: Initiate => lis_initiate Initiate object procedure, public, PASS( Obj ) :: Solve => lis_solve_1 Solve the system of linear equation procedure, public, PASS( To ) :: setMatrix => lis_setmatrix set/link tangent matrix to the linear solver engine procedure, public, PASS( Obj ) :: setPrecondition => lis_setprecond Set preconditioner properties procedure, public, PASS( To ) :: setSparsity => lis_set_sparsity Set sparsity pattern related information of tangent matrix procedure, public, PASS( Obj ) :: set_dbcNodes_1 => lis_setDBC_1 set Information about the Dirichlet boundary nodes procedure, public, PASS( Obj ) :: set_dbcNodes_2 => lis_setDBC_2 set Information about the Dirichlet boundary nodes procedure, public, PASS( Obj ) :: writeResidueHistory => lis_write_res_his Output the residue history type, private :: LinSolverPointer_ This data type contains pointer to LinSolver_ Components Type Visibility Attributes Name Initial class( LinSolver_ ), public, POINTER :: Ptr => NULL() type, public, ABSTRACT :: LinSolver_ LinSolver_ is an abstract class for solving system of linear equation Read more… Components Type Visibility Attributes Name Initial character(len=5), public :: Matrixprop = \"UNSYM\" Matrix Property integer(kind=I4B), public :: comm = 0 MPI COMM integer(kind=I4B), public :: ierr = 0 error code returned by the solver integer(kind=I4B), public :: myRank = 0 MPI Rank integer(kind=I4B), public :: numproc = 0 Number of processor running integer(kind=I4B), public :: precondType = 0 Name of preconditioner integer(kind=I4B), public :: solverName = 0 Solver name integer(kind=I4B), public :: storageFMT = Nodes_FMT storageFMT integer(kind=I4B), public, ALLOCATABLE :: tNodes (:) Total number of spatial nodes in each dof integer(kind=I4B), public :: tdof = 1 Total number of degrees of freedom per node Type-Bound Procedures procedure(ls_deallocate), public, PASS( Obj ) :: DeallocateData Deallocate Data procedure(ls_display), public, PASS( Obj ) :: Display Display the content procedure(ls_init), public, PASS( Obj ) :: Initiate Initiate the object procedure(ls_solve), public, PASS( Obj ) :: Solve Solve system of linear equation generic, public :: setDirichletBCNodes => set_dbcNodes_1, set_dbcNodes_2 Set Dirichlet boundary condition information procedure(ls_set_matrix), public, PASS( To ) :: setMatrix Set the matrix procedure(ls_set_precon), public, PASS( Obj ) :: setPrecondition Set preconditioner and its properties procedure(ls_set_sparsity), public, PASS( To ) :: setSparsity Set sparsity pattern procedure(ls_set_dbc_1), public, PASS( Obj ) :: set_dbcNodes_1 Set Dirichlet boundary condition information procedure(ls_set_dbc_2), public, PASS( Obj ) :: set_dbcNodes_2 Set Dirichlet boundary condition information procedure(ls_w_res), public, PASS( Obj ) :: writeResidueHistory Write the residue history to a file type, public :: LisPointer_ Components Type Visibility Attributes Name Initial class( LIS_ ), public, POINTER :: Ptr => NULL() type, public :: SparsekitPointer_ Components Type Visibility Attributes Name Initial class( Sparsekit_ ), public, POINTER :: Ptr => NULL() type, public, EXTENDS( LinSolver_ ) :: Sparsekit_ Sparsekit_ data type is a container around Yusef Saad’s SparseKit\n lib. Read more… Components Type Visibility Attributes Name Initial real(kind=DFP), public, POINTER :: A (:) => NULL() CSR format real(kind=DFP), public, ALLOCATABLE :: ALU (:) integer(kind=I4B), public, POINTER :: IA (:) => NULL() CSR format integer(kind=I4B), public, ALLOCATABLE :: IPERM (:) Internal var integer(kind=I4B), public, POINTER :: JA (:) => NULL() CSR format integer(kind=I4B), public, ALLOCATABLE :: JLU (:) Internal var integer(kind=I4B), public, ALLOCATABLE :: JU (:) Internal var integer(kind=I4B), public, ALLOCATABLE :: JW (:) Internal var real(kind=DFP), public, ALLOCATABLE :: RES (:) real(kind=DFP), public, ALLOCATABLE :: W (:) real(kind=DFP), public, ALLOCATABLE :: WK (:) real(kind=DFP), public :: alpha = 0.0 integer(kind=I4B), public, ALLOCATABLE :: dbcIA (:) integer(kind=I4B), public, ALLOCATABLE :: dbcIndx (:) integer(kind=I4B), public, ALLOCATABLE :: dbcJA (:) integer(kind=I4B), public, ALLOCATABLE :: dbcNptrs (:) Ids of nodal variables where Dirichlet boundary condition is imposed real(kind=DFP), public :: droptol = 0.0 real(kind=DFP), public :: fpar (14) = 0.0_DFP integer(kind=I4B), public :: ipar (14) = 0 integer(kind=I4B), public :: lfil = 0 integer(kind=I4B), public :: mbloc = 0 real(kind=DFP), public :: permtol = 0.0 Type-Bound Procedures procedure, public, PASS( Obj ) :: DeallocateData => skit_deallocatedata DeallocateData procedure, public, PASS( Obj ) :: Display => skit_display Display the contents procedure, public, PASS( Obj ) :: Initiate => skit_initiate Initiate object procedure, public, PASS( Obj ) :: Solve => skit_solve Solve the system of linear equation procedure, public, PASS( To ) :: setMatrix => skit_setmatrix set/link tangent matrix to the linear solver engine procedure, public, PASS( Obj ) :: setPrecondition => skit_setprecond Set preconditioner properties procedure, public, PASS( To ) :: setSparsity => skit_set_sparsity Set sparsity pattern related information of tangent matrix procedure, public, PASS( Obj ) :: set_dbcNodes_1 => skit_setDBC_1 set Information about the Dirichlet boundary nodes procedure, public, PASS( Obj ) :: set_dbcNodes_2 => skit_setDBC_2 set Information about the Dirichlet boundary nodes procedure, public, PASS( Obj ) :: writeResidueHistory => skit_write_res_his Output the residue history","tags":"","loc":"module/linsolver_class.html"},{"title":"Material_Class – Fortran Program","text":"State of soil option Uses GlobalData ThermCondModel_Class VolHeatCapModel_Class SFCCModel_Class Contents Variables Constant_ThermCond Exp_SFCC Johansen_ThermCond MAX_CHAR_LEN MAX_NUM_MINERALS MINERAL_QUARTZ Mineral_Name SFCCModel_Name SOIL_COARSE_GRAINED SOIL_FINE_GRAINED SOIL_PEAT STATE_FROZEN STATE_UNFROZEN SoilType_Name State_Name ThermCondModel_Name TypeMaterial TypeSoil User_SFCC User_ThermCond constant_volHeatCap mix_volHeatCap user_volHeatCap volHeatCapModel_Name Interfaces Display Soil Soil_Constructor soil_display Abstract Interfaces sfcc_get_value thermcond_get_value volHeatCap_get_value Derived Types Material_ MatetrialPointer_ Soil_ Variables Type Visibility Attributes Name Initial integer(kind=I4B), private, parameter :: Constant_ThermCond = 1 integer(kind=I4B), private, parameter :: Exp_SFCC = 2 integer(kind=I4B), private, parameter :: Johansen_ThermCond = 3 integer(kind=I4B), private, parameter :: MAX_CHAR_LEN = 50 integer(kind=I4B), private, parameter :: MAX_NUM_MINERALS = 20 integer(kind=I4B), private, parameter :: MINERAL_QUARTZ = 1 character(len=MAX_CHAR_LEN), private, parameter :: Mineral_Name (1) = [\"Quartz\"] ThermCondModel character(len=MAX_CHAR_LEN), private, parameter :: SFCCModel_Name (2) = [\"User Defined\", \"Exp         \"] integer(kind=I4B), private, parameter :: SOIL_COARSE_GRAINED = 2 integer(kind=I4B), private, parameter :: SOIL_FINE_GRAINED = 1 integer(kind=I4B), private, parameter :: SOIL_PEAT = 300 integer(kind=I4B), private, parameter :: STATE_FROZEN = 1 integer(kind=I4B), private, parameter :: STATE_UNFROZEN = 2 character(len=MAX_CHAR_LEN), private, parameter :: SoilType_Name (3) = [\"Fine Grained  \", \"Coarse Grained\", \"Peat          \"] Soil minerals character(len=MAX_CHAR_LEN), private, parameter :: State_Name (2) = [\"Frozen  \", \"Unfrozen\"] Soil Type options character(len=MAX_CHAR_LEN), private, parameter :: ThermCondModel_Name (3) = [\"Constant    \", \"User Defined\", \"Johansen    \"] volumetric heat capacity type( Material_ ), public, parameter :: TypeMaterial = Material_() type( Soil_ ), public, parameter :: TypeSoil = Soil_() integer(kind=I4B), private, parameter :: User_SFCC = 1 integer(kind=I4B), private, parameter :: User_ThermCond = 2 integer(kind=I4B), private, parameter :: constant_volHeatCap = 1 integer(kind=I4B), private, parameter :: mix_volHeatCap = 3 integer(kind=I4B), private, parameter :: user_volHeatCap = 2 character(len=MAX_CHAR_LEN), private, parameter :: volHeatCapModel_Name (3) = [\"Constant    \", \"User Defined\", \"Mixture     \"] SFCC Interfaces public interface Display private interface soil_display () Arguments None public interface Soil private interface Soil_Constructor () Arguments None interface private function Soil_Constructor(State, SoilType, Gravel, Sand, Silt, Clay, OrganicMatter, SpecificGravity, DryDensity, Gravimetric_Moisture, Porosity, voidRatio, volFrac_solid, volFrac_water, volFrac_ice, volFrac_air, Minerals, Lambda_sat, Lambda_dry, Lambda_e, ThermCondModel, ThermCondVal, UserThermCond, volHeatCap_solid, volHeatCapModel, volHeatCapVal, UservolHeatCap, SFCCModel, UserSFCC_Value, UserSFCC_Slope, SFCC_Theta_r, SFCC_Temp_l, SFCC_Temp_s, SFCC_Coeff) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), optional :: State integer(kind=I4B), intent(in), optional :: SoilType real(kind=DFP), intent(in), optional :: Gravel real(kind=DFP), intent(in), optional :: Sand real(kind=DFP), intent(in), optional :: Silt real(kind=DFP), intent(in), optional :: Clay real(kind=DFP), intent(in), optional :: OrganicMatter real(kind=DFP), intent(in), optional :: SpecificGravity real(kind=DFP), intent(in), optional :: DryDensity real(kind=DFP), intent(in), optional :: Gravimetric_Moisture real(kind=DFP), intent(in), optional :: Porosity real(kind=DFP), intent(in), optional :: voidRatio real(kind=DFP), intent(in), optional :: volFrac_solid real(kind=DFP), intent(in), optional :: volFrac_water real(kind=DFP), intent(in), optional :: volFrac_ice real(kind=DFP), intent(in), optional :: volFrac_air real(kind=DFP), intent(in), optional :: Minerals (:) real(kind=DFP), intent(in), optional :: Lambda_sat real(kind=DFP), intent(in), optional :: Lambda_dry real(kind=DFP), intent(in), optional :: Lambda_e integer(kind=I4B), intent(in), optional :: ThermCondModel real(kind=DFP), intent(in), optional :: ThermCondVal procedure( thermcond_get_value ), intent(in), optional POINTER :: UserThermCond real(kind=DFP), intent(in), optional :: volHeatCap_solid integer(kind=I4B), intent(in), optional :: volHeatCapModel real(kind=DFP), intent(in), optional :: volHeatCapVal procedure( volHeatCap_get_value ), intent(in), optional POINTER :: UservolHeatCap integer(kind=I4B), intent(in), optional :: SFCCModel procedure( sfcc_get_value ), intent(in), optional POINTER :: UserSFCC_Value procedure( sfcc_get_value ), intent(in), optional POINTER :: UserSFCC_Slope real(kind=DFP), intent(in), optional :: SFCC_Theta_r real(kind=DFP), intent(in), optional :: SFCC_Temp_l real(kind=DFP), intent(in), optional :: SFCC_Temp_s real(kind=DFP), intent(in), optional :: SFCC_Coeff Return Value type( Soil_ ) interface private subroutine soil_display(Obj, msg, unitNo) Arguments Type Intent Optional Attributes Name class( Soil_ ), intent(in) :: Obj character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitNo Abstract Interfaces abstract interface private pure function sfcc_get_value(Obj, Temp) result(Ans) Arguments Type Intent Optional Attributes Name class(SFCCModel_), intent(in) :: Obj real(kind=DFP), intent(in) :: Temp Return Value real(kind=DFP) abstract interface private pure function thermcond_get_value(Obj, volFrac_solid, volFrac_water, volFrac_ice, volFrac_air, Temp, x, y, z) result(Ans) Arguments Type Intent Optional Attributes Name class(ThermCondModel_), intent(in) :: Obj real(kind=DFP), intent(in), optional :: volFrac_solid real(kind=DFP), intent(in), optional :: volFrac_water real(kind=DFP), intent(in), optional :: volFrac_ice real(kind=DFP), intent(in), optional :: volFrac_air real(kind=DFP), intent(in), optional :: Temp real(kind=DFP), intent(in), optional :: x real(kind=DFP), intent(in), optional :: y real(kind=DFP), intent(in), optional :: z Return Value real(kind=DFP) abstract interface private pure function volHeatCap_get_value(Obj, volFrac_solid, volFrac_water, volFrac_ice, volFrac_air, Temp, x, y, z) result(Ans) Arguments Type Intent Optional Attributes Name class(volHeatCapModel_), intent(in) :: Obj real(kind=DFP), intent(in), optional :: volFrac_solid real(kind=DFP), intent(in), optional :: volFrac_water real(kind=DFP), intent(in), optional :: volFrac_ice real(kind=DFP), intent(in), optional :: volFrac_air real(kind=DFP), intent(in), optional :: Temp real(kind=DFP), intent(in), optional :: x real(kind=DFP), intent(in), optional :: y real(kind=DFP), intent(in), optional :: z Return Value real(kind=DFP) Derived Types type, public :: Material_ Material_ type contains materials properties Components Type Visibility Attributes Name Initial real(kind=DFP), public :: DynamicViscosity = 0.0_DFP real(kind=DFP), public :: boilTemp = 0.0_DFP real(kind=DFP), public :: bulkModulus = 0.0_DFP real(kind=DFP), public :: criticalPressure = 0.0_DFP real(kind=DFP), public :: criticalTemp = 0.0_DFP real(kind=DFP), public :: density = 0.0_DFP real(kind=DFP), public :: latentHeatBoil = 0.0_DFP real(kind=DFP), public :: latentHeatMelt = 0.0_DFP real(kind=DFP), public :: meltTemp = 0.0_DFP real(kind=DFP), public :: specificHeatCap = 0.0_DFP real(kind=DFP), public :: thermCond = 0.0_DFP real(kind=DFP), public :: thermDiffusivity = 0.0_DFP real(kind=DFP), public :: triplePointPressure = 0.0_DFP real(kind=DFP), public :: triplePointTemp = 0.0_DFP real(kind=DFP), public :: volHeatCap = 0.0_DFP real(kind=DFP), public :: volThermCoeff = 0.0_DFP type, public :: MatetrialPointer_ Components Type Visibility Attributes Name Initial class( Material_ ), public, POINTER :: Ptr => NULL() type, public, EXTENDS( Material_ ) :: Soil_ soil state; frozen and unfrozen Components Type Visibility Attributes Name Initial real(kind=DFP), public :: Clay = 0.0_DFP integer(kind=I4B), public :: CoarseGrained = SOIL_COARSE_GRAINED integer(kind=I4B), public :: ConstantThermCond = Constant_ThermCond integer(kind=I4B), public :: ConstantVolHeatCap = Constant_volHeatCap real(kind=DFP), public :: DryDensity = 0.0_DFP integer(kind=I4B), public :: ExpSFCC = Exp_SFCC integer(kind=I4B), public :: FineGrained = SOIL_FINE_GRAINED integer(kind=I4B), public :: Frozen = STATE_FROZEN real(kind=DFP), public :: Gravel = 0.0_DFP real(kind=DFP), public :: Gravimetric_Moisture = 0.0_DFP integer(kind=I4B), public :: JohansenThermCond = Johansen_ThermCond real(kind=DFP), public :: Minerals (MAX_NUM_MINERALS) = 0.0_DFP real(kind=DFP), public :: OrganicMatter = 0.0_DFP index properties integer(kind=I4B), public :: Peat = SOIL_PEAT grain size distribution real(kind=DFP), public :: Porosity = 0.0_DFP integer(kind=I4B), public :: Quartz = Mineral_Quartz thermal conductivity model class(SFCCModel_), public, POINTER :: SFCCModel => NULL() Consolidation characteristics\n Hydraulic characteristics\n Undrained characteristics\n Drained characteristics integer(kind=I4B), public :: SFCC_Model = Exp_SFCC real(kind=DFP), public :: Sand = 0.0_DFP real(kind=DFP), public :: Silt = 0.0_DFP integer(kind=I4B), public :: SoilType = SOIL_COARSE_GRAINED real(kind=DFP), public :: SpecificGravity = 0.0_DFP integer(kind=I4B), public :: State = STATE_UNFROZEN soil type; fine-grained, coarse-grained, peat integer(kind=I4B), public :: ThermCond_Model = Constant_ThermCond integer(kind=I4B), public :: Unfrozen = STATE_UNFROZEN integer(kind=I4B), public :: UserSFCC = User_SFCC integer(kind=I4B), public :: UserThermCond = User_ThermCond integer(kind=I4B), public :: UserVolHeatCap = User_volHeatCap integer(kind=I4B), public :: mixVolHeatCap = Mix_VolHeatCap class(ThermCondModel_), public, POINTER :: thermCondModel => NULL() volumetric heat capacity model real(kind=DFP), public :: voidRatio = 0.0_DFP real(kind=DFP), public :: volFrac_air = 0.0_DFP mineral composition real(kind=DFP), public :: volFrac_ice = 0.0_DFP real(kind=DFP), public :: volFrac_solid = 0.0_DFP real(kind=DFP), public :: volFrac_water = 0.0_DFP class(volHeatCapModel_), public, POINTER :: volHeatCapModel => NULL() volumetric heat capacity model integer(kind=I4B), public :: volHeatCap_Model = Constant_volHeatCap","tags":"","loc":"module/material_class~2.html"},{"title":"StdMaterials – Fortran Program","text":"These properties are taken from following references\n https://www.engineeringtoolbox.com/water-liquid-gas-thermal-conductivity-temperature-pressure-d_2012.html\n http://thermopedia.com/content/1254/ Uses GlobalData Material_Class Contents Variables Air Ice Quartz Water Functions SpecificHeatCap_Air SpecificHeatCap_Quartz ThermCond_Air ThermCond_Quartz density_ice density_water density_water_Temp_Pressure density_water_pressure density_water_temp specificHeatCap_ice specificHeatCap_water specificHeatCap_water_Temp specificHeatCap_water_Temp_Pressure specificHeatCap_water_pressure thermCond_ice thermCond_water thermCond_water_Temp thermCond_water_Temp_Pressure thermCond_water_pressure volHeatCap_Air volHeatCap_Quartz volHeatCap_ice volHeatCap_water Variables Type Visibility Attributes Name Initial type(Material_), public, parameter :: Air = Material_(thermCond=0.02514, specificHeatCap=1007.0_DFP, density=1.204_DFP, volHeatCap=1000.0_DFP*1.177_DFP, thermDiffusivity=2.074E-5, DynamicViscosity=1.825E-5) W/m/K at 20 degree C\n J/Kg/K at 20 degree C\n kg/m3 at 20 degree C\n J/m3/K at 20 degree C\n m2/sec at 20 degree C type(Material_), public, parameter :: Ice = Material_(thermCond=2.30_DFP, specificHeatCap=2000.0_DFP, density=918.9_DFP, volHeatCap=2000.0_DFP*918.9_DFP, thermDiffusivity=2.30_DFP/2000.0_DFP/918.9_DFP, latentHeatMelt=334000.0_DFP, meltTemp=273.15_DFP) W/m/K at -10 degree C\n J/Kg/K at -10 degree C\n kg/m3 at -10 degree C\n J/m3/K at -10 degree C\n m2/sec at -10 degree C\n J/Kg type(Material_), public, parameter :: Quartz = Material_(thermCond=8.8_DFP, specificHeatCap=733.0_DFP, density=2650.0_DFP, volHeatCap=2650.0_DFP*733.0_DFP, thermDiffusivity=8.8_DFP/733.0_DFP/2650.0_DFP) W/m/K at 20 degree C\n J/Kg/K at 20 degree C\n kg/m3 at 20 degree C\n J/m3/K at 20 degree C\n m2/sec at 20 degree C type(Material_), public, parameter :: Water = Material_(thermCond=0.59803_DFP, specificHeatCap=4184.4_DFP, volHeatCap=4184.4_DFP*998.207_DFP, thermDiffusivity=0.143D-6, density=999.975_DFP, DynamicViscosity=0.0010016_DFP, latentHeatMelt=334000.0_DFP, latentHeatBoil=2256.0D+3, meltTemp=273.15_DFP, boilTemp=373.15_DFP, criticalTemp=273.15_DFP+373.946_DFP, criticalPressure=22.06D+6, triplePointPressure=611.657_DFP, triplePointTemp=273.16_DFP, bulkModulus=2.15D+9) W/m/K at 20 degree C\n https://www.engineeringtoolbox.com/water-liquid-gas-thermal-conductivity-temperature-pressure-d_2012.html\n J/m3/K at 20 degree C\n https://www.engineeringtoolbox.com/specific-heat-capacity-water-d_660.html\n m2/sec at 20 degree C\n https://www.engineeringtoolbox.com/water-steam-thermal-diffusivity-d_2058.html\n kg/m3 at 4 degree C\n https://www.engineeringtoolbox.com/water-temperature-specific-gravity-d_1179.html\n N-s/m2 at 20 degree C\n https://www.engineeringtoolbox.com/water-dynamic-kinematic-viscosity-d_596.html\n J/Kg\n https://www.engineeringtoolbox.com/water-thermal-properties-d_162.html\n J/Kg\n https://www.engineeringtoolbox.com/water-thermal-properties-d_162.html\n in Kelvin\n https://www.engineeringtoolbox.com/water-thermal-properties-d_162.html\n in Kelvin\n At 1 atm pressure\n https://www.engineeringtoolbox.com/water-thermal-properties-d_162.html\n Degree C\n https://www.engineeringtoolbox.com/water-thermal-properties-d_162.html\n Pa\n https://www.engineeringtoolbox.com/water-thermal-properties-d_162.html\n Pa\n https://www.engineeringtoolbox.com/water-thermal-properties-d_162.html\n in Kelvin\n https://www.engineeringtoolbox.com/water-thermal-properties-d_162.html\n N/m2 Functions public pure function SpecificHeatCap_Air (Temp, Pressure) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in), optional :: Temp real(kind=DFP), intent(in), optional :: Pressure Return Value real(kind=DFP) public pure function SpecificHeatCap_Quartz (Temp, Pressure) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in), optional :: Temp real(kind=DFP), intent(in), optional :: Pressure Return Value real(kind=DFP) public pure function ThermCond_Air (Temp, Pressure) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in), optional :: Temp real(kind=DFP), intent(in), optional :: Pressure Return Value real(kind=DFP) public pure function ThermCond_Quartz (Temp, Pressure) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in), optional :: Temp real(kind=DFP), intent(in), optional :: Pressure Return Value real(kind=DFP) public pure function density_ice (Temp, Pressure) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in), optional :: Temp real(kind=DFP), intent(in), optional :: Pressure Return Value real(kind=DFP) public pure function density_water (Temp, Pressure) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in), optional :: Temp real(kind=DFP), intent(in), optional :: Pressure Return Value real(kind=DFP) internal variables public pure function density_water_Temp_Pressure (Temp, Pressure) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Temp real(kind=DFP), intent(in) :: Pressure Return Value real(kind=DFP) public pure function density_water_pressure (Pressure) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Pressure Return Value real(kind=DFP) public pure function density_water_temp (Temp) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Temp Return Value real(kind=DFP) public pure function specificHeatCap_ice (Temp, Pressure) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in), optional :: Temp real(kind=DFP), intent(in), optional :: Pressure Return Value real(kind=DFP) public pure function specificHeatCap_water (Temp, Pressure) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in), optional :: Temp real(kind=DFP), intent(in), optional :: Pressure Return Value real(kind=DFP) internal variables public pure function specificHeatCap_water_Temp (Temp) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Temp Return Value real(kind=DFP) public pure function specificHeatCap_water_Temp_Pressure (Temp, Pressure) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Temp real(kind=DFP), intent(in) :: Pressure Return Value real(kind=DFP) public pure function specificHeatCap_water_pressure (Pressure) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Pressure Return Value real(kind=DFP) public pure function thermCond_ice (Temp, Pressure) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in), optional :: Temp real(kind=DFP), intent(in), optional :: Pressure Return Value real(kind=DFP) public pure function thermCond_water (Temp, Pressure) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in), optional :: Temp real(kind=DFP), intent(in), optional :: Pressure Return Value real(kind=DFP) internal variables public pure function thermCond_water_Temp (Temp) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Temp Return Value real(kind=DFP) public pure function thermCond_water_Temp_Pressure (Temp, Pressure) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Temp real(kind=DFP), intent(in) :: Pressure Return Value real(kind=DFP) public pure function thermCond_water_pressure (Pressure) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Pressure Return Value real(kind=DFP) public pure function volHeatCap_Air (Temp, Pressure) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in), optional :: Temp real(kind=DFP), intent(in), optional :: Pressure Return Value real(kind=DFP) public pure function volHeatCap_Quartz (Temp, Pressure) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in), optional :: Temp real(kind=DFP), intent(in), optional :: Pressure Return Value real(kind=DFP) public pure function volHeatCap_ice (Temp, Pressure) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in), optional :: Temp real(kind=DFP), intent(in), optional :: Pressure Return Value real(kind=DFP) public pure function volHeatCap_water (Temp, Pressure) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in), optional :: Temp real(kind=DFP), intent(in), optional :: Pressure Return Value real(kind=DFP) internal variables","tags":"","loc":"module/stdmaterials.html"},{"title":"Material_Class – Fortran Program","text":"Uses BaseType GlobalData Contents Variables TypeMaterial Interfaces DeallocateData Display Initiate mat_append mat_deallocate mat_display mat_display_vec mat_get_prop mat_initiate mat_size Derived Types Material_ MatetrialPointer_ Variables Type Visibility Attributes Name Initial type( Material_ ), public, parameter :: TypeMaterial = Material_(Props=NULL()) Interfaces public interface DeallocateData private interface mat_deallocate () Deallocate data stored in Material_ Arguments None public interface Display private interface mat_display () Arguments None private interface mat_display_vec () Arguments None public interface Initiate Generic subroutine to construct Material_ private interface mat_initiate () Subroutine that constructs Material_ Arguments None interface Append keyval object to Material_ private subroutine mat_append(Obj, KeyValObj) Arguments Type Intent Optional Attributes Name class( Material_ ), intent(inout) :: Obj type(KeyValue_), intent(in) :: KeyValObj interface Deallocate data stored in Material_ private subroutine mat_deallocate(Obj) Arguments Type Intent Optional Attributes Name class( Material_ ), intent(inout) :: Obj interface private subroutine mat_display(Obj, msg, unitno) Arguments Type Intent Optional Attributes Name class( Material_ ), intent(in) :: Obj character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitno interface private subroutine mat_display_vec(Obj, msg, unitno) Arguments Type Intent Optional Attributes Name type( Material_ ), intent(in) :: Obj (:) character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitno interface Function that return a property as an instance of KeyValue_ private pure function mat_get_prop(Obj, Key) result(Ans) Arguments Type Intent Optional Attributes Name class( Material_ ), intent(in) :: Obj character(len=*), intent(in) :: Key Return Value type(KeyValue_) interface Subroutine that constructs Material_ private subroutine mat_initiate(Obj, tprop) Arguments Type Intent Optional Attributes Name class( Material_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: tprop interface Get total number of parameters stored in Material_ private pure function mat_size(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( Material_ ), intent(in) :: Obj Return Value integer(kind=I4B) Derived Types type, public :: Material_ Material_ type contains materials properties Components Type Visibility Attributes Name Initial type(KeyValue_), public, ALLOCATABLE :: Props (:) Each entry in prop denotes a material parameter Type-Bound Procedures procedure, public, PASS( Obj ) :: Append => mat_append Append value to the list procedure, public, PASS( Obj ) :: Initiate => mat_initiate Construct the object procedure, public, PASS( Obj ) :: Property => mat_get_prop Returns property as a [keyvalue_] instance procedure, public, PASS( Obj ) :: Size => mat_size get total number of properties/parameters type, public :: MatetrialPointer_ Components Type Visibility Attributes Name Initial class( Material_ ), public, POINTER :: Ptr => NULL()","tags":"","loc":"module/material_class.html"},{"title":"Kernel_Class – Fortran Program","text":"Uses EASIFEM Contents Variables ALGO_OPT_FLUX ALGO_OPT_FLUX_AIR ALGO_OPT_FLUX_WATER ALGO_OPT_FLUX_WATER_AIR ALGO_OPT_NO_FLUX ALGO_OPT_NO_PHASE_CHANGE ALGO_OPT_PHASE_CHANGE ALGO_OPT_SEMIDISCRETE ALGO_OPT_SPACETIME ALGO_OPT_STATIC ALGO_OPT_TRANSIENT LIS_FPAR_LEN LIS_IPAR_LEN LIS_PRECOND_FPAR_LEN LIS_PRECOND_IPAR_LEN MAX_MATERIAL_TYPE NSD_1_HORIZONTAL NSD_1_VERTICAL NSD_2_AXISYMMETRIC NSD_2_CARTESIAN NSD_3 Interfaces kernel_dealloc kernel_init kernel_mesh_quality kernel_setalgo kernel_setdomain kernel_setlinsol kernel_setmatprops kernel_setprecond kernel_settanmat set_material set_total_materials Abstract Interfaces kernel_assemble kernel_isconverg kernel_savestate kernel_set_kernel kernel_solve kernel_update kernel_writedata Derived Types KernelPointer_ Kernel_ Variables Type Visibility Attributes Name Initial integer(kind=I4B), private, parameter :: ALGO_OPT_FLUX = 2 integer(kind=I4B), private, parameter :: ALGO_OPT_FLUX_AIR = 7 integer(kind=I4B), private, parameter :: ALGO_OPT_FLUX_WATER = 6 integer(kind=I4B), private, parameter :: ALGO_OPT_FLUX_WATER_AIR = 8 integer(kind=I4B), private, parameter :: ALGO_OPT_NO_FLUX = 3 integer(kind=I4B), private, parameter :: ALGO_OPT_NO_PHASE_CHANGE = 5 integer(kind=I4B), private, parameter :: ALGO_OPT_PHASE_CHANGE = 4 integer(kind=I4B), private, parameter :: ALGO_OPT_SEMIDISCRETE = 1 integer(kind=I4B), private, parameter :: ALGO_OPT_SPACETIME = 2 integer(kind=I4B), private, parameter :: ALGO_OPT_STATIC = 0 integer(kind=I4B), private, parameter :: ALGO_OPT_TRANSIENT = 1 integer(kind=I4B), private, parameter :: LIS_FPAR_LEN = 10 integer(kind=I4B), private, parameter :: LIS_IPAR_LEN = 10 integer(kind=I4B), private, parameter :: LIS_PRECOND_FPAR_LEN = 10 integer(kind=I4B), private, parameter :: LIS_PRECOND_IPAR_LEN = 10 integer(kind=I4B), private, parameter :: MAX_MATERIAL_TYPE = 20 integer(kind=I4B), private, parameter :: NSD_1_HORIZONTAL = 1 integer(kind=I4B), private, parameter :: NSD_1_VERTICAL = 2 integer(kind=I4B), private, parameter :: NSD_2_AXISYMMETRIC = 4 integer(kind=I4B), private, parameter :: NSD_2_CARTESIAN = 3 integer(kind=I4B), private, parameter :: NSD_3 = 5 Interfaces interface private subroutine kernel_dealloc(Obj) Arguments Type Intent Optional Attributes Name class( Kernel_ ), intent(inout) :: Obj interface This subroutine initiate the Kernel private subroutine kernel_init(Obj, nsd, nnt, dt, SpatialCoordType, tn, NTS, tol_res, tol_sol) This subroutine initiate the kernel\n - If NNT (num of nodes in time domain) is not given then NNT=1 - NSD is the spatial dimension of the problem\n - dt is the time step size; default value is ‘1.0’ Arguments Type Intent Optional Attributes Name class( Kernel_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: nsd integer(kind=I4B), intent(in), optional :: nnt real(kind=DFP), intent(in), optional :: dt integer(kind=I4B), intent(in), optional :: SpatialCoordType real(kind=DFP), intent(in), optional :: tn integer(kind=I4B), intent(in), optional :: NTS real(kind=DFP), intent(in), optional :: tol_res real(kind=DFP), intent(in), optional :: tol_sol interface This subroutine computes the mesh quality private subroutine kernel_mesh_quality(Obj, qmin, qmax, qavg, measure, q, nodes) This subroutine computes the mesh quality\n - if q is present then mesh-quality of each element will be returned in it\n   otherwise meshquality will be stored in obj%meshq - qmin qmax and qavg are statistical parameters\n - measure is quality measure which can be\n     - meshquality%area\n     - meshquality%minAngle\n     - meshquality%maxAngle\n     - meshquality%angleRatio\n     - meshquality%radiusRatio\n     - meshquality%edgeRatio\n     - meshquality%aspectRatio\n     - meshquality%scaledJacobian\n - if nodes are not present then dom%nodes are used Arguments Type Intent Optional Attributes Name class( Kernel_ ), intent(inout) :: Obj real(kind=DFP), intent(inout) :: qmin real(kind=DFP), intent(inout) :: qmax real(kind=DFP), intent(inout) :: qavg integer(kind=I4B), intent(in), optional :: measure real(kind=DFP), intent(inout), optional ALLOCATABLE :: q (:) real(kind=DFP), intent(in), optional :: nodes (:,:) interface This subroutine set the algorithm for the kernel private subroutine kernel_setalgo(Obj, mainOption, extraOption) This subroutine set the algorithm of the Kernel\n This subroutine should be defined by specific kernel Arguments Type Intent Optional Attributes Name class( Kernel_ ), intent(inout) :: Obj integer(kind=I4B), intent(in), optional :: mainOption (:) integer(kind=I4B), intent(in), optional :: extraOption (:) interface This subroutine set the domain to the kernel private subroutine kernel_setdomain(Obj, dom, omegaNo) This subroutine set the domain to the kernel\n - Here dom is the domain_ datatype\n - omegaNo is the IDs of regions which is required in the analysis\n - This subroutine will store information of omegano - It also prepares the mapping between local and global node numbers\n - Information such as, obj%tnodes and obj%telements are also stored\n inside the kernel Read more… Arguments Type Intent Optional Attributes Name class( Kernel_ ), intent(inout) :: Obj class(Domain_), intent(inout), TARGET :: dom integer(kind=I4B), intent(in) :: omegaNo (:) interface private subroutine kernel_setlinsol(Obj, name, maxiter, tol, fpar, ipar) Arguments Type Intent Optional Attributes Name class( Kernel_ ), intent(inout) :: Obj integer(kind=I4B), intent(in), optional :: name integer(kind=I4B), intent(in), optional :: maxiter real(kind=DFP), intent(in), optional :: tol real(kind=DFP), intent(in), optional :: fpar (:) integer(kind=I4B), intent(in), optional :: ipar (:) interface This subroutine set the material propeties in the kernel private subroutine kernel_setmatprops(Obj, matprops) This subroutine set the material properties in the kernel matprops contains information about different materials\n Each column of matprops denote a material type\n This method can be extended by the other kernels Arguments Type Intent Optional Attributes Name class( Kernel_ ), intent(inout) :: Obj real(kind=DFP), intent(in) :: matprops (:,:) interface private subroutine kernel_setprecond(Obj, name, fpar, ipar) Arguments Type Intent Optional Attributes Name class( Kernel_ ), intent(inout) :: Obj integer(kind=I4B), intent(in), optional :: name real(kind=DFP), intent(in), optional :: fpar (:) integer(kind=I4B), intent(in), optional :: ipar (:) interface private subroutine kernel_settanmat(Obj) Arguments Type Intent Optional Attributes Name class( Kernel_ ), intent(inout) :: Obj interface private subroutine set_material(Obj, materialNo) Arguments Type Intent Optional Attributes Name class( Kernel_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: materialNo (:) interface private subroutine set_total_materials(Obj, tMaterials) Arguments Type Intent Optional Attributes Name class( Kernel_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: tMaterials Abstract Interfaces abstract interface private subroutine kernel_assemble(Obj) Arguments Type Intent Optional Attributes Name class( Kernel_ ), intent(inout) :: Obj abstract interface private function kernel_isconverg(Obj, relTol, absTol, convergeInRes, convergeInSol) result(Ans) Arguments Type Intent Optional Attributes Name class( Kernel_ ), intent(inout) :: Obj real(kind=DFP), intent(in), optional :: relTol real(kind=DFP), intent(in), optional :: absTol logical(kind=LGT), intent(in), optional :: convergeInRes logical(kind=LGT), intent(in), optional :: convergeInSol Return Value logical(kind=LGT) abstract interface private subroutine kernel_savestate(Obj, Path, Filename, Extension, timestep) Arguments Type Intent Optional Attributes Name class( Kernel_ ), intent(inout) :: Obj character(len=*), intent(in) :: Path character(len=*), intent(in) :: Filename character(len=*), intent(in) :: Extension integer(kind=I4B), intent(in) :: timestep abstract interface private subroutine kernel_set_kernel(Obj) Arguments Type Intent Optional Attributes Name class( Kernel_ ), intent(inout) :: Obj abstract interface private subroutine kernel_solve(Obj) Arguments Type Intent Optional Attributes Name class( Kernel_ ), intent(inout) :: Obj abstract interface private subroutine kernel_update(Obj, reset) Arguments Type Intent Optional Attributes Name class( Kernel_ ), intent(inout) :: Obj logical(kind=LGT), intent(in) :: reset abstract interface private subroutine kernel_writedata(Obj, gmsh, path, filename, extension, indx) Arguments Type Intent Optional Attributes Name class( Kernel_ ), intent(inout) :: Obj type(gmsh_), intent(inout), optional :: gmsh character(len=*), intent(in), optional :: path character(len=*), intent(in), optional :: filename character(len=*), intent(in), optional :: extension integer(kind=I4B), intent(in) :: indx (:) Derived Types type, public :: KernelPointer_ Components Type Visibility Attributes Name Initial class( Kernel_ ), public, POINTER :: Ptr => NULL() type, public :: Kernel_ Components Type Visibility Attributes Name Initial procedure( kernel_assemble ), public, POINTER, PASS(Obj) :: Assemble => NULL() procedure( kernel_assemble ), public, POINTER, PASS(Obj) :: AssembleRHS => NULL() procedure( kernel_assemble ), public, POINTER, PASS(Obj) :: AssembleTanMat => NULL() type(IntVector_), public, ALLOCATABLE :: DB (:) DB(1) uniform pressure DB\n DB(2) hydrostate pressure DB\n DB(3) uniform discharge/flux NB\n DB(4) drainage/ filter / robin/ boundary NB integer(kind=I4B), public, ALLOCATABLE :: DBCinfo (:) Boundary info class(Domain_), public, POINTER :: Dom => NULL() integer(kind=I4B), public :: ITER = 0 integer(kind=I4B), public :: ITS = 0 real(kind=DFP), public :: LIS_FPAR (LIS_FPAR_LEN) = 0.0 real parameters for linear iterative solver integer(kind=I4B), public :: LIS_IPAR (LIS_IPAR_LEN) = 0 integer parameters for linear iterative solver integer(kind=I4B), public :: MAXITER = 100 integer(kind=I4B), public :: NNT = 2 number of nodes in time finite element method integer(kind=I4B), public :: NSD = 2 Spatial dimension of problem integer(kind=I4B), public :: NTS = 0 maximum iteration number for linear iterative solver integer(kind=I4B), public, ALLOCATABLE :: Nptrs (:) Global Nptrs integer(kind=I4B), public, ALLOCATABLE :: OmegaNo (:) Id of cell mesh in domain integer(kind=I4B), public, ALLOCATABLE :: OmegaNoToMaterials (:) Mesh region to material mapping integer(kind=I4B), public :: OneD_Horizontal = NSD_1_HORIZONTAL integer(kind=I4B), public :: OneD_Vertical = NSD_1_VERTICAL real(kind=DFP), public :: PRECOND_FPAR (LIS_PRECOND_FPAR_LEN) = 0.0 real parameter for linear iterative solver integer(kind=I4B), public :: PRECOND_IPAR (LIS_PRECOND_IPAR_LEN) = 0 integer parameters for linear iterative solver integer(kind=I4B), public :: STATIC = ALGO_OPT_STATIC procedure( kernel_solve ), public, POINTER, PASS(Obj) :: Solve => NULL() integer(kind=I4B), public :: SpatialCoordType = 0 Spatial coordinate type real(kind=DFP), public :: TOL = 1.0E-5 tolerance for linear iterative solver integer(kind=I4B), public :: TRANSIENT = ALGO_OPT_TRANSIENT integer(kind=I4B), public :: ThreeD = NSD_3 integer(kind=I4B), public :: TwoD_AxiSymmetric = NSD_2_AXISYMMETRIC integer(kind=I4B), public :: TwoD_Cartesian = NSD_2_CARTESIAN procedure( kernel_update ), public, POINTER, PASS(Obj) :: Update => NULL() procedure( kernel_writedata ), public, POINTER, PASS(Obj) :: WriteData => NULL() type(DOF_), public, ALLOCATABLE :: dof (:) dof( 1 ) :: pressure\n dof( 2 ) :: right hand side (residual)\n dof( 3 ) :: velocity real(kind=DFP), public :: dt = 0.01_DFP real(kind=DFP), public :: err = 0.0_DFP real(kind=DFP), public :: err0 = 0.0_DFP real(kind=DFP), public :: err0_res = 0.0_DFP real(kind=DFP), public :: err_res = 0.0_DFP type(IntVector_), public, ALLOCATABLE :: intvec (:) procedure( kernel_isconverg ), public, POINTER, PASS(Obj) :: isConverged => NULL() class(LinSolver_), public, POINTER :: linsol => NULL() integer(kind=I4B), public, ALLOCATABLE :: local_nptrs (:) Local Nptrs real(kind=DFP), public, ALLOCATABLE :: matprops (:,:) material properties real(kind=DFP), public, ALLOCATABLE :: meshq (:) Mesh quality type(RealVector_), public, ALLOCATABLE :: nodalVar (:) nodalVar( 1 ) :: pressure\n nodalVar( 2 ) :: right hand side (residual)\n nodalVar( 3 ) :: velocity integer(kind=I4B), public :: precondType = P_ILUD linear iterative solver preconditioning procedure( kernel_savestate ), public, POINTER, PASS( Obj ) :: saveState => NULL() procedure( kernel_set_kernel ), public, POINTER, PASS( Obj ) :: setKernel => NULL() integer(kind=I4B), public :: solverName = LIS_CG linear iterative solver name integer(kind=I4B), public :: tDOF = 0 total number of degrees of freedom per node integer(kind=I4B), public :: tELEMENTS = 0 total elements integer(kind=I4B), public :: tMaterials = 1 Total number of materials integer(kind=I4B), public :: tNODES = 0 total number of nodes in problem class(SparseMatrix_), public, POINTER :: tanmat => NULL() real(kind=DFP), public :: tn = 0.0_DFP real(kind=DFP), public :: tol_res = 1.0E-5 Time step for solving dynamic/ transient problems real(kind=DFP), public :: tol_sol = 1.0E-5 Time step for solving dynamic/ transient problems Type-Bound Procedures procedure, public, PASS( Obj ) :: Finalize => kernel_dealloc procedure, public, PASS( Obj ) :: Initiate => kernel_init procedure, public, PASS( Obj ) :: SetDomain => kernel_setdomain procedure, public, PASS( Obj ) :: getMeshQuality => kernel_mesh_quality procedure, public, PASS( Obj ) :: setAlgorithm => kernel_setalgo procedure, public, PASS( Obj ) :: setLinearSolver => kernel_setlinsol procedure, public, PASS( Obj ) :: setMaterial => set_material procedure, public, PASS( Obj ) :: setPrecondition => kernel_setprecond procedure, public, PASS( Obj ) :: setTanMat => kernel_settanmat procedure, public, PASS( Obj ) :: setTotalMaterials => set_total_materials","tags":"","loc":"module/kernel_class.html"},{"title":"BaseMethod – Fortran Program","text":"Uses GlobalData IO Buffer_Method Utility ErrorHandling File_Method BoundingBox_Method AbstractArray_Method AbstractMatrix_Method AbstractVector_Method RealVector_Method IntVector_Method RealMatrix_Method SparseMatrix_Method IndexValue_Method DOF_Method IterationData_Method DISPMODULE KeyValue_Method Random_Method VoigtRank2Tensor_Method Rank2Tensor_Method ReferenceElement_Method QuadraturePoint_Method ElemshapeData_Method FEVariable_Method FEMatrix_Module Contents None","tags":"","loc":"module/basemethod.html"},{"title":"BaseType – Fortran Program","text":"Uses GlobalData StringiFor PENF Used by Descendants: AdditionalMethods Contents Variables Constant CosineLode DOF_FMT DofToNodes FMT_DOF FMT_NODES GeneralTensor Matrix NODES_FMT NONE Nodal NodesToDOF Quadrature QualityMeasure Scalar SineLode SkewSymTensor Space SpaceTime StrainTypeVoigt StressTypeVoigt SymTensor Time TypeBasisContinuity TypeBoundingBox TypeDG TypeDOF TypeElemShapeData TypeElementData TypeFEVariable TypeFEVariableConstant TypeFEVariableMatrix TypeFEVariableScalar TypeFEVariableSpace TypeFEVariableSpaceTime TypeFEVariableTime TypeFEVariableVector TypeFile TypeH1 TypeH1CURL TypeH1DIV TypeHermitInterpolation TypeHierarchyInterpolation TypeIndexValue TypeIntVector TypeIterationData TypeKeyValue TypeLagrangeInterpolation TypeQuadraturePoint TypeRandom TypeRank2Tensor TypeRealMatrix TypeRealVector TypeReferenceHexahedron TypeReferenceLine TypeReferencePrism TypeReferencePyramid TypeReferenceQuadrangle TypeReferenceTetrahedron TypeReferenceTriangle TypeSTElemShapeData TypeSerendipityInterpolation TypeShapeData TypeSparseMatrix TypeString TypeVariableConstant TypeVariableMatrix TypeVariableScalar TypeVariableSpace TypeVariableSpaceTime TypeVariableTime TypeVariableVector TypeVoigtRank2Tensor Vector WithSpectral WithoutSpectral Interfaces lag_elem_refHexahedron lag_elem_refPrism lag_elem_refPyramid lag_elem_refQuadrangle lag_elem_refTetrahedron lag_elem_refTriangle lag_elem_refelem lag_elem_refline lp_refelem lp_refelem_Hexahedron lp_refelem_Prism lp_refelem_Pyramid lp_refelem_Quadrangle lp_refelem_Tetrahedron lp_refelem_Triangle lp_refelem_line Derived Types AbstractArrayPointer_ AbstractArray_ AbstractMatrixPointer_ AbstractMatrix_ AbstractVectorPointer_ AbstractVector_ BaseInterpolation_ BasisContinuity_ BoundingBoxPointer_ BoundingBox_ Buffer_ DG_ DOFPointer_ DOF_ ElemShapeDataPointer_ ElemShapeData_ ElementDataPointer_ ElementData_ FEVariableConstant_ FEVariableMatrix_ FEVariableScalar_ FEVariableSpaceTime_ FEVariableSpace_ FEVariableTime_ FEVariableVector_ FEVariable_ FilePointer_ File_ H1CURL_ H1DIV_ H1_ HermitInterpolation_ HierarchyInterpolation_ IndexValuePointer_ IndexValue_ IntVectorPointer_ IntVector_ IterationDataPointer_ IterationData_ KeyValue_ LagrangeInterpolation_ QuadraturePointPointer_ QuadraturePoint_ QualityMeasure_ Random_ Rank2TensorPointer_ Rank2Tensor_ RealMatrixPointer_ RealMatrix_ RealVectorPointer_ RealVector_ ReferenceElementPointer_ ReferenceElement_ ReferenceHexahedron_ ReferenceLine_ ReferencePrism_ ReferencePyramid_ ReferenceQuadrangle_ ReferenceTetrahedron_ ReferenceTopologyPointer_ ReferenceTopology_ ReferenceTriangle_ STElemShapeData_ STShapeDataPointer_ STShapeData_ SerendipityInterpolation_ ShapeDataPointer_ ShapeData_ SparseMatrixPointer_ SparseMatrix_ StringPointer_ Tensor_ VoigtRank2TensorPointer VoigtRank2Tensor_ Variables Type Visibility Attributes Name Initial integer(kind=I4B), public, parameter :: Constant = 0 integer(kind=I4B), public, parameter :: CosineLode = 0 integer(kind=I4B), public, parameter :: DOF_FMT = 0 integer(kind=I4B), public, parameter :: DofToNodes = 0 integer(kind=I4B), public, parameter :: FMT_DOF = 0 integer(kind=I4B), public, parameter :: FMT_NODES = 1 integer(kind=I4B), public, parameter :: GeneralTensor = 0 integer(kind=I4B), public, parameter :: Matrix = 2 integer(kind=I4B), public, parameter :: NODES_FMT = 1 integer(kind=I4B), public, parameter :: NONE = -1 integer(kind=I4B), public, parameter :: Nodal = 1 integer(kind=I4B), public, parameter :: NodesToDOF = 1 integer(kind=I4B), public, parameter :: Quadrature = 2 type( QualityMeasure_ ), public, parameter :: QualityMeasure = QualityMeasure_() integer(kind=I4B), public, parameter :: Scalar = 0 integer(kind=I4B), public, parameter :: SineLode = 1 integer(kind=I4B), public, parameter :: SkewSymTensor = -1 integer(kind=I4B), public, parameter :: Space = 1 integer(kind=I4B), public, parameter :: SpaceTime = 2 integer(kind=I4B), public, parameter :: StrainTypeVoigt = -1 integer(kind=I4B), public, parameter :: StressTypeVoigt = 1 integer(kind=I4B), public, parameter :: SymTensor = 1 integer(kind=I4B), public, parameter :: Time = 3 type( BasisContinuity_ ), public, parameter :: TypeBasisContinuity = BasisContinuity_() type( BoundingBox_ ), public, parameter :: TypeBoundingBox = BoundingBox_(NSD=0, Box=0) type( DG_ ), public, parameter :: TypeDG = DG_() type( DOF_ ), public, parameter :: TypeDOF = DOF_(MAP=NULL(), ValMap=NULL(), StorageFMT=Nodes_FMT) type( ElemShapeData_ ), public, parameter :: TypeElemShapeData = ElemShapeData_(N=NULL(), dNdXi=NULL(), Jacobian=NULL(), Js=NULL(), Ws=NULL(), dNdXt=NULL(), Thickness=NULL(), Coord=NULL(), Normal=NULL()) type( ElementData_ ), public, parameter :: TypeElementData = ElementData_(NSD=-1, NNE=-1, NNS=-1, NNT=-1, XiDimension=-1, ElemTopology=-1, SpaceElemTopo=-1, TimeElemTopo=-1, ElemType=-1, MAT_Type=-1) type( FEVariable_ ), public, parameter :: TypeFEVariable = FEVariable_(R1=NULL(), R2=NULL(), R3=NULL(), R4=NULL()) type( FEVariableConstant_ ), public, parameter :: TypeFEVariableConstant = FEVariableConstant_(1_I4B) type( FEVariableMatrix_ ), public, parameter :: TypeFEVariableMatrix = FEVariableMatrix_(2_I4B) type( FEVariableScalar_ ), public, parameter :: TypeFEVariableScalar = FEVariableScalar_(0_I4B) type( FEVariableSpace_ ), public, parameter :: TypeFEVariableSpace = FEVariableSpace_(2_I4B) type( FEVariableSpaceTime_ ), public, parameter :: TypeFEVariableSpaceTime = FEVariableSpaceTime_(3_I4B) type( FEVariableTime_ ), public, parameter :: TypeFEVariableTime = FEVariableTime_(4_I4B) type( FEVariableVector_ ), public, parameter :: TypeFEVariableVector = FEVariableVector_(1_I4B) type( File_ ), public, parameter :: TypeFile = File_(FileName=TypeString, Path=TypeString, Extension=TypeString, ACTION=TypeString, STATUS=TypeString, ACCESS=TypeString, UnitNo=-1, WriteNo=-1, IOSTAT=-1, isOpen=.FALSE.) type( H1_ ), public, parameter :: TypeH1 = H1_() type( H1CURL_ ), public, parameter :: TypeH1CURL = H1CURL_() type( H1DIV_ ), public, parameter :: TypeH1DIV = H1DIV_() type( HermitInterpolation_ ), public, parameter :: TypeHermitInterpolation = HermitInterpolation_() type( HierarchyInterpolation_ ), public, parameter :: TypeHierarchyInterpolation = HierarchyInterpolation_() type( IndexValue_ ), public, parameter :: TypeIndexValue = IndexValue_(Indx=0, Val=0.0_DFP) type( IntVector_ ), public, parameter :: TypeIntVector = IntVector_(tDimension=1_I4B, Val=NULL()) type( IterationData_ ), public, parameter :: TypeIterationData = IterationData_() type( KeyValue_ ), public, parameter :: TypeKeyValue = KeyValue_(Value=NULL(), Key=TypeString) type( LagrangeInterpolation_ ), public, parameter :: TypeLagrangeInterpolation = LagrangeInterpolation_() type( QuadraturePoint_ ), public, parameter :: TypeQuadraturePoint = QuadraturePoint_(Points=NULL()) type( Random_ ), public, parameter :: TypeRandom = Random_(random_int_seed=NULL(), random_int_vec=NULL(), random_real_vec=NULL()) type( Rank2Tensor_ ), public, parameter :: TypeRank2Tensor = Rank2Tensor_(T=0.0_DFP) type( RealMatrix_ ), public, parameter :: TypeRealMatrix = RealMatrix_(Val=NULL()) type( RealVector_ ), public, parameter :: TypeRealVector = RealVector_(tDimension=1_I4B, Val=NULL()) type( ReferenceHexahedron_ ), public, parameter :: TypeReferenceHexahedron = ReferenceHexahedron_(XiJ=NULL(), EntityCounts=[0, 0, 0, 0], XiDimension=0, Name=0, Topology=NULL(), Order=0, NSD=0) type( ReferenceLine_ ), public, parameter :: TypeReferenceLine = ReferenceLine_(XiJ=NULL(), EntityCounts=[0, 0, 0, 0], XiDimension=0, Name=0, Topology=NULL(), Order=0, NSD=0) type( ReferencePrism_ ), public, parameter :: TypeReferencePrism = ReferencePrism_(XiJ=NULL(), EntityCounts=[0, 0, 0, 0], XiDimension=0, Name=0, Topology=NULL(), Order=0, NSD=0) type( ReferencePyramid_ ), public, parameter :: TypeReferencePyramid = ReferencePyramid_(XiJ=NULL(), EntityCounts=[0, 0, 0, 0], XiDimension=0, Name=0, Topology=NULL(), Order=0, NSD=0) type( ReferenceQuadrangle_ ), public, parameter :: TypeReferenceQuadrangle = ReferenceQuadrangle_(XiJ=NULL(), EntityCounts=[0, 0, 0, 0], XiDimension=0, Name=0, Topology=NULL(), Order=0, NSD=0) type( ReferenceTetrahedron_ ), public, parameter :: TypeReferenceTetrahedron = ReferenceTetrahedron_(XiJ=NULL(), EntityCounts=[0, 0, 0, 0], XiDimension=0, Name=0, Topology=NULL(), Order=0, NSD=0) type( ReferenceTriangle_ ), public, parameter :: TypeReferenceTriangle = ReferenceTriangle_(XiJ=NULL(), EntityCounts=[0, 0, 0, 0], XiDimension=0, Name=0, Topology=NULL(), Order=0, NSD=0) type( STElemShapeData_ ), public, parameter :: TypeSTElemShapeData = STElemShapeData_(N=NULL(), dNdXi=NULL(), Jacobian=NULL(), Js=NULL(), Ws=NULL(), dNdXt=NULL(), Thickness=NULL(), Coord=NULL(), Normal=NULL(), T=NULL(), dTdTheta=NULL(), dNTdt=NULL(), dNTdXt=NULL()) type( SerendipityInterpolation_ ), public, parameter :: TypeSerendipityInterpolation = SerendipityInterpolation_() type( ShapeData_ ), public, parameter :: TypeShapeData = ShapeData_(N=NULL(), dNdXi=NULL(), dNdXt=NULL(), Jacobian=NULL()) type( SparseMatrix_ ), public, parameter :: TypeSparseMatrix = SparseMatrix_(Row=NULL(), IA=NULL(), JA=NULL(), ColSize=NULL(), RowSize=NULL(), DiagIndx=NULL(), A=NULL(), Diag=NULL()) type(String), public, parameter :: TypeString = String(raw=NULL()) type( FEVariableConstant_ ), public, parameter :: TypeVariableConstant = FEVariableConstant_(1_I4B) type( FEVariableMatrix_ ), public, parameter :: TypeVariableMatrix = FEVariableMatrix_(2_I4B) type( FEVariableScalar_ ), public, parameter :: TypeVariableScalar = FEVariableScalar_(0_I4B) type( FEVariableSpace_ ), public, parameter :: TypeVariableSpace = FEVariableSpace_(2_I4B) type( FEVariableSpaceTime_ ), public, parameter :: TypeVariableSpaceTime = FEVariableSpaceTime_(3_I4B) type( FEVariableTime_ ), public, parameter :: TypeVariableTime = FEVariableTime_(4_I4B) type( FEVariableVector_ ), public, parameter :: TypeVariableVector = FEVariableVector_(1_I4B) type( VoigtRank2Tensor_ ), public, parameter :: TypeVoigtRank2Tensor = VoigtRank2Tensor_(V=0.0_DFP) integer(kind=I4B), public, parameter :: Vector = 1 integer(kind=I4B), public, parameter :: WithSpectral = 1 integer(kind=I4B), public, parameter :: WithoutSpectral = -1 Interfaces interface private module function lag_elem_refHexahedron(Obj, Order) result(Ans) Implementation → Arguments Type Intent Optional Attributes Name class( ReferenceHexahedron_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value class( ReferenceElement_ ),\n  POINTER interface private module function lag_elem_refPrism(Obj, Order) result(Ans) Implementation → Arguments Type Intent Optional Attributes Name class( ReferencePrism_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value class( ReferenceElement_ ),\n  POINTER interface private module function lag_elem_refPyramid(Obj, Order) result(Ans) Implementation → Arguments Type Intent Optional Attributes Name class( ReferencePyramid_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value class( ReferenceElement_ ),\n  POINTER interface private module function lag_elem_refQuadrangle(Obj, Order) result(Ans) Implementation → Arguments Type Intent Optional Attributes Name class( ReferenceQuadrangle_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value class( ReferenceElement_ ),\n  POINTER interface private module function lag_elem_refTetrahedron(Obj, Order) result(Ans) Implementation → Arguments Type Intent Optional Attributes Name class( ReferenceTetrahedron_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value class( ReferenceElement_ ),\n  POINTER interface private module function lag_elem_refTriangle(Obj, Order) result(Ans) Implementation → Arguments Type Intent Optional Attributes Name class( ReferenceTriangle_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value class( ReferenceElement_ ),\n  POINTER interface private module function lag_elem_refelem(Obj, Order) result(Ans) Implementation → Arguments Type Intent Optional Attributes Name class( ReferenceElement_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value class( ReferenceElement_ ),\n  POINTER interface private module function lag_elem_refline(Obj, Order) result(Ans) Implementation → Arguments Type Intent Optional Attributes Name class( ReferenceLine_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value class( ReferenceElement_ ),\n  POINTER interface private pure module function lp_refelem(Obj, Order) result(Ans) Implementation → Arguments Type Intent Optional Attributes Name class( ReferenceElement_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) interface private pure module function lp_refelem_Hexahedron(Obj, Order) result(Ans) Implementation → Arguments Type Intent Optional Attributes Name class( ReferenceHexahedron_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) interface private pure module function lp_refelem_Prism(Obj, Order) result(Ans) Implementation → Arguments Type Intent Optional Attributes Name class( ReferencePrism_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) interface private pure module function lp_refelem_Pyramid(Obj, Order) result(Ans) Implementation → Arguments Type Intent Optional Attributes Name class( ReferencePyramid_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) interface private pure module function lp_refelem_Quadrangle(Obj, Order) result(Ans) Implementation → Arguments Type Intent Optional Attributes Name class( ReferenceQuadrangle_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) interface private pure module function lp_refelem_Tetrahedron(Obj, Order) result(Ans) Implementation → Arguments Type Intent Optional Attributes Name class( ReferenceTetrahedron_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) interface private pure module function lp_refelem_Triangle(Obj, Order) result(Ans) Implementation → Arguments Type Intent Optional Attributes Name class( ReferenceTriangle_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) interface private pure module function lp_refelem_line(Obj, Order) result(Ans) Implementation → Arguments Type Intent Optional Attributes Name class( ReferenceLine_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) Derived Types type, public :: AbstractArrayPointer_ Components Type Visibility Attributes Name Initial class( AbstractArray_ ), public, POINTER :: Ptr => NULL() type, public :: AbstractArray_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: tDimension = 0_I4B type, public :: AbstractMatrixPointer_ Components Type Visibility Attributes Name Initial class( AbstractMatrix_ ), public, POINTER :: Ptr => NULL() type, public, EXTENDS( AbstractArray_ ) :: AbstractMatrix_ type, private :: AbstractVectorPointer_ Components Type Visibility Attributes Name Initial class( AbstractVector_ ), public, POINTER :: Ptr => NULL() type, public, EXTENDS( AbstractArray_ ) :: AbstractVector_ type, public :: BaseInterpolation_ type, public :: BasisContinuity_ type, public :: BoundingBoxPointer_ Components Type Visibility Attributes Name Initial class( BoundingBoxPointer_ ), public, POINTER :: Ptr => NULL() type, public :: BoundingBox_ Components Type Visibility Attributes Name Initial real(kind=DFP), public :: Box (2,3) integer(kind=I4B), public :: NSD type, public :: Buffer_ Components Type Visibility Attributes Name Initial type( StringPointer_ ), public, ALLOCATABLE :: Line (:) integer(kind=I4B), public :: tLine = 0 type, public, EXTENDS( BasisContinuity_ ) :: DG_ type, public :: DOFPointer_ Components Type Visibility Attributes Name Initial class( DOF_ ), public, POINTER :: Ptr => NULL() type, public :: DOF_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public, ALLOCATABLE :: MAP (:,:) integer(kind=I4B), public :: StorageFMT = Nodes_FMT integer(kind=I4B), public, ALLOCATABLE :: ValMap (:) type, public :: ElemShapeDataPointer_ Components Type Visibility Attributes Name Initial class( ShapeDataPointer_ ), public, POINTER :: Ptr => NULL() type, public :: ElemShapeData_ This data type contains shapefunction related data defined\n at all gauss points of an elements Components Type Visibility Attributes Name Initial real(kind=DFP), public, ALLOCATABLE :: Coord (:,:) Barycentric coordinate real(kind=DFP), public, ALLOCATABLE :: Jacobian (:,:,:) Jacobian of mapping J(:,:,ips) also $\\mathbf{F}_{\\Xi x}$ real(kind=DFP), public, ALLOCATABLE :: Js (:) Determinant of Jacobian at ips real(kind=DFP), public, ALLOCATABLE :: N (:,:) Shape function value N(I,ips) real(kind=DFP), public, ALLOCATABLE :: Normal (:,:) Normal in case of facet element type( QuadraturePoint_ ), public :: Quad Quadrature points type( ReferenceElement_ ), public :: RefElem Refererece element real(kind=DFP), public, ALLOCATABLE :: Thickness (:) Thickness of element real(kind=DFP), public, ALLOCATABLE :: Ws (:) Weighting functions real(kind=DFP), public, ALLOCATABLE :: dNdXi (:,:,:) Local derivative of a shape function real(kind=DFP), public, ALLOCATABLE :: dNdXt (:,:,:) Spatial derivative of shape function type, public :: ElementDataPointer_ Components Type Visibility Attributes Name Initial class( ElementData_ ), public, POINTER :: Ptr => NULL() type, public :: ElementData_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: ElemTopology integer(kind=I4B), public :: ElemType integer(kind=I4B), public :: MAT_Type integer(kind=I4B), public :: NNE integer(kind=I4B), public :: NNS integer(kind=I4B), public :: NNT integer(kind=I4B), public :: NSD integer(kind=I4B), public :: SpaceElemTopo integer(kind=I4B), public :: TimeElemTopo integer(kind=I4B), public :: XiDimension type, public :: FEVariableConstant_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: Val = 1 type, public :: FEVariableMatrix_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: Val = 2 type, public :: FEVariableScalar_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: Val = 0 type, public :: FEVariableSpaceTime_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: Val = 3 type, public :: FEVariableSpace_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: Val = 2 type, public :: FEVariableTime_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: Val = 4 type, public :: FEVariableVector_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: Val = 1 type, public :: FEVariable_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: CaseType = 0 integer(kind=I4B), public :: DefineOn = 0 real(kind=DFP), public :: R0 = 0. real(kind=DFP), public, ALLOCATABLE :: R1 (:) real(kind=DFP), public, ALLOCATABLE :: R2 (:,:) real(kind=DFP), public, ALLOCATABLE :: R3 (:,:,:) real(kind=DFP), public, ALLOCATABLE :: R4 (:,:,:,:) integer(kind=I4B), public :: Rank = 0 integer(kind=I4B), public :: VarType = 0 type, public :: FilePointer_ Components Type Visibility Attributes Name Initial class( File_ ), public, POINTER :: Ptr => NULL() type, public :: File_ Components Type Visibility Attributes Name Initial type(String), public :: ACCESS type(String), public :: ACTION character(len=1), public :: Comment = \"#\" type(String), public :: Extension type(String), public :: FileName integer(kind=I4B), public :: IOSTAT = 1 type(String), public :: Path type(String), public :: STATUS character(len=1), public :: Separator = \",\" integer(kind=I4B), public :: UnitNo = 1 integer(kind=I4B), public :: WriteNo = 1 logical(kind=LGT), public :: isBinary = .FALSE. logical(kind=LGT), public :: isOpen = .FALSE. type, public, EXTENDS( BasisContinuity_ ) :: H1CURL_ type, public, EXTENDS( BasisContinuity_ ) :: H1DIV_ type, public, EXTENDS( BasisContinuity_ ) :: H1_ type, public, EXTENDS( BaseInterpolation_ ) :: HermitInterpolation_ type, public, EXTENDS( BaseInterpolation_ ) :: HierarchyInterpolation_ type, public :: IndexValuePointer_ Components Type Visibility Attributes Name Initial class( IndexValue_ ), public, POINTER :: Ptr => NULL() type, public :: IndexValue_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: Indx real(kind=DFP), public :: Val type, public :: IntVectorPointer_ Components Type Visibility Attributes Name Initial class( IntVector_ ), public, POINTER :: Ptr => NULL() type, public, EXTENDS( AbstractVector_ ) :: IntVector_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public, ALLOCATABLE :: Val (:) type, public :: IterationDataPointer_ Components Type Visibility Attributes Name Initial class( IterationData_ ), public, POINTER :: Ptr => NULL() type, public :: IterationData_ Components Type Visibility Attributes Name Initial logical(kind=LGT), public :: Converged = .FALSE. integer(kind=I4B), public :: ConvergenceIn = ConvergenceInRes integer(kind=I4B), public :: ConvergenceType = RelativeConvergence real(kind=DFP), public :: ErrorAtEnd = 0.0 real(kind=DFP), public :: ErrorAtStart = 0.0 integer(kind=I4B), public :: IterationNumber = 0 integer(kind=I4B), public :: MaxIter = 100 integer(kind=I4B), public :: NormType = NormL2 real(kind=DFP), public :: TimeAtEnd = 0.0 real(kind=DFP), public :: TimeAtStart = 0.0 real(kind=DFP), public :: Tolerance = 1.0E-5 type, public :: KeyValue_ KeyValue_ is a poor implementation of dict Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: DataType = 0 type(String), public :: Key real(kind=DFP), public, ALLOCATABLE :: Value (:,:) type, public, EXTENDS( BaseInterpolation_ ) :: LagrangeInterpolation_ type, public :: QuadraturePointPointer_ Components Type Visibility Attributes Name Initial class( QuadraturePoint_ ), public, POINTER :: Ptr => NULL() type, public :: QuadraturePoint_ QuadraturePoint_ data type contains the quadrature point information Read more… Components Type Visibility Attributes Name Initial real(kind=DFP), public, ALLOCATABLE :: Points (:,:) integer(kind=I4B), public :: tXi = 0 type, private :: QualityMeasure_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: AngleRatio = 103 integer(kind=I4B), public :: AspectRatio = 106 integer(kind=I4B), public :: Default = 106 integer(kind=I4B), public :: EdgeRatio = 105 integer(kind=I4B), public :: RadiusRatio = 104 integer(kind=I4B), public :: ScaledJacobian = 107 integer(kind=I4B), public :: area = 100 integer(kind=I4B), public :: maxAngle = 101 integer(kind=I4B), public :: minAngle = 102 type, public :: Random_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: random_int = 100 integer(kind=I4B), public, ALLOCATABLE :: random_int_seed (:) integer(kind=I4B), public, ALLOCATABLE :: random_int_vec (:) real(kind=DFP), public :: random_real = 0.0_DFP real(kind=DFP), public, ALLOCATABLE :: random_real_vec (:) type, public :: Rank2TensorPointer_ Components Type Visibility Attributes Name Initial class( Rank2Tensor_ ), public, POINTER :: Ptr => NULL() type, public, EXTENDS( Tensor_ ) :: Rank2Tensor_ Components Type Visibility Attributes Name Initial real(kind=DFP), public :: T (3,3) type, public :: RealMatrixPointer_ Components Type Visibility Attributes Name Initial class( RealMatrix_ ), public, POINTER :: Ptr => NULL() type, public, EXTENDS( AbstractMatrix_ ) :: RealMatrix_ Components Type Visibility Attributes Name Initial character(len=5), public :: MatrixProp = 'UNSYM' real(kind=DFP), public, ALLOCATABLE :: Val (:,:) type, public :: RealVectorPointer_ Components Type Visibility Attributes Name Initial class( RealVector_ ), public, POINTER :: Ptr => NULL() type, public, EXTENDS( AbstractVector_ ) :: RealVector_ Components Type Visibility Attributes Name Initial real(kind=DFP), public, ALLOCATABLE :: Val (:) type, public :: ReferenceElementPointer_ Components Type Visibility Attributes Name Initial class( ReferenceElement_ ), public, POINTER :: Ptr => NULL() type, public :: ReferenceElement_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: EntityCounts (4) integer(kind=I4B), public :: NSD integer(kind=I4B), public :: Name integer(kind=I4B), public :: Order type( ReferenceTopology_ ), public, ALLOCATABLE :: Topology (:) integer(kind=I4B), public :: XiDimension real(kind=DFP), public, ALLOCATABLE :: XiJ (:,:) Type-Bound Procedures procedure, public, PASS( Obj ) :: LagrangeElement => lag_elem_refelem procedure, public, PASS( Obj ) :: LagrangePoints => lp_refelem type, public, EXTENDS( ReferenceElement_ ) :: ReferenceHexahedron_ Type-Bound Procedures procedure, public, PASS( Obj ) :: LagrangeElement => lag_elem_refHexahedron procedure, public, PASS( Obj ) :: LagrangePoints => lp_refelem_Hexahedron type, public, EXTENDS( ReferenceElement_ ) :: ReferenceLine_ Type-Bound Procedures procedure, public, PASS( Obj ) :: LagrangeElement => lag_elem_refline procedure, public, PASS( Obj ) :: LagrangePoints => lp_refelem_line type, public, EXTENDS( ReferenceElement_ ) :: ReferencePrism_ Type-Bound Procedures procedure, public, PASS( Obj ) :: LagrangeElement => lag_elem_refPrism procedure, public, PASS( Obj ) :: LagrangePoints => lp_refelem_Prism type, public, EXTENDS( ReferenceElement_ ) :: ReferencePyramid_ Type-Bound Procedures procedure, public, PASS( Obj ) :: LagrangeElement => lag_elem_refPyramid procedure, public, PASS( Obj ) :: LagrangePoints => lp_refelem_Pyramid type, public, EXTENDS( ReferenceElement_ ) :: ReferenceQuadrangle_ Type-Bound Procedures procedure, public, PASS( Obj ) :: LagrangeElement => lag_elem_refQuadrangle procedure, public, PASS( Obj ) :: LagrangePoints => lp_refelem_Quadrangle type, public, EXTENDS( ReferenceElement_ ) :: ReferenceTetrahedron_ Type-Bound Procedures procedure, public, PASS( Obj ) :: LagrangeElement => lag_elem_refTetrahedron procedure, public, PASS( Obj ) :: LagrangePoints => lp_refelem_Tetrahedron type, public :: ReferenceTopologyPointer_ Components Type Visibility Attributes Name Initial class( ReferenceTopology_ ), public, POINTER :: Ptr => NULL() type, public :: ReferenceTopology_ Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: Name integer(kind=I4B), public, ALLOCATABLE :: Nptrs (:) integer(kind=I4B), public :: XiDimension type, public, EXTENDS( ReferenceElement_ ) :: ReferenceTriangle_ Type-Bound Procedures procedure, public, PASS( Obj ) :: LagrangeElement => lag_elem_refTriangle procedure, public, PASS( Obj ) :: LagrangePoints => lp_refelem_Triangle type, public, EXTENDS( ElemShapeData_ ) :: STElemShapeData_ This data type contains shapefunction related data defined\n at all gauss points of an elements Read more… Components Type Visibility Attributes Name Initial real(kind=DFP), public :: Jt = 0.0 Jacobian $\\frac{dt}{d\\theta}$ real(kind=DFP), public, ALLOCATABLE :: T (:) Shape function in time domain real(kind=DFP), public :: Theta = 0.0 Gauss point in time domain real(kind=DFP), public :: Wt = 0.0 Weight of gauss point in time domain real(kind=DFP), public, ALLOCATABLE :: dNTdXt (:,:,:,:) real(kind=DFP), public, ALLOCATABLE :: dNTdt (:,:,:) real(kind=DFP), public, ALLOCATABLE :: dTdTheta (:) Local shape function derivative in time domain type, public :: STShapeDataPointer_ Components Type Visibility Attributes Name Initial class( STShapeData_ ), public, POINTER :: Ptr => NULL() type, public, EXTENDS( ShapeData_ ) :: STShapeData_ This class extends ShapeData_ class to space-time FEM applcation Components Type Visibility Attributes Name Initial real(kind=DFP), public :: Jt = 0.0 integer(kind=I4B), public :: SpaceElemTopo = 0 real(kind=DFP), public, ALLOCATABLE :: T (:) values of shape function at different time nodes real(kind=DFP), public :: Theta = 0.0 integer(kind=I4B), public :: TimeElemTopo = 0 real(kind=DFP), public :: Wt = 0.0 real(kind=DFP), public, ALLOCATABLE :: dNTdXt (:,:,:) Spatial gradient of the shape functions at space-time gauss points real(kind=DFP), public, ALLOCATABLE :: dNTdt (:,:) Value of global time derivative of T at time gauss points real(kind=DFP), public, ALLOCATABLE :: dTdTheta (:) Value of local time derivative of T at time gauss point type, public, EXTENDS( BaseInterpolation_ ) :: SerendipityInterpolation_ type, public :: ShapeDataPointer_ Components Type Visibility Attributes Name Initial class( ShapeDataPointer_ ), public, POINTER :: Ptr => NULL() type, public :: ShapeData_ This Class bundles all required variables(related to shapefunctions)\n at a Gauss Point Components Type Visibility Attributes Name Initial integer(kind=I4B), public :: ElemTopology = 0 real(kind=DFP), public, ALLOCATABLE :: Jacobian (:,:) real(kind=DFP), public :: Js = 0.0_DFP real(kind=DFP), public, ALLOCATABLE :: N (:) integer(kind=I4B), public :: NSD = 0 real(kind=DFP), public :: Normal (3) = 0.0_DFP real(kind=DFP), public :: Thickness = 1.0_DFP real(kind=DFP), public :: Ws = 0.0_DFP real(kind=DFP), public :: XBar (3) = 0.0_DFP real(kind=DFP), public :: Xi (3) = 0.0_DFP real(kind=DFP), public, ALLOCATABLE :: dNdXi (:,:) real(kind=DFP), public, ALLOCATABLE :: dNdXt (:,:) type, public :: SparseMatrixPointer_ Components Type Visibility Attributes Name Initial class( SparseMatrix_ ), public, POINTER :: Ptr => NULL() type, public, EXTENDS( AbstractMatrix_ ) :: SparseMatrix_ Components Type Visibility Attributes Name Initial real(kind=DFP), public, ALLOCATABLE :: A (:) integer(kind=I4B), public, ALLOCATABLE :: ColSize (:) real(kind=DFP), public, ALLOCATABLE :: Diag (:) integer(kind=I4B), public, ALLOCATABLE :: DiagIndx (:) integer(kind=I4B), public, ALLOCATABLE :: IA (:) integer(kind=I4B), public, ALLOCATABLE :: JA (:) character(len=5), public :: MatrixProp = 'UNSYM' type( IntVector_ ), public, ALLOCATABLE :: Row (:) integer(kind=I4B), public, ALLOCATABLE :: RowSize (:) integer(kind=I4B), public :: StorageFMT = Nodes_FMT integer(kind=I4B), public :: ncol = 0 integer(kind=I4B), public :: nnz = 0 integer(kind=I4B), public :: nrow = 0 integer(kind=I4B), public :: tDOF = 1 integer(kind=I4B), public :: tNodes = 0 type, public :: StringPointer_ Components Type Visibility Attributes Name Initial type(String), public, POINTER :: Ptr => NULL() type, private :: Tensor_ type, public :: VoigtRank2TensorPointer Components Type Visibility Attributes Name Initial class( VoigtRank2Tensor_ ), public, POINTER :: Ptr => NULL() type, public :: VoigtRank2Tensor_ Components Type Visibility Attributes Name Initial real(kind=DFP), public :: V (9)","tags":"","loc":"module/basetype.html"},{"title":"GlobalData – Fortran Program","text":"Uses iso_fortran_env Contents Variables AbsoluteConvergence AugmentedBC BIDFP BIFloat BII4B BIInt BIInt16 BIInt32 BIInt64 BIInt8 BIReal BIReal128 BIReal32 BIReal64 BYDFP BYFloat BYI4B BYInt BYInt16 BYInt32 BYInt64 BYInt8 BYReal BYReal128 BYReal32 BYReal64 Chebyshev ChebyshevLIP ChebyshevQP ConvergenceInRes ConvergenceInSol DDFP DFP DFPC DFloat DI4B DIP DInt DInt16 DInt32 DInt64 DInt8 DP DPC DReal DReal128 DReal32 DReal64 Equidistance EquidistanceLIP Error_Flag Eye2 Eye3 FDFP FFloat FI4B FI4BZP FInt FInt16 FInt16ZP FInt32 FInt32ZP FInt64 FInt64ZP FInt8 FInt8ZP FIntZP FReal FReal128 FReal32 FReal64 Float GaussLegendre GaussLegendreLIP GaussLegendreQP GaussLobatto GaussLobattoLIP GaussLobattoQP GeometryTag HeirarchicalPolynomial Hexahedron Hexahedron125 Hexahedron20 Hexahedron27 Hexahedron64 Hexahedron8 I4B INTEGER_FORMATS_LIST INTEGER_KINDS_LIST Int16 Int32 Int64 Int8 LGT LagrangeMultiplierBC LagrangePolynomial Line Line2 Line3 Line4 Line5 Line6 MaxDFP MaxFloat MaxI4B MaxInt MaxInt16 MaxInt32 MaxInt64 MaxInt8 MaxReal MaxReal128 MaxReal32 MaxReal64 MinDFP MinFloat MinI4B MinInt MinInt16 MinInt32 MinInt64 MinInt8 MinReal MinReal128 MinReal32 MinReal64 NitscheBC NoPrecond NormInfinity NormL1 NormL2 PenaltyBC PhysicalTag Pi Point Point1 PrecondLeft PrecondRight Prism Prism15 Prism18 Prism6 Pyramid Pyramid13 Pyramid14 Pyramid5 Quadrangle Quadrangle4 Quadrangle8 Quadrangle9 REAL_FORMATS_LIST REAL_KINDS_LIST Real128 Real32 Real64 RelativeConvergence SP SPC ScalarDOF SerendipityPolynomial SkewSymNitsch StrongBC SymNitsche Tetrahedron Tetrahedron10 Tetrahedron20 Tetrahedron35 Tetrahedron4 Tetrahedron56 Triangle Triangle10 Triangle12 Triangle15 Triangle15a Triangle15b Triangle21 Triangle3 Triangle6 Triangle9 TypeDFP TypeFloat TypeInt TypeInt16 TypeInt32 TypeInt64 TypeInt8 TypeIntI4B TypeReal TypeReal128 TypeReal32 TypeReal64 Zero ZeroReal128 ZeroReal32 ZeroReal64 endian endianB endianL is_initialized smallDFP smallFloat smallReal smallReal128 smallReal32 smallReal64 Variables Type Visibility Attributes Name Initial integer(kind=I4B), public, parameter :: AbsoluteConvergence = 2 integer(kind=I4B), public, parameter :: AugmentedBC = 5 integer(kind=Int8), public :: BIDFP integer(kind=Int8), public :: BIFloat integer(kind=DIP), public, parameter :: BII4B = bit_size(MaxInt) integer(kind=DIP), public, parameter :: BIInt = bit_size(MaxInt) integer(kind=Int16), public, parameter :: BIInt16 = bit_size(MaxInt16) integer(kind=Int32), public, parameter :: BIInt32 = bit_size(MaxInt32) integer(kind=Int64), public, parameter :: BIInt64 = bit_size(MaxInt64) integer(kind=Int8), public, parameter :: BIInt8 = bit_size(MaxInt8) integer(kind=Int8), public :: BIReal integer(kind=Int16), public :: BIReal128 integer(kind=Int8), public :: BIReal32 integer(kind=Int8), public :: BIReal64 integer(kind=Int8), public :: BYDFP integer(kind=Int8), public :: BYFloat integer(kind=DIP), public, parameter :: BYI4B = bit_size(MaxInt)/8_DIP integer(kind=DIP), public, parameter :: BYInt = bit_size(MaxInt)/8_DIP integer(kind=Int16), public, parameter :: BYInt16 = bit_size(MaxInt16)/8_Int16 integer(kind=Int32), public, parameter :: BYInt32 = bit_size(MaxInt32)/8_Int32 integer(kind=Int64), public, parameter :: BYInt64 = bit_size(MaxInt64)/8_Int64 integer(kind=Int8), public, parameter :: BYInt8 = bit_size(MaxInt8)/8_Int8 integer(kind=Int8), public :: BYReal integer(kind=Int16), public :: BYReal128 integer(kind=Int8), public :: BYReal32 integer(kind=Int8), public :: BYReal64 integer(kind=I4B), public, parameter :: Chebyshev = 4 integer(kind=I4B), public, parameter :: ChebyshevLIP = Chebyshev integer(kind=I4B), public, parameter :: ChebyshevQP = Chebyshev integer(kind=I4B), public, parameter :: ConvergenceInRes = 1 integer(kind=I4B), public, parameter :: ConvergenceInSol = 2 integer, public, parameter :: DDFP = DReal64 integer, public, parameter :: DFP = Real64 integer, public, parameter :: DFPC = KIND((1.0D0, 1.0D0)) integer, public, parameter :: DFloat = DReal64 integer, public, parameter :: DI4B = DInt32 integer, public, parameter :: DIP = Int32 integer, public, parameter :: DInt = DInt32 integer, public, parameter :: DInt16 = 6 integer, public, parameter :: DInt32 = 11 integer, public, parameter :: DInt64 = 20 integer, public, parameter :: DInt8 = 4 integer, public, parameter :: DP = Real64 integer, public, parameter :: DPC = KIND((1.0D0, 1.0D0)) integer, public, parameter :: DReal = DReal64 integer, public, parameter :: DReal128 = 23 integer, public, parameter :: DReal32 = 13 integer, public, parameter :: DReal64 = 23 integer(kind=I4B), public, parameter :: Equidistance = 1 integer(kind=I4B), public, parameter :: EquidistanceLIP = Equidistance logical, public :: Error_Flag = .FALSE. real(kind=DFP), public, DIMENSION( 2, 2 ) :: Eye2 = RESHAPE((/1.0_DFP, 0.0_DFP, 0.0_DFP, 1.0_DFP/), (/2, 2/)) real(kind=DFP), public, DIMENSION( 3, 3 ) :: Eye3 = RESHAPE((/1.0_DFP, 0.0_DFP, 0.0_DFP, 0.0_DFP, 1.0_DFP, 0.0_DFP, 0.0_DFP, 0.0_DFP, 1.0_DFP/), (/3, 3/)) character(len=*), public, parameter :: FDFP = FReal64 character(len=*), public, parameter :: FFloat = FReal64 character(len=*), public, parameter :: FI4B = FInt32 character(len=*), public, parameter :: FI4BZP = FInt32ZP character(len=*), public, parameter :: FInt = FInt32 character(len=*), public, parameter :: FInt16 = '(I6)' character(len=*), public, parameter :: FInt16ZP = '(I6.5)' character(len=*), public, parameter :: FInt32 = '(I11)' character(len=*), public, parameter :: FInt32ZP = '(I11.10)' character(len=*), public, parameter :: FInt64 = '(I20)' character(len=*), public, parameter :: FInt64ZP = '(I20.19)' character(len=*), public, parameter :: FInt8 = '(I4)' character(len=*), public, parameter :: FInt8ZP = '(I4.3)' character(len=*), public, parameter :: FIntZP = FInt32ZP character(len=*), public, parameter :: FReal = FReal64 character(len=*), public, parameter :: FReal128 = '(E23.15E3)' character(len=*), public, parameter :: FReal32 = '(E13.6E2)' character(len=*), public, parameter :: FReal64 = '(E23.15E3)' integer, public, parameter :: Float = Real64 integer(kind=I4B), public, parameter :: GaussLegendre = 2 integer(kind=I4B), public, parameter :: GaussLegendreLIP = GaussLegendre integer(kind=I4B), public, parameter :: GaussLegendreQP = GaussLegendre integer(kind=I4B), public, parameter :: GaussLobatto = 3 integer(kind=I4B), public, parameter :: GaussLobattoLIP = GaussLobatto integer(kind=I4B), public, parameter :: GaussLobattoQP = GaussLobatto integer(kind=I4B), public, parameter :: GeometryTag = 2 integer(kind=I4B), public, parameter :: HeirarchicalPolynomial = 3 integer(kind=I4B), public, parameter :: Hexahedron = 5 integer(kind=I4B), public, parameter :: Hexahedron125 = 93 integer(kind=I4B), public, parameter :: Hexahedron20 = 17 integer(kind=I4B), public, parameter :: Hexahedron27 = 12 integer(kind=I4B), public, parameter :: Hexahedron64 = 92 integer(kind=I4B), public, parameter :: Hexahedron8 = 5 integer, public, parameter :: I4B = Int32 character(len=*), public, parameter :: INTEGER_FORMATS_LIST (1:5) = [FInt64, FInt32, FInt16//' ', FInt8//' ', FInt] integer, public, parameter :: INTEGER_KINDS_LIST (1:5) = [Int64, Int32, Int16, Int8, DIP] integer, public, parameter :: Int16 = SELECTED_INT_KIND(4) integer, public, parameter :: Int32 = SELECTED_INT_KIND(9) integer, public, parameter :: Int64 = SELECTED_INT_KIND(18) integer, public, parameter :: Int8 = SELECTED_INT_KIND(2) integer, public, parameter :: LGT = KIND(.true.) integer(kind=I4B), public, parameter :: LagrangeMultiplierBC = 3 integer(kind=I4B), public, parameter :: LagrangePolynomial = 1 integer(kind=I4B), public, parameter :: Line = 1 integer(kind=I4B), public, parameter :: Line2 = 1 integer(kind=I4B), public, parameter :: Line3 = 8 integer(kind=I4B), public, parameter :: Line4 = 26 integer(kind=I4B), public, parameter :: Line5 = 27 integer(kind=I4B), public, parameter :: Line6 = 28 real(kind=Float), public, parameter :: MaxDFP = MaxReal64 real(kind=Float), public, parameter :: MaxFloat = MaxReal64 integer(kind=DIP), public, parameter :: MaxI4B = MaxInt32 integer(kind=DIP), public, parameter :: MaxInt = MaxInt32 integer(kind=Int16), public, parameter :: MaxInt16 = huge(1_Int16) integer(kind=Int32), public, parameter :: MaxInt32 = huge(1_Int32) integer(kind=Int64), public, parameter :: MaxInt64 = huge(1_Int64) integer(kind=Int8), public, parameter :: MaxInt8 = huge(1_Int8) real(kind=Float), public, parameter :: MaxReal = MaxReal64 real(kind=Real128), public, parameter :: MaxReal128 = huge(1._Real128) real(kind=Real32), public, parameter :: MaxReal32 = huge(1._Real32) real(kind=Real64), public, parameter :: MaxReal64 = huge(1._Real64) real(kind=Float), public, parameter :: MinDFP = MinReal64 real(kind=Float), public, parameter :: MinFloat = MinReal64 integer(kind=I4B), public, parameter :: MinI4B = MinInt32 integer(kind=DIP), public, parameter :: MinInt = MinInt32 integer(kind=Int16), public, parameter :: MinInt16 = -huge(1_Int16) integer(kind=Int32), public, parameter :: MinInt32 = -huge(1_Int32) integer(kind=Int64), public, parameter :: MinInt64 = -huge(1_Int64) integer(kind=Int8), public, parameter :: MinInt8 = -huge(1_Int8) real(kind=Float), public, parameter :: MinReal = MinReal64 real(kind=Real128), public, parameter :: MinReal128 = -huge(1._Real128) real(kind=Real32), public, parameter :: MinReal32 = -huge(1._Real32) real(kind=Real64), public, parameter :: MinReal64 = -huge(1._Real64) integer(kind=I4B), public, parameter :: NitscheBC = 2 integer(kind=I4B), public, parameter :: NoPrecond = 0 integer(kind=I4B), public, parameter :: NormInfinity = 3 integer(kind=I4B), public, parameter :: NormL1 = 1 integer(kind=I4B), public, parameter :: NormL2 = 2 integer(kind=I4B), public, parameter :: PenaltyBC = 4 integer(kind=I4B), public, parameter :: PhysicalTag = 1 real(kind=DFP), public, parameter :: Pi = 3.14159265359_DFP integer(kind=I4B), public, parameter :: Point = 15 integer(kind=I4B), public, parameter :: Point1 = 15 integer(kind=I4B), public, parameter :: PrecondLeft = 1 integer(kind=I4B), public, parameter :: PrecondRight = 2 integer(kind=I4B), public, parameter :: Prism = 6 integer(kind=I4B), public, parameter :: Prism15 = 18 integer(kind=I4B), public, parameter :: Prism18 = 13 integer(kind=I4B), public, parameter :: Prism6 = 6 integer(kind=I4B), public, parameter :: Pyramid = 7 integer(kind=I4B), public, parameter :: Pyramid13 = 19 integer(kind=I4B), public, parameter :: Pyramid14 = 14 integer(kind=I4B), public, parameter :: Pyramid5 = 7 integer(kind=I4B), public, parameter :: Quadrangle = 3 integer(kind=I4B), public, parameter :: Quadrangle4 = 3 integer(kind=I4B), public, parameter :: Quadrangle8 = 16 integer(kind=I4B), public, parameter :: Quadrangle9 = 10 character(len=*), public, parameter :: REAL_FORMATS_LIST (1:4) = [FReal128, FReal64, FReal32//' ', FReal] integer, public, parameter :: REAL_KINDS_LIST (1:4) = [Real128, Real64, Real32, Float] integer, public, parameter :: Real128 = SELECTED_REAL_KIND(15, 307) integer, public, parameter :: Real32 = SELECTED_REAL_KIND(6, 37) integer, public, parameter :: Real64 = SELECTED_REAL_KIND(15, 307) integer(kind=I4B), public, parameter :: RelativeConvergence = 1 integer, public, parameter :: SP = Real32 integer, public, parameter :: SPC = KIND((1.0, 1.0)) integer(kind=I4B), public, parameter :: ScalarDOF = -1 integer(kind=I4B), public, parameter :: SerendipityPolynomial = 2 integer(kind=I4B), public, parameter :: SkewSymNitsch = 1 integer(kind=I4B), public, parameter :: StrongBC = 1 integer(kind=I4B), public, parameter :: SymNitsche = 2 integer(kind=I4B), public, parameter :: Tetrahedron = 4 integer(kind=I4B), public, parameter :: Tetrahedron10 = 11 integer(kind=I4B), public, parameter :: Tetrahedron20 = 29 integer(kind=I4B), public, parameter :: Tetrahedron35 = 30 integer(kind=I4B), public, parameter :: Tetrahedron4 = 4 integer(kind=I4B), public, parameter :: Tetrahedron56 = 31 integer(kind=I4B), public, parameter :: Triangle = 2 integer(kind=I4B), public, parameter :: Triangle10 = 21 integer(kind=I4B), public, parameter :: Triangle12 = 22 integer(kind=I4B), public, parameter :: Triangle15 = 24 integer(kind=I4B), public, parameter :: Triangle15a = 23 integer(kind=I4B), public, parameter :: Triangle15b = 24 integer(kind=I4B), public, parameter :: Triangle21 = 25 integer(kind=I4B), public, parameter :: Triangle3 = 2 integer(kind=I4B), public, parameter :: Triangle6 = 9 integer(kind=I4B), public, parameter :: Triangle9 = 20 real(kind=Float), public, parameter :: TypeDFP = 1.0 real(kind=Float), public, parameter :: TypeFloat = 1.0 integer(kind=DIP), public, parameter :: TypeInt = 1 integer(kind=Int16), public, parameter :: TypeInt16 = 1 integer(kind=Int32), public, parameter :: TypeInt32 = 1 integer(kind=Int64), public, parameter :: TypeInt64 = 1 integer(kind=Int8), public, parameter :: TypeInt8 = 1 integer(kind=I4B), public, parameter :: TypeIntI4B = 1 real(kind=Float), public, parameter :: TypeReal = 1.0 real(kind=Real128), public, parameter :: TypeReal128 = 1.0 real(kind=Real32), public, parameter :: TypeReal32 = 1.0 real(kind=Real64), public, parameter :: TypeReal64 = 1.0 real(kind=Float), public, parameter :: Zero = ZeroReal64 real(kind=Real128), public, parameter :: ZeroReal128 = nearest(1._Real128, 1._Real128)-nearest(1._Real128, -1._Real128) real(kind=Real32), public, parameter :: ZeroReal32 = nearest(1._Real32, 1._Real32)-nearest(1._Real32, -1._Real32) real(kind=Real64), public, parameter :: ZeroReal64 = nearest(1._Real64, 1._Real64)-nearest(1._Real64, -1._Real64) integer, public :: endian = endianL integer, public, parameter :: endianB = 0 integer, public, parameter :: endianL = 1 logical, public :: is_initialized = .FALSE. real(kind=Float), public, parameter :: smallDFP = smallReal64 real(kind=Float), public, parameter :: smallFloat = smallReal64 real(kind=Float), public, parameter :: smallReal = smallReal64 real(kind=Real128), public, parameter :: smallReal128 = tiny(1._Real128) real(kind=Real32), public, parameter :: smallReal32 = tiny(1._Real32) real(kind=Real64), public, parameter :: smallReal64 = tiny(1._Real64)","tags":"","loc":"module/globaldata.html"},{"title":"AbstractMatrix_Method – Fortran Program","text":"Uses GlobalData BaseType Contents Interfaces Shape Size Functions get_shape get_size Interfaces public interface Shape private pure function get_shape (Obj) result(Ans) Arguments Type Intent Optional Attributes Name type( AbstractMatrix_ ), intent(in) :: Obj Return Value integer(kind=I4B)\n  (2) public interface Size private pure function get_size (Obj, Dims) result(Ans) Arguments Type Intent Optional Attributes Name type( AbstractMatrix_ ), intent(in) :: Obj integer(kind=I4B), intent(in), optional :: Dims Return Value integer(kind=I4B) Functions private pure function get_shape (Obj) result(Ans) Arguments Type Intent Optional Attributes Name type( AbstractMatrix_ ), intent(in) :: Obj Return Value integer(kind=I4B)\n  (2) private pure function get_size (Obj, Dims) result(Ans) Arguments Type Intent Optional Attributes Name type( AbstractMatrix_ ), intent(in) :: Obj integer(kind=I4B), intent(in), optional :: Dims Return Value integer(kind=I4B)","tags":"","loc":"module/abstractmatrix_method.html"},{"title":"BLASInterface – Fortran Program","text":"Contents Interfaces ASUM AXPBY AXPY AXPYI CABS1 COPY DOT DOTC DOTCI DOTI DOTU DOTUI GBMV GEM2V GEMM GEMM3M GEMM3M_BATCH GEMMT GEMM_BATCH GEMV GER GERC GERU GTHR GTHRZ HBMV HEMM HEMV HER HER2 HER2K HERK HPMV HPR HPR2 IAMAX IAMIN NRM2 ROT ROTG ROTI ROTM ROTMG SBMV SCAL SCTR SDOT SPMV SPR SPR2 SWAP SYMM SYMV SYR SYR2 SYR2K SYRK TBMV TBSV TPMV TPSV TRMM TRMV TRSM TRSM_BATCH TRSV XERBLA Interfaces public interface ASUM public pure function DASUM(N, X, INCX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX Return Value real(kind=WP) public pure function DZASUM(N, X, INCX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX Return Value real(kind=WP) public pure function SASUM(N, X, INCX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX Return Value real(kind=WP) public pure function SCASUM(N, X, INCX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX Return Value real(kind=WP) public interface AXPBY public subroutine CAXPBY(N, ALPHA, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine DAXPBY(N, ALPHA, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(in) :: BETA real(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine SAXPBY(N, ALPHA, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(in) :: BETA real(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine ZAXPBY(N, ALPHA, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public interface AXPY public subroutine CAXPY(N, A, X, INCX, Y, INCY) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N complex(kind=WP), intent(in) :: A complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine DAXPY(N, A, X, INCX, Y, INCY) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(in) :: A real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine SAXPY(N, A, X, INCX, Y, INCY) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(in) :: A real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine ZAXPY(N, A, X, INCX, Y, INCY) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N complex(kind=WP), intent(in) :: A complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public interface AXPYI public subroutine CAXPYI(NZ, A, X, INDX, Y) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NZ complex(kind=WP), intent(in) :: A complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INDX (*) complex(kind=WP), intent(inout) :: Y (*) public subroutine DAXPYI(NZ, A, X, INDX, Y) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NZ real(kind=WP), intent(in) :: A real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INDX (*) real(kind=WP), intent(inout) :: Y (*) public subroutine SAXPYI(NZ, A, X, INDX, Y) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NZ real(kind=WP), intent(in) :: A real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INDX (*) real(kind=WP), intent(inout) :: Y (*) public subroutine ZAXPYI(NZ, A, X, INDX, Y) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NZ complex(kind=WP), intent(in) :: A complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INDX (*) complex(kind=WP), intent(inout) :: Y (*) public interface CABS1 public pure function DCABS1(Z) Arguments Type Intent Optional Attributes Name complex(kind=WP), intent(in) :: Z Return Value real(kind=WP) public pure function SCABS1(C) Arguments Type Intent Optional Attributes Name complex(kind=WP), intent(in) :: C Return Value real(kind=WP) public interface COPY public subroutine CCOPY(N, X, INCX, Y, INCY) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine DCOPY(N, X, INCX, Y, INCY) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine SCOPY(N, X, INCX, Y, INCY) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine ZCOPY(N, X, INCX, Y, INCY) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public interface DOT public pure function DDOT(N, X, INCX, Y, INCY) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(in) :: Y (*) integer, intent(in) :: INCY Return Value real(kind=WP) public pure function SDOT(N, X, INCX, Y, INCY) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(in) :: Y (*) integer, intent(in) :: INCY Return Value real(kind=WP) public interface DOTC public pure function CDOTC(N, X, INCX, Y, INCY) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: Y (*) integer, intent(in) :: INCY Return Value complex(kind=WP) public pure function ZDOTC(N, X, INCX, Y, INCY) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: Y (*) integer, intent(in) :: INCY Return Value complex(kind=WP) public interface DOTCI public pure function CDOTCI(NZ, X, INDX, Y) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NZ complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INDX (*) complex(kind=WP), intent(in) :: Y (*) Return Value complex(kind=WP) public pure function ZDOTCI(NZ, X, INDX, Y) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NZ complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INDX (*) complex(kind=WP), intent(in) :: Y (*) Return Value complex(kind=WP) public interface DOTI public pure function DDOTI(NZ, X, INDX, Y) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NZ real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INDX (*) real(kind=WP), intent(in) :: Y (*) Return Value real(kind=WP) public pure function SDOTI(NZ, X, INDX, Y) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NZ real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INDX (*) real(kind=WP), intent(in) :: Y (*) Return Value real(kind=WP) public interface DOTU public pure function CDOTU(N, X, INCX, Y, INCY) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: Y (*) integer, intent(in) :: INCY Return Value complex(kind=WP) public pure function ZDOTU(N, X, INCX, Y, INCY) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: Y (*) integer, intent(in) :: INCY Return Value complex(kind=WP) public interface DOTUI public pure function CDOTUI(NZ, X, INDX, Y) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NZ complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INDX (*) complex(kind=WP), intent(in) :: Y (*) Return Value complex(kind=WP) public pure function ZDOTUI(NZ, X, INDX, Y) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NZ complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INDX (*) complex(kind=WP), intent(in) :: Y (*) Return Value complex(kind=WP) public interface GBMV public subroutine CGBMV(TRANS, M, N, KL, KU, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANS integer, intent(in) :: M integer, intent(in) :: N integer, intent(in) :: KL integer, intent(in) :: KU complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine DGBMV(TRANS, M, N, KL, KU, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANS integer, intent(in) :: M integer, intent(in) :: N integer, intent(in) :: KL integer, intent(in) :: KU real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(in) :: BETA real(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine SGBMV(TRANS, M, N, KL, KU, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANS integer, intent(in) :: M integer, intent(in) :: N integer, intent(in) :: KL integer, intent(in) :: KU real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(in) :: BETA real(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine ZGBMV(TRANS, M, N, KL, KU, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANS integer, intent(in) :: M integer, intent(in) :: N integer, intent(in) :: KL integer, intent(in) :: KU complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public interface GEM2V public subroutine CGEM2VC(M, N, ALPHA, A, LDA, X1, INCX1, X2, INCX2, BETA, Y1, INCY1, Y2, INCY2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: M integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: X1 (*) integer, intent(in) :: INCX1 complex(kind=WP), intent(in) :: X2 (*) integer, intent(in) :: INCX2 complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: Y1 (*) integer, intent(in) :: INCY1 complex(kind=WP), intent(inout) :: Y2 (*) integer, intent(in) :: INCY2 public subroutine DGEM2VU(M, N, ALPHA, A, LDA, X1, INCX1, X2, INCX2, BETA, Y1, INCY1, Y2, INCY2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: M integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(in) :: X1 (*) integer, intent(in) :: INCX1 real(kind=WP), intent(in) :: X2 (*) integer, intent(in) :: INCX2 real(kind=WP), intent(in) :: BETA real(kind=WP), intent(inout) :: Y1 (*) integer, intent(in) :: INCY1 real(kind=WP), intent(inout) :: Y2 (*) integer, intent(in) :: INCY2 public subroutine SGEM2VU(M, N, ALPHA, A, LDA, X1, INCX1, X2, INCX2, BETA, Y1, INCY1, Y2, INCY2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: M integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(in) :: X1 (*) integer, intent(in) :: INCX1 real(kind=WP), intent(in) :: X2 (*) integer, intent(in) :: INCX2 real(kind=WP), intent(in) :: BETA real(kind=WP), intent(inout) :: Y1 (*) integer, intent(in) :: INCY1 real(kind=WP), intent(inout) :: Y2 (*) integer, intent(in) :: INCY2 public subroutine ZGEM2VC(M, N, ALPHA, A, LDA, X1, INCX1, X2, INCX2, BETA, Y1, INCY1, Y2, INCY2) Arguments Type Intent Optional Attributes Name integer, intent(in) :: M integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: X1 (*) integer, intent(in) :: INCX1 complex(kind=WP), intent(in) :: X2 (*) integer, intent(in) :: INCX2 complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: Y1 (*) integer, intent(in) :: INCY1 complex(kind=WP), intent(inout) :: Y2 (*) integer, intent(in) :: INCY2 public interface GEMM public subroutine CGEMM(TRANSA, TRANSB, M, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANSA character(len=1), intent(in) :: TRANSB integer, intent(in) :: M integer, intent(in) :: N integer, intent(in) :: K complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: B (LDB,*) integer, intent(in) :: LDB complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public subroutine DGEMM(TRANSA, TRANSB, M, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANSA character(len=1), intent(in) :: TRANSB integer, intent(in) :: M integer, intent(in) :: N integer, intent(in) :: K real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(in) :: B (LDB,*) integer, intent(in) :: LDB real(kind=WP), intent(in) :: BETA real(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public subroutine DZGEMM(TRANSA, TRANSB, M, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANSA character(len=1), intent(in) :: TRANSB integer, intent(in) :: M integer, intent(in) :: N integer, intent(in) :: K complex(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: B (LDB,*) integer, intent(in) :: LDB complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public subroutine SCGEMM(TRANSA, TRANSB, M, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANSA character(len=1), intent(in) :: TRANSB integer, intent(in) :: M integer, intent(in) :: N integer, intent(in) :: K complex(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: B (LDB,*) integer, intent(in) :: LDB complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public subroutine SGEMM(TRANSA, TRANSB, M, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANSA character(len=1), intent(in) :: TRANSB integer, intent(in) :: M integer, intent(in) :: N integer, intent(in) :: K real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(in) :: B (LDB,*) integer, intent(in) :: LDB real(kind=WP), intent(in) :: BETA real(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public subroutine ZGEMM(TRANSA, TRANSB, M, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANSA character(len=1), intent(in) :: TRANSB integer, intent(in) :: M integer, intent(in) :: N integer, intent(in) :: K complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: B (LDB,*) integer, intent(in) :: LDB complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public interface GEMM3M public subroutine CGEMM3M(TRANSA, TRANSB, M, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANSA character(len=1), intent(in) :: TRANSB integer, intent(in) :: M integer, intent(in) :: N integer, intent(in) :: K complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: B (LDB,*) integer, intent(in) :: LDB complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public subroutine ZGEMM3M(TRANSA, TRANSB, M, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANSA character(len=1), intent(in) :: TRANSB integer, intent(in) :: M integer, intent(in) :: N integer, intent(in) :: K complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: B (LDB,*) integer, intent(in) :: LDB complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public interface GEMM3M_BATCH public subroutine CGEMM3M_BATCH(TRANSA_ARRAY, TRANSB_ARRAY, M_ARRAY, N_ARRAY, K_ARRAY, ALPHA_ARRAY, A_ARRAY, LDA_ARRAY, B_ARRAY, LDB_ARRAY, BETA_ARRAY, C_ARRAY, LDC_ARRAY, GROUP_COUNT, GROUP_SIZE) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANSA_ARRAY (*) character(len=1), intent(in) :: TRANSB_ARRAY (*) integer, intent(in) :: M_ARRAY (*) integer, intent(in) :: N_ARRAY (*) integer, intent(in) :: K_ARRAY (*) complex(kind=WP), intent(in) :: ALPHA_ARRAY (*) integer(kind=C_SIZE_T), intent(in) :: A_ARRAY (*) integer, intent(in) :: LDA_ARRAY (*) integer(kind=C_SIZE_T), intent(in) :: B_ARRAY (*) integer, intent(in) :: LDB_ARRAY (*) complex(kind=WP), intent(in) :: BETA_ARRAY (*) integer(kind=C_SIZE_T), intent(inout) :: C_ARRAY (*) integer, intent(in) :: LDC_ARRAY (*) integer, intent(in) :: GROUP_COUNT integer, intent(in) :: GROUP_SIZE (*) public subroutine ZGEMM3M_BATCH(TRANSA_ARRAY, TRANSB_ARRAY, M_ARRAY, N_ARRAY, K_ARRAY, ALPHA_ARRAY, A_ARRAY, LDA_ARRAY, B_ARRAY, LDB_ARRAY, BETA_ARRAY, C_ARRAY, LDC_ARRAY, GROUP_COUNT, GROUP_SIZE) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANSA_ARRAY (*) character(len=1), intent(in) :: TRANSB_ARRAY (*) integer, intent(in) :: M_ARRAY (*) integer, intent(in) :: N_ARRAY (*) integer, intent(in) :: K_ARRAY (*) complex(kind=WP), intent(in) :: ALPHA_ARRAY (*) integer(kind=C_SIZE_T), intent(in) :: A_ARRAY (*) integer, intent(in) :: LDA_ARRAY (*) integer(kind=C_SIZE_T), intent(in) :: B_ARRAY (*) integer, intent(in) :: LDB_ARRAY (*) complex(kind=WP), intent(in) :: BETA_ARRAY (*) integer(kind=C_SIZE_T), intent(inout) :: C_ARRAY (*) integer, intent(in) :: LDC_ARRAY (*) integer, intent(in) :: GROUP_COUNT integer, intent(in) :: GROUP_SIZE (*) public interface GEMMT public subroutine CGEMMT(UPLO, TRANSA, TRANSB, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANSA character(len=1), intent(in) :: TRANSB integer, intent(in) :: N integer, intent(in) :: K complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: B (LDB,*) integer, intent(in) :: LDB complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public subroutine DGEMMT(UPLO, TRANSA, TRANSB, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANSA character(len=1), intent(in) :: TRANSB integer, intent(in) :: N integer, intent(in) :: K real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(in) :: B (LDB,*) integer, intent(in) :: LDB real(kind=WP), intent(in) :: BETA real(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public subroutine SGEMMT(UPLO, TRANSA, TRANSB, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANSA character(len=1), intent(in) :: TRANSB integer, intent(in) :: N integer, intent(in) :: K real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(in) :: B (LDB,*) integer, intent(in) :: LDB real(kind=WP), intent(in) :: BETA real(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public subroutine ZGEMMT(UPLO, TRANSA, TRANSB, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANSA character(len=1), intent(in) :: TRANSB integer, intent(in) :: N integer, intent(in) :: K complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: B (LDB,*) integer, intent(in) :: LDB complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public interface GEMM_BATCH public subroutine CGEMM_BATCH(TRANSA_ARRAY, TRANSB_ARRAY, M_ARRAY, N_ARRAY, K_ARRAY, ALPHA_ARRAY, A_ARRAY, LDA_ARRAY, B_ARRAY, LDB_ARRAY, BETA_ARRAY, C_ARRAY, LDC_ARRAY, GROUP_COUNT, GROUP_SIZE) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANSA_ARRAY (*) character(len=1), intent(in) :: TRANSB_ARRAY (*) integer, intent(in) :: M_ARRAY (*) integer, intent(in) :: N_ARRAY (*) integer, intent(in) :: K_ARRAY (*) complex(kind=WP), intent(in) :: ALPHA_ARRAY (*) integer(kind=C_SIZE_T), intent(in) :: A_ARRAY (*) integer, intent(in) :: LDA_ARRAY (*) integer(kind=C_SIZE_T), intent(in) :: B_ARRAY (*) integer, intent(in) :: LDB_ARRAY (*) complex(kind=WP), intent(in) :: BETA_ARRAY (*) integer(kind=C_SIZE_T), intent(inout) :: C_ARRAY (*) integer, intent(in) :: LDC_ARRAY (*) integer, intent(in) :: GROUP_COUNT integer, intent(in) :: GROUP_SIZE (*) public subroutine DGEMM_BATCH(TRANSA_ARRAY, TRANSB_ARRAY, M_ARRAY, N_ARRAY, K_ARRAY, ALPHA_ARRAY, A_ARRAY, LDA_ARRAY, B_ARRAY, LDB_ARRAY, BETA_ARRAY, C_ARRAY, LDC_ARRAY, GROUP_COUNT, GROUP_SIZE) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANSA_ARRAY (*) character(len=1), intent(in) :: TRANSB_ARRAY (*) integer, intent(in) :: M_ARRAY (*) integer, intent(in) :: N_ARRAY (*) integer, intent(in) :: K_ARRAY (*) real(kind=WP), intent(in) :: ALPHA_ARRAY (*) integer(kind=C_SIZE_T), intent(in) :: A_ARRAY (*) integer, intent(in) :: LDA_ARRAY (*) integer(kind=C_SIZE_T), intent(in) :: B_ARRAY (*) integer, intent(in) :: LDB_ARRAY (*) real(kind=WP), intent(in) :: BETA_ARRAY (*) integer(kind=C_SIZE_T), intent(inout) :: C_ARRAY (*) integer, intent(in) :: LDC_ARRAY (*) integer, intent(in) :: GROUP_COUNT integer, intent(in) :: GROUP_SIZE (*) public subroutine SGEMM_BATCH(TRANSA_ARRAY, TRANSB_ARRAY, M_ARRAY, N_ARRAY, K_ARRAY, ALPHA_ARRAY, A_ARRAY, LDA_ARRAY, B_ARRAY, LDB_ARRAY, BETA_ARRAY, C_ARRAY, LDC_ARRAY, GROUP_COUNT, GROUP_SIZE) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANSA_ARRAY (*) character(len=1), intent(in) :: TRANSB_ARRAY (*) integer, intent(in) :: M_ARRAY (*) integer, intent(in) :: N_ARRAY (*) integer, intent(in) :: K_ARRAY (*) real(kind=WP), intent(in) :: ALPHA_ARRAY (*) integer(kind=C_SIZE_T), intent(in) :: A_ARRAY (*) integer, intent(in) :: LDA_ARRAY (*) integer(kind=C_SIZE_T), intent(in) :: B_ARRAY (*) integer, intent(in) :: LDB_ARRAY (*) real(kind=WP), intent(in) :: BETA_ARRAY (*) integer(kind=C_SIZE_T), intent(inout) :: C_ARRAY (*) integer, intent(in) :: LDC_ARRAY (*) integer, intent(in) :: GROUP_COUNT integer, intent(in) :: GROUP_SIZE (*) public subroutine ZGEMM_BATCH(TRANSA_ARRAY, TRANSB_ARRAY, M_ARRAY, N_ARRAY, K_ARRAY, ALPHA_ARRAY, A_ARRAY, LDA_ARRAY, B_ARRAY, LDB_ARRAY, BETA_ARRAY, C_ARRAY, LDC_ARRAY, GROUP_COUNT, GROUP_SIZE) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANSA_ARRAY (*) character(len=1), intent(in) :: TRANSB_ARRAY (*) integer, intent(in) :: M_ARRAY (*) integer, intent(in) :: N_ARRAY (*) integer, intent(in) :: K_ARRAY (*) complex(kind=WP), intent(in) :: ALPHA_ARRAY (*) integer(kind=C_SIZE_T), intent(in) :: A_ARRAY (*) integer, intent(in) :: LDA_ARRAY (*) integer(kind=C_SIZE_T), intent(in) :: B_ARRAY (*) integer, intent(in) :: LDB_ARRAY (*) complex(kind=WP), intent(in) :: BETA_ARRAY (*) integer(kind=C_SIZE_T), intent(inout) :: C_ARRAY (*) integer, intent(in) :: LDC_ARRAY (*) integer, intent(in) :: GROUP_COUNT integer, intent(in) :: GROUP_SIZE (*) public interface GEMV public subroutine CGEMV(TRANS, M, N, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANS integer, intent(in) :: M integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine DGEMV(TRANS, M, N, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANS integer, intent(in) :: M integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(in) :: BETA real(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine DZGEMV(TRANS, M, N, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANS integer, intent(in) :: M integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine SCGEMV(TRANS, M, N, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANS integer, intent(in) :: M integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine SGEMV(TRANS, M, N, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANS integer, intent(in) :: M integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(in) :: BETA real(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine ZGEMV(TRANS, M, N, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: TRANS integer, intent(in) :: M integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public interface GER public subroutine DGER(M, N, ALPHA, X, INCX, Y, INCY, A, LDA) Arguments Type Intent Optional Attributes Name integer, intent(in) :: M integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(in) :: Y (*) integer, intent(in) :: INCY real(kind=WP), intent(inout) :: A (LDA,*) integer, intent(in) :: LDA public subroutine SGER(M, N, ALPHA, X, INCX, Y, INCY, A, LDA) Arguments Type Intent Optional Attributes Name integer, intent(in) :: M integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(in) :: Y (*) integer, intent(in) :: INCY real(kind=WP), intent(inout) :: A (LDA,*) integer, intent(in) :: LDA public interface GERC public subroutine CGERC(M, N, ALPHA, X, INCX, Y, INCY, A, LDA) Arguments Type Intent Optional Attributes Name integer, intent(in) :: M integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: Y (*) integer, intent(in) :: INCY complex(kind=WP), intent(inout) :: A (LDA,*) integer, intent(in) :: LDA public subroutine ZGERC(M, N, ALPHA, X, INCX, Y, INCY, A, LDA) Arguments Type Intent Optional Attributes Name integer, intent(in) :: M integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: Y (*) integer, intent(in) :: INCY complex(kind=WP), intent(inout) :: A (LDA,*) integer, intent(in) :: LDA public interface GERU public subroutine CGERU(M, N, ALPHA, X, INCX, Y, INCY, A, LDA) Arguments Type Intent Optional Attributes Name integer, intent(in) :: M integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: Y (*) integer, intent(in) :: INCY complex(kind=WP), intent(inout) :: A (LDA,*) integer, intent(in) :: LDA public subroutine ZGERU(M, N, ALPHA, X, INCX, Y, INCY, A, LDA) Arguments Type Intent Optional Attributes Name integer, intent(in) :: M integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: Y (*) integer, intent(in) :: INCY complex(kind=WP), intent(inout) :: A (LDA,*) integer, intent(in) :: LDA public interface GTHR public subroutine CGTHR(NZ, Y, X, INDX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NZ complex(kind=WP), intent(in) :: Y (*) complex(kind=WP), intent(out) :: X (*) integer, intent(in) :: INDX (*) public subroutine DGTHR(NZ, Y, X, INDX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NZ real(kind=WP), intent(in) :: Y (*) real(kind=WP), intent(out) :: X (*) integer, intent(in) :: INDX (*) public subroutine SGTHR(NZ, Y, X, INDX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NZ real(kind=WP), intent(in) :: Y (*) real(kind=WP), intent(out) :: X (*) integer, intent(in) :: INDX (*) public subroutine ZGTHR(NZ, Y, X, INDX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NZ complex(kind=WP), intent(in) :: Y (*) complex(kind=WP), intent(out) :: X (*) integer, intent(in) :: INDX (*) public interface GTHRZ public subroutine CGTHRZ(NZ, Y, X, INDX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NZ complex(kind=WP), intent(inout) :: Y (*) complex(kind=WP), intent(out) :: X (*) integer, intent(in) :: INDX (*) public subroutine DGTHRZ(NZ, Y, X, INDX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NZ real(kind=WP), intent(inout) :: Y (*) real(kind=WP), intent(out) :: X (*) integer, intent(in) :: INDX (*) public subroutine SGTHRZ(NZ, Y, X, INDX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NZ real(kind=WP), intent(inout) :: Y (*) real(kind=WP), intent(out) :: X (*) integer, intent(in) :: INDX (*) public subroutine ZGTHRZ(NZ, Y, X, INDX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NZ complex(kind=WP), intent(inout) :: Y (*) complex(kind=WP), intent(out) :: X (*) integer, intent(in) :: INDX (*) public interface HBMV public subroutine CHBMV(UPLO, N, K, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N integer, intent(in) :: K complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine ZHBMV(UPLO, N, K, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N integer, intent(in) :: K complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public interface HEMM public subroutine CHEMM(SIDE, UPLO, M, N, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: SIDE character(len=1), intent(in) :: UPLO integer, intent(in) :: M integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: B (LDB,*) integer, intent(in) :: LDB complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public subroutine ZHEMM(SIDE, UPLO, M, N, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: SIDE character(len=1), intent(in) :: UPLO integer, intent(in) :: M integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: B (LDB,*) integer, intent(in) :: LDB complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public interface HEMV public subroutine CHEMV(UPLO, N, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine ZHEMV(UPLO, N, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public interface HER public subroutine CHER(UPLO, N, ALPHA, X, INCX, A, LDA) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(inout) :: A (LDA,*) integer, intent(in) :: LDA public subroutine ZHER(UPLO, N, ALPHA, X, INCX, A, LDA) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(inout) :: A (LDA,*) integer, intent(in) :: LDA public interface HER2 public subroutine CHER2(UPLO, N, ALPHA, X, INCX, Y, INCY, A, LDA) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: Y (*) integer, intent(in) :: INCY complex(kind=WP), intent(inout) :: A (LDA,*) integer, intent(in) :: LDA public subroutine ZHER2(UPLO, N, ALPHA, X, INCX, Y, INCY, A, LDA) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: Y (*) integer, intent(in) :: INCY complex(kind=WP), intent(inout) :: A (LDA,*) integer, intent(in) :: LDA public interface HER2K public subroutine CHER2K(UPLO, TRANS, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS integer, intent(in) :: N integer, intent(in) :: K complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: B (LDB,*) integer, intent(in) :: LDB real(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public subroutine ZHER2K(UPLO, TRANS, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS integer, intent(in) :: N integer, intent(in) :: K complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: B (LDB,*) integer, intent(in) :: LDB real(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public interface HERK public subroutine CHERK(UPLO, TRANS, N, K, ALPHA, A, LDA, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS integer, intent(in) :: N integer, intent(in) :: K real(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public subroutine ZHERK(UPLO, TRANS, N, K, ALPHA, A, LDA, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS integer, intent(in) :: N integer, intent(in) :: K real(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public interface HPMV public subroutine CHPMV(UPLO, N, ALPHA, AP, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: AP (*) complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine ZHPMV(UPLO, N, ALPHA, AP, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: AP (*) complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public interface HPR public subroutine CHPR(UPLO, N, ALPHA, X, INCX, AP) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(inout) :: AP (*) public subroutine ZHPR(UPLO, N, ALPHA, X, INCX, AP) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(inout) :: AP (*) public interface HPR2 public subroutine CHPR2(UPLO, N, ALPHA, X, INCX, Y, INCY, AP) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: Y (*) integer, intent(in) :: INCY complex(kind=WP), intent(inout) :: AP (*) public subroutine ZHPR2(UPLO, N, ALPHA, X, INCX, Y, INCY, AP) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(in) :: Y (*) integer, intent(in) :: INCY complex(kind=WP), intent(inout) :: AP (*) public interface IAMAX public pure function ICAMAX(N, X, INCX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX Return Value integer public pure function IDAMAX(N, X, INCX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX Return Value integer public pure function ISAMAX(N, X, INCX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX Return Value integer public pure function IZAMAX(N, X, INCX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX Return Value integer public interface IAMIN public pure function ICAMIN(N, X, INCX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX Return Value integer public pure function IDAMIN(N, X, INCX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX Return Value integer public pure function ISAMIN(N, X, INCX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX Return Value integer public pure function IZAMIN(N, X, INCX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX Return Value integer public interface NRM2 public pure function DNRM2(N, X, INCX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX Return Value real(kind=WP) public pure function DZNRM2(N, X, INCX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX Return Value real(kind=WP) public pure function SCNRM2(N, X, INCX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX Return Value real(kind=WP) public pure function SNRM2(N, X, INCX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX Return Value real(kind=WP) public interface ROT public subroutine CSROT(N, X, INCX, Y, INCY, C, S) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N complex(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY real(kind=WP), intent(in) :: C real(kind=WP), intent(in) :: S public subroutine DROT(N, X, INCX, Y, INCY, C, S) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY real(kind=WP), intent(in) :: C real(kind=WP), intent(in) :: S public subroutine SROT(N, X, INCX, Y, INCY, C, S) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY real(kind=WP), intent(in) :: C real(kind=WP), intent(in) :: S public subroutine ZDROT(N, X, INCX, Y, INCY, C, S) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N complex(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY real(kind=WP), intent(in) :: C real(kind=WP), intent(in) :: S public interface ROTG public subroutine CROTG(A, B, C, S) Arguments Type Intent Optional Attributes Name complex(kind=WP), intent(inout) :: A complex(kind=WP), intent(inout) :: B real(kind=WP), intent(out) :: C complex(kind=WP), intent(out) :: S public subroutine DROTG(A, B, C, S) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(inout) :: A real(kind=WP), intent(inout) :: B real(kind=WP), intent(out) :: C real(kind=WP), intent(out) :: S public subroutine SROTG(A, B, C, S) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(inout) :: A real(kind=WP), intent(inout) :: B real(kind=WP), intent(out) :: C real(kind=WP), intent(out) :: S public subroutine ZROTG(A, B, C, S) Arguments Type Intent Optional Attributes Name complex(kind=WP), intent(inout) :: A complex(kind=WP), intent(inout) :: B real(kind=WP), intent(out) :: C complex(kind=WP), intent(out) :: S public interface ROTI public subroutine DROTI(NZ, X, INDX, Y, C, S) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NZ real(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INDX (*) real(kind=WP), intent(in) :: Y (*) real(kind=WP), intent(in) :: C real(kind=WP), intent(in) :: S public subroutine SROTI(NZ, X, INDX, Y, C, S) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NZ real(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INDX (*) real(kind=WP), intent(in) :: Y (*) real(kind=WP), intent(in) :: C real(kind=WP), intent(in) :: S public interface ROTM public subroutine DROTM(N, X, INCX, Y, INCY, PARAM) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY real(kind=WP), intent(in) :: PARAM (5) public subroutine SROTM(N, X, INCX, Y, INCY, PARAM) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY real(kind=WP), intent(in) :: PARAM (5) public interface ROTMG public subroutine DROTMG(D1, D2, X1, Y1, PARAM) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(inout) :: D1 real(kind=WP), intent(inout) :: D2 real(kind=WP), intent(inout) :: X1 real(kind=WP), intent(in) :: Y1 real(kind=WP), intent(out) :: PARAM (5) public subroutine SROTMG(D1, D2, X1, Y1, PARAM) Arguments Type Intent Optional Attributes Name real(kind=WP), intent(inout) :: D1 real(kind=WP), intent(inout) :: D2 real(kind=WP), intent(inout) :: X1 real(kind=WP), intent(in) :: Y1 real(kind=WP), intent(out) :: PARAM (5) public interface SBMV public subroutine DSBMV(UPLO, N, K, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N integer, intent(in) :: K real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(in) :: BETA real(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine SSBMV(UPLO, N, K, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N integer, intent(in) :: K real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(in) :: BETA real(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public interface SCAL public subroutine CSCAL(N, A, X, INCX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N complex(kind=WP), intent(in) :: A complex(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public subroutine CSSCAL(N, A, X, INCX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(in) :: A complex(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public subroutine DSCAL(N, A, X, INCX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(in) :: A real(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public subroutine SSCAL(N, A, X, INCX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(in) :: A real(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public subroutine ZDSCAL(N, A, X, INCX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(in) :: A complex(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public subroutine ZSCAL(N, A, X, INCX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N complex(kind=WP), intent(in) :: A complex(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public interface SCTR public subroutine CSCTR(NZ, X, INDX, Y) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NZ complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INDX (*) complex(kind=WP), intent(out) :: Y (*) public subroutine DSCTR(NZ, X, INDX, Y) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NZ real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INDX (*) real(kind=WP), intent(out) :: Y (*) public subroutine SSCTR(NZ, X, INDX, Y) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NZ real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INDX (*) real(kind=WP), intent(out) :: Y (*) public subroutine ZSCTR(NZ, X, INDX, Y) Arguments Type Intent Optional Attributes Name integer, intent(in) :: NZ complex(kind=WP), intent(in) :: X (*) integer, intent(in) :: INDX (*) complex(kind=WP), intent(out) :: Y (*) public interface SDOT public pure function DSDOT(N, SX, INCX, SY, INCY) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=SP), intent(in) :: SX (*) integer, intent(in) :: INCX real(kind=SP), intent(in) :: SY (*) integer, intent(in) :: INCY Return Value real(kind=WP) public pure function SDSDOT(N, SB, SX, INCX, SY, INCY) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(in) :: SB real(kind=WP), intent(in) :: SX (*) integer, intent(in) :: INCX real(kind=WP), intent(in) :: SY (*) integer, intent(in) :: INCY Return Value real(kind=WP) public interface SPMV public subroutine DSPMV(UPLO, N, ALPHA, AP, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: AP (*) real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(in) :: BETA real(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine SSPMV(UPLO, N, ALPHA, AP, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: AP (*) real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(in) :: BETA real(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public interface SPR public subroutine DSPR(UPLO, N, ALPHA, X, INCX, AP) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(inout) :: AP (*) public subroutine SSPR(UPLO, N, ALPHA, X, INCX, AP) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(inout) :: AP (*) public interface SPR2 public subroutine DSPR2(UPLO, N, ALPHA, X, INCX, Y, INCY, AP) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(in) :: Y (*) integer, intent(in) :: INCY real(kind=WP), intent(inout) :: AP (*) public subroutine SSPR2(UPLO, N, ALPHA, X, INCX, Y, INCY, AP) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(in) :: Y (*) integer, intent(in) :: INCY real(kind=WP), intent(inout) :: AP (*) public interface SWAP public subroutine CSWAP(N, X, INCX, Y, INCY) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N complex(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine DSWAP(N, X, INCX, Y, INCY) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine SSWAP(N, X, INCX, Y, INCY) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine ZSWAP(N, X, INCX, Y, INCY) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N complex(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX complex(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public interface SYMM public subroutine CSYMM(SIDE, UPLO, M, N, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: SIDE character(len=1), intent(in) :: UPLO integer, intent(in) :: M integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: B (LDB,*) integer, intent(in) :: LDB complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public subroutine DSYMM(SIDE, UPLO, M, N, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: SIDE character(len=1), intent(in) :: UPLO integer, intent(in) :: M integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(in) :: B (LDB,*) integer, intent(in) :: LDB real(kind=WP), intent(in) :: BETA real(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public subroutine SSYMM(SIDE, UPLO, M, N, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: SIDE character(len=1), intent(in) :: UPLO integer, intent(in) :: M integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(in) :: B (LDB,*) integer, intent(in) :: LDB real(kind=WP), intent(in) :: BETA real(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public subroutine ZSYMM(SIDE, UPLO, M, N, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: SIDE character(len=1), intent(in) :: UPLO integer, intent(in) :: M integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: B (LDB,*) integer, intent(in) :: LDB complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public interface SYMV public subroutine DSYMV(UPLO, N, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(in) :: BETA real(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public subroutine SSYMV(UPLO, N, ALPHA, A, LDA, X, INCX, BETA, Y, INCY) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(in) :: BETA real(kind=WP), intent(inout) :: Y (*) integer, intent(in) :: INCY public interface SYR public subroutine DSYR(UPLO, N, ALPHA, X, INCX, A, LDA) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(inout) :: A (LDA,*) integer, intent(in) :: LDA public subroutine SSYR(UPLO, N, ALPHA, X, INCX, A, LDA) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(inout) :: A (LDA,*) integer, intent(in) :: LDA public interface SYR2 public subroutine DSYR2(UPLO, N, ALPHA, X, INCX, Y, INCY, A, LDA) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(in) :: Y (*) integer, intent(in) :: INCY real(kind=WP), intent(inout) :: A (LDA,*) integer, intent(in) :: LDA public subroutine SSYR2(UPLO, N, ALPHA, X, INCX, Y, INCY, A, LDA) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: X (*) integer, intent(in) :: INCX real(kind=WP), intent(in) :: Y (*) integer, intent(in) :: INCY real(kind=WP), intent(inout) :: A (LDA,*) integer, intent(in) :: LDA public interface SYR2K public subroutine CSYR2K(UPLO, TRANS, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS integer, intent(in) :: N integer, intent(in) :: K complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: B (LDB,*) integer, intent(in) :: LDB complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public subroutine DSYR2K(UPLO, TRANS, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS integer, intent(in) :: N integer, intent(in) :: K real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(in) :: B (LDB,*) integer, intent(in) :: LDB real(kind=WP), intent(in) :: BETA real(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public subroutine SSYR2K(UPLO, TRANS, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS integer, intent(in) :: N integer, intent(in) :: K real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(in) :: B (LDB,*) integer, intent(in) :: LDB real(kind=WP), intent(in) :: BETA real(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public subroutine ZSYR2K(UPLO, TRANS, N, K, ALPHA, A, LDA, B, LDB, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS integer, intent(in) :: N integer, intent(in) :: K complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: B (LDB,*) integer, intent(in) :: LDB complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public interface SYRK public subroutine CSYRK(UPLO, TRANS, N, K, ALPHA, A, LDA, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS integer, intent(in) :: N integer, intent(in) :: K complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public subroutine DSYRK(UPLO, TRANS, N, K, ALPHA, A, LDA, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS integer, intent(in) :: N integer, intent(in) :: K real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(in) :: BETA real(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public subroutine SSYRK(UPLO, TRANS, N, K, ALPHA, A, LDA, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS integer, intent(in) :: N integer, intent(in) :: K real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(in) :: BETA real(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public subroutine ZSYRK(UPLO, TRANS, N, K, ALPHA, A, LDA, BETA, C, LDC) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS integer, intent(in) :: N integer, intent(in) :: K complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(in) :: BETA complex(kind=WP), intent(inout) :: C (LDC,*) integer, intent(in) :: LDC public interface TBMV public subroutine CTBMV(UPLO, TRANS, DIAG, N, K, A, LDA, X, INCX) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS character(len=1), intent(in) :: DIAG integer, intent(in) :: N integer, intent(in) :: K complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public subroutine DTBMV(UPLO, TRANS, DIAG, N, K, A, LDA, X, INCX) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS character(len=1), intent(in) :: DIAG integer, intent(in) :: N integer, intent(in) :: K real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public subroutine STBMV(UPLO, TRANS, DIAG, N, K, A, LDA, X, INCX) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS character(len=1), intent(in) :: DIAG integer, intent(in) :: N integer, intent(in) :: K real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public subroutine ZTBMV(UPLO, TRANS, DIAG, N, K, A, LDA, X, INCX) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS character(len=1), intent(in) :: DIAG integer, intent(in) :: N integer, intent(in) :: K complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public interface TBSV public subroutine CTBSV(UPLO, TRANS, DIAG, N, K, A, LDA, X, INCX) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS character(len=1), intent(in) :: DIAG integer, intent(in) :: N integer, intent(in) :: K complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public subroutine DTBSV(UPLO, TRANS, DIAG, N, K, A, LDA, X, INCX) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS character(len=1), intent(in) :: DIAG integer, intent(in) :: N integer, intent(in) :: K real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public subroutine STBSV(UPLO, TRANS, DIAG, N, K, A, LDA, X, INCX) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS character(len=1), intent(in) :: DIAG integer, intent(in) :: N integer, intent(in) :: K real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public subroutine ZTBSV(UPLO, TRANS, DIAG, N, K, A, LDA, X, INCX) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS character(len=1), intent(in) :: DIAG integer, intent(in) :: N integer, intent(in) :: K complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public interface TPMV public subroutine CTPMV(UPLO, TRANS, DIAG, N, AP, X, INCX) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS character(len=1), intent(in) :: DIAG integer, intent(in) :: N complex(kind=WP), intent(in) :: AP (*) complex(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public subroutine DTPMV(UPLO, TRANS, DIAG, N, AP, X, INCX) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS character(len=1), intent(in) :: DIAG integer, intent(in) :: N real(kind=WP), intent(in) :: AP (*) real(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public subroutine STPMV(UPLO, TRANS, DIAG, N, AP, X, INCX) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS character(len=1), intent(in) :: DIAG integer, intent(in) :: N real(kind=WP), intent(in) :: AP (*) real(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public subroutine ZTPMV(UPLO, TRANS, DIAG, N, AP, X, INCX) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS character(len=1), intent(in) :: DIAG integer, intent(in) :: N complex(kind=WP), intent(in) :: AP (*) complex(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public interface TPSV public subroutine CTPSV(UPLO, TRANS, DIAG, N, AP, X, INCX) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS character(len=1), intent(in) :: DIAG integer, intent(in) :: N complex(kind=WP), intent(in) :: AP (*) complex(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public subroutine DTPSV(UPLO, TRANS, DIAG, N, AP, X, INCX) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS character(len=1), intent(in) :: DIAG integer, intent(in) :: N real(kind=WP), intent(in) :: AP (*) real(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public subroutine STPSV(UPLO, TRANS, DIAG, N, AP, X, INCX) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS character(len=1), intent(in) :: DIAG integer, intent(in) :: N real(kind=WP), intent(in) :: AP (*) real(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public subroutine ZTPSV(UPLO, TRANS, DIAG, N, AP, X, INCX) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS character(len=1), intent(in) :: DIAG integer, intent(in) :: N complex(kind=WP), intent(in) :: AP (*) complex(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public interface TRMM public subroutine CTRMM(SIDE, UPLO, TRANSA, DIAG, M, N, ALPHA, A, LDA, B, LDB) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: SIDE character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANSA character(len=1), intent(in) :: DIAG integer, intent(in) :: M integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(inout) :: B (LDB,*) integer, intent(in) :: LDB public subroutine DTRMM(SIDE, UPLO, TRANSA, DIAG, M, N, ALPHA, A, LDA, B, LDB) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: SIDE character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANSA character(len=1), intent(in) :: DIAG integer, intent(in) :: M integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(inout) :: B (LDB,*) integer, intent(in) :: LDB public subroutine STRMM(SIDE, UPLO, TRANSA, DIAG, M, N, ALPHA, A, LDA, B, LDB) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: SIDE character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANSA character(len=1), intent(in) :: DIAG integer, intent(in) :: M integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(inout) :: B (LDB,*) integer, intent(in) :: LDB public subroutine ZTRMM(SIDE, UPLO, TRANSA, DIAG, M, N, ALPHA, A, LDA, B, LDB) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: SIDE character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANSA character(len=1), intent(in) :: DIAG integer, intent(in) :: M integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(inout) :: B (LDB,*) integer, intent(in) :: LDB public interface TRMV public subroutine CTRMV(UPLO, TRANS, DIAG, N, A, LDA, X, INCX) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS character(len=1), intent(in) :: DIAG integer, intent(in) :: N complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public subroutine DTRMV(UPLO, TRANS, DIAG, N, A, LDA, X, INCX) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS character(len=1), intent(in) :: DIAG integer, intent(in) :: N real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public subroutine STRMV(UPLO, TRANS, DIAG, N, A, LDA, X, INCX) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS character(len=1), intent(in) :: DIAG integer, intent(in) :: N real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public subroutine ZTRMV(UPLO, TRANS, DIAG, N, A, LDA, X, INCX) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS character(len=1), intent(in) :: DIAG integer, intent(in) :: N complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public interface TRSM public subroutine CTRSM(SIDE, UPLO, TRANSA, DIAG, M, N, ALPHA, A, LDA, B, LDB) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: SIDE character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANSA character(len=1), intent(in) :: DIAG integer, intent(in) :: M integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(inout) :: B (LDB,*) integer, intent(in) :: LDB public subroutine DTRSM(SIDE, UPLO, TRANSA, DIAG, M, N, ALPHA, A, LDA, B, LDB) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: SIDE character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANSA character(len=1), intent(in) :: DIAG integer, intent(in) :: M integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(inout) :: B (LDB,*) integer, intent(in) :: LDB public subroutine STRSM(SIDE, UPLO, TRANSA, DIAG, M, N, ALPHA, A, LDA, B, LDB) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: SIDE character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANSA character(len=1), intent(in) :: DIAG integer, intent(in) :: M integer, intent(in) :: N real(kind=WP), intent(in) :: ALPHA real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(inout) :: B (LDB,*) integer, intent(in) :: LDB public subroutine ZTRSM(SIDE, UPLO, TRANSA, DIAG, M, N, ALPHA, A, LDA, B, LDB) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: SIDE character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANSA character(len=1), intent(in) :: DIAG integer, intent(in) :: M integer, intent(in) :: N complex(kind=WP), intent(in) :: ALPHA complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(inout) :: B (LDB,*) integer, intent(in) :: LDB public interface TRSM_BATCH public subroutine CTRSM_BATCH(SIDE_ARRAY, UPLO_ARRAY, TRANSA_ARRAY, DIAG_ARRAY, M_ARRAY, N_ARRAY, ALPHA_ARRAY, A_ARRAY, LDA_ARRAY, B_ARRAY, LDB_ARRAY, GROUP_COUNT, GROUP_SIZE) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: SIDE_ARRAY (*) character(len=1), intent(in) :: UPLO_ARRAY (*) character(len=1), intent(in) :: TRANSA_ARRAY (*) character(len=1), intent(in) :: DIAG_ARRAY (*) integer, intent(in) :: M_ARRAY (*) integer, intent(in) :: N_ARRAY (*) complex(kind=WP), intent(in) :: ALPHA_ARRAY (*) integer(kind=C_SIZE_T), intent(in) :: A_ARRAY (*) integer, intent(in) :: LDA_ARRAY (*) integer(kind=C_SIZE_T), intent(in) :: B_ARRAY (*) integer, intent(in) :: LDB_ARRAY (*) integer, intent(in) :: GROUP_COUNT integer, intent(in) :: GROUP_SIZE (*) public subroutine DTRSM_BATCH(SIDE_ARRAY, UPLO_ARRAY, TRANSA_ARRAY, DIAG_ARRAY, M_ARRAY, N_ARRAY, ALPHA_ARRAY, A_ARRAY, LDA_ARRAY, B_ARRAY, LDB_ARRAY, GROUP_COUNT, GROUP_SIZE) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: SIDE_ARRAY (*) character(len=1), intent(in) :: UPLO_ARRAY (*) character(len=1), intent(in) :: TRANSA_ARRAY (*) character(len=1), intent(in) :: DIAG_ARRAY (*) integer, intent(in) :: M_ARRAY (*) integer, intent(in) :: N_ARRAY (*) real(kind=WP), intent(in) :: ALPHA_ARRAY (*) integer(kind=C_SIZE_T), intent(in) :: A_ARRAY (*) integer, intent(in) :: LDA_ARRAY (*) integer(kind=C_SIZE_T), intent(in) :: B_ARRAY (*) integer, intent(in) :: LDB_ARRAY (*) integer, intent(in) :: GROUP_COUNT integer, intent(in) :: GROUP_SIZE (*) public subroutine STRSM_BATCH(SIDE_ARRAY, UPLO_ARRAY, TRANSA_ARRAY, DIAG_ARRAY, M_ARRAY, N_ARRAY, ALPHA_ARRAY, A_ARRAY, LDA_ARRAY, B_ARRAY, LDB_ARRAY, GROUP_COUNT, GROUP_SIZE) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: SIDE_ARRAY (*) character(len=1), intent(in) :: UPLO_ARRAY (*) character(len=1), intent(in) :: TRANSA_ARRAY (*) character(len=1), intent(in) :: DIAG_ARRAY (*) integer, intent(in) :: M_ARRAY (*) integer, intent(in) :: N_ARRAY (*) real(kind=WP), intent(in) :: ALPHA_ARRAY (*) integer(kind=C_SIZE_T), intent(in) :: A_ARRAY (*) integer, intent(in) :: LDA_ARRAY (*) integer(kind=C_SIZE_T), intent(in) :: B_ARRAY (*) integer, intent(in) :: LDB_ARRAY (*) integer, intent(in) :: GROUP_COUNT integer, intent(in) :: GROUP_SIZE (*) public subroutine ZTRSM_BATCH(SIDE_ARRAY, UPLO_ARRAY, TRANSA_ARRAY, DIAG_ARRAY, M_ARRAY, N_ARRAY, ALPHA_ARRAY, A_ARRAY, LDA_ARRAY, B_ARRAY, LDB_ARRAY, GROUP_COUNT, GROUP_SIZE) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: SIDE_ARRAY (*) character(len=1), intent(in) :: UPLO_ARRAY (*) character(len=1), intent(in) :: TRANSA_ARRAY (*) character(len=1), intent(in) :: DIAG_ARRAY (*) integer, intent(in) :: M_ARRAY (*) integer, intent(in) :: N_ARRAY (*) complex(kind=WP), intent(in) :: ALPHA_ARRAY (*) integer(kind=C_SIZE_T), intent(in) :: A_ARRAY (*) integer, intent(in) :: LDA_ARRAY (*) integer(kind=C_SIZE_T), intent(in) :: B_ARRAY (*) integer, intent(in) :: LDB_ARRAY (*) integer, intent(in) :: GROUP_COUNT integer, intent(in) :: GROUP_SIZE (*) public interface TRSV public subroutine CTRSV(UPLO, TRANS, DIAG, N, A, LDA, X, INCX) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS character(len=1), intent(in) :: DIAG integer, intent(in) :: N complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public subroutine DTRSV(UPLO, TRANS, DIAG, N, A, LDA, X, INCX) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS character(len=1), intent(in) :: DIAG integer, intent(in) :: N real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public subroutine STRSV(UPLO, TRANS, DIAG, N, A, LDA, X, INCX) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS character(len=1), intent(in) :: DIAG integer, intent(in) :: N real(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA real(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public subroutine ZTRSV(UPLO, TRANS, DIAG, N, A, LDA, X, INCX) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: UPLO character(len=1), intent(in) :: TRANS character(len=1), intent(in) :: DIAG integer, intent(in) :: N complex(kind=WP), intent(in) :: A (LDA,*) integer, intent(in) :: LDA complex(kind=WP), intent(inout) :: X (*) integer, intent(in) :: INCX public interface XERBLA public subroutine XERBLA(NAME, INFO) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: NAME integer, intent(in) :: INFO","tags":"","loc":"module/blasinterface.html"},{"title":"ErrorHandling – Fortran Program","text":"Module contains error handling procedures Uses GlobalData IO Contents Variables IO_CLOSE IO_OPEN IO_READ IO_WRITE OPT_ALLOC OPT_DEALLOC Subroutines AllocationErr ErrorMSG FileError WarningMSG Variables Type Visibility Attributes Name Initial integer(kind=I4B), public, parameter :: IO_CLOSE = 4 Constant for file close used by fErr integer(kind=I4B), public, parameter :: IO_OPEN = 1 Constant for file open used by fErr integer(kind=I4B), public, parameter :: IO_READ = 2 Constant for file read used by fErr integer(kind=I4B), public, parameter :: IO_WRITE = 3 Constant for file write used by fErr integer(kind=I4B), public, parameter :: OPT_ALLOC = 1 integer(kind=I4B), public, parameter :: OPT_DEALLOC = 2 Subroutines public subroutine AllocationErr (istat, aMsg, alloc, UnitNo, File, Routine, Line) Checks for successful (de)allocation.  Stops the code. Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: istat results of stat=istat in (de)allocate character(len=*), intent(in) :: aMsg Message associated with the (de)allocate integer(kind=I4B), intent(in) :: alloc 1 = allocate, 2 = deallocate integer(kind=I4B), intent(in), optional :: UnitNo Optional file id to write the message to character(len=*), intent(in) :: File Filename and routine name character(len=*), intent(in) :: Routine Filename and routine name integer(kind=I4B), intent(in) :: Line public subroutine ErrorMSG (Msg, File, Routine, Line, UnitNo) Write a message Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Msg Message to write character(len=*), intent(in) :: File Message to write character(len=*), intent(in) :: Routine Message to write integer(kind=I4B), intent(in) :: Line Line number integer(kind=I4B), intent(in), optional :: UnitNo file id to write the message to public subroutine FileError (istat, fname, flg, UnitNo, File, Routine, Line) Checks for a file error Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: istat Result of iostat=istat for open,read,write,close character(len=*), intent(in) :: fname Name of the file integer(kind=I4B), intent(in) :: flg IO_OPEN=Open, IO_READ=Read, IO_WRITE=Write, IO_CLOSE=Close integer(kind=I4B), intent(in), optional :: UnitNo file id to write the error to character(len=*), intent(in) :: File Filename and routine name character(len=*), intent(in) :: Routine Filename and routine name integer(kind=I4B), intent(in) :: Line public subroutine WarningMSG (Msg, File, Routine, Line, UnitNo) This subroutine prints the warning message Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Msg Message to write character(len=*), intent(in) :: File Message to write character(len=*), intent(in) :: Routine Message to write integer(kind=I4B), intent(in) :: Line Line number integer(kind=I4B), intent(in), optional :: UnitNo file id to write the message to","tags":"","loc":"module/errorhandling.html"},{"title":"AbstractVector_Method – Fortran Program","text":"Uses GlobalData BaseType Contents Interfaces Shape Size Functions get_shape get_size Interfaces public interface Shape private pure function get_shape (Obj) result(Ans) Arguments Type Intent Optional Attributes Name type( AbstractVector_ ), intent(in) :: Obj Return Value integer(kind=I4B)\n  (1) public interface Size private pure function get_size (Obj, Dims) result(Ans) Arguments Type Intent Optional Attributes Name type( AbstractVector_ ), intent(in) :: Obj integer(kind=I4B), intent(in), optional :: Dims Return Value integer(kind=I4B) Functions private pure function get_shape (Obj) result(Ans) Arguments Type Intent Optional Attributes Name type( AbstractVector_ ), intent(in) :: Obj Return Value integer(kind=I4B)\n  (1) private pure function get_size (Obj, Dims) result(Ans) Arguments Type Intent Optional Attributes Name type( AbstractVector_ ), intent(in) :: Obj integer(kind=I4B), intent(in), optional :: Dims Return Value integer(kind=I4B)","tags":"","loc":"module/abstractvector_method.html"},{"title":"Utility – Fortran Program","text":"Utility module contains useful general purpose routines Uses GlobalData IO ErrorHandling Contents Variables NPAR2_ARTH NPAR2_GEOP NPAR_ARTH NPAR_CUMPROD NPAR_CUMSUM NPAR_GEOP NPAR_POLY NPAR_POLYTERM Interfaces Append Cross_Product Degrees Det EvaluatePolynomial ExecuteCommand HeapSort IMAXLOC IMINLOC Input Inv LOC_NearestPoint OUTERPROD Real2Str Reallocate SWAP SearchNearestCoord VectorProduct arth assert_eq matmul outerdIFf radian Functions CROSS_PRODUCT_R1_R1 DP2Str Factorial Int2Str Loc_Nearest_Point OUTERPROD1_1 OUTERPROD1_1_sym OUTERPROD2_1 OUTERPROD2_11 OUTERPROD3_1 SP2Str arth_d arth_i arth_r assert_eq2 assert_eq3 assert_eq4 assert_eqn degrees_dfp det_2D det_3D eval_poly getExtension getUnitNo imaxloc_i imaxloc_r iminloc_r input_Int input_IntArray input_IntVec input_Real input_RealArray input_Realvec input_String input_logical matmul_r1_r3 matmul_r2_r3 matmul_r3_r1 matmul_r3_r2 matmul_r4_r1 outerdIFf_d outerdIFf_i outerdIFf_r radian_dfp radian_int vec_prod Subroutines Append_I1 Append_I2 Append_R1 Append_R2 HEAPSORT_INT HEAPSORT_REAL Inv_2D Inv_3D Rank1ToRank3 Reallocate1 Reallocate10 Reallocate2 Reallocate3 Reallocate4 Reallocate5 Reallocate6 Reallocate7 Reallocate8 Reallocate9 exe_cmd masked_swap_rm masked_swap_rs masked_swap_rv nrerror swap_c swap_cm swap_cv swap_i swap_r swap_rv Variables Type Visibility Attributes Name Initial integer(kind=I4B), private, parameter :: NPAR2_ARTH = 8 integer(kind=I4B), private, parameter :: NPAR2_GEOP = 2 integer(kind=I4B), private, parameter :: NPAR_ARTH = 16 integer(kind=I4B), private, parameter :: NPAR_CUMPROD = 8 integer(kind=I4B), private, parameter :: NPAR_CUMSUM = 16 integer(kind=I4B), private, parameter :: NPAR_GEOP = 4 integer(kind=I4B), private, parameter :: NPAR_POLY = 8 integer(kind=I4B), private, parameter :: NPAR_POLYTERM = 8 Interfaces public interface Append private subroutine Append_I1 (A, Entry) Append scalar INTEGER  to  INTEGER  vec tor Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), ALLOCATABLE :: A (:) integer(kind=I4B), intent(in) :: Entry private subroutine Append_I2 (A, Entry) Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), ALLOCATABLE :: A (:) integer(kind=I4B), intent(in) :: Entry (:) private subroutine Append_R1 (A, Entry) Read more… Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: A (:) real(kind=DFP), intent(in) :: Entry private subroutine Append_R2 (A, Entry) Append vector of REAL to REAL-vector Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: A (:) real(kind=DFP), intent(in) :: Entry (:) public interface Cross_Product private pure function CROSS_PRODUCT_R1_R1 (a, b) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a (3) real(kind=DFP), intent(in) :: b (3) Return Value real(kind=DFP)\n  (3) public interface Degrees private pure function degrees_dfp (rad) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: rad Return Value real(kind=DFP) public interface Det Generic FUNCTION to get determinent of 2x2 and 3x3 matrix private pure function det_2D (A) result(Ans) This FUNCTION returns determinent of 2 by 2 and 3 by 3 matrix Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: A (:,:) Return Value real(kind=DFP) private pure function det_3D (A) result(Ans) This FUNCTION returns the determinent of matrix Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: A (:,:,:) Return Value real(kind=DFP),\n  ALLOCATABLE, (:) public interface EvaluatePolynomial Generic FUNCTION to evaluate a polynomial private function eval_poly (PowerTable, Coeff, X, tTerms) result(Ans) this FUNCTION evaluate a polynomial\n - Power table contains the power of x, y, z\n - Its shape IF ( tTerms, 3 )\n    - Coeff is vector its size is tTerms\n    - X( 3 ) contains x, y, z Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in), DIMENSION( tTerms, 3 ) :: PowerTable real(kind=DFP), intent(in), DIMENSION( tTerms ) :: Coeff real(kind=DFP), intent(in) :: X (3) integer(kind=I4B), intent(in) :: tTerms Return Value real(kind=DFP) public interface ExecuteCommand private subroutine exe_cmd (CMD, Str) This subroutine run a system commoand on terminal Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: CMD character(len=*), intent(in) :: Str public interface HeapSort private subroutine HEAPSORT_INT (array) Heap Sort algorithm for Integer Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout) :: array (:) private subroutine HEAPSORT_REAL (array) Heap Sort algorithm for Real Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout) :: array (:) public interface IMAXLOC Generic FUNCTION to get local of maximum value private pure function imaxloc_r (arr) Function for getting location of maximum value Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in), DIMENSION(:) :: arr Return Value integer(kind=I4B) private pure function imaxloc_i (iarr) Function for getting location of maximum value Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION(:) :: iarr Return Value integer(kind=I4B) public interface IMINLOC Generic FUNCTION for getting location of minmum value private function iminloc_r (arr) Function for getting location of minimum value Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in), DIMENSION(:) :: arr Return Value integer(kind=I4B) public interface Input private pure function input_Int (default, option) result(val) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: default integer(kind=I4B), intent(in), optional :: option Return Value integer(kind=I4B) private function input_Real (default, option) result(val) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: default real(kind=DFP), intent(in), optional :: option Return Value real(kind=DFP) private function input_IntVec (default, option) result(val) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: default (:) integer(kind=I4B), intent(in), optional :: option (:) Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) private function input_Realvec (default, option) result(val) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: default (:) real(kind=DFP), intent(in), optional :: option (:) Return Value real(kind=DFP),\n  ALLOCATABLE, (:) private pure function input_IntArray (default, option) result(val) This function input integer array Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: default (:,:) integer(kind=I4B), intent(in), optional :: option (:,:) Return Value integer(kind=I4B),\n  ALLOCATABLE, (:,:) private pure function input_RealArray (default, option) result(val) This function input real array Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: default (:,:) real(kind=DFP), intent(in), optional :: option (:,:) Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) private pure function input_String (default, option) result(val) This function input string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: default character(len=*), intent(in), optional :: option Return Value character(len=200) private pure function input_logical (default, option) result(val) This function input logical variables Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(in) :: default logical(kind=LGT), intent(in), optional :: option Return Value logical(kind=LGT) public interface Inv Generic subroutine to get inverse of 2x2 and 3x3 matrix private subroutine Inv_2D (invA, A) This subroutine returns inverse of 2 by 2 and 3 by 3 matrix Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout) :: invA (:,:) real(kind=DFP), intent(in) :: A (:,:) private subroutine Inv_3D (invA, A) This subroutine returns inverse of 2 by 2 and 3 by 3 matrix Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout) :: invA (:,:,:) real(kind=DFP), intent(in) :: A (:,:,:) public interface LOC_NearestPoint private function Loc_Nearest_Point (Array, x) result(id) This subroutine search the location of nearest point to x in the\n array of coordinates; Array Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Array (:,:) Nodal coordinates in XiJ format real(kind=DFP), intent(in) :: x (:) Return Value integer(kind=I4B) public interface OUTERPROD Generic FUNCTION to evaluate outerproduct. private pure function OUTERPROD1_1 (a, b) result(Ans) This FUNCTION returns outerproduct(matrix) of two vectors \\mathbf{ans} = \\mathbf{a} \\otimes \\mathbf{b} Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in), DIMENSION(:) :: a real(kind=DFP), intent(in), DIMENSION(:) :: b Return Value real(kind=DFP),\n  DIMENSION(SIZE(a),SIZE(b)) private pure function OUTERPROD2_1 (a, b) result(Ans) This FUNCTION returns outerprod between a matrix and a vector Ans(:,:,i) = a(:,:) * b(i) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a (:,:) real(kind=DFP), intent(in) :: b (:) Return Value real(kind=DFP)\n  (SIZE(a,1),SIZE(a,2),SIZE(b)) private pure function OUTERPROD3_1 (a, b) result(Ans) This FUNCTION evaluate outerproduct between a 3D matrix and a vector\n - Ans( :, :, :,  I ) = a( :, :, : ) * b( I ) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a (:,:,:) real(kind=DFP), intent(in) :: b (:) Return Value real(kind=DFP)\n  (SIZE(a,1),SIZE(a,2),SIZE(a,3),SIZE(b)) private pure function OUTERPROD2_11 (a, b, c) result(ANS) This FUNCTION evaluates outer product between a matrix and two vector Read more… Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a (:,:) real(kind=DFP), intent(in) :: b (:) real(kind=DFP), intent(in) :: c (:) Return Value real(kind=DFP)\n  (SIZE(a,1),SIZE(a,2),SIZE(b),SIZE(c)) private pure function OUTERPROD1_1_sym (a, b, Sym) result(Ans) This FUNCTION returns outerproduct(matrix) of two vectors\n - \\mathbf{ans} = \\mathbf{a} \\otimes \\mathbf{b} - If Sym is .true. THEN symmetric part is returned Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a (:) real(kind=DFP), intent(in) :: b (:) logical(kind=LGT), intent(in) :: Sym Return Value real(kind=DFP),\n  DIMENSION(SIZE(a),SIZE(b)) public interface Real2Str private function SP2Str (I) Convert REAL to string Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: I Return Value character(len=20) private function DP2Str (I) Convert REAL to string Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: I Return Value character(len=20) public interface Reallocate Generic subroutine to reallocate arrays private subroutine Reallocate1 (Mat, row, col) Reallocate a 2D array Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: Mat (:,:) integer(kind=I4B), intent(in) :: row integer(kind=I4B), intent(in) :: col private subroutine Reallocate2 (Mat, row) This subroutine reallocates a vector Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: Mat (:) integer(kind=I4B), intent(in) :: row private subroutine Reallocate3 (Mat, i1, i2, i3) This subroutine reallocates a 3D array Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: Mat (:,:,:) integer(kind=I4B), intent(in) :: i1 integer(kind=I4B), intent(in) :: i2 integer(kind=I4B), intent(in) :: i3 private subroutine Reallocate4 (Mat, row, col) This subroutine reallocates a 2D matrix Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), ALLOCATABLE :: Mat (:,:) integer(kind=I4B), intent(in) :: row integer(kind=I4B), intent(in) :: col private subroutine Reallocate5 (Mat, row) This subroutine reallocates a vector Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), ALLOCATABLE :: Mat (:) integer(kind=I4B), intent(in) :: row private subroutine Reallocate6 (Vec1, n1, Vec2, n2, Vec3, n3, Vec4, n4, Vec5, n5, Vec6, n6) This subroutine can reallocates upto six vectors Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), ALLOCATABLE :: Vec1 (:) integer(kind=I4B), intent(in) :: n1 integer(kind=I4B), intent(inout), ALLOCATABLE :: Vec2 (:) integer(kind=I4B), intent(in) :: n2 integer(kind=I4B), intent(inout), optional ALLOCATABLE :: Vec3 (:) integer(kind=I4B), intent(in), optional :: n3 integer(kind=I4B), intent(inout), optional ALLOCATABLE :: Vec4 (:) integer(kind=I4B), intent(in), optional :: n4 integer(kind=I4B), intent(inout), optional ALLOCATABLE :: Vec5 (:) integer(kind=I4B), intent(in), optional :: n5 integer(kind=I4B), intent(inout), optional ALLOCATABLE :: Vec6 (:) integer(kind=I4B), intent(in), optional :: n6 private subroutine Reallocate7 (Vec1, n1, Vec2, n2, Vec3, n3, Vec4, n4, Vec5, n5, Vec6, n6) This subroutine can reallocate upto six vectors Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: Vec1 (:) integer(kind=I4B), intent(in) :: n1 real(kind=DFP), intent(inout), ALLOCATABLE :: Vec2 (:) integer(kind=I4B), intent(in) :: n2 real(kind=DFP), intent(inout), optional ALLOCATABLE :: Vec3 (:) integer(kind=I4B), intent(in), optional :: n3 real(kind=DFP), intent(inout), optional ALLOCATABLE :: Vec4 (:) integer(kind=I4B), intent(in), optional :: n4 real(kind=DFP), intent(inout), optional ALLOCATABLE :: Vec5 (:) integer(kind=I4B), intent(in), optional :: n5 real(kind=DFP), intent(inout), optional ALLOCATABLE :: Vec6 (:) integer(kind=I4B), intent(in), optional :: n6 private subroutine Reallocate8 (A, nA, IA, nIA, JA, nJA) This subroutine can reallocate three vectors; it is useful for\n sparse matrix related methods Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: A (:) integer(kind=I4B), intent(in) :: nA integer(kind=I4B), intent(inout), ALLOCATABLE :: IA (:) integer(kind=I4B), intent(in) :: nIA integer(kind=I4B), intent(inout), ALLOCATABLE :: JA (:) integer(kind=I4B), intent(in) :: nJA private subroutine Reallocate9 (A, nA, IA, nIA) This subroutine can reallocate two vectors Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: A (:) integer(kind=I4B), intent(in) :: nA integer(kind=I4B), intent(inout), ALLOCATABLE :: IA (:) integer(kind=I4B), intent(in) :: nIA private subroutine Reallocate10 (Mat, i1, i2, i3, i4) This subroutine reallocates a 3D array Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: Mat (:,:,:,:) integer(kind=I4B), intent(in) :: i1 integer(kind=I4B), intent(in) :: i2 integer(kind=I4B), intent(in) :: i3 integer(kind=I4B), intent(in) :: i4 public interface SWAP Generic subroutine for swapping private subroutine swap_i (a, b) Subroutine for interchanging two INTEGER Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout) :: a integer(kind=I4B), intent(inout) :: b private subroutine swap_r (a, b) Subroutine for interchanging two REAL numbers Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout) :: a real(kind=DFP), intent(inout) :: b private subroutine swap_rv (a, b) Subroutine for interchanging two REAL valued vectors Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), DIMENSION(:) :: a real(kind=DFP), intent(inout), DIMENSION(:) :: b private subroutine swap_c (a, b) Subroutine for interchanging two complex numbers Arguments Type Intent Optional Attributes Name complex(kind=DFPC), intent(inout) :: a complex(kind=DFPC), intent(inout) :: b private subroutine swap_cv (a, b) Subroutine for interchanging two complexed valued vectors Arguments Type Intent Optional Attributes Name complex(kind=DFPC), intent(inout), DIMENSION(:) :: a complex(kind=DFPC), intent(inout), DIMENSION(:) :: b private subroutine swap_cm (a, b) Subroutine for interchanging two complexed valued matrices Arguments Type Intent Optional Attributes Name complex(kind=DFPC), intent(inout), DIMENSION(:,:) :: a complex(kind=DFPC), intent(inout), DIMENSION(:,:) :: b private subroutine masked_swap_rs (a, b, mask) Subroutine for interchanging two REAL valued number Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout) :: a real(kind=DFP), intent(inout) :: b logical(kind=LGT), intent(in) :: mask private subroutine masked_swap_rv (a, b, mask) Subroutine for interchanging two REAL valued vectors Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), DIMENSION(:) :: a real(kind=DFP), intent(inout), DIMENSION(:) :: b logical(kind=LGT), intent(in), DIMENSION(:) :: mask private subroutine masked_swap_rm (a, b, mask) Subroutine for interchanging two REAL valued matrices Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), DIMENSION(:,:) :: a real(kind=DFP), intent(inout), DIMENSION(:,:) :: b logical(kind=LGT), intent(in), DIMENSION(:,:) :: mask public interface SearchNearestCoord private function Loc_Nearest_Point (Array, x) result(id) This subroutine search the location of nearest point to x in the\n array of coordinates; Array Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Array (:,:) Nodal coordinates in XiJ format real(kind=DFP), intent(in) :: x (:) Return Value integer(kind=I4B) public interface VectorProduct Generic FUNCTION to evaluate vector product private pure function vec_prod (a, b) result(c) This FUNCTION evaluate vectors product \\mathbf{ans} = \\mathbf{a} \\times \\mathbf{b} Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a (3) real(kind=DFP), intent(in) :: b (3) Return Value real(kind=DFP)\n  (3) public interface arth private pure function arth_r (first, increment, n) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: first real(kind=SP), intent(in) :: increment integer(kind=I4B), intent(in) :: n Return Value real(kind=SP),\n  DIMENSION(n) private pure function arth_d (first, increment, n) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: first real(kind=DP), intent(in) :: increment integer(kind=I4B), intent(in) :: n Return Value real(kind=DP),\n  DIMENSION(n) private pure function arth_i (first, increment, n) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: first integer(kind=I4B), intent(in) :: increment integer(kind=I4B), intent(in) :: n Return Value integer(kind=I4B),\n  DIMENSION(n) public interface assert_eq private function assert_eq2 (n1, n2, string) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n1 integer(kind=I4B), intent(in) :: n2 character(len=*), intent(in) :: string Return Value integer(kind=I4B) private function assert_eq3 (n1, n2, n3, string) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n1 integer(kind=I4B), intent(in) :: n2 integer(kind=I4B), intent(in) :: n3 character(len=*), intent(in) :: string Return Value integer(kind=I4B) private function assert_eq4 (n1, n2, n3, n4, string) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n1 integer(kind=I4B), intent(in) :: n2 integer(kind=I4B), intent(in) :: n3 integer(kind=I4B), intent(in) :: n4 character(len=*), intent(in) :: string Return Value integer(kind=I4B) private function assert_eqn (nn, string) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION( : ) :: nn character(len=*), intent(in) :: string Return Value integer(kind=I4B) public interface matmul private pure function matmul_r3_r1 (a1, a2) result(Ans) This fuction performs following task Ans(:,:) = a1(:,:,a)*a2(a) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a1 (:,:,:) real(kind=DFP), intent(in) :: a2 (:) Return Value real(kind=DFP)\n  (size(a1,1),size(a1,2)) private pure function matmul_r4_r1 (a1, a2) result(Ans) This fuction performs following task Ans(:,:,:) = a1(:,:,:,a)*a2(a) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a1 (:,:,:,:) real(kind=DFP), intent(in) :: a2 (:) Return Value real(kind=DFP)\n  (size(a1,1),size(a1,2),size(a1,3)) private pure function matmul_r3_r2 (a1, a2) result(Ans) This fuction performs following task Ans(i,j,ip) = a1(i,j,I)*a2(I,ip) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a1 (:,:,:) real(kind=DFP), intent(in) :: a2 (:,:) Return Value real(kind=DFP)\n  (size(a1,1),size(a1,2),size(a2,2)) private pure function matmul_r1_r3 (a1, a2) result(Ans) This fuction performs following task Ans(i,j) = a1(a)*a2(a,i,j) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a1 (:) real(kind=DFP), intent(in) :: a2 (:,:,:) Return Value real(kind=DFP)\n  (size(a2,2),size(a2,3)) private pure function matmul_r2_r3 (a1, a2) result(Ans) This fuction performs following task Ans(i,j,ip) = a1(i,I)*a2(I,j,ip) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a1 (:,:) real(kind=DFP), intent(in) :: a2 (:,:,:) Return Value real(kind=DFP)\n  (size(a1,1),size(a2,2),size(a2,3)) public interface outerdIFf private pure function outerdIFf_r (a, b) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: a real(kind=SP), intent(in), DIMENSION(:) :: b Return Value real(kind=SP),\n  DIMENSION(size(a),size(b)) private pure function outerdIFf_i (a, b) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION(:) :: a integer(kind=I4B), intent(in), DIMENSION(:) :: b Return Value integer(kind=I4B),\n  DIMENSION(size(a),size(b)) private pure function outerdIFf_d (a, b) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: a real(kind=DP), intent(in), DIMENSION(:) :: b Return Value real(kind=DP),\n  DIMENSION(size(a),size(b)) public interface radian private pure function radian_dfp (deg) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: deg Return Value real(kind=DFP) private pure function radian_int (deg) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: deg Return Value real(kind=DFP) Functions private pure function CROSS_PRODUCT_R1_R1 (a, b) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a (3) real(kind=DFP), intent(in) :: b (3) Return Value real(kind=DFP)\n  (3) private function DP2Str (I) Convert REAL to string Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: I Return Value character(len=20) public recursive function Factorial (N) result(Fact) This FUNCTION computes the factorial of an INTEGER Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: N Return Value integer(kind=I4B) public pure function Int2Str (I) Convert INTEGER  to  string Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: I Return Value character(len=15) private function Loc_Nearest_Point (Array, x) result(id) This subroutine search the location of nearest point to x in the\n array of coordinates; Array Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Array (:,:) Nodal coordinates in XiJ format real(kind=DFP), intent(in) :: x (:) Return Value integer(kind=I4B) private pure function OUTERPROD1_1 (a, b) result(Ans) This FUNCTION returns outerproduct(matrix) of two vectors \\mathbf{ans} = \\mathbf{a} \\otimes \\mathbf{b} Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in), DIMENSION(:) :: a real(kind=DFP), intent(in), DIMENSION(:) :: b Return Value real(kind=DFP),\n  DIMENSION(SIZE(a),SIZE(b)) private pure function OUTERPROD1_1_sym (a, b, Sym) result(Ans) This FUNCTION returns outerproduct(matrix) of two vectors\n - \\mathbf{ans} = \\mathbf{a} \\otimes \\mathbf{b} - If Sym is .true. THEN symmetric part is returned Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a (:) real(kind=DFP), intent(in) :: b (:) logical(kind=LGT), intent(in) :: Sym Return Value real(kind=DFP),\n  DIMENSION(SIZE(a),SIZE(b)) private pure function OUTERPROD2_1 (a, b) result(Ans) This FUNCTION returns outerprod between a matrix and a vector Ans(:,:,i) = a(:,:) * b(i) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a (:,:) real(kind=DFP), intent(in) :: b (:) Return Value real(kind=DFP)\n  (SIZE(a,1),SIZE(a,2),SIZE(b)) private pure function OUTERPROD2_11 (a, b, c) result(ANS) This FUNCTION evaluates outer product between a matrix and two vector Read more… Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a (:,:) real(kind=DFP), intent(in) :: b (:) real(kind=DFP), intent(in) :: c (:) Return Value real(kind=DFP)\n  (SIZE(a,1),SIZE(a,2),SIZE(b),SIZE(c)) private pure function OUTERPROD3_1 (a, b) result(Ans) This FUNCTION evaluate outerproduct between a 3D matrix and a vector\n - Ans( :, :, :,  I ) = a( :, :, : ) * b( I ) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a (:,:,:) real(kind=DFP), intent(in) :: b (:) Return Value real(kind=DFP)\n  (SIZE(a,1),SIZE(a,2),SIZE(a,3),SIZE(b)) private function SP2Str (I) Convert REAL to string Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: I Return Value character(len=20) private pure function arth_d (first, increment, n) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: first real(kind=DP), intent(in) :: increment integer(kind=I4B), intent(in) :: n Return Value real(kind=DP),\n  DIMENSION(n) private pure function arth_i (first, increment, n) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: first integer(kind=I4B), intent(in) :: increment integer(kind=I4B), intent(in) :: n Return Value integer(kind=I4B),\n  DIMENSION(n) private pure function arth_r (first, increment, n) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in) :: first real(kind=SP), intent(in) :: increment integer(kind=I4B), intent(in) :: n Return Value real(kind=SP),\n  DIMENSION(n) private function assert_eq2 (n1, n2, string) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n1 integer(kind=I4B), intent(in) :: n2 character(len=*), intent(in) :: string Return Value integer(kind=I4B) private function assert_eq3 (n1, n2, n3, string) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n1 integer(kind=I4B), intent(in) :: n2 integer(kind=I4B), intent(in) :: n3 character(len=*), intent(in) :: string Return Value integer(kind=I4B) private function assert_eq4 (n1, n2, n3, n4, string) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: n1 integer(kind=I4B), intent(in) :: n2 integer(kind=I4B), intent(in) :: n3 integer(kind=I4B), intent(in) :: n4 character(len=*), intent(in) :: string Return Value integer(kind=I4B) private function assert_eqn (nn, string) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION( : ) :: nn character(len=*), intent(in) :: string Return Value integer(kind=I4B) private pure function degrees_dfp (rad) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: rad Return Value real(kind=DFP) private pure function det_2D (A) result(Ans) This FUNCTION returns determinent of 2 by 2 and 3 by 3 matrix Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: A (:,:) Return Value real(kind=DFP) private pure function det_3D (A) result(Ans) This FUNCTION returns the determinent of matrix Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: A (:,:,:) Return Value real(kind=DFP),\n  ALLOCATABLE, (:) private function eval_poly (PowerTable, Coeff, X, tTerms) result(Ans) this FUNCTION evaluate a polynomial\n - Power table contains the power of x, y, z\n - Its shape IF ( tTerms, 3 )\n    - Coeff is vector its size is tTerms\n    - X( 3 ) contains x, y, z Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in), DIMENSION( tTerms, 3 ) :: PowerTable real(kind=DFP), intent(in), DIMENSION( tTerms ) :: Coeff real(kind=DFP), intent(in) :: X (3) integer(kind=I4B), intent(in) :: tTerms Return Value real(kind=DFP) public function getExtension (char) result(ext) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: char Return Value character(len=7) public function getUnitNo (Str) This FUNCTION returns valid unit no for input output Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Str Return Value integer(kind=I4B) private pure function imaxloc_i (iarr) Function for getting location of maximum value Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION(:) :: iarr Return Value integer(kind=I4B) private pure function imaxloc_r (arr) Function for getting location of maximum value Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in), DIMENSION(:) :: arr Return Value integer(kind=I4B) private function iminloc_r (arr) Function for getting location of minimum value Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in), DIMENSION(:) :: arr Return Value integer(kind=I4B) private pure function input_Int (default, option) result(val) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: default integer(kind=I4B), intent(in), optional :: option Return Value integer(kind=I4B) private pure function input_IntArray (default, option) result(val) This function input integer array Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: default (:,:) integer(kind=I4B), intent(in), optional :: option (:,:) Return Value integer(kind=I4B),\n  ALLOCATABLE, (:,:) private function input_IntVec (default, option) result(val) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: default (:) integer(kind=I4B), intent(in), optional :: option (:) Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) private function input_Real (default, option) result(val) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: default real(kind=DFP), intent(in), optional :: option Return Value real(kind=DFP) private pure function input_RealArray (default, option) result(val) This function input real array Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: default (:,:) real(kind=DFP), intent(in), optional :: option (:,:) Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) private function input_Realvec (default, option) result(val) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: default (:) real(kind=DFP), intent(in), optional :: option (:) Return Value real(kind=DFP),\n  ALLOCATABLE, (:) private pure function input_String (default, option) result(val) This function input string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: default character(len=*), intent(in), optional :: option Return Value character(len=200) private pure function input_logical (default, option) result(val) This function input logical variables Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(in) :: default logical(kind=LGT), intent(in), optional :: option Return Value logical(kind=LGT) private pure function matmul_r1_r3 (a1, a2) result(Ans) This fuction performs following task Ans(i,j) = a1(a)*a2(a,i,j) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a1 (:) real(kind=DFP), intent(in) :: a2 (:,:,:) Return Value real(kind=DFP)\n  (size(a2,2),size(a2,3)) private pure function matmul_r2_r3 (a1, a2) result(Ans) This fuction performs following task Ans(i,j,ip) = a1(i,I)*a2(I,j,ip) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a1 (:,:) real(kind=DFP), intent(in) :: a2 (:,:,:) Return Value real(kind=DFP)\n  (size(a1,1),size(a2,2),size(a2,3)) private pure function matmul_r3_r1 (a1, a2) result(Ans) This fuction performs following task Ans(:,:) = a1(:,:,a)*a2(a) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a1 (:,:,:) real(kind=DFP), intent(in) :: a2 (:) Return Value real(kind=DFP)\n  (size(a1,1),size(a1,2)) private pure function matmul_r3_r2 (a1, a2) result(Ans) This fuction performs following task Ans(i,j,ip) = a1(i,j,I)*a2(I,ip) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a1 (:,:,:) real(kind=DFP), intent(in) :: a2 (:,:) Return Value real(kind=DFP)\n  (size(a1,1),size(a1,2),size(a2,2)) private pure function matmul_r4_r1 (a1, a2) result(Ans) This fuction performs following task Ans(:,:,:) = a1(:,:,:,a)*a2(a) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a1 (:,:,:,:) real(kind=DFP), intent(in) :: a2 (:) Return Value real(kind=DFP)\n  (size(a1,1),size(a1,2),size(a1,3)) private pure function outerdIFf_d (a, b) Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in), DIMENSION(:) :: a real(kind=DP), intent(in), DIMENSION(:) :: b Return Value real(kind=DP),\n  DIMENSION(size(a),size(b)) private pure function outerdIFf_i (a, b) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION(:) :: a integer(kind=I4B), intent(in), DIMENSION(:) :: b Return Value integer(kind=I4B),\n  DIMENSION(size(a),size(b)) private pure function outerdIFf_r (a, b) Arguments Type Intent Optional Attributes Name real(kind=SP), intent(in), DIMENSION(:) :: a real(kind=SP), intent(in), DIMENSION(:) :: b Return Value real(kind=SP),\n  DIMENSION(size(a),size(b)) private pure function radian_dfp (deg) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: deg Return Value real(kind=DFP) private pure function radian_int (deg) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: deg Return Value real(kind=DFP) private pure function vec_prod (a, b) result(c) This FUNCTION evaluate vectors product \\mathbf{ans} = \\mathbf{a} \\times \\mathbf{b} Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a (3) real(kind=DFP), intent(in) :: b (3) Return Value real(kind=DFP)\n  (3) Subroutines private subroutine Append_I1 (A, Entry) Append scalar INTEGER  to  INTEGER  vec tor Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), ALLOCATABLE :: A (:) integer(kind=I4B), intent(in) :: Entry private subroutine Append_I2 (A, Entry) Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), ALLOCATABLE :: A (:) integer(kind=I4B), intent(in) :: Entry (:) private subroutine Append_R1 (A, Entry) Read more… Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: A (:) real(kind=DFP), intent(in) :: Entry private subroutine Append_R2 (A, Entry) Append vector of REAL to REAL-vector Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: A (:) real(kind=DFP), intent(in) :: Entry (:) private subroutine HEAPSORT_INT (array) Heap Sort algorithm for Integer Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout) :: array (:) private subroutine HEAPSORT_REAL (array) Heap Sort algorithm for Real Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout) :: array (:) private subroutine Inv_2D (invA, A) This subroutine returns inverse of 2 by 2 and 3 by 3 matrix Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout) :: invA (:,:) real(kind=DFP), intent(in) :: A (:,:) private subroutine Inv_3D (invA, A) This subroutine returns inverse of 2 by 2 and 3 by 3 matrix Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout) :: invA (:,:,:) real(kind=DFP), intent(in) :: A (:,:,:) private subroutine Rank1ToRank3 (R1, R3, NSD, NNS, NNT) Returns a 3D arrays of pointers Arguments Type Intent Optional Attributes Name real(kind=DFP), DIMENSION( : ), CONTIGUOUS, TARGET :: R1 real(kind=DFP), DIMENSION( :, :, : ), POINTER :: R3 integer(kind=I4B), intent(in) :: NSD integer(kind=I4B), intent(in) :: NNS integer(kind=I4B), intent(in) :: NNT private subroutine Reallocate1 (Mat, row, col) Reallocate a 2D array Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: Mat (:,:) integer(kind=I4B), intent(in) :: row integer(kind=I4B), intent(in) :: col private subroutine Reallocate10 (Mat, i1, i2, i3, i4) This subroutine reallocates a 3D array Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: Mat (:,:,:,:) integer(kind=I4B), intent(in) :: i1 integer(kind=I4B), intent(in) :: i2 integer(kind=I4B), intent(in) :: i3 integer(kind=I4B), intent(in) :: i4 private subroutine Reallocate2 (Mat, row) This subroutine reallocates a vector Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: Mat (:) integer(kind=I4B), intent(in) :: row private subroutine Reallocate3 (Mat, i1, i2, i3) This subroutine reallocates a 3D array Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: Mat (:,:,:) integer(kind=I4B), intent(in) :: i1 integer(kind=I4B), intent(in) :: i2 integer(kind=I4B), intent(in) :: i3 private subroutine Reallocate4 (Mat, row, col) This subroutine reallocates a 2D matrix Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), ALLOCATABLE :: Mat (:,:) integer(kind=I4B), intent(in) :: row integer(kind=I4B), intent(in) :: col private subroutine Reallocate5 (Mat, row) This subroutine reallocates a vector Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), ALLOCATABLE :: Mat (:) integer(kind=I4B), intent(in) :: row private subroutine Reallocate6 (Vec1, n1, Vec2, n2, Vec3, n3, Vec4, n4, Vec5, n5, Vec6, n6) This subroutine can reallocates upto six vectors Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), ALLOCATABLE :: Vec1 (:) integer(kind=I4B), intent(in) :: n1 integer(kind=I4B), intent(inout), ALLOCATABLE :: Vec2 (:) integer(kind=I4B), intent(in) :: n2 integer(kind=I4B), intent(inout), optional ALLOCATABLE :: Vec3 (:) integer(kind=I4B), intent(in), optional :: n3 integer(kind=I4B), intent(inout), optional ALLOCATABLE :: Vec4 (:) integer(kind=I4B), intent(in), optional :: n4 integer(kind=I4B), intent(inout), optional ALLOCATABLE :: Vec5 (:) integer(kind=I4B), intent(in), optional :: n5 integer(kind=I4B), intent(inout), optional ALLOCATABLE :: Vec6 (:) integer(kind=I4B), intent(in), optional :: n6 private subroutine Reallocate7 (Vec1, n1, Vec2, n2, Vec3, n3, Vec4, n4, Vec5, n5, Vec6, n6) This subroutine can reallocate upto six vectors Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: Vec1 (:) integer(kind=I4B), intent(in) :: n1 real(kind=DFP), intent(inout), ALLOCATABLE :: Vec2 (:) integer(kind=I4B), intent(in) :: n2 real(kind=DFP), intent(inout), optional ALLOCATABLE :: Vec3 (:) integer(kind=I4B), intent(in), optional :: n3 real(kind=DFP), intent(inout), optional ALLOCATABLE :: Vec4 (:) integer(kind=I4B), intent(in), optional :: n4 real(kind=DFP), intent(inout), optional ALLOCATABLE :: Vec5 (:) integer(kind=I4B), intent(in), optional :: n5 real(kind=DFP), intent(inout), optional ALLOCATABLE :: Vec6 (:) integer(kind=I4B), intent(in), optional :: n6 private subroutine Reallocate8 (A, nA, IA, nIA, JA, nJA) This subroutine can reallocate three vectors; it is useful for\n sparse matrix related methods Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: A (:) integer(kind=I4B), intent(in) :: nA integer(kind=I4B), intent(inout), ALLOCATABLE :: IA (:) integer(kind=I4B), intent(in) :: nIA integer(kind=I4B), intent(inout), ALLOCATABLE :: JA (:) integer(kind=I4B), intent(in) :: nJA private subroutine Reallocate9 (A, nA, IA, nIA) This subroutine can reallocate two vectors Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: A (:) integer(kind=I4B), intent(in) :: nA integer(kind=I4B), intent(inout), ALLOCATABLE :: IA (:) integer(kind=I4B), intent(in) :: nIA private subroutine exe_cmd (CMD, Str) This subroutine run a system commoand on terminal Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: CMD character(len=*), intent(in) :: Str private subroutine masked_swap_rm (a, b, mask) Subroutine for interchanging two REAL valued matrices Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), DIMENSION(:,:) :: a real(kind=DFP), intent(inout), DIMENSION(:,:) :: b logical(kind=LGT), intent(in), DIMENSION(:,:) :: mask private subroutine masked_swap_rs (a, b, mask) Subroutine for interchanging two REAL valued number Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout) :: a real(kind=DFP), intent(inout) :: b logical(kind=LGT), intent(in) :: mask private subroutine masked_swap_rv (a, b, mask) Subroutine for interchanging two REAL valued vectors Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), DIMENSION(:) :: a real(kind=DFP), intent(inout), DIMENSION(:) :: b logical(kind=LGT), intent(in), DIMENSION(:) :: mask private subroutine nrerror (string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string private subroutine swap_c (a, b) Subroutine for interchanging two complex numbers Arguments Type Intent Optional Attributes Name complex(kind=DFPC), intent(inout) :: a complex(kind=DFPC), intent(inout) :: b private subroutine swap_cm (a, b) Subroutine for interchanging two complexed valued matrices Arguments Type Intent Optional Attributes Name complex(kind=DFPC), intent(inout), DIMENSION(:,:) :: a complex(kind=DFPC), intent(inout), DIMENSION(:,:) :: b private subroutine swap_cv (a, b) Subroutine for interchanging two complexed valued vectors Arguments Type Intent Optional Attributes Name complex(kind=DFPC), intent(inout), DIMENSION(:) :: a complex(kind=DFPC), intent(inout), DIMENSION(:) :: b private subroutine swap_i (a, b) Subroutine for interchanging two INTEGER Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout) :: a integer(kind=I4B), intent(inout) :: b private subroutine swap_r (a, b) Subroutine for interchanging two REAL numbers Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout) :: a real(kind=DFP), intent(inout) :: b private subroutine swap_rv (a, b) Subroutine for interchanging two REAL valued vectors Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), DIMENSION(:) :: a real(kind=DFP), intent(inout), DIMENSION(:) :: b","tags":"","loc":"module/utility.html"},{"title":"AbstractArray_Method – Fortran Program","text":"Uses GlobalData BaseType Contents Interfaces Shape Size TotalDimension setTotalDimension Functions get_shape get_size get_tdimension Subroutines set_tdimension Interfaces public interface Shape private pure function get_shape (Obj) result(Ans) Arguments Type Intent Optional Attributes Name type( AbstractArray_ ), intent(in) :: Obj Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) public interface Size private pure function get_size (Obj, Dims) result(Ans) Arguments Type Intent Optional Attributes Name type( AbstractArray_ ), intent(in) :: Obj integer(kind=I4B), intent(in), optional :: Dims Return Value integer(kind=I4B) public interface TotalDimension private pure function get_tdimension (Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( AbstractArray_ ), intent(in) :: Obj Return Value integer(kind=I4B) public interface setTotalDimension private subroutine set_tdimension (Obj, tDimension) Arguments Type Intent Optional Attributes Name class( AbstractArray_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: tDimension Functions private pure function get_shape (Obj) result(Ans) Arguments Type Intent Optional Attributes Name type( AbstractArray_ ), intent(in) :: Obj Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) private pure function get_size (Obj, Dims) result(Ans) Arguments Type Intent Optional Attributes Name type( AbstractArray_ ), intent(in) :: Obj integer(kind=I4B), intent(in), optional :: Dims Return Value integer(kind=I4B) private pure function get_tdimension (Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( AbstractArray_ ), intent(in) :: Obj Return Value integer(kind=I4B) Subroutines private subroutine set_tdimension (Obj, tDimension) Arguments Type Intent Optional Attributes Name class( AbstractArray_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: tDimension","tags":"","loc":"module/abstractarray_method.html"},{"title":"IO – Fortran Program","text":"Uses GlobalData DISPMODULE H5Fortran BaseType Contents Variables minCol minRow Interfaces Display Functions Int2Str Subroutines BlankLines DashLine DebugTag Display_Int Display_Logical Display_Mat2_Int Display_Mat2_Real Display_Mat3_Real Display_Mat4_Real Display_Real Display_Str Display_Str2 Display_Vector_Int DotLine EqualLine ExecuteCommand TIMESTAMP Variables Type Visibility Attributes Name Initial integer(kind=I4B), private, parameter :: minCol = 4 integer(kind=I4B), private, parameter :: minRow = 4 Interfaces public interface Display private subroutine Display_Str (msg, unitno) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitno private subroutine Display_Str2 (val, msg, unitno) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: val character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitno private subroutine Display_Real (vec, msg, unitNo) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: vec character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitNo private subroutine Display_Int (vec, msg, unitNo) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: vec character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitNo private subroutine Display_Logical (vec, msg, unitNo) Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(in) :: vec character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitNo private subroutine Display_Vector_Int (vec, msg, unitNo, full) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION( : ) :: vec character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitNo logical(kind=LGT), intent(in), optional :: full private subroutine Display_Mat2_Real (Mat, msg, unitNo, full) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in), DIMENSION( :, : ) :: Mat character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitNo logical(kind=LGT), intent(in), optional :: full private subroutine Display_Mat2_Int (Mat, msg, unitNo, full) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Mat (:,:) character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitNo logical(kind=LGT), intent(in), optional :: full private subroutine Display_Mat3_Real (Mat, msg, unitNo) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Mat (:,:,:) character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitNo private subroutine Display_Mat4_Real (Mat, msg, unitNo) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Mat (:,:,:,:) character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitNo Functions private function Int2Str (I) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: I Return Value character(len=15) Subroutines public subroutine BlankLines (unitNo, NOL) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), optional :: unitNo integer(kind=I4B), intent(in), optional :: NOL public subroutine DashLine (unitNo) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), optional :: unitNo public subroutine DebugTag (Tag, unitNo) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), optional :: Tag integer(kind=I4B), intent(in), optional :: unitNo private subroutine Display_Int (vec, msg, unitNo) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: vec character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitNo private subroutine Display_Logical (vec, msg, unitNo) Arguments Type Intent Optional Attributes Name logical(kind=LGT), intent(in) :: vec character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitNo private subroutine Display_Mat2_Int (Mat, msg, unitNo, full) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Mat (:,:) character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitNo logical(kind=LGT), intent(in), optional :: full private subroutine Display_Mat2_Real (Mat, msg, unitNo, full) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in), DIMENSION( :, : ) :: Mat character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitNo logical(kind=LGT), intent(in), optional :: full private subroutine Display_Mat3_Real (Mat, msg, unitNo) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Mat (:,:,:) character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitNo private subroutine Display_Mat4_Real (Mat, msg, unitNo) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Mat (:,:,:,:) character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitNo private subroutine Display_Real (vec, msg, unitNo) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: vec character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitNo private subroutine Display_Str (msg, unitno) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitno private subroutine Display_Str2 (val, msg, unitno) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: val character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitno private subroutine Display_Vector_Int (vec, msg, unitNo, full) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), DIMENSION( : ) :: vec character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitNo logical(kind=LGT), intent(in), optional :: full public subroutine DotLine (unitNo) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), optional :: unitNo public subroutine EqualLine (unitNo) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in), optional :: unitNo private subroutine ExecuteCommand (CMD, Str) This subroutine run a system commoand on terminal Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: CMD character(len=*), intent(in) :: Str public subroutine TIMESTAMP () Arguments None","tags":"","loc":"module/io.html"},{"title":"QuadraturePoint_Method – Fortran Program","text":"Uses BaseType GlobalData Contents Interfaces Constructor1 Constructor_1 DeallocateData Display GaussLegendreQuadrature GetQuadraturePoints Initiate QuadraturePoint QuadraturePoint_Pointer SIZE deallocate_data display_obj getGaussLegendreQP1 getGaussLegendreQP2 getGaussLegendreQPHexahedron1 getGaussLegendreQPHexahedron2 getGaussLegendreQPLine1 getGaussLegendreQPLine2 getGaussLegendreQPPrism1 getGaussLegendreQPPrism2 getGaussLegendreQPPyramid1 getGaussLegendreQPPyramid2 getGaussLegendreQPQuadrangle1 getGaussLegendreQPQuadrangle2 getGaussLegendreQPTetrahedron1 getGaussLegendreQPTetrahedron2 getGaussLegendreQPTriangle1 getGaussLegendreQPTriangle2 getQP1 getQP2 initiate_obj initiate_obj_txi size_obj Interfaces interface private pure function Constructor1(Points) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Points (:,:) Return Value type(QuadraturePoint_) interface private pure function Constructor_1(Points) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Points (:,:) Return Value class(QuadraturePoint_),\n  POINTER public interface DeallocateData private interface deallocate_data () Arguments None public interface Display private interface display_obj () Arguments None public interface GaussLegendreQuadrature private interface getGaussLegendreQP1 () Arguments None private interface getGaussLegendreQP2 () Arguments None public interface GetQuadraturePoints private interface getQP1 () Arguments None private interface getQP2 () Arguments None public interface Initiate private interface initiate_obj () Arguments None private interface initiate_obj_txi () Arguments None public interface QuadraturePoint private interface Constructor1 () Arguments None public interface QuadraturePoint_Pointer private interface Constructor_1 () Arguments None public interface SIZE private interface size_obj () Arguments None interface private subroutine deallocate_data(Obj) Arguments Type Intent Optional Attributes Name class(QuadraturePoint_), intent(inout) :: Obj interface private subroutine display_obj(Obj, msg, unitno) Arguments Type Intent Optional Attributes Name class(QuadraturePoint_), intent(in) :: Obj character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitno interface private pure function getGaussLegendreQP1(RefElem, Order) result(Obj) Arguments Type Intent Optional Attributes Name class(ReferenceElement_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: Order Return Value type(QuadraturePoint_) interface private pure function getGaussLegendreQP2(RefElem, NIPS) result(Obj) Arguments Type Intent Optional Attributes Name class(ReferenceElement_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: NIPS (1) Return Value type(QuadraturePoint_) interface private pure function getGaussLegendreQPHexahedron1(RefElem, Order) result(Obj) Arguments Type Intent Optional Attributes Name type(ReferenceHexahedron_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: Order Return Value type(QuadraturePoint_) interface private pure function getGaussLegendreQPHexahedron2(RefElem, NIPS) result(Obj) Arguments Type Intent Optional Attributes Name type(ReferenceHexahedron_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: NIPS (1) Return Value type(QuadraturePoint_) interface private pure function getGaussLegendreQPLine1(RefElem, Order) result(Obj) Arguments Type Intent Optional Attributes Name type(ReferenceLine_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: Order Return Value type(QuadraturePoint_) interface private pure function getGaussLegendreQPLine2(RefElem, NIPS) result(Obj) Arguments Type Intent Optional Attributes Name type(ReferenceLine_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: NIPS (1) Return Value type(QuadraturePoint_) interface private pure function getGaussLegendreQPPrism1(RefElem, Order) result(Obj) Arguments Type Intent Optional Attributes Name type(ReferencePrism_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: Order Return Value type(QuadraturePoint_) interface private pure function getGaussLegendreQPPrism2(RefElem, NIPS) result(Obj) Arguments Type Intent Optional Attributes Name type(ReferencePrism_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: NIPS (1) Return Value type(QuadraturePoint_) interface private pure function getGaussLegendreQPPyramid1(RefElem, Order) result(Obj) Arguments Type Intent Optional Attributes Name type(ReferencePyramid_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: Order Return Value type(QuadraturePoint_) interface private pure function getGaussLegendreQPPyramid2(RefElem, NIPS) result(Obj) Arguments Type Intent Optional Attributes Name type(ReferencePyramid_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: NIPS (1) Return Value type(QuadraturePoint_) interface private pure function getGaussLegendreQPQuadrangle1(RefElem, Order) result(Obj) Arguments Type Intent Optional Attributes Name type(ReferenceQuadrangle_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: Order Return Value type(QuadraturePoint_) interface private pure function getGaussLegendreQPQuadrangle2(RefElem, NIPS) result(Obj) Arguments Type Intent Optional Attributes Name type(ReferenceQuadrangle_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: NIPS (1) Return Value type(QuadraturePoint_) interface private pure function getGaussLegendreQPTetrahedron1(RefElem, Order) result(Obj) Arguments Type Intent Optional Attributes Name type(ReferenceTetrahedron_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: Order Return Value type(QuadraturePoint_) interface private pure function getGaussLegendreQPTetrahedron2(RefElem, NIPS) result(Obj) Arguments Type Intent Optional Attributes Name type(ReferenceTetrahedron_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: NIPS (1) Return Value type(QuadraturePoint_) interface private pure function getGaussLegendreQPTriangle1(RefElem, Order) result(Obj) Arguments Type Intent Optional Attributes Name type(ReferenceTriangle_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: Order Return Value type(QuadraturePoint_) interface private pure function getGaussLegendreQPTriangle2(RefElem, NIPS) result(Obj) Arguments Type Intent Optional Attributes Name type(ReferenceTriangle_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: NIPS (1) Return Value type(QuadraturePoint_) interface private subroutine getQP1(Obj, Point, Weight, Num) Arguments Type Intent Optional Attributes Name class(QuadraturePoint_), intent(in) :: Obj real(kind=DFP), intent(inout) :: Point (3) real(kind=DFP), intent(inout) :: Weight integer(kind=I4B), intent(in) :: Num interface private subroutine getQP2(Obj, Point, Weight) Arguments Type Intent Optional Attributes Name class(QuadraturePoint_), intent(in) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: Point (:,:) real(kind=DFP), intent(inout), ALLOCATABLE :: Weight (:) interface private subroutine initiate_obj(Obj, Points) Arguments Type Intent Optional Attributes Name class(QuadraturePoint_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Points (:,:) interface private subroutine initiate_obj_txi(Obj, tXi, tPoints) Arguments Type Intent Optional Attributes Name class(QuadraturePoint_), intent(inout) :: Obj integer(kind=I4B), intent(in) :: tXi integer(kind=I4B), intent(in) :: tPoints interface private pure function size_obj(Obj, dims) result(Ans) Arguments Type Intent Optional Attributes Name class(QuadraturePoint_), intent(in) :: Obj integer(kind=I4B), intent(in) :: dims Return Value integer(kind=I4B)","tags":"","loc":"module/quadraturepoint_method.html"},{"title":"DOF_Method – Fortran Program","text":"Constructor for pointer to DOF_ object Uses GlobalData BaseType Contents Interfaces ArrayValues Constructor1 DOF DOF_Pointer DeallocateData Display IndexOf Initiate OPERATOR( .Names. ) OPERATOR( .tDOF. ) OPERATOR( .tDOF. ) OPERATOR( .tNames. ) OPERATOR( .tNodes. ) OPERATOR( .tNodes. ) OPERATOR( .tSpaceComponents. ) OPERATOR( .tTimeComponents. ) SIZE SIZE addContribution arrayvalues_single_vec deallocate_data display_obj dof_addValue_1 dof_addValue_2 dof_all_names dof_display_vec dof_setValue_1 dof_setValue_2 dof_single_name getArrayValues getArrayValues get_arrayvalues_array get_arrayvalues_single_vec get_index_of_name get_tDOF get_tDOF_iname get_tNames get_tNodes get_tNodes_idof get_tTime_compo get_tspace_compo initiate_2val initiate_realvector_scalar initiate_realvector_vector initiate_st_dof initiate_val setValue Functions Constructor_1 Interfaces public interface ArrayValues private interface arrayvalues_single_vec () Arguments None interface Constructor for DOF_ object private pure function Constructor1(tNodes, Names, SpaceCompo, TimeCompo, StorageFMT) result(Obj) This function return instance of DOF_ for more see DOF_ Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: tNodes (:) character(len=1), intent(in) :: Names (:) integer(kind=I4B), intent(in) :: SpaceCompo (:) integer(kind=I4B), intent(in) :: TimeCompo (:) integer(kind=I4B), intent(in) :: StorageFMT Return Value type(DOF_) public interface DOF Generic function to construct DOF_ object private interface Constructor1 () Constructor for DOF_ object Arguments None public interface DOF_Pointer Generic interface to get pointer to instance of DOF_ object private function Constructor_1 (tNodes, Names, SpaceCompo, TimeCompo, StorageFMT) result(Obj) This function returns the pointer to instance of DOF_ object\n for more see DOF_ Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: tNodes (:) character(len=1), intent(in) :: Names (:) integer(kind=I4B), intent(in) :: SpaceCompo (:) integer(kind=I4B), intent(in) :: TimeCompo (:) integer(kind=I4B), intent(in) :: StorageFMT Return Value class(DOF_),\n  POINTER public interface DeallocateData Generic interface to deallocate data in DOF_ private interface deallocate_data () Deallocate data in DOF_ Arguments None public interface Display Generic subroutine to displacy content of DOF_ private interface display_obj () Display content of DOF_ Arguments None private interface dof_display_vec () Display content of fortran vec with DOF_ object info Arguments None public interface IndexOf private interface get_index_of_name () Arguments None public interface Initiate Generic interface to initiate Fortran vectors or realvectors_ from DOF_ object private interface initiate_st_dof () Initiate DOF_ object Arguments None private interface initiate_val () Initiate a fortran vector using DOF_ object Arguments None private interface initiate_realvector_scalar () Initiate RealVector_ using DOF_ object Arguments None private interface initiate_realvector_vector () Initiate a vector of RealVector_ from DOF_ object Arguments None private interface initiate_2val () Initiate two fortran vectors using DOF_ object Arguments None public interface OPERATOR( .Names. ) private interface dof_all_names () This function returns the name of all physical variables stored in obj Arguments None private interface dof_single_name () This function returns the name of a physical variable Arguments None public interface OPERATOR( .tDOF. ) private interface get_tDOF () This function returns the total number of degree of freedom Arguments None private interface OPERATOR( .tDOF. ) private interface get_tDOF_iname () This subroutine returns the total number of degrees of freedom Arguments None public interface OPERATOR( .tNames. ) private interface get_tNames () This subroutine returns the total number of names Arguments None public interface OPERATOR( .tNodes. ) private interface get_tNodes () This function returns the total number of nodes Arguments None private interface OPERATOR( .tNodes. ) private interface get_tNodes_idof () This function returns the total number of nodes Arguments None public interface OPERATOR( .tSpaceComponents. ) private interface get_tspace_compo () Arguments None public interface OPERATOR( .tTimeComponents. ) private interface get_tTime_compo () Arguments None public interface SIZE private interface get_tNodes () This function returns the total number of nodes Arguments None private interface SIZE private interface get_tNodes_idof () This function returns the total number of nodes Arguments None public interface addContribution Generic subroutine to add values in vectors using DOF_ object private interface dof_addValue_1 () Set values in a vector of real numbers Arguments None private interface dof_addValue_2 () Set values in a vector of real numbers Arguments None interface private pure function arrayvalues_single_vec(Val, Obj, DOFNo, StorageFMT, Nptrs, force3D) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Val (:) class(DOF_), intent(in) :: Obj integer(kind=I4B), intent(in) :: DOFNo (:) integer(kind=I4B), intent(in) :: StorageFMT integer(kind=I4B), intent(in), optional :: Nptrs (:) logical(kind=LGT), intent(in), optional :: force3D Return Value real(kind=DFP),\n  ALLOCATABLE, (:) interface Deallocate data in DOF_ private subroutine deallocate_data(Obj) This subroutine deallocates the data in DOF_ object Arguments Type Intent Optional Attributes Name class(DOF_), intent(inout) :: Obj interface Display content of DOF_ private subroutine display_obj(Obj, msg, UnitNo) This subroutine display the content of DOF_ object Arguments Type Intent Optional Attributes Name class(DOF_), intent(in) :: Obj character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: UnitNo interface Set values in a vector of real numbers private subroutine dof_addValue_1(Vec, Obj, Nptrs, Val, scale, Conversion) This subroutine is designed to add values in a vector of real number\n - DOF_ object obj contains the storage pattern of degrees of freedom\n inside Vec . This storage pattern can be FMT_Nodes or FMT_DOF - Val denotes the nodal values of all dof defined inside Obj . Once\n storage pattern in Val can be FMT_DOF or FMT_Nodes .\n - To tackle this Conversion can be set to DOFToNodes , NodesToDOF or NONE . Read more… Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout) :: Vec (:) class(DOF_), intent(in) :: Obj integer(kind=I4B), intent(in) :: Nptrs (:) real(kind=DFP), intent(in) :: Val (:) real(kind=DFP), intent(in) :: scale integer(kind=I4B), intent(in) :: Conversion (1) interface Set values in a vector of real numbers private subroutine dof_addValue_2(Vec, Obj, Nptrs, Val, scale, dofno) This subroutine is designed to add values in a vector of real number\n - DOF_ object obj contains the storage pattern of degrees of freedom\n inside Vec . This storage pattern can be FMT_Nodes or FMT_DOF - Val denotes the nodal values of dof dofno . Read more… Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout) :: Vec (:) class(DOF_), intent(in) :: Obj integer(kind=I4B), intent(in) :: Nptrs (:) real(kind=DFP), intent(in) :: Val (:) real(kind=DFP), intent(in) :: scale integer(kind=I4B), intent(in) :: dofno interface This function returns the name of all physical variables stored in obj private pure function dof_all_names(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class(DOF_), intent(in) :: Obj Return Value character(len=1),\n  ALLOCATABLE, (:) interface Display content of fortran vec with DOF_ object info private subroutine dof_display_vec(Vec, Obj, msg, unitno) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Vec (:) class(DOF_), intent(in) :: Obj character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitno interface Set values in a vector of real numbers private subroutine dof_setValue_1(Vec, Obj, Nptrs, Val, Conversion) This subroutine is designed to set the values in a vector of real number Read more… Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout) :: Vec (:) class(DOF_), intent(in) :: Obj integer(kind=I4B), intent(in) :: Nptrs (:) real(kind=DFP), intent(in) :: Val (:) integer(kind=I4B), intent(in) :: Conversion (1) interface Set values in a vector of real numbers private subroutine dof_setValue_2(Vec, Obj, Nptrs, Val, dofno) This subroutine is designed to set the values in a vector of real number\n - DOF_ object obj contains the storage pattern of degrees of freedom\n inside Vec . This storage pattern can be FMT_Nodes or FMT_DOF - Val denotes the nodal values of dof dofno . Read more… Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout) :: Vec (:) class(DOF_), intent(in) :: Obj integer(kind=I4B), intent(in) :: Nptrs (:) real(kind=DFP), intent(in) :: Val (:) integer(kind=I4B), intent(in) :: dofno interface This function returns the name of a physical variable private pure function dof_single_name(Obj, ii) result(Ans) Arguments Type Intent Optional Attributes Name class(DOF_), intent(in) :: Obj integer(kind=I4B), intent(in) :: ii Return Value character(len=1),\n  ALLOCATABLE public interface getArrayValues private interface get_arrayvalues_single_vec () Returns the values of degrees of freedom in a single vector Arguments None private interface getArrayValues private interface get_arrayvalues_array () Returns the values of degrees of freedom in a 2D array Arguments None interface Returns the values of degrees of freedom in a 2D array private subroutine get_arrayvalues_array(v, Val, Obj, DOFNo, force3D) This subroutine extracts the values of from val corresponding to\n degrees of freedom specified by DOFNo(:) and return it in V(:,:) Values in Val(:,:) are stored in xiJ format. Read more… Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: v (:,:) real(kind=DFP), intent(in) :: Val (:) class(DOF_), intent(in) :: Obj integer(kind=I4B), intent(in) :: DOFNo (:) logical(kind=LGT), intent(in), optional :: force3D interface Returns the values of degrees of freedom in a single vector private subroutine get_arrayvalues_single_vec(v, Val, Obj, DOFNo, StorageFMT, Nptrs) This subroutine extracts the values of from val corresponding to\n degrees of freedom specified by DOFNo(:) and return it in V Read more… Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: v (:) real(kind=DFP), intent(in) :: Val (:) class(DOF_), intent(in) :: Obj integer(kind=I4B), intent(in) :: DOFNo (:) integer(kind=I4B), intent(in) :: StorageFMT integer(kind=I4B), intent(in), optional :: Nptrs (:) interface private pure function get_index_of_name(Obj, Name) result(Ans) Arguments Type Intent Optional Attributes Name class(DOF_), intent(in) :: Obj character(len=1), intent(in) :: Name Return Value integer(kind=I4B) interface This function returns the total number of degree of freedom private pure function get_tDOF(Obj) result(Ans) This function returns the total dof Arguments Type Intent Optional Attributes Name class(DOF_), intent(in) :: Obj Return Value integer(kind=I4B) interface This subroutine returns the total number of degrees of freedom private pure function get_tDOF_iname(Obj, Name) result(Ans) This function returns the total number of dof in given physical name Arguments Type Intent Optional Attributes Name class(DOF_), intent(in) :: Obj character(len=1), intent(in) :: Name Return Value integer(kind=I4B) interface This subroutine returns the total number of names private pure function get_tNames(Obj) result(Ans) This subroutine returns the total number of names or total number of\n physical quantities Arguments Type Intent Optional Attributes Name class(DOF_), intent(in) :: Obj Return Value integer(kind=I4B) interface This function returns the total number of nodes private pure function get_tNodes(Obj) result(Ans) This function returns the total length of the vector which stores the\n dof stored inside obj . Arguments Type Intent Optional Attributes Name class(DOF_), intent(in) :: Obj Return Value integer(kind=I4B) interface This function returns the total number of nodes private pure function get_tNodes_idof(Obj, idof) result(Ans) This subroutine returns the size of a given degree of freedom Arguments Type Intent Optional Attributes Name class(DOF_), intent(in) :: Obj integer(kind=I4B), intent(in) :: idof Return Value integer(kind=I4B) interface private pure function get_tTime_compo(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class(DOF_), intent(in) :: Obj Return Value integer(kind=I4B) interface private pure function get_tspace_compo(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class(DOF_), intent(in) :: Obj Return Value integer(kind=I4B) interface Initiate two fortran vectors using DOF_ object private subroutine initiate_2val(Val1, Val2, Obj) This subroutine initiate two fortran vectors using  the information\n stored inside the DOF_ object Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: Val1 (:) real(kind=DFP), intent(inout), ALLOCATABLE :: Val2 (:) class(DOF_), intent(in) :: Obj interface Initiate RealVector_ using DOF_ object private subroutine initiate_realvector_scalar(Val, Obj) This subroutine initiate RealVector_ using information stored inside DOF_ object Arguments Type Intent Optional Attributes Name class(RealVector_), intent(inout) :: Val class(DOF_), intent(in) :: Obj interface Initiate a vector of RealVector_ from DOF_ object private subroutine initiate_realvector_vector(Val, Obj) This subroutine initiate a vector of RealVector_ object\n Each entry Val( idof ) denotes degree of freedom idof Arguments Type Intent Optional Attributes Name type(RealVector_), intent(inout), ALLOCATABLE :: Val (:) class(DOF_), intent(in) :: Obj interface Initiate DOF_ object private subroutine initiate_st_dof(Obj, tNodes, Names, SpaceCompo, TimeCompo, StorageFMT) This subroutine initiate DOF_ object Read more… Arguments Type Intent Optional Attributes Name class(DOF_), intent(inout) :: Obj degree of freedom object integer(kind=I4B), intent(in) :: tNodes (:) number of nodes for each physical variable character(len=1), intent(in) :: Names (:) Names of each physical variable integer(kind=I4B), intent(in) :: SpaceCompo (:) Space component of each physical variable integer(kind=I4B), intent(in) :: TimeCompo (:) Time component of each physical variable integer(kind=I4B), intent(in) :: StorageFMT Storage format FMT_DOF , FMT_Nodes interface Initiate a fortran vector using DOF_ object private subroutine initiate_val(Val, Obj) This subroutine initiate a fortran vector using information stored inside DOF_ object Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: Val (:) class(DOF_), intent(in) :: Obj public interface setValue Generic subroutine to set values in fortran vectors using DOF_ object private interface dof_setValue_1 () Set values in a vector of real numbers Arguments None private interface dof_setValue_2 () Set values in a vector of real numbers Arguments None Functions private function Constructor_1 (tNodes, Names, SpaceCompo, TimeCompo, StorageFMT) result(Obj) This function returns the pointer to instance of DOF_ object\n for more see DOF_ Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: tNodes (:) character(len=1), intent(in) :: Names (:) integer(kind=I4B), intent(in) :: SpaceCompo (:) integer(kind=I4B), intent(in) :: TimeCompo (:) integer(kind=I4B), intent(in) :: StorageFMT Return Value class(DOF_),\n  POINTER","tags":"","loc":"module/dof_method.html"},{"title":"File_Method – Fortran Program","text":"This module contains routine related to file handling\n Routines for File_ userdata typehas been defined\n Submodules\n - Constructor\n - WriteMethods\n - ReadLine Uses GlobalData BaseType Contents Interfaces CloseFile Constructor1 DeleteFile Exists File File_Pointer Initiate OpenBinaryFileToWrite OpenFile OpenFileToAppend OpenFileToRead OpenFileToWrite ReadLine ReadLine ReadLine ReopenFile SIZE Write WriteLine checkIsOpen close_file fileExists file_size hasExtension init_file isOpen open_bfile_write_a open_file open_file_Append_a open_file_Append_b open_file_Append_c open_file_Read_a open_file_Read_b open_file_Read_c open_file_write_a open_file_write_b open_file_write_c readline_a readline_ab readline_abc readline_abcd readline_abcde readline_abcdev readline_abcdv readline_abcdvev readline_abcv readline_abcvdv readline_abv readline_abvcv readline_av readline_avbv readline_avbvcv reopen_file writeLine_a writeLine_ab writeLine_abc writeLine_abcd writeLine_abcde writeLine_av writeLine_avbv writeLine_avbvcv write_data_ascii_r1 write_data_ascii_r2 write_data_ascii_scalar Functions Constructor_1 Interfaces public interface CloseFile private interface close_file () Arguments None interface private function Constructor1() result(Ans) Arguments None Return Value type(File_) interface This subroutine deletes the file on the hard-disk public subroutine DeleteFile(Obj) This routine deletes the file on the hard disk Arguments Type Intent Optional Attributes Name class(File_), intent(in) :: Obj public interface Exists private interface fileExists () This subroutine checks whether filename exists or not Arguments None public interface File private interface Constructor1 () Arguments None public interface File_Pointer private function Constructor_1 () result(Obj) Arguments None Return Value class(File_),\n  POINTER public interface Initiate private interface init_file () This routine intiate the File_ object Arguments None public interface OpenBinaryFileToWrite private interface open_bfile_write_a () This routine open a binary file to write Arguments None public interface OpenFile private interface open_file () Arguments None public interface OpenFileToAppend private interface open_file_Append_a () Arguments None private interface open_file_Append_b () Arguments None private interface open_file_Append_c () Arguments None public interface OpenFileToRead private interface open_file_Read_a () Arguments None private interface open_file_Read_b () Arguments None private interface open_file_Read_c () Arguments None public interface OpenFileToWrite private interface open_file_write_a () This routine open a file to write Arguments None private interface open_file_write_b () This routine open a file to write Arguments None private interface open_file_write_c () This routine open a file to write Arguments None public interface ReadLine private interface readline_a () Arguments None private interface readline_ab () Arguments None private interface readline_abc () Arguments None private interface readline_abcd () Arguments None private interface readline_abcde () Arguments None private interface ReadLine private interface readline_av () Arguments None private interface readline_avbv () Arguments None private interface readline_avbvcv () Arguments None private interface ReadLine private interface readline_abv () Arguments None private interface readline_abvcv () Arguments None private interface readline_abcv () Arguments None private interface readline_abcvdv () Arguments None private interface readline_abcdv () Arguments None private interface readline_abcdvev () Arguments None private interface readline_abcdev () Arguments None public interface ReopenFile private interface reopen_file () This subroutine opens a file to Arguments None public interface SIZE private interface file_size () this function returns the file size in bytes Arguments None public interface Write private interface write_data_ascii_r1 () This routine writes data into a file Arguments None private interface write_data_ascii_r2 () This routine writes data into a file Arguments None private interface write_data_ascii_scalar () This routine writes data into a file Arguments None public interface WriteLine private interface writeLine_a () Arguments None private interface writeLine_ab () Arguments None private interface writeLine_abc () Arguments None private interface writeLine_abcd () Arguments None private interface writeLine_abcde () Arguments None private interface writeLine_av () Arguments None private interface writeLine_avbv () Arguments None private interface writeLine_avbvcv () Arguments None interface private function checkIsOpen(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class(File_), intent(in) :: Obj Return Value logical(kind=LGT) interface private subroutine close_file(Obj) Arguments Type Intent Optional Attributes Name class(File_), intent(inout) :: Obj interface This subroutine checks whether filename exists or not private function fileExists(Obj) result(Ans) This function checks whether the filename exists or not Arguments Type Intent Optional Attributes Name class(File_), intent(in) :: Obj Return Value logical(kind=LGT) interface this function returns the file size in bytes private function file_size(Obj) result(Ans) This subroutine returns the file size in bytes Arguments Type Intent Optional Attributes Name class(File_), intent(in) :: Obj Return Value integer(kind=I4B) interface public function hasExtension(Obj, Extension) result(Ans) Arguments Type Intent Optional Attributes Name class(File_), intent(in) :: Obj character(len=3), intent(in) :: Extension Return Value logical(kind=LGT) interface This routine intiate the File_ object private subroutine init_file(Obj, Path, FileName, Extension, Status, Action, Access, isBinary, Comment, Separator) Arguments Type Intent Optional Attributes Name class(File_), intent(inout) :: Obj File object character(len=*), intent(in) :: Path character(len=*), intent(in) :: FileName character(len=*), intent(in) :: Extension character(len=*), intent(in) :: Status character(len=*), intent(in) :: Action character(len=*), intent(in), optional :: Access logical(kind=LGT), intent(in), optional :: isBinary Flag for binary file character(len=1), intent(in), optional :: Comment character(len=1), intent(in), optional :: Separator public interface isOpen private interface checkIsOpen () Arguments None interface This routine open a binary file to write private subroutine open_bfile_write_a(Obj, Path, FileName, Extension) This routine opens a binary file to write Arguments Type Intent Optional Attributes Name class(File_), intent(inout) :: Obj character(len=*), intent(in) :: Path character(len=*), intent(in) :: FileName character(len=*), intent(in) :: Extension interface private subroutine open_file(Obj) Arguments Type Intent Optional Attributes Name class(File_), intent(inout) :: Obj interface private subroutine open_file_Append_a(Obj, Path, FileName, Extension) Arguments Type Intent Optional Attributes Name class(File_), intent(inout) :: Obj character(len=*), intent(in) :: Path character(len=*), intent(in) :: FileName character(len=*), intent(in) :: Extension interface private subroutine open_file_Append_b(Obj, PFE) Arguments Type Intent Optional Attributes Name class(File_), intent(inout) :: Obj type(String), intent(in) :: PFE (:) interface private subroutine open_file_Append_c(Obj, Path, FileName, Extension) Arguments Type Intent Optional Attributes Name class(File_), intent(inout) :: Obj type(String), intent(in) :: Path type(String), intent(in) :: FileName type(String), intent(in) :: Extension interface private subroutine open_file_Read_a(Obj, Path, FileName, Extension) Arguments Type Intent Optional Attributes Name class(File_), intent(inout) :: Obj character(len=*), intent(in) :: Path character(len=*), intent(in) :: FileName character(len=*), intent(in) :: Extension interface private subroutine open_file_Read_b(Obj, PFE) Arguments Type Intent Optional Attributes Name class(File_), intent(inout) :: Obj type(String), intent(in) :: PFE (:) interface private subroutine open_file_Read_c(Obj, Path, FileName, Extension) Arguments Type Intent Optional Attributes Name class(File_), intent(inout) :: Obj type(String), intent(in) :: Path type(String), intent(in) :: FileName type(String), intent(in) :: Extension interface This routine open a file to write private subroutine open_file_write_a(Obj, Path, FileName, Extension) This routine opens a file to write Arguments Type Intent Optional Attributes Name class(File_), intent(inout) :: Obj character(len=*), intent(in) :: Path character(len=*), intent(in) :: FileName character(len=*), intent(in) :: Extension interface This routine open a file to write private subroutine open_file_write_b(Obj, PFE) This routine opens a file to write Arguments Type Intent Optional Attributes Name class(File_), intent(inout) :: Obj type(String), intent(in) :: PFE (:) interface This routine open a file to write private subroutine open_file_write_c(Obj, Path, FileName, Extension) This routine opens a file to write Arguments Type Intent Optional Attributes Name class(File_), intent(inout) :: Obj type(String), intent(in) :: Path type(String), intent(in) :: FileName type(String), intent(in) :: Extension interface private subroutine readline_a(a, buffer, fileName, UnitNo) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(out) :: a Number character(len=*), intent(in), optional :: buffer Character string to read from instead of the line in the file character(len=*), intent(in), optional :: fileName File name integer(kind=I4B), intent(in), optional :: UnitNo File id number to read from interface private subroutine readline_ab(a, b, buffer, fileName, UnitNo) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(out) :: a Number real(kind=DFP), intent(out) :: b Number character(len=*), intent(in), optional :: buffer Character string to read from instead of the line in the file character(len=*), intent(in), optional :: fileName File name integer(kind=I4B), intent(in), optional :: UnitNo File id number to read from interface private subroutine readline_abc(a, b, c, buffer, fileName, UnitNo) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(out) :: a Number real(kind=DFP), intent(out) :: b Number real(kind=DFP), intent(out) :: c Number character(len=*), intent(in), optional :: buffer Character string to read from instead of the line in the file character(len=*), intent(in), optional :: fileName File name integer(kind=I4B), intent(in), optional :: UnitNo File id number to read from interface private subroutine readline_abcd(a, b, c, d, buffer, fileName, UnitNo) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(out) :: a Number real(kind=DFP), intent(out) :: b Number real(kind=DFP), intent(out) :: c Number real(kind=DFP), intent(out) :: d Number character(len=*), intent(in), optional :: buffer Character string to read from instead of the line in the file character(len=*), intent(in) :: fileName File name integer(kind=I4B), intent(in) :: UnitNo File id number to read from interface private subroutine readline_abcde(a, b, c, d, e, buffer, fileName, UnitNo) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(out) :: a Number real(kind=DFP), intent(out) :: b Number real(kind=DFP), intent(out) :: c Number real(kind=DFP), intent(out) :: d Number real(kind=DFP), intent(out) :: e Number character(len=*), intent(in), optional :: buffer Character string to read from instead of the line in the file character(len=*), intent(in), optional :: fileName File name integer(kind=I4B), intent(in), optional :: UnitNo File id number to read from interface private subroutine readline_abcdev(a, b, c, d, e, buffer, fileName, UnitNo) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(out) :: a Number real(kind=DFP), intent(out) :: b Number real(kind=DFP), intent(out) :: c Number real(kind=DFP), intent(out) :: d Number real(kind=DFP), intent(out) :: e (:) Number character(len=*), intent(in), optional :: buffer Character string to read from instead of the line in the file character(len=*), intent(in), optional :: fileName File name integer(kind=I4B), intent(in), optional :: UnitNo File id number to read from interface private subroutine readline_abcdv(a, b, c, d, buffer, fileName, UnitNo) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(out) :: a Number real(kind=DFP), intent(out) :: b Number real(kind=DFP), intent(out) :: c Number real(kind=DFP), intent(out) :: d (:) Number character(len=*), intent(in), optional :: buffer Character string to read from instead of the line in the file character(len=*), intent(in), optional :: fileName File name integer(kind=I4B), intent(in), optional :: UnitNo File id number to read from interface private subroutine readline_abcdvev(a, b, c, d, e, buffer, fileName, UnitNo) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(out) :: a Number real(kind=DFP), intent(out) :: b Number real(kind=DFP), intent(out) :: c Number real(kind=DFP), intent(out) :: d (:) Number real(kind=DFP), intent(out) :: e (:) Number character(len=*), intent(in), optional :: buffer Character string to read from instead of the line in the file character(len=*), intent(in), optional :: fileName File name integer(kind=I4B), intent(in), optional :: UnitNo File id number to read from interface private subroutine readline_abcv(a, b, c, buffer, fileName, UnitNo) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(out) :: a Number real(kind=DFP), intent(out) :: b Number real(kind=DFP), intent(out) :: c (:) Number character(len=*), intent(in), optional :: buffer Character string to read from instead of the line in the file character(len=*), intent(in), optional :: fileName File name integer(kind=I4B), intent(in), optional :: UnitNo File id number to read from interface private subroutine readline_abcvdv(a, b, c, d, buffer, fileName, UnitNo) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(out) :: a Number real(kind=DFP), intent(out) :: b Number real(kind=DFP), intent(out) :: c (:) Number real(kind=DFP), intent(out) :: d (:) Number character(len=*), intent(in), optional :: buffer Character string to read from instead of the line in the file character(len=*), intent(in), optional :: fileName File name integer(kind=I4B), intent(in), optional :: UnitNo File id number to read from interface private subroutine readline_abv(a, b, buffer, fileName, UnitNo) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(out) :: a Number real(kind=DFP), intent(out) :: b (:) Number character(len=*), intent(in), optional :: buffer Character string to read from instead of the line in the file character(len=*), intent(in), optional :: fileName File name integer(kind=I4B), intent(in), optional :: UnitNo File id number to read from interface private subroutine readline_abvcv(a, b, c, buffer, fileName, UnitNo) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(out) :: a Number real(kind=DFP), intent(out) :: b (:) Number real(kind=DFP), intent(out) :: c (:) Number character(len=*), intent(in), optional :: buffer Character string to read from instead of the line in the file character(len=*), intent(in), optional :: fileName File name integer(kind=I4B), intent(in), optional :: UnitNo File id number to read from interface private subroutine readline_av(a, buffer, fileName, UnitNo) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(out) :: a (:) Number character(len=*), intent(in), optional :: buffer Character string to read from instead of the line in the file character(len=*), intent(in), optional :: fileName File name integer(kind=I4B), intent(in), optional :: UnitNo File id number to read from interface private subroutine readline_avbv(a, b, buffer, fileName, UnitNo) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(out) :: a (:) Number real(kind=DFP), intent(out) :: b (:) Number character(len=*), intent(in), optional :: buffer Character string to read from instead of the line in the file character(len=*), intent(in), optional :: fileName File name integer(kind=I4B), intent(in), optional :: UnitNo File id number to read from interface private subroutine readline_avbvcv(a, b, c, buffer, fileName, UnitNo) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(out) :: a (:) Number real(kind=DFP), intent(out) :: b (:) Number real(kind=DFP), intent(out) :: c (:) Number character(len=*), intent(in), optional :: buffer Character string to read from instead of the line in the file character(len=*), intent(in), optional :: fileName File name integer(kind=I4B), intent(in), optional :: UnitNo File id number to read from interface This subroutine opens a file to private subroutine reopen_file(Obj) This subroutine reopens the file Arguments Type Intent Optional Attributes Name class(File_), intent(inout) :: Obj interface private subroutine writeLine_a(a, fileName, unitno) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a character(len=*), intent(in) :: fileName integer(kind=I4B), intent(in), optional :: unitno interface private subroutine writeLine_ab(a, b, fileName, unitno) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a real(kind=DFP), intent(in) :: b character(len=*), intent(in) :: fileName integer(kind=I4B), intent(in), optional :: unitno interface private subroutine writeLine_abc(a, b, c, fileName, unitno) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a real(kind=DFP), intent(in) :: b real(kind=DFP), intent(in) :: c character(len=*), intent(in) :: fileName integer(kind=I4B), intent(in), optional :: unitno interface private subroutine writeLine_abcd(a, b, c, d, fileName, unitno) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a real(kind=DFP), intent(in) :: b real(kind=DFP), intent(in) :: c real(kind=DFP), intent(in) :: d character(len=*), intent(in) :: fileName integer(kind=I4B), intent(in), optional :: unitno interface private subroutine writeLine_abcde(a, b, c, d, e, fileName, unitno) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a real(kind=DFP), intent(in) :: b real(kind=DFP), intent(in) :: c real(kind=DFP), intent(in) :: d real(kind=DFP), intent(in) :: e character(len=*), intent(in) :: fileName integer(kind=I4B), intent(in), optional :: unitno interface private subroutine writeLine_av(a, fileName, unitno) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a (:) character(len=*), intent(in) :: fileName integer(kind=I4B), intent(in), optional :: unitno interface private subroutine writeLine_avbv(a, b, fileName, unitno) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a (:) real(kind=DFP), intent(in) :: b (:) character(len=*), intent(in) :: fileName integer(kind=I4B), intent(in), optional :: unitno interface private subroutine writeLine_avbvcv(a, b, c, fileName, unitno) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a (:) real(kind=DFP), intent(in) :: b (:) real(kind=DFP), intent(in) :: c (:) character(len=*), intent(in) :: fileName integer(kind=I4B), intent(in), optional :: unitno interface This routine writes data into a file private subroutine write_data_ascii_r1(Obj, Val, row, col) This routine writes data into a file\n If row is present then data is printed as row\n If col is present then data is printed as column\n If both row or col are absent then data is printed as row Arguments Type Intent Optional Attributes Name class(File_), intent(inout) :: Obj File object class(*), intent(in) :: Val (:) One D array logical(kind=LGT), intent(in), optional :: row If present then vector will be printed as rowwise logical(kind=LGT), intent(in), optional :: col If present then vector will be printed as column wise interface This routine writes data into a file private subroutine write_data_ascii_r2(Obj, Val, transpose) This routine writes data into a file\n If transpose is true then data is printed after taking transpose Arguments Type Intent Optional Attributes Name class(File_), intent(inout) :: Obj class(*), intent(in) :: Val (:,:) logical(kind=LGT), intent(in) :: transpose interface This routine writes data into a file private subroutine write_data_ascii_scalar(Obj, Val) This routine writes data into a file\n If transpose is present then data is printed after taking transpose Arguments Type Intent Optional Attributes Name class(File_), intent(inout) :: Obj class(*), intent(in) :: Val Functions private function Constructor_1 () result(Obj) Arguments None Return Value class(File_),\n  POINTER","tags":"","loc":"module/file_method.html"},{"title":"FEMatrix_Module – Fortran Program","text":"This module contains interfaces of finite element matrices Uses BaseType GlobalData Contents Interfaces DiffusionMatrix MassMatrix NitscheMatrix Space_DiffusionMatrix Space_DiffusionMatrix_C Space_DiffusionMatrix_K Space_MassMatrix Space_StiffnessMatrix_Cijkl Space_StiffnessMatrix_LamMu Space_StiffnessMatrix_Lambda StiffnessMatrix StiffnessMatrix StiffnessMatrix space_nitsche_mat_1 space_nitsche_mat_2 space_nitsche_mat_3 space_nitsche_mat_4 space_nitsche_mat_5 space_nitsche_mat_7 st_diffusionMatrix st_diffusionMatrix_C st_diffusionMatrix_K st_massMatrix_a Interfaces public interface DiffusionMatrix private interface Space_DiffusionMatrix () This subroutine returns the diffusion matrix in space domain Arguments None private interface Space_DiffusionMatrix_K () This subroutine returns the diffusion matrix in space domain Arguments None private interface Space_DiffusionMatrix_C () This subroutine returns the diffusion matrix in space domain Arguments None private interface st_diffusionMatrix () Arguments None private interface st_diffusionMatrix_K () Arguments None private interface st_diffusionMatrix_C () Arguments None public interface MassMatrix Generic function to obtain mass matrix private interface Space_MassMatrix () This subroutine makes mass matrix in space domain Arguments None private interface st_massMatrix_a () This subroutine makes mass matrix in space time domain Arguments None public interface NitscheMatrix private interface space_nitsche_mat_1 () Arguments None private interface space_nitsche_mat_2 () Arguments None private interface space_nitsche_mat_3 () Arguments None private interface space_nitsche_mat_4 () Arguments None private interface space_nitsche_mat_5 () Arguments None private interface space_nitsche_mat_7 () Arguments None interface This subroutine returns the diffusion matrix in space domain private pure function Space_DiffusionMatrix(Test, Trial, nCopy) result(Ans) This function returns the diffusion matrix in space domain Read more… Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Test class(ElemshapeData_), intent(in) :: Trial integer(kind=I4B), intent(in), optional :: nCopy Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) interface This subroutine returns the diffusion matrix in space domain private pure function Space_DiffusionMatrix_C(Test, Trial, C1, C2, nCopy) result(Ans) This function returns the diffusion matrix in space domain Read more… Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Test class(ElemshapeData_), intent(in) :: Trial class(FEVariable_), intent(in) :: C1 class(FEVariable_), intent(in) :: C2 integer(kind=I4B), intent(in), optional :: nCopy Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) interface This subroutine returns the diffusion matrix in space domain private pure function Space_DiffusionMatrix_K(Test, Trial, K, nCopy) result(Ans) This function returns the diffusion matrix in space domain Read more… Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Test class(ElemshapeData_), intent(in) :: Trial class(FEVariable_), intent(in) :: K integer(kind=I4B), intent(in), optional :: nCopy Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) interface This subroutine makes mass matrix in space domain private pure function Space_MassMatrix(Test, Trial, Rho, nCopy) result(Ans) This subroutine makes space matrix in space domain, Here Rho $\\rho$ is a\n finite element variable Read more… Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Test Shapedata for test function class(ElemshapeData_), intent(in) :: Trial Shapedata for trial function class(FEVariable_), intent(in), optional :: Rho Finite element variable (density) integer(kind=I4B), intent(in), optional :: nCopy number of diagonal copies Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) interface private pure function Space_StiffnessMatrix_Cijkl(Test, Trial, Cijkl) result(Ans) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Test class(ElemshapeData_), intent(in) :: Trial class(FEVariable_), intent(in) :: Cijkl Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) interface private pure function Space_StiffnessMatrix_LamMu(Test, Trial, Lambda, Mu) result(Ans) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Test class(ElemshapeData_), intent(in) :: Trial real(kind=DFP), intent(in) :: Lambda real(kind=DFP), intent(in) :: Mu Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) interface private pure function Space_StiffnessMatrix_Lambda(Test, Trial, Lambda, Mu) result(Ans) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Test class(ElemshapeData_), intent(in) :: Trial class(FEVariable_), intent(in) :: Lambda class(FEVariable_), intent(in) :: Mu Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) public interface StiffnessMatrix private interface Space_StiffnessMatrix_Cijkl () Arguments None private interface StiffnessMatrix private interface Space_StiffnessMatrix_Lambda () Arguments None private interface StiffnessMatrix private interface Space_StiffnessMatrix_LamMu () Arguments None interface private pure function space_nitsche_mat_1(Test, Trial, Lambda, Mu, Evec) result(Ans) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Test class(ElemshapeData_), intent(in) :: Trial class(FEVariable_), intent(in) :: Lambda class(FEVariable_), intent(in) :: Mu class(FEVariable_), intent(in) :: Evec Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) interface private pure function space_nitsche_mat_2(Test, Trial, Alpha, Evec) result(Ans) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Test class(ElemshapeData_), intent(in) :: Trial class(FEVariable_), intent(in) :: Alpha class(FEVariable_), intent(in) :: Evec Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) interface private pure function space_nitsche_mat_3(Test, Trial, Lambda, Mu, Evec) result(Ans) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Test class(ElemshapeData_), intent(in) :: Trial real(kind=DFP), intent(in) :: Lambda real(kind=DFP), intent(in) :: Mu class(FEVariable_), intent(in) :: Evec Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) interface private pure function space_nitsche_mat_4(Test, Trial, Alpha, Evec) result(Ans) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Test class(ElemshapeData_), intent(in) :: Trial real(kind=DFP), intent(in) :: Alpha class(FEVariable_), intent(in) :: Evec Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) interface private pure function space_nitsche_mat_5(Test, Trial, Lambda, Mu, isNoSlip) result(Ans) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Test class(ElemshapeData_), intent(in) :: Trial real(kind=DFP), intent(in) :: Lambda real(kind=DFP), intent(in) :: Mu logical(kind=LGT), intent(in) :: isNoSlip Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) interface private pure function space_nitsche_mat_7(Test, Trial, Lambda, Mu, isNoSlip) result(Ans) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Test class(ElemshapeData_), intent(in) :: Trial class(FEVariable_), intent(in) :: Lambda class(FEVariable_), intent(in) :: Mu logical(kind=LGT), intent(in) :: isNoSlip Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) interface private pure function st_diffusionMatrix(Test, Trial, nCopy) result(Ans) Arguments Type Intent Optional Attributes Name class(STElemshapeData_), intent(in) :: Test (:) class(STElemshapeData_), intent(in) :: Trial (:) integer(kind=I4B), intent(in), optional :: nCopy Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) interface private pure function st_diffusionMatrix_C(Test, Trial, C1, C2, nCopy) result(Ans) Arguments Type Intent Optional Attributes Name class(STElemshapeData_), intent(in) :: Test (:) class(STElemshapeData_), intent(in) :: Trial (:) class(FEVariable_), intent(in) :: C1 class(FEVariable_), intent(in) :: C2 integer(kind=I4B), intent(in), optional :: nCopy Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) interface private pure function st_diffusionMatrix_K(Test, Trial, K, nCopy) result(Ans) Arguments Type Intent Optional Attributes Name class(STElemshapeData_), intent(in) :: Test (:) class(STElemshapeData_), intent(in) :: Trial (:) class(FEVariable_), intent(in) :: K integer(kind=I4B), intent(in), optional :: nCopy Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) interface This subroutine makes mass matrix in space time domain private pure function st_massMatrix_a(Test, Trial, Rho, Term1, Term2, nCopy) result(Ans) This subroutine makes space matrix in space domain, Here Rho $\\rho$ is a\n finite element variable. Following expression can be evaluated Read more… Arguments Type Intent Optional Attributes Name class(STElemshapeData_), intent(in) :: Test (:) class(STElemshapeData_), intent(in) :: Trial (:) type(FEVariable_), intent(in), optional :: Rho integer(kind=I4B), intent(in) :: Term1 If 0 then time derivative in first term true, otherwise false integer(kind=I4B), intent(in) :: Term2 If 0 then time derivative in second term true, otherwise false integer(kind=I4B), intent(in), optional :: nCopy Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:)","tags":"","loc":"module/fematrix_module.html"},{"title":"IndexValue_Method – Fortran Program","text":"Uses GlobalData BaseType Contents Interfaces Constructor1 Constructor2 Constructor3 IndexValue Interfaces interface private pure function Constructor1(Indx, Val) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Indx real(kind=DFP), intent(in) :: Val Return Value type(IndexValue_) interface private pure function Constructor2(Indx, Val) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Indx (:) real(kind=DFP), intent(in) :: Val (:) Return Value type(IndexValue_),\n  ALLOCATABLE, (:) interface private pure function Constructor3(Indx, Val) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Indx (:) real(kind=DFP), intent(in) :: Val Return Value type(IndexValue_),\n  ALLOCATABLE, (:) public interface IndexValue private interface Constructor1 () Arguments None private interface Constructor2 () Arguments None private interface Constructor3 () Arguments None","tags":"","loc":"module/indexvalue_method.html"},{"title":"IterationData_Method – Fortran Program","text":"Uses GlobalData BaseType Contents Interfaces Display Display_obj Initiate initiate_obj isConverged is_converged Interfaces public interface Display private interface Display_obj () Arguments None interface private subroutine Display_obj(Obj, msg, UnitNo) Arguments Type Intent Optional Attributes Name type(IterationData_), intent(in) :: Obj character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: UnitNo public interface Initiate private interface initiate_obj () Arguments None interface private subroutine initiate_obj(Obj, MaxIter, IterationNumber, Tolerance, ErrorAtStart, ErrorAtEnd, TimeAtStart, TimeAtEnd, ConvergenceType, ConvergenceIn, NormType, Converged) Arguments Type Intent Optional Attributes Name type(IterationData_), intent(inout) :: Obj integer(kind=I4B), intent(in), optional :: MaxIter integer(kind=I4B), intent(in), optional :: IterationNumber real(kind=DFP), intent(in), optional :: Tolerance real(kind=DFP), intent(in), optional :: ErrorAtStart real(kind=DFP), intent(in), optional :: ErrorAtEnd real(kind=DFP), intent(in), optional :: TimeAtStart real(kind=DFP), intent(in), optional :: TimeAtEnd integer(kind=I4B), intent(in), optional :: ConvergenceType integer(kind=I4B), intent(in), optional :: ConvergenceIn integer(kind=I4B), intent(in), optional :: NormType logical(kind=LGT), intent(in), optional :: Converged public interface isConverged private interface is_converged () Arguments None interface private pure function is_converged(Obj) result(Ans) Arguments Type Intent Optional Attributes Name type(IterationData_), intent(in) :: Obj Return Value logical(kind=LGT)","tags":"","loc":"module/iterationdata_method.html"},{"title":"KeyValue_Method – Fortran Program","text":"This module contains interfaces of methods related to KeyValue_ authors: Dr. Vikas Sharma Usage fortran\n program main\n use easifem\n implicit none\n type( keyvalue_ ) :: obj\n real( dfp ) :: vec( 3 ), mat( 3, 3 )\n call random_number( vec )\n call random_number( mat )\n obj = keyvalue( 'real-rank-0', 1.0_dfp )\n obj = 1.0_dfp\n call display( obj, 'obj' )\n obj = keyvalue( 'real-rank-1', vec )\n obj = [1.0_dfp, 1.0_dfp, 1.0_dfp]\n call display( obj, 'obj' )\n obj = keyvalue( 'real-rank-2', mat )\n call display( obj, 'obj' )\n end program main Uses BaseType GlobalData StringiFor Contents Variables INT_RANK_0 INT_RANK_1 INT_RANK_2 REAL_RANK_0 REAL_RANK_1 REAL_RANK_2 Interfaces ASSIGNMENT( = ) ASSIGNMENT( = ) ASSIGNMENT( = ) ASSIGNMENT( = ) Append Constructor1 Constructor10 Constructor11 Constructor12 Constructor2 Constructor3 Constructor4 Constructor5 Constructor6 Constructor7 Constructor8 Constructor9 Contains1 Contains2 DeallocateData Display Equal1 Equal2 Equal3 Equal4 Index1 Index2 IndexOf Initiate Initiate1 Initiate10 Initiate11 Initiate12 Initiate13 Initiate2 Initiate3 Initiate4 Initiate5 Initiate6 Initiate7 Initiate8 Initiate9 KeyValue KeyValue_Pointer OPERATOR( .CONTAINS. ) OPERATOR( .EQ. ) OPERATOR( .INDEX. ) Present1 Present2 SetValue1 SetValue2 SetValue3 SetValue4 SetValue5 SetValue6 getKey getKey1 getKey2 getValue getValue1 getValue2 getValue3 getValue4 getValue5 getValue6 keyvalue_append keyvalue_deallocate keyvalue_display mp_display setKey setKey1 setKey2 setValue Functions Constructor_1 Constructor_10 Constructor_11 Constructor_12 Constructor_2 Constructor_3 Constructor_4 Constructor_5 Constructor_6 Constructor_7 Constructor_8 Constructor_9 Variables Type Visibility Attributes Name Initial integer, private, parameter :: INT_RANK_0 = 3 integer, private, parameter :: INT_RANK_1 = 4 integer, private, parameter :: INT_RANK_2 = 5 integer, private, parameter :: REAL_RANK_0 = 0 integer, private, parameter :: REAL_RANK_1 = 1 integer, private, parameter :: REAL_RANK_2 = 2 Interfaces public interface ASSIGNMENT( = ) private interface SetValue1 () Set value in KeyValue_ object Arguments None private interface SetValue2 () Set value in KeyValue_ object Arguments None private interface SetValue3 () Set value in KeyValue_ object Arguments None private interface SetValue4 () Set value in KeyValue_ object Arguments None private interface SetValue5 () Set value in KeyValue_ object Arguments None private interface SetValue6 () Set value in KeyValue_ object Arguments None private interface ASSIGNMENT( = ) private interface setKey1 () Set key in KeyValue_ object Arguments None private interface setKey2 () Set key in KeyValue_ object Arguments None private interface ASSIGNMENT( = ) private interface getKey1 () get key from KeyValue_ Arguments None private interface getKey2 () get key from KeyValue_ Arguments None private interface ASSIGNMENT( = ) private interface getValue1 () getValue from KeyValue_ Arguments None private interface getValue2 () getValue from KeyValue_ Arguments None private interface getValue3 () getValue from KeyValue_ Arguments None private interface getValue4 () getValue from KeyValue_ Arguments None private interface getValue5 () getValue from KeyValue_ Arguments None private interface getValue6 () getValue from KeyValue_ Arguments None public interface Append private interface keyvalue_append () Subroutine that append keyvalue_ instance to an array of KeyValue_ type Arguments None interface Function that constructs KeyValue_ private elemental function Constructor1(Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Key real(kind=DFP), intent(in) :: Value Return Value type(keyValue_) interface Function that constructs KeyValue_ private pure function Constructor10(Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name type(String), intent(in) :: Key integer(kind=I4B), intent(in) :: Value (:) Return Value type(keyValue_) interface Function that constructs KeyValue_ private pure function Constructor11(Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Key integer(kind=I4B), intent(in) :: Value (:,:) Return Value type(keyValue_) interface Function that constructs KeyValue_ private pure function Constructor12(Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name type(String), intent(in) :: Key integer(kind=I4B), intent(in) :: Value (:,:) Return Value type(keyValue_) interface Function that constructs KeyValue_ private elemental function Constructor2(Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name type(String), intent(in) :: Key real(kind=DFP), intent(in) :: Value Return Value type(keyValue_) interface Function that constructs KeyValue_ private pure function Constructor3(Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Key real(kind=DFP), intent(in) :: Value (:) Return Value type(keyValue_) interface Function that constructs KeyValue_ private pure function Constructor4(Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name type(String), intent(in) :: Key real(kind=DFP), intent(in) :: Value (:) Return Value type(keyValue_) interface Function that constructs KeyValue_ private pure function Constructor5(Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Key real(kind=DFP), intent(in) :: Value (:,:) Return Value type(keyValue_) interface Function that constructs KeyValue_ private pure function Constructor6(Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name type(String), intent(in) :: Key real(kind=DFP), intent(in) :: Value (:,:) Return Value type(keyValue_) interface Function that constructs KeyValue_ private elemental function Constructor7(Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Key integer(kind=I4B), intent(in) :: Value Return Value type(keyValue_) interface Function that constructs KeyValue_ private elemental function Constructor8(Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name type(String), intent(in) :: Key integer(kind=I4B), intent(in) :: Value Return Value type(keyValue_) interface Function that constructs KeyValue_ private pure function Constructor9(Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Key integer(kind=I4B), intent(in) :: Value (:) Return Value type(keyValue_) interface private pure function Contains1(Obj, Key) result(Ans) Arguments Type Intent Optional Attributes Name type(KeyValue_), intent(in) :: Obj (:) character(len=*), intent(in) :: Key Return Value logical(kind=LGT) interface private pure function Contains2(Obj, Key) result(Ans) Arguments Type Intent Optional Attributes Name type(KeyValue_), intent(in) :: Obj (:) type(String), intent(in) :: Key Return Value logical(kind=LGT) public interface DeallocateData private interface keyvalue_deallocate () Arguments None public interface Display Generic subroutine to display content of KeyValue_ private interface keyvalue_display () This subroutine display contents of KeyValue_ Arguments None private interface mp_display () Display content of vector of KeyValue_ Arguments None interface Function to check equality in KeyValue_ private elemental function Equal1(Obj, Key) result(Ans) Arguments Type Intent Optional Attributes Name class(KeyValue_), intent(in) :: Obj character(len=*), intent(in) :: Key Return Value logical(kind=LGT) interface Function to check equality in KeyValue_ private elemental function Equal2(Key, Obj) result(Ans) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Key class(KeyValue_), intent(in) :: Obj Return Value logical(kind=LGT) interface Function to check equality in KeyValue_ private elemental function Equal3(Obj, Key) result(Ans) Arguments Type Intent Optional Attributes Name class(KeyValue_), intent(in) :: Obj type(String), intent(in) :: Key Return Value logical(kind=LGT) interface Function to check equality in KeyValue_ private elemental function Equal4(Key, Obj) result(Ans) Arguments Type Intent Optional Attributes Name type(String), intent(in) :: Key class(KeyValue_), intent(in) :: Obj Return Value logical(kind=LGT) interface private pure function Index1(Obj, Key) result(Ans) Arguments Type Intent Optional Attributes Name type(KeyValue_), intent(in) :: Obj (:) character(len=*), intent(in) :: Key Return Value integer(kind=I4B) interface private pure function Index2(Obj, Key) result(Ans) Arguments Type Intent Optional Attributes Name type(KeyValue_), intent(in) :: Obj (:) type(String), intent(in) :: Key Return Value integer(kind=I4B) public interface IndexOf private interface Index1 () Arguments None private interface Index2 () Arguments None public interface Initiate private interface Initiate1 () Subroutine that initiate instance of KeyValue_ Arguments None private interface Initiate2 () Subroutine that initiate instance of KeyValue_ Arguments None private interface Initiate3 () Subroutine that initiate instance of KeyValue_ Arguments None private interface Initiate4 () Subroutine that initiate instance of KeyValue_ Arguments None private interface Initiate5 () Subroutine that initiate instance of KeyValue_ Arguments None private interface Initiate6 () Subroutine that initiate instance of KeyValue_ Arguments None private interface Initiate7 () Subroutine that initiate instance of KeyValue_ Arguments None private interface Initiate8 () Subroutine that initiate instance of KeyValue_ Arguments None private interface Initiate9 () Subroutine that initiate instance of KeyValue_ Arguments None private interface Initiate10 () Subroutine that initiate instance of KeyValue_ Arguments None private interface Initiate11 () Subroutine that initiate instance of KeyValue_ Arguments None private interface Initiate12 () Subroutine that initiate instance of KeyValue_ Arguments None private interface Initiate13 () Subroutine that initiate instance of KeyValue_ Arguments None interface Subroutine that initiate instance of KeyValue_ private subroutine Initiate1(Obj, Key, Value) This suborutine constructs KeyValue_ object\n - Key = char - Value = Real Rank 0 Read more… Arguments Type Intent Optional Attributes Name class(keyValue_), intent(inout) :: Obj character(len=*), intent(in) :: Key real(kind=DFP), intent(in) :: Value interface Subroutine that initiate instance of KeyValue_ private subroutine Initiate10(Obj, Key, Value) This suborutine constructs KeyValue_ object\n - Key = string - Value = Int Rank 1 Arguments Type Intent Optional Attributes Name class(keyValue_), intent(inout) :: Obj type(String), intent(in) :: Key integer(kind=I4B), intent(in) :: Value (:) interface Subroutine that initiate instance of KeyValue_ private subroutine Initiate11(Obj, Key, Value) This suborutine constructs KeyValue_ object\n - Key = char - Value = Int Rank 2 Arguments Type Intent Optional Attributes Name class(keyValue_), intent(inout) :: Obj character(len=*), intent(in) :: Key integer(kind=I4B), intent(in) :: Value (:,:) interface Subroutine that initiate instance of KeyValue_ private subroutine Initiate12(Obj, Key, Value) This suborutine constructs KeyValue_ object\n - Key = string - Value = Int Rank 2 Arguments Type Intent Optional Attributes Name class(keyValue_), intent(inout) :: Obj type(String), intent(in) :: Key integer(kind=I4B), intent(in) :: Value (:,:) interface Subroutine that initiate instance of KeyValue_ private subroutine Initiate13(Obj, Obj2) This suborutine constructs KeyValue_ object Arguments Type Intent Optional Attributes Name class(keyValue_), intent(inout) :: Obj class(keyValue_), intent(in) :: Obj2 interface Subroutine that initiate instance of KeyValue_ private subroutine Initiate2(Obj, Key, Value) This suborutine constructs KeyValue_ object\n - Key = string - Value = Real Rank 0 Read more… Arguments Type Intent Optional Attributes Name class(keyValue_), intent(inout) :: Obj type(String), intent(in) :: Key real(kind=DFP), intent(in) :: Value interface Subroutine that initiate instance of KeyValue_ private subroutine Initiate3(Obj, Key, Value) This suborutine constructs KeyValue_ object\n - Key = char - Value = Real Rank 1 Arguments Type Intent Optional Attributes Name class(keyValue_), intent(inout) :: Obj character(len=*), intent(in) :: Key real(kind=DFP), intent(in) :: Value (:) interface Subroutine that initiate instance of KeyValue_ private subroutine Initiate4(Obj, Key, Value) This suborutine constructs KeyValue_ object\n - Key = String - Value = Real Rank 1 Arguments Type Intent Optional Attributes Name class(keyValue_), intent(inout) :: Obj type(String), intent(in) :: Key real(kind=DFP), intent(in) :: Value (:) interface Subroutine that initiate instance of KeyValue_ private subroutine Initiate5(Obj, Key, Value) This suborutine constructs KeyValue_ object\n - Key = char - Value = Real Rank 2 Arguments Type Intent Optional Attributes Name class(keyValue_), intent(inout) :: Obj character(len=*), intent(in) :: Key real(kind=DFP), intent(in) :: Value (:,:) interface Subroutine that initiate instance of KeyValue_ private subroutine Initiate6(Obj, Key, Value) This suborutine constructs KeyValue_ object\n - Key = String - Value = Real Rank 2 Arguments Type Intent Optional Attributes Name class(keyValue_), intent(inout) :: Obj type(String), intent(in) :: Key real(kind=DFP), intent(in) :: Value (:,:) interface Subroutine that initiate instance of KeyValue_ private subroutine Initiate7(Obj, Key, Value) This suborutine constructs KeyValue_ object\n - Key = char - Value = Int Rank 0 Arguments Type Intent Optional Attributes Name class(keyValue_), intent(inout) :: Obj character(len=*), intent(in) :: Key integer(kind=I4B), intent(in) :: Value interface Subroutine that initiate instance of KeyValue_ private subroutine Initiate8(Obj, Key, Value) This suborutine constructs KeyValue_ object\n - Key = String - Value = Int Rank 0 Arguments Type Intent Optional Attributes Name class(keyValue_), intent(inout) :: Obj type(String), intent(in) :: Key integer(kind=I4B), intent(in) :: Value interface Subroutine that initiate instance of KeyValue_ private subroutine Initiate9(Obj, Key, Value) This suborutine constructs KeyValue_ object\n - Key = char - Value = Int Rank 1 Arguments Type Intent Optional Attributes Name class(keyValue_), intent(inout) :: Obj character(len=*), intent(in) :: Key integer(kind=I4B), intent(in) :: Value (:) public interface KeyValue private interface Constructor1 () Function that constructs KeyValue_ Arguments None private interface Constructor2 () Function that constructs KeyValue_ Arguments None private interface Constructor3 () Function that constructs KeyValue_ Arguments None private interface Constructor4 () Function that constructs KeyValue_ Arguments None private interface Constructor5 () Function that constructs KeyValue_ Arguments None private interface Constructor6 () Function that constructs KeyValue_ Arguments None private interface Constructor7 () Function that constructs KeyValue_ Arguments None private interface Constructor8 () Function that constructs KeyValue_ Arguments None private interface Constructor9 () Function that constructs KeyValue_ Arguments None private interface Constructor10 () Function that constructs KeyValue_ Arguments None private interface Constructor11 () Function that constructs KeyValue_ Arguments None private interface Constructor12 () Function that constructs KeyValue_ Arguments None public interface KeyValue_Pointer private function Constructor_1 (Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Key real(kind=DFP), intent(in) :: Value Return Value class(keyValue_),\n  POINTER private function Constructor_2 (Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name type(String), intent(in) :: Key real(kind=DFP), intent(in) :: Value Return Value class(keyValue_),\n  POINTER private function Constructor_3 (Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Key real(kind=DFP), intent(in) :: Value (:) Return Value class(keyValue_),\n  POINTER private function Constructor_4 (Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name type(String), intent(in) :: Key real(kind=DFP), intent(in) :: Value (:) Return Value class(keyValue_),\n  POINTER private function Constructor_5 (Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Key real(kind=DFP), intent(in) :: Value (:,:) Return Value class(keyValue_),\n  POINTER private function Constructor_6 (Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name type(String), intent(in) :: Key real(kind=DFP), intent(in) :: Value (:,:) Return Value class(keyValue_),\n  POINTER private function Constructor_7 (Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Key integer(kind=I4B), intent(in) :: Value Return Value class(keyValue_),\n  POINTER private function Constructor_8 (Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name type(String), intent(in) :: Key integer(kind=I4B), intent(in) :: Value Return Value class(keyValue_),\n  POINTER private function Constructor_9 (Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Key integer(kind=I4B), intent(in) :: Value (:) Return Value class(keyValue_),\n  POINTER private function Constructor_10 (Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name type(String), intent(in) :: Key integer(kind=I4B), intent(in) :: Value (:) Return Value class(keyValue_),\n  POINTER private function Constructor_11 (Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Key integer(kind=I4B), intent(in) :: Value (:,:) Return Value class(keyValue_),\n  POINTER private function Constructor_12 (Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name type(String), intent(in) :: Key integer(kind=I4B), intent(in) :: Value (:,:) Return Value class(keyValue_),\n  POINTER public interface OPERATOR( .CONTAINS. ) private interface Present1 () Arguments None private interface Present2 () Arguments None private interface Contains1 () Arguments None private interface Contains2 () Arguments None public interface OPERATOR( .EQ. ) private interface Equal1 () Function to check equality in KeyValue_ Arguments None private interface Equal2 () Function to check equality in KeyValue_ Arguments None private interface Equal3 () Function to check equality in KeyValue_ Arguments None private interface Equal4 () Function to check equality in KeyValue_ Arguments None public interface OPERATOR( .INDEX. ) private interface Index1 () Arguments None private interface Index2 () Arguments None interface private pure function Present1(Key, Obj) result(Ans) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Key type(KeyValue_), intent(in) :: Obj (:) Return Value logical(kind=LGT) interface private pure function Present2(Key, Obj) result(Ans) Arguments Type Intent Optional Attributes Name type(String), intent(in) :: Key type(KeyValue_), intent(in) :: Obj (:) Return Value logical(kind=LGT) interface Set value in KeyValue_ object private subroutine SetValue1(Obj, Value) This subroutine set real scalar value in KeyValue_ Read more… Arguments Type Intent Optional Attributes Name class(keyValue_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Value interface Set value in KeyValue_ object private subroutine SetValue2(Obj, Value) This subroutine set real vector value in KeyValue_ Read more… Arguments Type Intent Optional Attributes Name class(keyValue_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Value (:) interface Set value in KeyValue_ object private subroutine SetValue3(Obj, Value) This subroutine set real matrix value in KeyValue_ Read more… Arguments Type Intent Optional Attributes Name class(keyValue_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Value (:,:) interface Set value in KeyValue_ object private subroutine SetValue4(Obj, Value) This subroutine set integer scalar value in KeyValue_ Read more… Arguments Type Intent Optional Attributes Name class(keyValue_), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Value interface Set value in KeyValue_ object private subroutine SetValue5(Obj, Value) This subroutine set integer vector value in KeyValue_ Read more… Arguments Type Intent Optional Attributes Name class(keyValue_), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Value (:) interface Set value in KeyValue_ object private subroutine SetValue6(Obj, Value) This subroutine set integer matrix value in KeyValue_ Read more… Arguments Type Intent Optional Attributes Name class(keyValue_), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Value (:,:) public interface getKey Generic subroutine to get key from KeyValue_ private interface getKey1 () get key from KeyValue_ Arguments None private interface getKey2 () get key from KeyValue_ Arguments None interface get key from KeyValue_ private subroutine getKey1(Key, Obj) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: Key class(KeyValue_), intent(in) :: Obj interface get key from KeyValue_ private subroutine getKey2(Key, Obj) Arguments Type Intent Optional Attributes Name type(String), intent(inout) :: Key class(KeyValue_), intent(in) :: Obj public interface getValue Generic subroutine to get value from KeyValue_ private interface getValue1 () getValue from KeyValue_ Arguments None private interface getValue2 () getValue from KeyValue_ Arguments None private interface getValue3 () getValue from KeyValue_ Arguments None private interface getValue4 () getValue from KeyValue_ Arguments None private interface getValue5 () getValue from KeyValue_ Arguments None private interface getValue6 () getValue from KeyValue_ Arguments None interface getValue from KeyValue_ private subroutine getValue1(Value, Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout) :: Value class(keyValue_), intent(in) :: Obj interface getValue from KeyValue_ private subroutine getValue2(Value, Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: Value (:) class(keyValue_), intent(in) :: Obj interface getValue from KeyValue_ private subroutine getValue3(Value, Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: Value (:,:) class(keyValue_), intent(in) :: Obj interface getValue from KeyValue_ private subroutine getValue4(Value, Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout) :: Value class(keyValue_), intent(in) :: Obj interface getValue from KeyValue_ private subroutine getValue5(Value, Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), ALLOCATABLE :: Value (:) class(keyValue_), intent(in) :: Obj interface getValue from KeyValue_ private subroutine getValue6(Value, Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), ALLOCATABLE :: Value (:,:) class(keyValue_), intent(in) :: Obj interface Subroutine that append keyvalue_ instance to an array of KeyValue_ type private subroutine keyvalue_append(Obj, KeyValObj) Arguments Type Intent Optional Attributes Name type(KeyValue_), intent(inout), ALLOCATABLE :: Obj (:) type(KeyValue_), intent(in) :: KeyValObj interface private subroutine keyvalue_deallocate(Obj) Arguments Type Intent Optional Attributes Name class(KeyValue_), intent(inout) :: Obj interface This subroutine display contents of KeyValue_ private subroutine keyvalue_display(Obj, msg, UnitNo) Arguments Type Intent Optional Attributes Name class(keyValue_), intent(in) :: Obj character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: UnitNo interface Display content of vector of KeyValue_ private subroutine mp_display(Obj, msg, UnitNo) Arguments Type Intent Optional Attributes Name type(keyvalue_), intent(in) :: Obj (:) character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: UnitNo public interface setKey Generic subroutine to set key in KeyValue_ private interface setKey1 () Set key in KeyValue_ object Arguments None private interface setKey2 () Set key in KeyValue_ object Arguments None interface Set key in KeyValue_ object private subroutine setKey1(Obj, Key) This subroutine set key in KeyValue_ Read more… Arguments Type Intent Optional Attributes Name class(KeyValue_), intent(inout) :: Obj character(len=*), intent(in) :: Key interface Set key in KeyValue_ object private subroutine setKey2(Obj, Key) This subroutine set key in KeyValue_ Read more… Arguments Type Intent Optional Attributes Name class(KeyValue_), intent(inout) :: Obj type(String), intent(in) :: Key public interface setValue Generic subroutine to set values in KeyValue_ private interface SetValue1 () Set value in KeyValue_ object Arguments None private interface SetValue2 () Set value in KeyValue_ object Arguments None private interface SetValue3 () Set value in KeyValue_ object Arguments None private interface SetValue4 () Set value in KeyValue_ object Arguments None private interface SetValue5 () Set value in KeyValue_ object Arguments None private interface SetValue6 () Set value in KeyValue_ object Arguments None Functions private function Constructor_1 (Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Key real(kind=DFP), intent(in) :: Value Return Value class(keyValue_),\n  POINTER private function Constructor_10 (Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name type(String), intent(in) :: Key integer(kind=I4B), intent(in) :: Value (:) Return Value class(keyValue_),\n  POINTER private function Constructor_11 (Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Key integer(kind=I4B), intent(in) :: Value (:,:) Return Value class(keyValue_),\n  POINTER private function Constructor_12 (Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name type(String), intent(in) :: Key integer(kind=I4B), intent(in) :: Value (:,:) Return Value class(keyValue_),\n  POINTER private function Constructor_2 (Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name type(String), intent(in) :: Key real(kind=DFP), intent(in) :: Value Return Value class(keyValue_),\n  POINTER private function Constructor_3 (Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Key real(kind=DFP), intent(in) :: Value (:) Return Value class(keyValue_),\n  POINTER private function Constructor_4 (Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name type(String), intent(in) :: Key real(kind=DFP), intent(in) :: Value (:) Return Value class(keyValue_),\n  POINTER private function Constructor_5 (Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Key real(kind=DFP), intent(in) :: Value (:,:) Return Value class(keyValue_),\n  POINTER private function Constructor_6 (Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name type(String), intent(in) :: Key real(kind=DFP), intent(in) :: Value (:,:) Return Value class(keyValue_),\n  POINTER private function Constructor_7 (Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Key integer(kind=I4B), intent(in) :: Value Return Value class(keyValue_),\n  POINTER private function Constructor_8 (Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name type(String), intent(in) :: Key integer(kind=I4B), intent(in) :: Value Return Value class(keyValue_),\n  POINTER private function Constructor_9 (Key, Value) result(Ans) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Key integer(kind=I4B), intent(in) :: Value (:) Return Value class(keyValue_),\n  POINTER","tags":"","loc":"module/keyvalue_method.html"},{"title":"SparseMatrix_Method – Fortran Program","text":"Uses GlobalData BaseType Contents Interfaces AllocateData Allocate_data ArrayValues Clean ColSORT Convert Copy CsrToDense DeallocateData Deallocate_Data Display Display_CSR_2 Display_obj Initiate MatVec Matmul RemoveDuplicates Shape Size SparseKit_ILUT SparseKit_ilud SparseKit_iludp SparseKit_ilutp Sparsekit_LSolve Sparsekit_LUSOLVE Sparsekit_LUTSOLVE Sparsekit_USolve Spy addContribution addContributionInternally addContribution_1 aij_convert_dns clean_CSR copy_CSR_CSR csort_CSR getNNZ get_nnz get_scalar_value get_shape get_size ilud_csr iludp_csr ilut_csr ilutp_csr initiate_obj1 initiate_obj2 initiate_obj3 initiate_obj4 initiate_obj5 lsol_csr lusol_alu lutsol_alu matmul_CSR matvec_CSR_amux obj_convert_dns obj_spy remove_duplicates_csr setSparsity setSparsity_1 setSparsity_2 setSparsity_3 setValue setValueInternally setValue_1 setValue_2 usol_csr Interfaces public interface AllocateData private interface Allocate_data () This subroutine creates memeory space for the sparse matrix object Arguments None interface This subroutine creates memeory space for the sparse matrix object private subroutine Allocate_data(Obj, Dims, MatrixProp) This subroutine creates memory space for the sparse matrix Read more… Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Dims (2) character(len=*), intent(in), optional :: MatrixProp public interface ArrayValues private interface get_scalar_value () Arguments None public interface Clean private interface clean_CSR () —    1 eliminate duplicates and zeros\n—    2 eliminate duplicates and perform partial ordering\n—    3 eliminate duplicates and sort entries in increasing order of\n—    col indices\n— Values  .true. work on Obj % A too, otherwise dont touch Obj % A\n— INDU contains pointers to upper triangle Arguments None public interface ColSORT private interface csort_CSR () Arguments None public interface Convert private interface aij_convert_dns () This subroutine converts sparsematrix to dense storage Arguments None private interface obj_convert_dns () Arguments None public interface Copy private interface copy_CSR_CSR () Arguments None public interface CsrToDense public subroutine CSRDNS(nrow, ncol, A, JA, IA, DNS, ndns, ierr) Arguments Type Intent Optional Attributes Name integer(kind=Int32), intent(in) :: nrow integer(kind=Int32), intent(in) :: ncol real(kind=Real64), intent(in) :: A (:) integer(kind=Int32), intent(in) :: JA (:) integer(kind=Int32), intent(in) :: IA (:) real(kind=Real64), intent(inout) :: DNS (:,:) integer(kind=Int32), intent(in) :: ndns integer(kind=Int32), intent(inout) :: ierr public interface DeallocateData private interface Deallocate_Data () This subroutine deallocates the data Arguments None interface This subroutine deallocates the data private subroutine Deallocate_Data(Obj) This subroutine deallocates the data stored Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(inout) :: Obj public interface Display private interface Display_obj () This subroutine display the content of sparse matrix Arguments None private interface Display_CSR_2 () This subroutine displays the content of sparse matrix Arguments None interface This subroutine displays the content of sparse matrix private subroutine Display_CSR_2(Obj, msg, options) This subroutine displays the content of sparse matrix\n - options( 1 ) = i1\n - options( 2 ) = i2\n - options( 3 ) = 1 if values need to be printed else dont print values\n - options( 4 ) = unitno Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(in) :: Obj character(len=*), intent(in) :: msg integer(kind=I4B), intent(in) :: options (:) interface This subroutine display the content of sparse matrix private subroutine Display_obj(Obj, Msg, UnitNo) This subroutine display the content of sparse matrix\n - In this subroutine dump routine from sparsekit lib is called Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(in) :: Obj character(len=*), intent(in) :: Msg integer(kind=I4B), intent(in), optional :: UnitNo public interface Initiate private interface initiate_obj1 () This subroutine construct the SparseMatrix_ object Arguments None private interface initiate_obj2 () This subroutine converts a dense matrix into sparse matrix Arguments None private interface initiate_obj3 () This matrix converts a dense matrix into a sparse matrix Arguments None private interface initiate_obj4 () This subroutine construct sparsematrix_ object from IA, JA, A Arguments None private interface initiate_obj5 () Arguments None public interface MatVec private interface matvec_CSR_amux () Arguments None public interface Matmul private interface matmul_CSR () Arguments None public interface RemoveDuplicates private interface remove_duplicates_csr () Arguments None public interface Shape private interface get_shape () This function returns the shape of sparse matrix Arguments None public interface Size private interface get_size () This function returns the size of sparse matrix Arguments None public interface SparseKit_ILUT private interface ilut_csr () Arguments None public interface SparseKit_ilud private interface ilud_csr () Arguments None public interface SparseKit_iludp private interface iludp_csr () Arguments None public interface SparseKit_ilutp private interface ilutp_csr () Arguments None public interface Sparsekit_LSolve private interface lsol_csr () — Solve Lx = y by forward elimination technique will be used Arguments None public interface Sparsekit_LUSOLVE private interface lusol_alu () Arguments None public interface Sparsekit_LUTSOLVE private interface lutsol_alu () Arguments None public interface Sparsekit_USolve private interface usol_csr () — Solve Ux = y by backward elimination technique will be used Arguments None public interface Spy private interface obj_spy () Arguments None public interface addContribution private interface addContribution_1 () Arguments None interface private subroutine addContributionInternally(Obj, Nptrs, Val, Scale) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Nptrs (:) real(kind=DFP), intent(in) :: Val (:,:) real(kind=DFP), intent(in) :: Scale interface private subroutine addContribution_1(Obj, Nptrs, Val, Scale, StorageFMT) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Nptrs (:) real(kind=DFP), intent(in) :: Val (:,:) real(kind=DFP), intent(in) :: Scale integer(kind=I4B), intent(in) :: StorageFMT interface This subroutine converts sparsematrix to dense storage private subroutine aij_convert_dns(A, IA, JA, mat) This subroutine converts sparsematrix to dense storage format A(:), IA(:), JA(:) denotes CSR format. Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: A (:) integer(kind=I4B), intent(in) :: IA (:) integer(kind=I4B), intent(in) :: JA (:) real(kind=DFP), intent(inout), ALLOCATABLE :: mat (:,:) interface —    1 eliminate duplicates and zeros\n—    2 eliminate duplicates and perform partial ordering\n—    3 eliminate duplicates and sort entries in increasing order of\n—    col indices\n— Values  .true. work on Obj % A too, otherwise dont touch Obj % A\n— INDU contains pointers to upper triangle private subroutine clean_CSR(Obj, Values, ExtraOption, INDU) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(inout) :: Obj logical(kind=LGT), intent(in) :: Values integer(kind=I4B), intent(in) :: ExtraOption integer(kind=I4B), intent(inout), ALLOCATABLE :: INDU (:) interface private subroutine copy_CSR_CSR(From, To, Values) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(in) :: From type(SparseMatrix_), intent(inout) :: To logical(kind=LGT), intent(in), optional :: Values interface private subroutine csort_CSR(Obj, Values) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(inout) :: Obj logical(kind=LGT), intent(in), optional :: Values public interface getNNZ private interface get_nnz () Return the total number of non zero entry in the matrix Arguments None interface Return the total number of non zero entry in the matrix private pure function get_nnz(Obj) result(Ans) This function return the total number of non-zero entry in the sparse matrix Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(in) :: Obj Return Value integer(kind=I4B) interface private function get_scalar_value(Obj, i, j, Sorted) result(Ans) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(in) :: Obj integer(kind=I4B), intent(in) :: i integer(kind=I4B), intent(in) :: j logical(kind=LGT), intent(in), optional :: Sorted Return Value real(kind=DFP) interface This function returns the shape of sparse matrix private pure function get_shape(Obj) result(Ans) This function returns the shape of sparse matrix Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(in) :: Obj Return Value integer(kind=I4B)\n  (2) interface This function returns the size of sparse matrix private pure function get_size(Obj, Dims) result(Ans) This function returns the size of sparse matrix\n If Dims equal to 1 then total number of rows are returned\n If Dims is equal to 2 then total number of columns are return\n If Dims is absent then nrow*ncol are returned Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(in) :: Obj integer(kind=I4B), intent(in), optional :: Dims Return Value integer(kind=I4B) interface private subroutine ilud_csr(Obj, alu, jlu, ju, ierr, alpha, droptol) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(in) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: alu (:) integer(kind=I4B), intent(inout), ALLOCATABLE :: jlu (:) integer(kind=I4B), intent(inout), ALLOCATABLE :: ju (:) integer(kind=I4B), intent(inout) :: ierr real(kind=DFP), intent(in), optional :: alpha real(kind=DFP), intent(in), optional :: droptol interface private subroutine iludp_csr(Obj, alu, jlu, ju, iperm, ierr, droptol, permtol, alpha, mbloc) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(inout) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: alu (:) integer(kind=I4B), intent(inout), ALLOCATABLE :: jlu (:) integer(kind=I4B), intent(inout), ALLOCATABLE :: ju (:) integer(kind=I4B), intent(inout), ALLOCATABLE :: iperm (:) integer(kind=I4B), intent(inout) :: ierr real(kind=DFP), intent(in), optional :: droptol real(kind=DFP), intent(in), optional :: permtol real(kind=DFP), intent(in), optional :: alpha integer(kind=I4B), intent(in), optional :: mbloc interface private subroutine ilut_csr(Obj, alu, jlu, ju, ierr, droptol, lfil) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(in) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: alu (:) integer(kind=I4B), intent(inout), ALLOCATABLE :: jlu (:) integer(kind=I4B), intent(inout), ALLOCATABLE :: ju (:) integer(kind=I4B), intent(inout) :: ierr real(kind=DFP), intent(in), optional :: droptol integer(kind=I4B), intent(in), optional :: lfil interface private subroutine ilutp_csr(Obj, alu, jlu, ju, iperm, ierr, droptol, permtol, lfil, mbloc) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(inout) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: alu (:) integer(kind=I4B), intent(inout), ALLOCATABLE :: jlu (:) integer(kind=I4B), intent(inout), ALLOCATABLE :: ju (:) integer(kind=I4B), intent(inout), ALLOCATABLE :: iperm (:) integer(kind=I4B), intent(inout) :: ierr real(kind=DFP), intent(in), optional :: droptol real(kind=DFP), intent(in), optional :: permtol integer(kind=I4B), intent(in), optional :: lfil integer(kind=I4B), intent(in), optional :: mbloc interface This subroutine construct the SparseMatrix_ object private subroutine initiate_obj1(Obj, tDOF, tNodes, MatrixProp, StorageFMT) This subroutine construct the sparsematrix_ object Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(inout) :: Obj integer(kind=I4B), intent(in) :: tDOF Total number of degrees of freedom integer(kind=I4B), intent(in) :: tNodes (:) Total nunber of spatial nodes (size of vec) of each dof character(len=*), intent(in), optional :: MatrixProp Matrix is SYM , UNSYM integer(kind=I4B), intent(in), optional :: StorageFMT interface This subroutine converts a dense matrix into sparse matrix private subroutine initiate_obj2(Obj, Val, MatrixProp) This subroutine converts a dense matrix into a sparse matrix Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val (:,:) character(len=*), intent(in), optional :: MatrixProp interface This matrix converts a dense matrix into a sparse matrix private subroutine initiate_obj3(Obj, Val, MatrixProp) This matrix converts a dense matrix into a sparse matrix Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(inout) :: Obj type(RealMatrix_), intent(in) :: Val character(len=*), intent(in), optional :: MatrixProp interface This subroutine construct sparsematrix_ object from IA, JA, A private subroutine initiate_obj4(Obj, A, IA, JA, MatrixProp) This subroutine constructs sparsematrix_ object from IA, JA, and A Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(inout) :: Obj real(kind=DFP), intent(in) :: A (:) integer(kind=I4B), intent(in) :: IA (:) integer(kind=I4B), intent(in) :: JA (:) character(len=*), intent(in), optional :: MatrixProp interface private subroutine initiate_obj5(Obj, IA, JA, MatrixProp) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(inout) :: Obj integer(kind=I4B), intent(in) :: IA (:) integer(kind=I4B), intent(in) :: JA (:) character(len=*), intent(in), optional :: MatrixProp interface — Solve Lx = y by forward elimination technique will be used private subroutine lsol_csr(Obj, x, y) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(in) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: x (:) real(kind=DFP), intent(in) :: y (:) interface private subroutine lusol_alu(x, y, alu, jlu, ju) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: x (:) real(kind=DFP), intent(in) :: y (:) real(kind=DFP), intent(in) :: alu (:) integer(kind=I4B), intent(in) :: jlu (:) integer(kind=I4B), intent(in) :: ju (:) interface private subroutine lutsol_alu(x, y, alu, jlu, ju) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: x (:) real(kind=DFP), intent(in) :: y (:) real(kind=DFP), intent(in) :: alu (:) integer(kind=I4B), intent(in) :: jlu (:) integer(kind=I4B), intent(in) :: ju (:) interface private function matmul_CSR(Obj, x, matvectype) result(Ans) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(in) :: Obj real(kind=DFP), intent(in) :: x (:) character(len=*), intent(in) :: matvectype Return Value real(kind=DFP)\n  (SIZE(x)) interface private subroutine matvec_CSR_amux(Obj, x, y, matvectype) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(in) :: Obj real(kind=DFP), intent(in) :: x (:) real(kind=DFP), intent(inout), ALLOCATABLE :: y (:) character(len=*), intent(in) :: matvectype interface private subroutine obj_convert_dns(From, To) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(in) :: From real(kind=DFP), intent(inout), ALLOCATABLE :: To (:,:) interface private subroutine obj_spy(Obj, PFE, ScriptLang, Values) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(in) :: Obj type(String), intent(in) :: PFE (3) character(len=*), intent(in) :: ScriptLang logical(kind=LGT), intent(in) :: Values interface private subroutine remove_duplicates_csr(Obj, Values) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(inout) :: Obj logical(kind=LGT), intent(in), optional :: Values public interface setSparsity private interface setSparsity_1 () This subroutine set the sparsity pattern of a given row Arguments None private interface setSparsity_2 () This subroutine set the sparsity pattern of a given row Arguments None private interface setSparsity_3 () This subroutine set sparsity pattern of sparsematrix_ Arguments None interface This subroutine set the sparsity pattern of a given row private subroutine setSparsity_1(Obj, Row, Col) This subroutine set the sparsity pattern of a given row\n  - If obj%tdof is equal to 1, then Col is sorted in increasing order,\n and appended to Obj%Row(Row) - If obj%tdof is not equal  to 1, then based on the storage format and Col connectivity information is generated. Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Row integer(kind=I4B), intent(in) :: Col (:) interface This subroutine set the sparsity pattern of a given row private subroutine setSparsity_2(Obj, Row, Col) This subroutine sets the sparsity pattern of a given row\n This subroutine calls setSparsity_1 Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Row (:) type(IntVector_), intent(in) :: Col (:) interface This subroutine set sparsity pattern of sparsematrix_ private subroutine setSparsity_3(Obj) This subroutine set sparsity pattern of sparsematrix_ This will finally set the data into\n - Obj % A(:) - Obj % IA(:) ,\n - Obj % JA(:) in CSR format. This routine also set data inside Obj % ColSize(:) and Obj % RowSize(:) , and Obj % DiagIndx(:) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(inout) :: Obj public interface setValue private interface setValue_1 () This subroutine set the value in sparse matrix Arguments None private interface setValue_2 () This subroutine set all values of SparseMatrix_ to given scalar value Arguments None interface This subroutine set the value in sparsematrix_ private subroutine setValueInternally(Obj, Nptrs, Val) This subroutine sets the value in sparsematrix_ - Shape( Val ) = [SIZE(Nptrs) tdof, SIZE(Nptrs) tdof]\n - Usually Val denotes the element matrix\n - Symbolic we are performing following task Obj(Nptrs, Nptrs)=Val Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Nptrs (:) real(kind=DFP), intent(in) :: Val (:,:) interface This subroutine set the value in sparse matrix private subroutine setValue_1(Obj, Nptrs, Val, StorageFMT) This subroutine sets the values in sparse matrix\n - Usually Val(:,:) represents the elemental finite element matrix\n - StorageFMT denotes the storage format of Val; Nodes_FMT or DOF_FMT - Usually finite element matrix is stored with DOF_FMT Read more… Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Nptrs (:) real(kind=DFP), intent(in) :: Val (:,:) integer(kind=I4B), intent(in) :: StorageFMT interface This subroutine set all values of SparseMatrix_ to given scalar value private subroutine setValue_2(Obj, Val) This subroutine set all values of SparseMatrix_ to a given scalar value Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val interface — Solve Ux = y by backward elimination technique will be used private subroutine usol_csr(Obj, x, y) Arguments Type Intent Optional Attributes Name type(SparseMatrix_), intent(in) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: x (:) real(kind=DFP), intent(in) :: y (:)","tags":"","loc":"module/sparsematrix_method.html"},{"title":"BoundingBox_Method – Fortran Program","text":"Uses GlobalData IO BaseType Contents Interfaces BoundingBox BoundingBox_Pointer Center Constructor1 Constructor2 Constructor3 Constructor_1 Constructor_2 Display Initiate Intersection OPERATOR( .Intersection. ) OPERATOR( .Nptrs. ) OPERATOR( .isInside. ) OPERATOR(.Center.) OPERATOR(.UNION.) Operator( .Xmax. ) Operator( .Xmin. ) Operator( .Ymax. ) Operator( .Ymin. ) Operator( .Zmax. ) Operator( .Zmin. ) Operator( .isIntersect. ) Union display_obj getXmax getXmin getYmax getYmin getZmax getZmin get_Center get_Union get_intersection get_nptrs initiate_1 initiate_2 isInside isIntersect isIntersectInX isIntersectInY isIntersectInZ is_Inside is_intersect is_intersect_in_X is_intersect_in_Y is_intersect_in_Z setXmax setXmin setYmax setYmin setZmax setZmin Interfaces public interface BoundingBox private interface Constructor1 () Arguments None private interface Constructor2 () Arguments None private interface Constructor3 () Return the bouding box for a given set of coordinates Arguments None public interface BoundingBox_Pointer private interface Constructor_1 () Arguments None private interface Constructor_2 () Arguments None public interface Center private interface get_Center () Arguments None interface private pure function Constructor1(nsd, lim) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: nsd real(kind=DFP), intent(in) :: lim (6) Return Value type(BoundingBox_) interface private pure function Constructor2(AnotherObj) result(Ans) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(in) :: AnotherObj Return Value type(BoundingBox_) interface Return the bouding box for a given set of coordinates private pure function Constructor3(xij) result(Ans) Return the bouding box for a given set of coordinates Read more… Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: xij (:,:) Nodal coordinates xij( 1:nsd, 1:tnodes ) Return Value type(BoundingBox_) interface private function Constructor_1(nsd, lim) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: nsd real(kind=DFP), intent(in) :: lim (6) Return Value class(BoundingBox_),\n  POINTER interface private function Constructor_2(AnotherObj) result(Ans) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(in) :: AnotherObj Return Value class(BoundingBox_),\n  POINTER public interface Display private interface display_obj () Arguments None public interface Initiate private interface initiate_1 () Arguments None private interface initiate_2 () Arguments None public interface Intersection private interface get_intersection () Arguments None public interface OPERATOR( .Intersection. ) private interface get_intersection () Arguments None public interface OPERATOR( .Nptrs. ) private interface get_nptrs () Arguments None public interface OPERATOR( .isInside. ) private interface is_Inside () Arguments None public interface OPERATOR(.Center.) private interface get_Center () Arguments None public interface OPERATOR(.UNION.) private interface get_Union () Arguments None public interface Operator( .Xmax. ) private interface getXmax () Arguments None public interface Operator( .Xmin. ) private interface getXmin () Arguments None public interface Operator( .Ymax. ) private interface getYmax () Arguments None public interface Operator( .Ymin. ) private interface getYmin () Arguments None public interface Operator( .Zmax. ) private interface getZmax () Arguments None public interface Operator( .Zmin. ) private interface getZmin () Arguments None public interface Operator( .isIntersect. ) private interface is_intersect () Arguments None public interface Union private interface get_Union () Arguments None interface private subroutine display_obj(Obj, msg, unitNo) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(in) :: Obj character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitNo interface private pure function getXmax(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(in) :: Obj Return Value real(kind=DFP) interface private pure function getXmin(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(in) :: Obj Return Value real(kind=DFP) interface private pure function getYmax(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(in) :: Obj Return Value real(kind=DFP) interface private pure function getYmin(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(in) :: Obj Return Value real(kind=DFP) interface private pure function getZmax(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(in) :: Obj Return Value real(kind=DFP) interface private pure function getZmin(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(in) :: Obj Return Value real(kind=DFP) interface private pure function get_Center(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(in) :: Obj Return Value real(kind=DFP)\n  (3) interface private pure function get_Union(Obj, Obj2) result(Ans) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(in) :: Obj class(BoundingBox_), intent(in) :: Obj2 Return Value type(BoundingBox_) interface private pure function get_intersection(Obj, Obj2) result(Ans) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(in) :: Obj class(BoundingBox_), intent(in) :: Obj2 Return Value type(BoundingBox_) interface private pure function get_nptrs(Obj, xij) result(Ans) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(in) :: Obj real(kind=DFP), intent(in) :: xij (:,:) Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) interface private subroutine initiate_1(Obj, NSD, lim) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(inout) :: Obj integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in) :: lim (6) interface private subroutine initiate_2(Obj, AnotherObj) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(inout) :: Obj class(BoundingBox_), intent(in) :: AnotherObj public interface isInside private interface is_Inside () Arguments None public interface isIntersect private interface is_intersect () Arguments None public interface isIntersectInX private interface is_intersect_in_X () Arguments None public interface isIntersectInY private interface is_intersect_in_Y () Arguments None public interface isIntersectInZ private interface is_intersect_in_Z () Arguments None interface private pure function is_Inside(Obj, Val) result(Ans) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(in) :: Obj real(kind=DFP), intent(in) :: Val (:) Return Value logical(kind=LGT) interface private pure function is_intersect(Obj, Obj2) result(Ans) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(in) :: Obj class(BoundingBox_), intent(in) :: Obj2 Return Value logical(kind=LGT) interface private pure function is_intersect_in_X(Obj, Obj2) result(Ans) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(in) :: Obj class(BoundingBox_), intent(in) :: Obj2 Return Value logical(kind=LGT) interface private pure function is_intersect_in_Y(Obj, Obj2) result(Ans) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(in) :: Obj class(BoundingBox_), intent(in) :: Obj2 Return Value logical(kind=LGT) interface private pure function is_intersect_in_Z(Obj, Obj2) result(Ans) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(in) :: Obj class(BoundingBox_), intent(in) :: Obj2 Return Value logical(kind=LGT) interface private subroutine setXmax(Obj, Val) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val interface private subroutine setXmin(Obj, Val) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val interface private subroutine setYmax(Obj, Val) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val interface private subroutine setYmin(Obj, Val) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val interface private subroutine setZmax(Obj, Val) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val interface private subroutine setZmin(Obj, Val) Arguments Type Intent Optional Attributes Name class(BoundingBox_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val","tags":"","loc":"module/boundingbox_method.html"},{"title":"ReferenceElement_Method – Fortran Program","text":"Uses BaseType GlobalData Contents Interfaces ASSIGNMENT( = ) Angles Area AreaVector Barycentric Centroid CircumCenter CircumCircle CircumRadius ContainsLine ContainsPoint DeallocateData DeallocateData Display DistanceFromPoint EdgeLength Elem_Topology Elem_XiDimension ElementName ElementOrder ElementQuality ElementTopology ElementType Element_Name Element_Order Element_Order_RefElem Element_Quality Element_Type EquidistanceLIP_Hexahedron EquidistanceLIP_Line EquidistanceLIP_Prism EquidistanceLIP_Pyramid EquidistanceLIP_Quadrangle EquidistanceLIP_Tetrahedron EquidistanceLIP_Triangle FacetMatrix Facet_Matrix_RefElem Hexahedron_quality Incenter Incircle Initiate Initiate Initiate Initiate Initiate Initiate Initiate Initiate Inradius LagrangeElement LagrangeElement LagrangeElement LagrangeElement LagrangeElement LagrangeElement LagrangeElement LagrangeElement_Hexahedron LagrangeElement_Line LagrangeElement_Prism LagrangeElement_Pyramid LagrangeElement_Quadrangle LagrangeElement_Tetrahedron LagrangeElement_Triangle LagrangePoints LagrangePoints LagrangePoints LagrangePoints LagrangePoints LagrangePoints LagrangePoints LocalNodeCoord Local_NodeCoord Local_NodeCoord_RefElem MeasureSimplex Measure_Simplex Measure_Simplex_Hexahedron Measure_Simplex_Line Measure_Simplex_Prism Measure_Simplex_Pyramid Measure_Simplex_Quadrangle Measure_Simplex_Tetrahedron Measure_Simplex_Triangle NearestPoint OPERATOR( .NNE. ) Orthocenter Prism_quality Pyramid_quality Quadrangle_quality RandomPoint ReferenceHexahedron ReferenceHexahedron_Pointer ReferenceLine ReferenceLine_Pointer ReferencePrism ReferencePrism_Pointer ReferencePyramid ReferencePyramid_Pointer ReferenceQuadrangle ReferenceQuadrangle_Pointer ReferenceTetrahedron ReferenceTetrahedron_Pointer ReferenceTopology ReferenceTriangle ReferenceTriangle_Pointer TotalNodesInElement Total_Nodes_In_Element XiDimension contains_point deallocatedata_ref_elem deallocatedata_ref_topology diameter display_ref_elem display_ref_topo getVTKelementType get_vtk_elemType init_refelem initiate_ref_Hexahedron initiate_ref_Line initiate_ref_Prism initiate_ref_Pyramid initiate_ref_Quadrangle initiate_ref_Tetrahedron initiate_ref_Triangle isHexahedron isLine isPoint isPrism isPyramid isQuadrangle isSerendipityElement isSurface isTetrahedron isTriangle isVolume line_quality reference_Hexahedron reference_Prism reference_Pyramid reference_Quadrangle reference_Tetrahedron reference_Triangle reference_line reference_topology tNodes_RefElem tNodes_RefTopo tetrahedron_quality triangle_angles triangle_area triangle_areaVector triangle_barycentric triangle_centroid triangle_circumcentre triangle_circumcircle triangle_circumradius triangle_contains_line triangle_contains_point triangle_diameter triangle_edge_length triangle_get_nearest_point triangle_incenter triangle_incircle triangle_inradius triangle_orthocenter triangle_point_dist triangle_quality triangle_random_point Functions reference_Hexahedron_Pointer reference_Line_Pointer reference_Prism_Pointer reference_Pyramid_Pointer reference_Quadrangle_Pointer reference_Tetrahedron_Pointer reference_Triangle_Pointer Interfaces public interface ASSIGNMENT( = ) private interface init_refelem () Arguments None public interface Angles private interface triangle_angles () Arguments None public interface Area private interface triangle_area () Arguments None public interface AreaVector private interface triangle_areaVector () Arguments None public interface Barycentric private interface triangle_barycentric () Arguments None public interface Centroid private interface triangle_centroid () Arguments None public interface CircumCenter private interface triangle_circumcentre () Arguments None public interface CircumCircle private interface triangle_circumcircle () Arguments None public interface CircumRadius private interface triangle_circumradius () Arguments None public interface ContainsLine private interface triangle_contains_line () Arguments None public interface ContainsPoint private interface contains_point () Arguments None public interface DeallocateData private interface deallocatedata_ref_topology () Arguments None private interface DeallocateData private interface deallocatedata_ref_elem () Arguments None public interface Display private interface display_ref_elem () Arguments None private interface display_ref_topo () Arguments None public interface DistanceFromPoint private interface triangle_point_dist () Arguments None public interface EdgeLength private interface triangle_edge_length () Arguments None interface private pure function Elem_Topology(ElemType) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ElemType Return Value integer(kind=I4B) interface private pure function Elem_XiDimension(ElemType) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ElemType Return Value integer(kind=I4B) public interface ElementName private interface Element_Name () Arguments None public interface ElementOrder private interface Element_Order_RefElem () Arguments None private interface Element_Order () Arguments None public interface ElementQuality private interface Element_Quality () Arguments None public interface ElementTopology private interface Elem_Topology () Arguments None public interface ElementType private interface Element_Type () Arguments None interface private pure function Element_Name(ElemType) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ElemType Return Value character(len=50) interface private pure function Element_Order(ElemType) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ElemType Return Value integer(kind=I4B) interface private pure function Element_Order_RefElem(RefElem) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceElement_), intent(in) :: RefElem Return Value integer(kind=I4B) interface private function Element_Quality(refelem, xij, measure) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceElement_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) integer(kind=I4B), intent(in) :: measure Return Value real(kind=DFP) interface private pure function Element_Type(ElemName) result(Ans) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: ElemName Return Value integer(kind=I4B) interface private pure function EquidistanceLIP_Hexahedron(RefElem, Order) result(NodeCoord) Arguments Type Intent Optional Attributes Name class(ReferenceHexahedron_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) interface private pure function EquidistanceLIP_Line(RefElem, Order) result(NodeCoord) Arguments Type Intent Optional Attributes Name class(ReferenceLine_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) interface private pure function EquidistanceLIP_Prism(RefElem, Order) result(NodeCoord) Arguments Type Intent Optional Attributes Name class(ReferencePrism_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) interface private pure function EquidistanceLIP_Pyramid(RefElem, Order) result(NodeCoord) Arguments Type Intent Optional Attributes Name class(ReferencePyramid_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) interface private pure function EquidistanceLIP_Quadrangle(RefElem, Order) result(NodeCoord) Arguments Type Intent Optional Attributes Name class(ReferenceQuadrangle_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) interface private pure function EquidistanceLIP_Tetrahedron(RefElem, Order) result(NodeCoord) Arguments Type Intent Optional Attributes Name class(ReferenceTetrahedron_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) interface private pure function EquidistanceLIP_Triangle(RefElem, Order) result(NodeCoord) Arguments Type Intent Optional Attributes Name class(ReferenceTriangle_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) public interface FacetMatrix private interface Facet_Matrix_RefElem () Arguments None interface private pure function Facet_Matrix_RefElem(RefElem) result(FM) Arguments Type Intent Optional Attributes Name class(ReferenceElement_), intent(in) :: RefElem Return Value integer(kind=I4B),\n  ALLOCATABLE, (:,:) interface private function Hexahedron_quality(refelem, xij, measure) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceHexahedron_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) integer(kind=I4B), intent(in) :: measure Return Value real(kind=DFP) public interface Incenter private interface triangle_incenter () Arguments None public interface Incircle private interface triangle_incircle () Arguments None public interface Initiate private interface init_refelem () Arguments None private interface Initiate private interface initiate_ref_Line () Arguments None private interface Initiate private interface initiate_ref_Triangle () Arguments None private interface Initiate private interface initiate_ref_Quadrangle () Arguments None private interface Initiate private interface initiate_ref_Tetrahedron () Arguments None private interface Initiate private interface initiate_ref_Hexahedron () Arguments None private interface Initiate private interface initiate_ref_Pyramid () Arguments None private interface Initiate private interface initiate_ref_Prism () Arguments None public interface Inradius private interface triangle_inradius () Arguments None public interface LagrangeElement private interface LagrangeElement_Line () Arguments None private interface LagrangeElement private interface LagrangeElement_Triangle () Arguments None private interface LagrangeElement private interface LagrangeElement_Quadrangle () Arguments None private interface LagrangeElement private interface LagrangeElement_Tetrahedron () Arguments None private interface LagrangeElement private interface LagrangeElement_Prism () Arguments None private interface LagrangeElement private interface LagrangeElement_Pyramid () Arguments None private interface LagrangeElement private interface LagrangeElement_Hexahedron () Arguments None interface private pure function LagrangeElement_Hexahedron(RefElem, Order) result(Obj) Arguments Type Intent Optional Attributes Name class(ReferenceHexahedron_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: Order Return Value type(ReferenceHexahedron_) interface private pure function LagrangeElement_Line(RefElem, Order) result(Obj) Arguments Type Intent Optional Attributes Name class(ReferenceLine_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: Order Return Value type(ReferenceLine_) interface private pure function LagrangeElement_Prism(RefElem, Order) result(Obj) Arguments Type Intent Optional Attributes Name class(ReferencePrism_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: Order Return Value type(ReferencePrism_) interface private pure function LagrangeElement_Pyramid(RefElem, Order) result(Obj) Arguments Type Intent Optional Attributes Name class(ReferencePyramid_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: Order Return Value type(ReferencePyramid_) interface private pure function LagrangeElement_Quadrangle(RefElem, Order) result(Obj) Arguments Type Intent Optional Attributes Name class(ReferenceQuadrangle_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: Order Return Value type(ReferenceQuadrangle_) interface private pure function LagrangeElement_Tetrahedron(RefElem, Order) result(Obj) Arguments Type Intent Optional Attributes Name class(ReferenceTetrahedron_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: Order Return Value type(ReferenceTetrahedron_) interface private pure function LagrangeElement_Triangle(RefElem, Order) result(Obj) Arguments Type Intent Optional Attributes Name class(ReferenceTriangle_), intent(in) :: RefElem integer(kind=I4B), intent(in) :: Order Return Value type(ReferenceTriangle_) public interface LagrangePoints private interface EquidistanceLIP_Line () Arguments None private interface LagrangePoints private interface EquidistanceLIP_Triangle () Arguments None private interface LagrangePoints private interface EquidistanceLIP_Quadrangle () Arguments None private interface LagrangePoints private interface EquidistanceLIP_Tetrahedron () Arguments None private interface LagrangePoints private interface EquidistanceLIP_Prism () Arguments None private interface LagrangePoints private interface EquidistanceLIP_Pyramid () Arguments None private interface LagrangePoints private interface EquidistanceLIP_Hexahedron () Arguments None public interface LocalNodeCoord private interface Local_NodeCoord_RefElem () Arguments None interface private subroutine Local_NodeCoord(NodeCoord, ElemType) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: NodeCoord (:,:) integer(kind=I4B), intent(in) :: ElemType interface private pure function Local_NodeCoord_RefElem(RefElem) result(NodeCoord) Arguments Type Intent Optional Attributes Name class(ReferenceElement_), intent(in) :: RefElem Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) public interface MeasureSimplex private interface Measure_Simplex () Arguments None interface private pure function Measure_Simplex(RefElem, XiJ) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceElement_), intent(in) :: RefElem real(kind=DFP), intent(in) :: XiJ (:,:) Return Value real(kind=DFP) interface private pure function Measure_Simplex_Hexahedron(RefElem, XiJ) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceHexahedron_), intent(in) :: RefElem real(kind=DFP), intent(in) :: XiJ (:,:) Return Value real(kind=DFP) interface private pure function Measure_Simplex_Line(RefElem, XiJ) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceLine_), intent(in) :: RefElem real(kind=DFP), intent(in) :: XiJ (:,:) Return Value real(kind=DFP) interface private pure function Measure_Simplex_Prism(RefElem, XiJ) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferencePrism_), intent(in) :: RefElem real(kind=DFP), intent(in) :: XiJ (:,:) Return Value real(kind=DFP) interface private pure function Measure_Simplex_Pyramid(RefElem, XiJ) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferencePyramid_), intent(in) :: RefElem real(kind=DFP), intent(in) :: XiJ (:,:) Return Value real(kind=DFP) interface private pure function Measure_Simplex_Quadrangle(RefElem, XiJ) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceQuadrangle_), intent(in) :: RefElem real(kind=DFP), intent(in) :: XiJ (:,:) Return Value real(kind=DFP) interface private pure function Measure_Simplex_Tetrahedron(RefElem, XiJ) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceTetrahedron_), intent(in) :: RefElem real(kind=DFP), intent(in) :: XiJ (:,:) Return Value real(kind=DFP) interface private pure function Measure_Simplex_Triangle(RefElem, XiJ) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceTriangle_), intent(in) :: RefElem real(kind=DFP), intent(in) :: XiJ (:,:) Return Value real(kind=DFP) public interface NearestPoint private interface triangle_get_nearest_point () Arguments None public interface OPERATOR( .NNE. ) private interface tNodes_RefTopo () Arguments None private interface tNodes_RefElem () Arguments None public interface Orthocenter private interface triangle_orthocenter () Arguments None interface private function Prism_quality(refelem, xij, measure) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferencePrism_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) integer(kind=I4B), intent(in) :: measure Return Value real(kind=DFP) interface private function Pyramid_quality(refelem, xij, measure) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferencePyramid_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) integer(kind=I4B), intent(in) :: measure Return Value real(kind=DFP) interface private function Quadrangle_quality(refelem, xij, measure) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceQuadrangle_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) integer(kind=I4B), intent(in) :: measure Return Value real(kind=DFP) public interface RandomPoint private interface triangle_random_point () Arguments None public interface ReferenceHexahedron private interface reference_Hexahedron () Arguments None public interface ReferenceHexahedron_Pointer private pure function reference_Hexahedron_Pointer (NSD, XiJ) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:) Return Value class(ReferenceHexahedron_),\n  POINTER public interface ReferenceLine private interface reference_line () Arguments None public interface ReferenceLine_Pointer private pure function reference_Line_Pointer (NSD, XiJ) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:) Return Value class(ReferenceLine_),\n  POINTER public interface ReferencePrism private interface reference_Prism () Arguments None public interface ReferencePrism_Pointer private pure function reference_Prism_Pointer (NSD, XiJ) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:) Return Value class(ReferencePrism_),\n  POINTER public interface ReferencePyramid private interface reference_Pyramid () Arguments None public interface ReferencePyramid_Pointer private pure function reference_Pyramid_Pointer (NSD, XiJ) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:) Return Value class(ReferencePyramid_),\n  POINTER public interface ReferenceQuadrangle private interface reference_Quadrangle () Arguments None public interface ReferenceQuadrangle_Pointer private pure function reference_Quadrangle_Pointer (NSD, XiJ) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:) Return Value class(ReferenceQuadrangle_),\n  POINTER public interface ReferenceTetrahedron private interface reference_Tetrahedron () Arguments None public interface ReferenceTetrahedron_Pointer private pure function reference_Tetrahedron_Pointer (NSD, XiJ) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:) Return Value class(ReferenceTetrahedron_),\n  POINTER public interface ReferenceTopology private interface reference_topology () Arguments None public interface ReferenceTriangle private interface reference_Triangle () Arguments None public interface ReferenceTriangle_Pointer private pure function reference_Triangle_Pointer (NSD, XiJ) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:) Return Value class(ReferenceTriangle_),\n  POINTER public interface TotalNodesInElement private interface Total_Nodes_In_Element () Arguments None interface private pure function Total_Nodes_In_Element(ElemType) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ElemType Return Value integer(kind=I4B) public interface XiDimension private interface Elem_XiDimension () Arguments None interface private function contains_point(refelem, xij, x) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceElement_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) real(kind=DFP), intent(in) :: x (:) Return Value logical(kind=LGT) interface private subroutine deallocatedata_ref_elem(Obj) Arguments Type Intent Optional Attributes Name class(ReferenceElement_), intent(inout) :: Obj interface private subroutine deallocatedata_ref_topology(Obj) Arguments Type Intent Optional Attributes Name class(ReferenceTopology_), intent(inout) :: Obj public interface diameter private interface triangle_diameter () Arguments None interface private subroutine display_ref_elem(Obj, msg, unitno) Arguments Type Intent Optional Attributes Name class(ReferenceElement_), intent(in) :: Obj character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitno interface private subroutine display_ref_topo(Obj, msg, unitno) Arguments Type Intent Optional Attributes Name class(ReferenceTopology_), intent(in) :: Obj character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitno public interface getVTKelementType private interface get_vtk_elemType () Arguments None interface private subroutine get_vtk_elemType(ElemType, vtk_type, nptrs) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ElemType integer(kind=Int8), intent(out) :: vtk_type integer(kind=I4B), intent(inout), ALLOCATABLE :: nptrs (:) interface private subroutine init_refelem(Obj, AnotherObj) Arguments Type Intent Optional Attributes Name class(ReferenceElement_), intent(inout) :: Obj class(ReferenceElement_), intent(in) :: AnotherObj interface private subroutine initiate_ref_Hexahedron(Obj, NSD, XiJ) Arguments Type Intent Optional Attributes Name class(ReferenceHexahedron_), intent(inout) :: Obj integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:) interface private subroutine initiate_ref_Line(Obj, NSD, XiJ) Arguments Type Intent Optional Attributes Name class(ReferenceLine_), intent(inout) :: Obj integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:) interface private subroutine initiate_ref_Prism(Obj, NSD, XiJ) Arguments Type Intent Optional Attributes Name class(ReferencePrism_), intent(inout) :: Obj integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:) interface private subroutine initiate_ref_Pyramid(Obj, NSD, XiJ) Arguments Type Intent Optional Attributes Name class(ReferencePyramid_), intent(inout) :: Obj integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:) interface private subroutine initiate_ref_Quadrangle(Obj, NSD, XiJ) Arguments Type Intent Optional Attributes Name class(ReferenceQuadrangle_), intent(inout) :: Obj integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:) interface private subroutine initiate_ref_Tetrahedron(Obj, NSD, XiJ) Arguments Type Intent Optional Attributes Name class(ReferenceTetrahedron_), intent(inout) :: Obj integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:) interface private subroutine initiate_ref_Triangle(Obj, NSD, XiJ) Arguments Type Intent Optional Attributes Name class(ReferenceTriangle_), intent(inout) :: Obj integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:) interface public pure function isHexahedron(ElemType) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ElemType Return Value logical(kind=LGT) interface public pure function isLine(ElemType) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ElemType Return Value logical(kind=LGT) interface public pure function isPoint(ElemType) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ElemType Return Value logical(kind=LGT) interface public pure function isPrism(ElemType) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ElemType Return Value logical(kind=LGT) interface public pure function isPyramid(ElemType) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ElemType Return Value logical(kind=LGT) interface public pure function isQuadrangle(ElemType) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ElemType Return Value logical(kind=LGT) interface public pure function isSerendipityElement(ElemType) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ElemType Return Value logical(kind=LGT) interface public pure function isSurface(ElemType) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ElemType Return Value logical(kind=LGT) interface public pure function isTetrahedron(ElemType) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ElemType Return Value logical(kind=LGT) interface public pure function isTriangle(ElemType) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ElemType Return Value logical(kind=LGT) interface public pure function isVolume(ElemType) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: ElemType Return Value logical(kind=LGT) interface private function line_quality(refelem, xij, measure) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceLine_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) integer(kind=I4B), intent(in) :: measure Return Value real(kind=DFP) interface private pure function reference_Hexahedron(NSD, XiJ) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:) Return Value type(ReferenceHexahedron_) interface private pure function reference_Prism(NSD, XiJ) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:) Return Value type(ReferencePrism_) interface private pure function reference_Pyramid(NSD, XiJ) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:) Return Value type(ReferencePyramid_) interface private pure function reference_Quadrangle(NSD, XiJ) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:) Return Value type(ReferenceQuadrangle_) interface private pure function reference_Tetrahedron(NSD, XiJ) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:) Return Value type(ReferenceTetrahedron_) interface private pure function reference_Triangle(NSD, XiJ) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:) Return Value type(ReferenceTriangle_) interface private pure function reference_line(NSD, XiJ) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:) Return Value type(ReferenceLine_) interface private pure function reference_topology(Nptrs, Name) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Nptrs (:) integer(kind=I4B), intent(in) :: Name Return Value type(ReferenceTopology_) interface private pure function tNodes_RefElem(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceElement_), intent(in) :: Obj Return Value integer(kind=I4B) interface private pure function tNodes_RefTopo(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceTopology_), intent(in) :: Obj Return Value integer(kind=I4B) interface private function tetrahedron_quality(refelem, xij, measure) result(Ans) Arguments Type Intent Optional Attributes Name class(Referencetetrahedron_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) integer(kind=I4B), intent(in) :: measure Return Value real(kind=DFP) interface private function triangle_angles(refelem, xij) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceTriangle_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) Return Value real(kind=DFP)\n  (3) interface private function triangle_area(refelem, xij) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceTriangle_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) Return Value real(kind=DFP) interface private function triangle_areaVector(refelem, xij) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceTriangle_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) Return Value real(kind=DFP)\n  (3) interface private function triangle_barycentric(refelem, xij, x) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceTriangle_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) real(kind=DFP), intent(in) :: x (:) Return Value real(kind=DFP)\n  (3) interface private function triangle_centroid(refelem, xij) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceTriangle_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) Return Value real(kind=DFP)\n  (3) interface private function triangle_circumcentre(refelem, xij) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceTriangle_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) Return Value real(kind=DFP)\n  (3) interface private function triangle_circumcircle(refelem, xij) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceTriangle_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) Return Value real(kind=DFP)\n  (4) Ans(1) = radius and Ans(2:4) center interface private function triangle_circumradius(refelem, xij) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceTriangle_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) Return Value real(kind=DFP) interface private subroutine triangle_contains_line(refelem, xij, x1, x2, parametricLine, inside, xint) Arguments Type Intent Optional Attributes Name class(ReferenceTriangle_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) real(kind=DFP), intent(in) :: x1 (3) real(kind=DFP), intent(in) :: x2 (3) logical(kind=LGT), intent(in) :: parametricLine logical(kind=LGT), intent(out) :: inside real(kind=DFP), intent(out) :: xint (3) interface private function triangle_contains_point(refelem, xij, x) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceTriangle_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) real(kind=DFP), intent(in) :: x (:) Return Value logical(kind=LGT) interface private function triangle_diameter(refelem, xij) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceTriangle_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) Return Value real(kind=DFP) interface private function triangle_edge_length(refelem, xij) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceTriangle_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) Return Value real(kind=DFP)\n  (3) interface private subroutine triangle_get_nearest_point(refelem, xij, x, xn, dist) Arguments Type Intent Optional Attributes Name class(ReferenceTriangle_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) real(kind=DFP), intent(in) :: x (:) real(kind=DFP), intent(inout) :: xn (:) real(kind=DFP), intent(out) :: dist interface private function triangle_incenter(refelem, xij) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceTriangle_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) Return Value real(kind=DFP)\n  (3) interface private function triangle_incircle(refelem, xij) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceTriangle_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) Return Value real(kind=DFP)\n  (4) interface private function triangle_inradius(refelem, xij) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceTriangle_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) Return Value real(kind=DFP) interface private function triangle_orthocenter(refelem, xij) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceTriangle_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) Return Value real(kind=DFP)\n  (3) interface private function triangle_point_dist(refelem, xij, x) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceTriangle_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) real(kind=DFP), intent(in) :: x (:) Return Value real(kind=DFP) interface private function triangle_quality(refelem, xij, measure) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceTriangle_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) integer(kind=I4B), intent(in) :: measure Return Value real(kind=DFP) interface private function triangle_random_point(refelem, xij, n, seed) result(Ans) Arguments Type Intent Optional Attributes Name class(ReferenceTriangle_), intent(in) :: refelem real(kind=DFP), intent(in) :: xij (:,:) integer(kind=I4B) :: n integer(kind=I4B) :: seed Return Value real(kind=DFP)\n  (3,n) Functions private pure function reference_Hexahedron_Pointer (NSD, XiJ) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:) Return Value class(ReferenceHexahedron_),\n  POINTER private pure function reference_Line_Pointer (NSD, XiJ) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:) Return Value class(ReferenceLine_),\n  POINTER private pure function reference_Prism_Pointer (NSD, XiJ) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:) Return Value class(ReferencePrism_),\n  POINTER private pure function reference_Pyramid_Pointer (NSD, XiJ) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:) Return Value class(ReferencePyramid_),\n  POINTER private pure function reference_Quadrangle_Pointer (NSD, XiJ) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:) Return Value class(ReferenceQuadrangle_),\n  POINTER private pure function reference_Tetrahedron_Pointer (NSD, XiJ) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:) Return Value class(ReferenceTetrahedron_),\n  POINTER private pure function reference_Triangle_Pointer (NSD, XiJ) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: NSD real(kind=DFP), intent(in), optional :: XiJ (:,:) Return Value class(ReferenceTriangle_),\n  POINTER","tags":"","loc":"module/referenceelement_method.html"},{"title":"Rank2Tensor_Method – Fortran Program","text":"Uses GlobalData IO BaseType Contents Interfaces ASSIGNMENT( = ) AXPY Contraction Convert Det Deviatoric Display Eigen IdentityTensor Initiate Invariants Isotropic IsotropicTensor J2 J3 LeftPolarDecomp LodeAngle OPERATOR( + ) OPERATOR( - ) Ones Ones_rank2 Rank2Tensor Rank2Tensor_Pointer RightPolarDecomp SkewSym Skewsym_r2t Sym SymEigen Trace Zeros Zeros_rank2 axpy_a1_a2 det_obj dev_part_obj display_obj identity_rank2 init_by_mat init_by_vec invariants_rank2 iso_part_obj isotropic_rank2 j2_obj j3_obj left_pd_r2t mat_add_obj mat_equal_rank2 mat_minus_obj mat_to_rank2 obj_add_mat obj_add_obj obj_add_scalar obj_minus_mat obj_minus_obj obj_minus_scalar r2_contract_r2 r2_contract_voigt_r2 r2t_by_mat r2t_by_voigtvec r2tp_by_mat r2tp_by_voigtvec rank2_equal_mat rank2_to_mat right_pd_r2t scalar_add_obj scalar_minus_obj spectral_r2t sym_r2t sym_spectral_r2t theta_obj theta_obj_j2j3 trace_obj voigt_r2_contract_r2 voigt_r2_contract_voigt_r2 Interfaces public interface ASSIGNMENT( = ) private interface rank2_equal_mat () Arguments None private interface mat_equal_rank2 () Arguments None public interface AXPY private interface axpy_a1_a2 () Arguments None public interface Contraction private interface r2_contract_r2 () Arguments None private interface r2_contract_voigt_r2 () Arguments None private interface voigt_r2_contract_r2 () Arguments None private interface voigt_r2_contract_voigt_r2 () Arguments None public interface Convert private interface mat_to_rank2 () Arguments None private interface rank2_to_mat () Arguments None public interface Det private interface det_obj () Arguments None public interface Deviatoric private interface dev_part_obj () Arguments None public interface Display private interface display_obj () Arguments None public interface Eigen private interface spectral_r2t () Arguments None public interface IdentityTensor private interface identity_rank2 () Arguments None public interface Initiate private interface init_by_mat () Arguments None private interface init_by_vec () Arguments None public interface Invariants private interface invariants_rank2 () Arguments None public interface Isotropic private interface iso_part_obj () Arguments None public interface IsotropicTensor private interface isotropic_rank2 () Arguments None public interface J2 private interface j2_obj () Arguments None public interface J3 private interface j3_obj () Arguments None public interface LeftPolarDecomp private interface right_pd_r2t () Arguments None public interface LodeAngle private interface theta_obj () Arguments None private interface theta_obj_j2j3 () Arguments None public interface OPERATOR( + ) private interface obj_add_obj () Arguments None private interface obj_add_mat () Arguments None private interface mat_add_obj () Arguments None private interface obj_add_scalar () Arguments None private interface scalar_add_obj () Arguments None public interface OPERATOR( - ) private interface obj_minus_obj () Arguments None private interface obj_minus_mat () Arguments None private interface mat_minus_obj () Arguments None private interface obj_minus_scalar () Arguments None private interface scalar_minus_obj () Arguments None public interface Ones private interface Ones_rank2 () Arguments None interface private subroutine Ones_rank2(Obj) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(inout) :: Obj public interface Rank2Tensor private interface r2t_by_mat () Arguments None private interface r2t_by_voigtvec () Arguments None public interface Rank2Tensor_Pointer private interface r2tp_by_mat () Arguments None private interface r2tp_by_voigtvec () Arguments None public interface RightPolarDecomp private interface right_pd_r2t () Arguments None public interface SkewSym private interface Skewsym_r2t () Arguments None interface private pure function Skewsym_r2t(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: Obj Return Value type(Rank2Tensor_) public interface Sym private interface sym_r2t () Arguments None public interface SymEigen private interface sym_spectral_r2t () Arguments None public interface Trace private interface trace_obj () Arguments None public interface Zeros private interface Zeros_rank2 () Arguments None interface private subroutine Zeros_rank2(Obj) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(inout) :: Obj interface private subroutine axpy_a1_a2(a1, Obj1, a2, Obj2) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: a1 class(Rank2Tensor_), intent(inout) :: Obj1 real(kind=DFP), intent(in) :: a2 class(Rank2Tensor_), intent(in) :: Obj2 interface private pure function det_obj(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: Obj Return Value real(kind=DFP) interface private pure function dev_part_obj(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: Obj Return Value type(Rank2Tensor_) interface private subroutine display_obj(Obj, Msg, UnitNo) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: Obj character(len=*), intent(in) :: Msg integer(kind=I4B), intent(in), optional :: UnitNo interface private subroutine identity_rank2(Obj) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(inout) :: Obj interface private subroutine init_by_mat(Obj, Mat) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Mat (3,3) interface private subroutine init_by_vec(Obj, Vec, VoigtType) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Vec (:) integer(kind=I4B), intent(in) :: VoigtType interface private pure function invariants_rank2(Obj, isDeviatoric) result(Ans) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: Obj logical(kind=LGT), intent(in) :: isDeviatoric Return Value real(kind=DFP)\n  (3) interface private pure function iso_part_obj(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: Obj Return Value type(Rank2Tensor_) interface private subroutine isotropic_rank2(Obj, Lambda) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Lambda interface private pure function j2_obj(Obj, isDeviatoric) result(Ans) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: Obj logical(kind=LGT), intent(in) :: isDeviatoric Return Value real(kind=DFP) interface private pure function j3_obj(Obj, isDeviatoric) result(Ans) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: Obj logical(kind=LGT), intent(in) :: isDeviatoric Return Value real(kind=DFP) interface private subroutine left_pd_r2t(Obj, V, R) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: Obj class(Rank2Tensor_), intent(inout) :: V class(Rank2Tensor_), intent(inout) :: R interface private pure function mat_add_obj(Obj1, Obj2) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Obj1 (3,3) class(Rank2Tensor_), intent(in) :: Obj2 Return Value type(Rank2Tensor_) interface private subroutine mat_equal_rank2(Mat, Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout) :: Mat (3,3) class(Rank2Tensor_), intent(in) :: Obj interface private pure function mat_minus_obj(Obj1, Obj2) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Obj1 (3,3) class(Rank2Tensor_), intent(in) :: Obj2 Return Value type(Rank2Tensor_) interface private subroutine mat_to_rank2(From, To) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: From (3,3) class(Rank2Tensor_), intent(inout) :: To interface private pure function obj_add_mat(Obj1, Obj2) result(Ans) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: Obj1 real(kind=DFP), intent(in) :: Obj2 (3,3) Return Value type(Rank2Tensor_) interface private pure function obj_add_obj(Obj1, Obj2) result(Ans) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: Obj1 class(Rank2Tensor_), intent(in) :: Obj2 Return Value type(Rank2Tensor_) interface private pure function obj_add_scalar(Obj1, Obj2) result(Ans) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: Obj1 real(kind=DFP), intent(in) :: Obj2 Return Value type(Rank2Tensor_) interface private pure function obj_minus_mat(Obj1, Obj2) result(Ans) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: Obj1 real(kind=DFP), intent(in) :: Obj2 (3,3) Return Value type(Rank2Tensor_) interface private pure function obj_minus_obj(Obj1, Obj2) result(Ans) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: Obj1 class(Rank2Tensor_), intent(in) :: Obj2 Return Value type(Rank2Tensor_) interface private pure function obj_minus_scalar(Obj1, Obj2) result(Ans) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: Obj1 real(kind=DFP), intent(in) :: Obj2 Return Value type(Rank2Tensor_) interface private pure function r2_contract_r2(Obj1, Obj2) result(Ans) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: Obj1 class(Rank2Tensor_), intent(in) :: Obj2 Return Value real(kind=DFP) interface private pure function r2_contract_voigt_r2(Obj1, Obj2) result(Ans) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: Obj1 class(VoigtRank2Tensor_), intent(in) :: Obj2 Return Value real(kind=DFP) interface private pure function r2t_by_mat(Mat) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Mat (3,3) Return Value type(Rank2Tensor_) interface private pure function r2t_by_voigtvec(VoigtVec, VoigtType) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: VoigtVec (:) integer(kind=I4B), intent(in) :: VoigtType Return Value type(Rank2Tensor_) interface private pure function r2tp_by_mat(Mat) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Mat (3,3) Return Value class(Rank2Tensor_),\n  POINTER interface private pure function r2tp_by_voigtvec(VoigtVec, VoigtType) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: VoigtVec (:) integer(kind=I4B), intent(in) :: VoigtType Return Value class(Rank2Tensor_),\n  POINTER interface private subroutine rank2_equal_mat(Obj, Mat) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Mat (3,3) interface private subroutine rank2_to_mat(From, To) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: From real(kind=DFP), intent(inout) :: To (3,3) interface private subroutine right_pd_r2t(Obj, R, U) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: Obj class(Rank2Tensor_), intent(inout) :: R class(Rank2Tensor_), intent(inout) :: U interface private pure function scalar_add_obj(Obj1, Obj2) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Obj1 class(Rank2Tensor_), intent(in) :: Obj2 Return Value type(Rank2Tensor_) interface private pure function scalar_minus_obj(Obj1, Obj2) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Obj1 class(Rank2Tensor_), intent(in) :: Obj2 Return Value type(Rank2Tensor_) interface private subroutine spectral_r2t(Obj, Q, W) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: Obj complex(kind=DFP), intent(inout) :: Q (3,3) complex(kind=DFP), intent(inout) :: W (3) interface private pure function sym_r2t(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: Obj Return Value type(Rank2Tensor_) interface private subroutine sym_spectral_r2t(Obj, Q, W) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: Obj real(kind=DFP), intent(inout) :: Q (3,3) real(kind=DFP), intent(inout) :: W (3) interface private pure function theta_obj(Obj, LodeType, isDeviatoric) result(Ans) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: Obj integer(kind=I4B), intent(in) :: LodeType logical(kind=LGT), intent(in) :: isDeviatoric Return Value real(kind=DFP) interface private pure function theta_obj_j2j3(Obj, LodeType, J2J3) result(Ans) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: Obj integer(kind=I4B), intent(in) :: LodeType real(kind=DFP), intent(in), optional :: J2J3 (2) Return Value real(kind=DFP) interface private pure function trace_obj(Obj, Power) result(Ans) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: Obj integer(kind=I4B), intent(in) :: Power Return Value real(kind=DFP) interface private pure function voigt_r2_contract_r2(Obj1, Obj2) result(Ans) Arguments Type Intent Optional Attributes Name class(VoigtRank2Tensor_), intent(in) :: Obj1 class(Rank2Tensor_), intent(in) :: Obj2 Return Value real(kind=DFP) interface private pure function voigt_r2_contract_voigt_r2(Obj1, Obj2) result(Ans) Arguments Type Intent Optional Attributes Name class(VoigtRank2Tensor_), intent(in) :: Obj1 class(VoigtRank2Tensor_), intent(in) :: Obj2 Return Value real(kind=DFP)","tags":"","loc":"module/rank2tensor_method.html"},{"title":"VoigtRank2Tensor_Method – Fortran Program","text":"Uses GlobalData IO BaseType Contents Interfaces Convert Display Initiate VoigtRank2Tensor VoigtRank2Tensor_Pointer constructor1 constructor_1 display_obj init_from_mat init_from_r2tensor init_from_vec tensor_to_voigt voigt_to_mat voigt_to_tensor voigt_to_vec Interfaces public interface Convert private interface voigt_to_mat () Arguments None private interface voigt_to_vec () Arguments None private interface voigt_to_tensor () Arguments None private interface tensor_to_voigt () Arguments None public interface Display private interface display_obj () Arguments None public interface Initiate private interface init_from_vec () Arguments None private interface init_from_r2tensor () Arguments None private interface init_from_mat () Arguments None public interface VoigtRank2Tensor private interface constructor1 () Arguments None public interface VoigtRank2Tensor_Pointer private interface constructor_1 () Arguments None interface private pure function constructor1(Vec, VoigtType) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Vec (:) integer(kind=I4B), intent(in) :: VoigtType Return Value type(VoigtRank2Tensor_) interface private pure function constructor_1(Vec, VoigtType) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Vec (:) integer(kind=I4B), intent(in) :: VoigtType Return Value class(VoigtRank2Tensor_),\n  POINTER interface private subroutine display_obj(Obj, Msg, UnitNo) Arguments Type Intent Optional Attributes Name class(VoigtRank2Tensor_), intent(in) :: Obj character(len=*), intent(in) :: Msg integer(kind=I4B), intent(in), optional :: UnitNo interface private subroutine init_from_mat(Obj, T, VoigtType) Arguments Type Intent Optional Attributes Name class(VoigtRank2Tensor_), intent(inout) :: Obj real(kind=DFP), intent(in) :: T (3,3) integer(kind=I4B), intent(in) :: VoigtType interface private subroutine init_from_r2tensor(Obj, T, VoigtType) Arguments Type Intent Optional Attributes Name class(VoigtRank2Tensor_), intent(inout) :: Obj class(Rank2Tensor_), intent(in) :: T integer(kind=I4B), intent(in) :: VoigtType interface private subroutine init_from_vec(Obj, Vec, VoigtType) Arguments Type Intent Optional Attributes Name class(VoigtRank2Tensor_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Vec (:) integer(kind=I4B), intent(in) :: VoigtType interface private subroutine tensor_to_voigt(From, To, VoigtType) Arguments Type Intent Optional Attributes Name class(Rank2Tensor_), intent(in) :: From class(VoigtRank2Tensor_), intent(inout) :: To integer(kind=I4B), intent(in) :: VoigtType interface private subroutine voigt_to_mat(From, To) Arguments Type Intent Optional Attributes Name class(VoigtRank2Tensor_), intent(in) :: From real(kind=DFP), intent(inout) :: To (3,3) interface private subroutine voigt_to_tensor(From, To) Arguments Type Intent Optional Attributes Name class(VoigtRank2Tensor_), intent(in) :: From class(Rank2Tensor_), intent(inout) :: To interface private subroutine voigt_to_vec(From, To) Arguments Type Intent Optional Attributes Name class(VoigtRank2Tensor_), intent(in) :: From real(kind=DFP), intent(inout) :: To (:)","tags":"","loc":"module/voigtrank2tensor_method.html"},{"title":"Random_Method – Fortran Program","text":"Module to handle random numbers in easifem Uses GlobalData BaseType Contents Interfaces Initiate RandomValue RandomValue RandomValue RandomValue SaveRandom getRandom getRandomInteger initRandom select_random_int_from_array select_random_int_from_vec select_random_real_from_array select_random_real_from_vec uniformRandom Interfaces public interface Initiate private interface initRandom () Arguments None public interface RandomValue private interface getRandom () Arguments None private interface RandomValue public interface uniformRandom () Arguments None private interface RandomValue private interface getRandomInteger () Arguments None private interface RandomValue private interface select_random_int_from_vec () Arguments None private interface select_random_int_from_array () Arguments None private interface select_random_real_from_vec () Arguments None private interface select_random_real_from_array () Arguments None interface public subroutine SaveRandom(Obj) Arguments Type Intent Optional Attributes Name class(Random_), intent(inout) :: Obj interface private function getRandom(Obj, distribution) result(Ans) Arguments Type Intent Optional Attributes Name class(Random_), intent(in) :: Obj character(len=*), intent(in), optional :: distribution Return Value real(kind=DFP) interface private function getRandomInteger(Obj, From, To) result(Ans) Arguments Type Intent Optional Attributes Name class(Random_), intent(in) :: Obj integer(kind=I4B), intent(in) :: From integer(kind=I4B), intent(in) :: To Return Value integer(kind=I4B) interface private subroutine initRandom(Obj) Arguments Type Intent Optional Attributes Name class(Random_), intent(inout) :: Obj interface private function select_random_int_from_array(Obj, Val) result(Ans) Arguments Type Intent Optional Attributes Name class(Random_), intent(in) :: Obj integer(kind=I4B), intent(in) :: Val (:,:) Return Value integer(kind=I4B) interface private function select_random_int_from_vec(Obj, Val) result(Ans) Arguments Type Intent Optional Attributes Name class(Random_), intent(in) :: Obj integer(kind=I4B), intent(in) :: Val (:) Return Value integer(kind=I4B) interface private function select_random_real_from_array(Obj, Val) result(Ans) Arguments Type Intent Optional Attributes Name class(Random_), intent(in) :: Obj real(kind=DFP), intent(in) :: Val (:,:) Return Value real(kind=DFP) interface private function select_random_real_from_vec(Obj, Val) result(Ans) Arguments Type Intent Optional Attributes Name class(Random_), intent(in) :: Obj real(kind=DFP), intent(in) :: Val (:) Return Value real(kind=DFP) interface public function uniformRandom(Obj, From, To) result(Ans) Arguments Type Intent Optional Attributes Name class(Random_), intent(in) :: Obj real(kind=DFP), intent(in) :: From real(kind=DFP), intent(in) :: To Return Value real(kind=DFP)","tags":"","loc":"module/random_method.html"},{"title":"IntVector_Method – Fortran Program","text":"Uses GlobalData IO BaseType Contents Interfaces AllocateData Allocate_Data Append Append_1 Append_2 Append_3 ArrayPointer ArrayValues ArrayValues Constructor1 ConstructorInt ConstructorReal Constructor_1 Constructor_Int Constructor_Real Convert DeallocateData Deallocate_Data Display IndexOF IndexOf_1 IndexOf_2 IndexOf_3 IndexOf_4 Initiate IntIntrinsicDisplay IntVector IntVector IntVector IntVectorDisplay IntVector_Pointer IntVector_Pointer IntVector_Pointer IntscalarDisplay LOC RemoveDuplicates Repeat SIZE SetValue Shape f_getARRAYSectionValues_Int f_getARRAYSectionValues_self f_getARRAYValuesFromTriplet_Int f_getARRAYValuesFromTriplet_self f_getARRAYValues_Int f_getARRAYValues_self f_getPointer_Int f_getPointer_self f_getSectionValues_Int f_getSectionValues_self f_getValuesFromTriplet_Int f_getValuesFromTriplet_self f_getValues_Int f_getValues_self getValues getValues get_shape get_size initiate_obj initiate_obj_ab initiate_obj_vector isPresent isPresent_1 isPresent_2 obj_convert_int remove_dupl_intvec remove_duplicates repeat_int repeat_obj setValue_1 Interfaces public interface AllocateData private interface Allocate_Data () Arguments None interface private subroutine Allocate_Data(Obj, Dims) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Dims public interface Append private interface Append_1 () Arguments None private interface Append_2 () Arguments None private interface Append_3 () Arguments None interface private subroutine Append_1(Obj, Value) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Value interface private subroutine Append_2(Obj, Value) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Value (:) interface private subroutine Append_3(Obj, AnotherObj) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(inout) :: Obj class( IntVector_ ), intent(in) :: AnotherObj public interface ArrayPointer private interface f_getPointer_self () Arguments None private interface f_getPointer_Int () Arguments None public interface ArrayValues private interface f_getValues_self () Arguments None private interface f_getSectionValues_self () Arguments None private interface f_getValuesFromTriplet_self () Arguments None private interface f_getARRAYValues_self () Arguments None private interface f_getARRAYSectionValues_self () Arguments None private interface f_getARRAYValuesFromTriplet_self () Arguments None private interface ArrayValues private interface f_getValues_Int () Arguments None private interface f_getSectionValues_Int () Arguments None private interface f_getValuesFromTriplet_Int () Arguments None private interface f_getARRAYValues_Int () Arguments None private interface f_getARRAYSectionValues_Int () Arguments None private interface f_getARRAYValuesFromTriplet_Int () Arguments None interface private pure function Constructor1(tSize) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: tSize Return Value type( IntVector_ ) interface private pure function ConstructorInt(Val) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Val (:) Return Value type( IntVector_ ) interface private pure function ConstructorReal(Val) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Val (:) Return Value type( IntVector_ ) interface private pure function Constructor_1(tSize) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: tSize Return Value class( IntVector_ ),\n  POINTER interface private pure function Constructor_Int(Val) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Val (:) Return Value class( IntVector_ ),\n  POINTER interface private pure function Constructor_Real(Val) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Val (:) Return Value class( IntVector_ ),\n  POINTER public interface Convert private interface obj_convert_int () Arguments None public interface DeallocateData private interface Deallocate_Data () Arguments None interface private subroutine Deallocate_Data(Obj) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(inout) :: Obj public interface Display private interface IntVectorDisplay () Arguments None private interface IntscalarDisplay () Arguments None public interface IndexOF private interface IndexOf_1 () Arguments None private interface IndexOf_2 () Arguments None private interface IndexOf_3 () Arguments None private interface IndexOf_4 () Arguments None interface private pure function IndexOf_1(Obj, Value) result(Ans) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Value Return Value integer(kind=I4B) interface private pure function IndexOf_2(Obj, Value) result(Ans) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Value (:) Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) interface private pure function IndexOf_3(Obj, Value) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Obj (:) integer(kind=I4B), intent(in) :: Value Return Value integer(kind=I4B) interface private pure function IndexOf_4(Obj, Value) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Obj (:) integer(kind=I4B), intent(in) :: Value (:) Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) public interface Initiate private interface initiate_obj () Arguments None private interface initiate_obj_vector () Arguments None private interface initiate_obj_ab () Arguments None interface private subroutine IntIntrinsicDisplay(Val, msg, UnitNo) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Val (:) character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: UnitNo public interface IntVector private interface Constructor1 () Arguments None private interface IntVector private interface ConstructorInt () Arguments None private interface IntVector private interface ConstructorReal () Arguments None interface private subroutine IntVectorDisplay(Obj, msg, UnitNo) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(in) :: Obj (:) character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: UnitNo public interface IntVector_Pointer private interface Constructor_1 () Arguments None private interface IntVector_Pointer private interface Constructor_Int () Arguments None private interface IntVector_Pointer private interface Constructor_Real () Arguments None interface private subroutine IntscalarDisplay(Obj, msg, UnitNo) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(in) :: Obj character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: UnitNo public interface LOC private interface IndexOf_1 () Arguments None private interface IndexOf_2 () Arguments None private interface IndexOf_3 () Arguments None private interface IndexOf_4 () Arguments None public interface RemoveDuplicates private interface remove_duplicates () Arguments None private interface remove_dupl_intvec () Arguments None public interface Repeat private interface repeat_int () Arguments None private interface repeat_obj () Arguments None public interface SIZE private interface get_size () Arguments None public interface SetValue private interface setValue_1 () Arguments None public interface Shape private interface get_shape () Arguments None interface private pure function f_getARRAYSectionValues_Int(Obj, Indx, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(in) :: Obj (:) integer(kind=I4B), intent(in) :: Indx (:) integer(kind=I4B), intent(in) :: DataType Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) interface private pure function f_getARRAYSectionValues_self(Obj, Indx, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(in) :: Obj (:) integer(kind=I4B), intent(in) :: Indx (:) type( IntVector_ ), intent(in) :: DataType Return Value type( IntVector_ ) interface private pure function f_getARRAYValuesFromTriplet_Int(Obj, iStart, iEnd, Stride, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(in) :: Obj (:) integer(kind=I4B), intent(in) :: iStart integer(kind=I4B), intent(in) :: iEnd integer(kind=I4B), intent(in) :: Stride integer(kind=I4B), intent(in) :: DataType Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) interface private pure function f_getARRAYValuesFromTriplet_self(Obj, iStart, iEnd, Stride, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(in) :: Obj (:) integer(kind=I4B), intent(in) :: iStart integer(kind=I4B), intent(in) :: iEnd integer(kind=I4B), intent(in) :: Stride type( IntVector_ ), intent(in) :: DataType Return Value type( IntVector_ ) interface private pure function f_getARRAYValues_Int(Obj, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(in) :: Obj (:) integer(kind=I4B), intent(in) :: DataType Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) interface private pure function f_getARRAYValues_self(Obj, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(in) :: Obj (:) type( IntVector_ ), intent(in) :: DataType Return Value type( IntVector_ ) interface private function f_getPointer_Int(Obj, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(in), TARGET :: Obj integer(kind=I4B), intent(in) :: DataType Return Value integer(kind=I4B),\n  POINTER, (:) interface private function f_getPointer_self(Obj, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(in), TARGET :: Obj type( IntVector_ ), intent(in) :: DataType Return Value type( IntVector_ ),\n  POINTER interface private pure function f_getSectionValues_Int(Obj, Indx, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Indx (:) integer(kind=I4B), intent(in) :: DataType Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) interface private pure function f_getSectionValues_self(Obj, Indx, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Indx (:) type( IntVector_ ), intent(in) :: DataType Return Value type( IntVector_ ) interface private pure function f_getValuesFromTriplet_Int(Obj, iStart, iEnd, Stride, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: iStart integer(kind=I4B), intent(in) :: iEnd integer(kind=I4B), intent(in) :: Stride integer(kind=I4B), intent(in) :: DataType Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) interface private pure function f_getValuesFromTriplet_self(Obj, iStart, iEnd, Stride, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: iStart integer(kind=I4B), intent(in) :: iEnd integer(kind=I4B), intent(in) :: Stride type( IntVector_ ), intent(in) :: DataType Return Value type( IntVector_ ) interface private pure function f_getValues_Int(Obj, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: DataType Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) interface private pure function f_getValues_self(Obj, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(in) :: Obj type( IntVector_ ), intent(in) :: DataType Return Value type( IntVector_ ) public interface getValues private interface f_getValues_self () Arguments None private interface f_getSectionValues_self () Arguments None private interface f_getValuesFromTriplet_self () Arguments None private interface f_getARRAYValues_self () Arguments None private interface f_getARRAYSectionValues_self () Arguments None private interface f_getARRAYValuesFromTriplet_self () Arguments None private interface getValues private interface f_getValues_Int () Arguments None private interface f_getSectionValues_Int () Arguments None private interface f_getValuesFromTriplet_Int () Arguments None private interface f_getARRAYValues_Int () Arguments None private interface f_getARRAYSectionValues_Int () Arguments None private interface f_getARRAYValuesFromTriplet_Int () Arguments None interface private pure function get_shape(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(in) :: Obj Return Value integer(kind=I4B)\n  (1) interface private pure function get_size(Obj, Dims) result(Ans) Arguments Type Intent Optional Attributes Name type( IntVector_ ), intent(in) :: Obj integer(kind=I4B), intent(in), optional :: Dims Return Value integer(kind=I4B) interface private subroutine initiate_obj(Obj, tSize) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: tSize interface private subroutine initiate_obj_ab(Obj, a, b) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: a integer(kind=I4B), intent(in) :: b interface private subroutine initiate_obj_vector(Obj, tSize) Arguments Type Intent Optional Attributes Name type( IntVector_ ), intent(inout), ALLOCATABLE :: Obj (:) integer(kind=I4B), intent(in) :: tSize (:) public interface isPresent private interface isPresent_1 () Arguments None private interface isPresent_2 () Arguments None interface private pure function isPresent_1(Obj, Value) result(Ans) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Value Return Value logical(kind=LGT) interface private pure function isPresent_2(Obj, Value) result(Ans) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Value (:) Return Value logical(kind=LGT),\n  ALLOCATABLE, (:) interface private subroutine obj_convert_int(From, To) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(in) :: From integer(kind=I4B), intent(inout), ALLOCATABLE :: To (:) interface private subroutine remove_dupl_intvec(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(inout), ALLOCATABLE :: Obj (:) interface private subroutine remove_duplicates(Obj) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(inout) :: Obj interface private pure function repeat_int(Val, rtimes) result(Ans) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Val (:) integer(kind=I4B), intent(in) :: rtimes Return Value integer(kind=I4B)\n  (SIZE(Val)*rtimes) interface private pure function repeat_obj(Obj, rtimes) result(Ans) Arguments Type Intent Optional Attributes Name type( IntVector_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: rtimes Return Value integer(kind=I4B)\n  (SIZE(Obj%Val)*rtimes) interface private subroutine setValue_1(Obj, Indx, Value) Arguments Type Intent Optional Attributes Name class( IntVector_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Indx (:) integer(kind=I4B), intent(in) :: Value (:)","tags":"","loc":"module/intvector_method.html"},{"title":"RealVector_Method – Fortran Program","text":"Uses GlobalData IO BaseType Contents Interfaces ASUM ASUMIntrinsic ASUMScalar ASUMvector AXPY AllocateData Allocate_Data Append Append_1 Append_2 Append_3 ArrayPointer ArrayValues ArrayValues ArrayValues COPY Constructor1 ConstructorInt16 ConstructorInt32 ConstructorInt64 ConstructorInt8 ConstructorReal32 ConstructorReal64 Constructor_1 Constructor_Int16 Constructor_Int32 Constructor_Int64 Constructor_Int8 Constructor_Real32 Constructor_Real64 DOT DeallocateData Deallocate_Data Display Display_Vector_Real IndexOF IndexOf_1 IndexOf_2 Initiate LOC NORM2 NORM2SQR NRM2SQRintrinsic NRM2SQRscalar NRM2SQRvector NRM2scalar NRM2vector OPERATOR( .EQ. ) RANDOM_NUMBER RANDOM_NUMBER_Obj Random_number_obj_vec RealVector RealVector RealVector RealVector RealVector RealVector RealVector RealVectorDisplay RealVector_Pointer RealVector_Pointer RealVector_Pointer RealVector_Pointer RealVector_Pointer RealVector_Pointer RealVector_Pointer RealscalarDisplay SCALE SCALintrinsic SCALscalar SCALvector SHALLOWCOPY SIZE SWAP SetValue Shape f_getARRAYSectionValues_Int f_getARRAYSectionValues_Real f_getARRAYSectionValues_self f_getARRAYValuesFromTriplet_Int f_getARRAYValuesFromTriplet_Real f_getARRAYValuesFromTriplet_self f_getARRAYValues_Int f_getARRAYValues_Real f_getARRAYValues_self f_getPointer_Real64 f_getPointer_self f_getSectionValues_Int f_getSectionValues_Real f_getSectionValues_self f_getValuesFromTriplet_Int f_getValuesFromTriplet_Real f_getValuesFromTriplet_self f_getValues_Int f_getValues_Real f_getValues_self get_shape get_size initiate_obj initiate_obj_ab initiate_obj_vector intrinsicAXPYintrinsic intrinsicCOPYintrinsic intrinsicCOPYscalar intrinsicDOTintrinsic intrinsicDOTscalar intrinsicSHALLOWCOPYintrinsic intrinsicSHALLOWCOPYscalar intrinsicSWAPintrinsic intrinsicSWAPscalar isPresent isPresent_1 isPresent_2 scalarAXPYintrinsic scalarAXPYscalar scalarCOPYintrinsic scalarCOPYscalar scalarCOPYvector scalarDOTintrinsic scalarDOTscalar scalarDOTvector scalarSHALLOWCOPYintrinsic scalarSHALLOWCOPYscalar scalarSHALLOWCOPYvector scalarSWAPintrinsic scalarSWAPscalar setValue_1 vectorAXPYvector vectorCOPYvector vectorDOTscalar vectorDOTvector vectorSHALLOWCOPYvector vectorSWAPvector Interfaces public interface ASUM private interface ASUMScalar () Arguments None private interface ASUMvector () Arguments None private interface ASUMIntrinsic () Arguments None interface private pure function ASUMIntrinsic(Val) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Val (:) Return Value real(kind=DFP) interface private pure function ASUMScalar(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj Return Value real(kind=DFP) interface private pure function ASUMvector(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj (:) Return Value real(kind=DFP) public interface AXPY private interface scalarAXPYscalar () Arguments None private interface vectorAXPYvector () Arguments None private interface scalarAXPYintrinsic () Arguments None private interface intrinsicAXPYintrinsic () Arguments None public interface AllocateData private interface Allocate_Data () Arguments None interface private subroutine Allocate_Data(Obj, Dims) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Dims public interface Append private interface Append_1 () Arguments None private interface Append_2 () Arguments None private interface Append_3 () Arguments None interface private subroutine Append_1(Obj, Value) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(inout) :: Obj real(kind=DFP), intent(in) :: Value interface private subroutine Append_2(Obj, Value) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(inout) :: Obj real(kind=DFP), intent(in) :: Value (:) interface private subroutine Append_3(Obj, AnotherObj) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(inout) :: Obj class( RealVector_ ), intent(in) :: AnotherObj public interface ArrayPointer private interface f_getPointer_self () Arguments None private interface f_getPointer_Real64 () Arguments None public interface ArrayValues private interface f_getValues_self () Arguments None private interface f_getSectionValues_self () Arguments None private interface f_getValuesFromTriplet_self () Arguments None private interface f_getARRAYValues_self () Arguments None private interface f_getARRAYSectionValues_self () Arguments None private interface f_getARRAYValuesFromTriplet_self () Arguments None private interface ArrayValues private interface f_getValues_Int () Arguments None private interface f_getSectionValues_Int () Arguments None private interface f_getValuesFromTriplet_Int () Arguments None private interface f_getARRAYValues_Int () Arguments None private interface f_getARRAYValuesFromTriplet_Int () Arguments None private interface ArrayValues private interface f_getValues_Real () Arguments None private interface f_getSectionValues_Real () Arguments None private interface f_getValuesFromTriplet_Real () Arguments None private interface f_getARRAYValues_Real () Arguments None private interface f_getARRAYSectionValues_Real () Arguments None private interface f_getARRAYValuesFromTriplet_Real () Arguments None public interface COPY private interface intrinsicCOPYintrinsic () Arguments None private interface scalarCOPYscalar () Arguments None private interface vectorCOPYvector () Arguments None private interface scalarCOPYvector () Arguments None private interface scalarCOPYintrinsic () Arguments None interface private pure function Constructor1(tSize) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: tSize Return Value type( RealVector_ ) interface private pure function ConstructorInt16(Val) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=Int16), intent(in) :: Val (:) Return Value type( RealVector_ ) interface private pure function ConstructorInt32(Val) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=Int32), intent(in) :: Val (:) Return Value type( RealVector_ ) interface private pure function ConstructorInt64(Val) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=Int64), intent(in) :: Val (:) Return Value type( RealVector_ ) interface private pure function ConstructorInt8(Val) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=Int8), intent(in) :: Val (:) Return Value type( RealVector_ ) interface private pure function ConstructorReal32(Val) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=Real32), intent(in) :: Val (:) Return Value type( RealVector_ ) interface private pure function ConstructorReal64(Val) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=Real64), intent(in) :: Val (:) Return Value type( RealVector_ ) interface private pure function Constructor_1(tSize) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: tSize Return Value class( RealVector_ ),\n  POINTER interface private pure function Constructor_Int16(Val) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=Int16), intent(in) :: Val (:) Return Value class( RealVector_ ),\n  POINTER interface private pure function Constructor_Int32(Val) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=Int32), intent(in) :: Val (:) Return Value class( RealVector_ ),\n  POINTER interface private pure function Constructor_Int64(Val) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=Int64), intent(in) :: Val (:) Return Value class( RealVector_ ),\n  POINTER interface private pure function Constructor_Int8(Val) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=Int8), intent(in) :: Val (:) Return Value class( RealVector_ ),\n  POINTER interface private pure function Constructor_Real32(Val) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=Real32), intent(in) :: Val (:) Return Value class( RealVector_ ),\n  POINTER interface private pure function Constructor_Real64(Val) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=Real64), intent(in) :: Val (:) Return Value class( RealVector_ ),\n  POINTER public interface DOT private interface scalarDOTscalar () Arguments None private interface vectorDOTvector () Arguments None private interface vectorDOTscalar () Arguments None private interface scalarDOTvector () Arguments None private interface intrinsicDOTintrinsic () Arguments None private interface scalarDOTintrinsic () Arguments None public interface DeallocateData private interface Deallocate_Data () Arguments None interface private subroutine Deallocate_Data(Obj) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(inout) :: Obj public interface Display private interface RealVectorDisplay () Arguments None private interface RealscalarDisplay () Arguments None private interface Display_Vector_Real () Arguments None interface private subroutine Display_Vector_Real(vec, msg, unitNo, path, filename, extension) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: vec (:) character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: unitNo character(len=*), intent(in), optional :: path character(len=*), intent(in), optional :: filename character(len=*), intent(in), optional :: extension public interface IndexOF private interface IndexOf_1 () Arguments None private interface IndexOf_2 () Arguments None interface private pure function IndexOf_1(Obj, Value) result(Ans) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj real(kind=DFP), intent(in) :: Value Return Value integer(kind=I4B) interface private pure function IndexOf_2(Obj, Value) result(Ans) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj real(kind=DFP), intent(in) :: Value (:) Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) public interface Initiate private interface initiate_obj () This subroutine allocate the memory for RealVector_ Arguments None private interface initiate_obj_vector () This subroutine allocate the memory for a vector of type RealVector_ Arguments None private interface initiate_obj_ab () This subroutine allocate the memory for an instance of RealVector_ Arguments None public interface LOC private interface IndexOf_1 () Arguments None private interface IndexOf_2 () Arguments None public interface NORM2 private interface NRM2scalar () Arguments None private interface NRM2vector () Arguments None public interface NORM2SQR private interface NRM2SQRscalar () Arguments None private interface NRM2SQRvector () Arguments None private interface NRM2SQRintrinsic () Arguments None interface private pure function NRM2SQRintrinsic(Val) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Val (:) Return Value real(kind=DFP) interface private pure function NRM2SQRscalar(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj Return Value real(kind=DFP) interface private pure function NRM2SQRvector(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj (:) Return Value real(kind=DFP) interface private pure function NRM2scalar(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj Return Value real(kind=DFP) interface private pure function NRM2vector(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj (:) Return Value real(kind=DFP) public interface OPERATOR( .EQ. ) private interface isPresent_1 () Arguments None private interface isPresent_2 () Arguments None public interface RANDOM_NUMBER private interface RANDOM_NUMBER_Obj () Arguments None private interface Random_number_obj_vec () Arguments None interface private subroutine RANDOM_NUMBER_Obj(Obj, tsize) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: tsize interface private subroutine Random_number_obj_vec(Obj, tsize) Arguments Type Intent Optional Attributes Name type( RealVector_ ), intent(inout), ALLOCATABLE :: Obj (:) integer(kind=I4B), intent(in) :: tsize (:) public interface RealVector private interface Constructor1 () Arguments None private interface RealVector private interface ConstructorInt8 () Arguments None private interface RealVector private interface ConstructorInt16 () Arguments None private interface RealVector private interface ConstructorInt32 () Arguments None private interface RealVector private interface ConstructorInt64 () Arguments None private interface RealVector private interface ConstructorReal32 () Arguments None private interface RealVector private interface ConstructorReal64 () Arguments None interface private subroutine RealVectorDisplay(Obj, msg, UnitNo, path, filename, extension) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj (:) character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: UnitNo character(len=*), intent(in), optional :: path character(len=*), intent(in), optional :: filename character(len=*), intent(in), optional :: extension public interface RealVector_Pointer private interface Constructor_1 () Arguments None private interface RealVector_Pointer private interface Constructor_Int8 () Arguments None private interface RealVector_Pointer private interface Constructor_Int16 () Arguments None private interface RealVector_Pointer private interface Constructor_Int32 () Arguments None private interface RealVector_Pointer private interface Constructor_Int64 () Arguments None private interface RealVector_Pointer private interface Constructor_Real32 () Arguments None private interface RealVector_Pointer private interface Constructor_Real64 () Arguments None interface private subroutine RealscalarDisplay(Obj, msg, UnitNo, path, filename, extension) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj character(len=*), intent(in) :: msg integer(kind=I4B), intent(in), optional :: UnitNo character(len=*), intent(in), optional :: path character(len=*), intent(in), optional :: filename character(len=*), intent(in), optional :: extension public interface SCALE private interface SCALintrinsic () Arguments None private interface SCALscalar () Arguments None private interface SCALvector () Arguments None interface private subroutine SCALintrinsic(alpha, Val) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: alpha real(kind=DFP), intent(inout) :: Val (:) interface private subroutine SCALscalar(alpha, Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: alpha class( RealVector_ ), intent(inout) :: Obj interface private subroutine SCALvector(alpha, Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: alpha class( RealVector_ ), intent(inout) :: Obj (:) public interface SHALLOWCOPY private interface intrinsicSHALLOWCOPYintrinsic () Arguments None private interface scalarSHALLOWCOPYscalar () Arguments None private interface vectorSHALLOWCOPYvector () Arguments None private interface scalarSHALLOWCOPYvector () Arguments None private interface scalarSHALLOWCOPYintrinsic () Arguments None public interface SIZE private interface get_size () Arguments None public interface SWAP private interface scalarSWAPscalar () Arguments None private interface vectorSWAPvector () Arguments None private interface scalarSWAPintrinsic () Arguments None public interface SetValue private interface setValue_1 () Arguments None public interface Shape private interface get_shape () Arguments None interface private pure function f_getARRAYSectionValues_Int(Obj, Indx, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj (:) integer(kind=I4B), intent(in) :: Indx (:) integer(kind=I4B), intent(in) :: DataType Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) interface private pure function f_getARRAYSectionValues_Real(Obj, Indx, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj (:) integer(kind=I4B), intent(in) :: Indx (:) real(kind=DFP), intent(in) :: DataType Return Value real(kind=DFP),\n  ALLOCATABLE, (:) interface private pure function f_getARRAYSectionValues_self(Obj, Indx, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj (:) integer(kind=I4B), intent(in) :: Indx (:) type( RealVector_ ), intent(in) :: DataType Return Value type( RealVector_ ) interface private pure function f_getARRAYValuesFromTriplet_Int(Obj, iStart, iEnd, Stride, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj (:) integer(kind=I4B), intent(in) :: iStart integer(kind=I4B), intent(in) :: iEnd integer(kind=I4B), intent(in) :: Stride integer(kind=I4B), intent(in) :: DataType Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) interface private pure function f_getARRAYValuesFromTriplet_Real(Obj, iStart, iEnd, Stride, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj (:) integer(kind=I4B), intent(in) :: iStart integer(kind=I4B), intent(in) :: iEnd integer(kind=I4B), intent(in) :: Stride real(kind=DFP), intent(in) :: DataType Return Value real(kind=DFP),\n  ALLOCATABLE, (:) interface private pure function f_getARRAYValuesFromTriplet_self(Obj, iStart, iEnd, Stride, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj (:) integer(kind=I4B), intent(in) :: iStart integer(kind=I4B), intent(in) :: iEnd integer(kind=I4B), intent(in) :: Stride type( RealVector_ ), intent(in) :: DataType Return Value type( RealVector_ ) interface private pure function f_getARRAYValues_Int(Obj, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj (:) integer(kind=I4B), intent(in) :: DataType Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) interface private pure function f_getARRAYValues_Real(Obj, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj (:) real(kind=DFP), intent(in) :: DataType Return Value real(kind=DFP),\n  ALLOCATABLE, (:) interface private pure function f_getARRAYValues_self(Obj, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj (:) type( RealVector_ ), intent(in) :: DataType Return Value type( RealVector_ ) interface private function f_getPointer_Real64(Obj, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in), TARGET :: Obj real(kind=Real64), intent(in) :: DataType Return Value real(kind=Real64),\n  POINTER, (:) interface private function f_getPointer_self(Obj, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in), TARGET :: Obj type( RealVector_ ), intent(in) :: DataType Return Value type( RealVector_ ),\n  POINTER interface private pure function f_getSectionValues_Int(Obj, Indx, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Indx (:) integer(kind=I4B), intent(in) :: DataType Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) interface private pure function f_getSectionValues_Real(Obj, Indx, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Indx (:) real(kind=DFP), intent(in) :: DataType Return Value real(kind=DFP),\n  ALLOCATABLE, (:) interface private pure function f_getSectionValues_self(Obj, Indx, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Indx (:) type( RealVector_ ), intent(in) :: DataType Return Value type( RealVector_ ) interface private pure function f_getValuesFromTriplet_Int(Obj, iStart, iEnd, Stride, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: iStart integer(kind=I4B), intent(in) :: iEnd integer(kind=I4B), intent(in) :: Stride integer(kind=I4B), intent(in) :: DataType Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) interface private pure function f_getValuesFromTriplet_Real(Obj, iStart, iEnd, Stride, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: iStart integer(kind=I4B), intent(in) :: iEnd integer(kind=I4B), intent(in) :: Stride real(kind=DFP), intent(in) :: DataType Return Value real(kind=DFP),\n  ALLOCATABLE, (:) interface private pure function f_getValuesFromTriplet_self(Obj, iStart, iEnd, Stride, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: iStart integer(kind=I4B), intent(in) :: iEnd integer(kind=I4B), intent(in) :: Stride type( RealVector_ ), intent(in) :: DataType Return Value type( RealVector_ ) interface private pure function f_getValues_Int(Obj, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: DataType Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) interface private pure function f_getValues_Real(Obj, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj real(kind=DFP), intent(in) :: DataType Return Value real(kind=DFP),\n  ALLOCATABLE, (:) interface private pure function f_getValues_self(Obj, DataType) result(Val) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj type( RealVector_ ), intent(in) :: DataType Return Value type( RealVector_ ) interface private pure function get_shape(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj Return Value integer(kind=I4B)\n  (1) interface private pure function get_size(Obj, Dims) result(Ans) Arguments Type Intent Optional Attributes Name type( RealVector_ ), intent(in) :: Obj integer(kind=I4B), intent(in), optional :: Dims Return Value integer(kind=I4B) interface This subroutine allocate the memory for RealVector_ private subroutine initiate_obj(Obj, tSize) This subroutine allocates the memeory for RealVector_ Read more… Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: tSize interface This subroutine allocate the memory for an instance of RealVector_ private subroutine initiate_obj_ab(Obj, a, b) This subroutine allocate the memory for an instance of RealVector_ .\n User can specify the lowerbounds and upper bounds Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: a integer(kind=I4B), intent(in) :: b interface This subroutine allocate the memory for a vector of type RealVector_ private subroutine initiate_obj_vector(Obj, tSize) This subroutine allocate the memory for a vector of type RealVector_ The size of Obj would be same as the size of tSize Arguments Type Intent Optional Attributes Name type( RealVector_ ), intent(inout), ALLOCATABLE :: Obj (:) integer(kind=I4B), intent(in) :: tSize (:) interface private subroutine intrinsicAXPYintrinsic(Val1, alpha, Val2) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout) :: Val1 (:) real(kind=DFP), intent(in) :: alpha real(kind=DFP), intent(in) :: Val2 (:) interface private subroutine intrinsicCOPYintrinsic(Val1, Val2) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: Val1 (:) real(kind=DFP), intent(in) :: Val2 (:) interface private subroutine intrinsicCOPYscalar(Val, Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: Val (:) class( RealVector_ ), intent(in) :: Obj interface private pure function intrinsicDOTintrinsic(Val1, Val2) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Val1 (:) real(kind=DFP), intent(in) :: Val2 (:) Return Value real(kind=DFP) interface private pure function intrinsicDOTscalar(Val, Obj) result(Ans) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Val (:) class( RealVector_ ), intent(in) :: Obj Return Value real(kind=DFP) interface private subroutine intrinsicSHALLOWCOPYintrinsic(Val1, Val2) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: Val1 (:) real(kind=DFP), intent(in) :: Val2 (:) interface private subroutine intrinsicSHALLOWCOPYscalar(Val, Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: Val (:) class( RealVector_ ), intent(in) :: Obj interface private subroutine intrinsicSWAPintrinsic(Val1, Val2) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout) :: Val1 (:) real(kind=DFP), intent(inout) :: Val2 (:) interface private subroutine intrinsicSWAPscalar(Val, Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout) :: Val (:) class( RealVector_ ), intent(inout) :: Obj public interface isPresent private interface isPresent_1 () Arguments None private interface isPresent_2 () Arguments None interface private pure function isPresent_1(Obj, Value) result(Ans) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj real(kind=DFP), intent(in) :: Value Return Value logical(kind=LGT) interface private pure function isPresent_2(Obj, Value) result(Ans) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj real(kind=DFP), intent(in) :: Value (:) Return Value logical(kind=LGT),\n  ALLOCATABLE, (:) interface private subroutine scalarAXPYintrinsic(Obj, alpha, Val) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(inout) :: Obj real(kind=DFP), intent(in) :: alpha real(kind=DFP), intent(in) :: Val (:) interface private subroutine scalarAXPYscalar(Obj1, alpha, Obj2) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(inout) :: Obj1 real(kind=DFP), intent(in) :: alpha class( RealVector_ ), intent(in) :: Obj2 interface private subroutine scalarCOPYintrinsic(Obj, Val) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val (:) interface private subroutine scalarCOPYscalar(Obj1, Obj2) Arguments Type Intent Optional Attributes Name type( RealVector_ ), intent(inout) :: Obj1 class( RealVector_ ), intent(in) :: Obj2 interface private subroutine scalarCOPYvector(Obj1, Obj2) Arguments Type Intent Optional Attributes Name type( RealVector_ ), intent(inout) :: Obj1 class( RealVector_ ), intent(in) :: Obj2 (:) interface private pure function scalarDOTintrinsic(Obj, Val) result(Ans) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj real(kind=DFP), intent(in) :: Val (:) Return Value real(kind=DFP) interface private pure function scalarDOTscalar(Obj1, Obj2) result(Ans) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj1 class( RealVector_ ), intent(in) :: Obj2 Return Value real(kind=DFP) interface private pure function scalarDOTvector(Obj1, Obj2) result(Ans) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj1 class( RealVector_ ), intent(in) :: Obj2 (:) Return Value real(kind=DFP) interface private subroutine scalarSHALLOWCOPYintrinsic(Obj, Val) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val (:) interface private subroutine scalarSHALLOWCOPYscalar(Obj1, Obj2) Arguments Type Intent Optional Attributes Name type( RealVector_ ), intent(inout) :: Obj1 class( RealVector_ ), intent(in) :: Obj2 interface private subroutine scalarSHALLOWCOPYvector(Obj1, Obj2) Arguments Type Intent Optional Attributes Name type( RealVector_ ), intent(inout) :: Obj1 class( RealVector_ ), intent(in) :: Obj2 (:) interface private subroutine scalarSWAPintrinsic(Obj, Val) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(inout) :: Obj real(kind=DFP), intent(inout) :: Val (:) interface private subroutine scalarSWAPscalar(Obj1, Obj2) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(inout) :: Obj1 class( RealVector_ ), intent(inout) :: Obj2 interface private subroutine setValue_1(Obj, Indx, Value) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Indx (:) real(kind=DFP), intent(in) :: Value (:) interface private subroutine vectorAXPYvector(Obj1, alpha, Obj2) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(inout) :: Obj1 (:) real(kind=DFP), intent(in) :: alpha class( RealVector_ ), intent(in) :: Obj2 (:) interface private subroutine vectorCOPYvector(Obj1, Obj2) Arguments Type Intent Optional Attributes Name type( RealVector_ ), intent(inout), ALLOCATABLE :: Obj1 (:) class( RealVector_ ), intent(in) :: Obj2 (:) interface private pure function vectorDOTscalar(Obj1, Obj2) result(Ans) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj1 (:) class( RealVector_ ), intent(in) :: Obj2 Return Value real(kind=DFP) interface private pure function vectorDOTvector(Obj1, Obj2) result(Ans) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(in) :: Obj1 (:) class( RealVector_ ), intent(in) :: Obj2 (:) Return Value real(kind=DFP) interface private subroutine vectorSHALLOWCOPYvector(Obj1, Obj2) Arguments Type Intent Optional Attributes Name type( RealVector_ ), intent(inout), ALLOCATABLE :: Obj1 (:) class( RealVector_ ), intent(in) :: Obj2 (:) interface private subroutine vectorSWAPvector(Obj1, Obj2) Arguments Type Intent Optional Attributes Name class( RealVector_ ), intent(inout) :: Obj1 (:) class( RealVector_ ), intent(inout) :: Obj2 (:)","tags":"","loc":"module/realvector_method.html"},{"title":"ElemshapeData_Method – Fortran Program","text":"This module implements methods related to ElemShapeData_ datatype Uses BaseType GlobalData Contents Interfaces AllocateData DeallocateData Display H1_Lagrange Hexahedron_H1_Lagrange Initiate Initiate Interpolation Line_H1_Lagrange Prism_H1_Lagrange Pyramid_H1_Lagrange Quadrangle_H1_Lagrange STInterpolation Tetrahedron_H1_Lagrange Triangle_H1_Lagrange deallocate_data display_obj getInterpolation getInterpolation getLocalGradient getLocalGradient_scalar getLocalGradient_vector getProjectionOfdNTdXt getProjectionOfdNTdXt_constvector getProjectionOfdNTdXt_fevar getProjectionOfdNdXt getProjectionOfdNdXt_fevar getProjectionOfdNdXt_spacevalues getSpatialGradient getSpatialGradient_scalar getSpatialGradient_vector getUnitNormal getUnitNormal_scalar getUnitNormal_vector get_interpol_fevar_matrix get_interpol_fevar_scalar get_interpol_matrix get_interpol_scalar get_interpol_vector initiate_obj interpol_matrix interpol_scalar interpol_vector setBarycentricCoord setJacobian setJs setNormal setThickness setValue set_Js set_coord set_dNdXt_internally set_jacobian set_normal set_thickness set_value setdNTdXt setdNTdt setdNdXt stsd_getLocalGradient_scalar stsd_getLocalGradient_vector stsd_getSpatialGradient_scalar stsd_getSpatialGradient_vector stsd_get_interpol_fevar_matrix stsd_get_interpol_fevar_scalar stsd_get_interpol_matrix stsd_get_interpol_scalar stsd_get_interpol_vector stsd_initiate stsd_interpol_matrix stsd_interpol_scalar stsd_interpol_vector stsd_set_coord stsd_set_dNTdXt_internally stsd_set_dNTdt stsd_set_jacobian stsd_set_thickness stsd_set_value Interfaces public interface AllocateData private interface initiate_obj () This subroutine allocate the memory for various matrices in the object Arguments None public interface DeallocateData private interface deallocate_data () this subroutine deallocates the data stored inside ElemShapeData_ Arguments None public interface Display private interface display_obj () This subroutine display the content of object Arguments None interface private subroutine H1_Lagrange(Obj, Quad, RefElem, ContinuityType, InterpolType) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(inout) :: Obj class(QuadraturePoint_), intent(in) :: Quad class(ReferenceElement_), intent(in) :: RefElem class(H1_), intent(in) :: ContinuityType class(LagrangeInterpolation_), intent(in) :: InterpolType interface private subroutine Hexahedron_H1_Lagrange(Obj, Quad, RefElem, ContinuityType, InterpolType) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(inout) :: Obj class(QuadraturePoint_), intent(in) :: Quad class(ReferenceHexahedron_), intent(in) :: RefElem class(H1_), intent(in) :: ContinuityType class(LagrangeInterpolation_), intent(in) :: InterpolType public interface Initiate private interface stsd_initiate () This subroutine initiate time shape function data in STElemShapeData_ Arguments None private interface Initiate private interface H1_Lagrange () Arguments None public interface Interpolation private interface interpol_scalar () This function returns the interpolation of a scalar Arguments None private interface interpol_vector () This function returns the interpolation of vector Arguments None private interface interpol_matrix () This function returns the interpolation of matrix Arguments None interface This subroutine computes the shape functions given by Lagrange polynomials !! over reference line element private subroutine Line_H1_Lagrange(Obj, Quad, RefElem, ContinuityType, InterpolType) This subroutine computes shape functions, lagrange polynomials, over\n reference line element\n The interpolation functions are defined inside the reference element itself\n The order of shape functions are also included inside the refelem Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(inout) :: Obj class(QuadraturePoint_), intent(in) :: Quad Quadrature points where shapefunctions will be evaluated class(ReferenceLine_), intent(in) :: RefElem Reference element where shape functions will be defined class(H1_), intent(in) :: ContinuityType H1 (nodal) Continuity type class(LagrangeInterpolation_), intent(in) :: InterpolType Lagrange polynomial will be used for interpolation interface private subroutine Prism_H1_Lagrange(Obj, Quad, RefElem, ContinuityType, InterpolType) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(inout) :: Obj class(QuadraturePoint_), intent(in) :: Quad class(ReferencePrism_), intent(in) :: RefElem class(H1_), intent(in) :: ContinuityType class(LagrangeInterpolation_), intent(in) :: InterpolType interface private subroutine Pyramid_H1_Lagrange(Obj, Quad, RefElem, ContinuityType, InterpolType) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(inout) :: Obj class(QuadraturePoint_), intent(in) :: Quad class(ReferencePyramid_), intent(in) :: RefElem class(H1_), intent(in) :: ContinuityType class(LagrangeInterpolation_), intent(in) :: InterpolType interface private subroutine Quadrangle_H1_Lagrange(Obj, Quad, RefElem, ContinuityType, InterpolType) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(inout) :: Obj class(QuadraturePoint_), intent(in) :: Quad class(ReferenceQuadrangle_), intent(in) :: RefElem class(H1_), intent(in) :: ContinuityType class(LagrangeInterpolation_), intent(in) :: InterpolType private interface STInterpolation private interface stsd_interpol_scalar () This function performs interpolations of scalar Arguments None private interface stsd_interpol_vector () This function performs interpolations of vector Arguments None private interface stsd_interpol_matrix () This function performs interpolations of matrix Arguments None interface private subroutine Tetrahedron_H1_Lagrange(Obj, Quad, RefElem, ContinuityType, InterpolType) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(inout) :: Obj class(QuadraturePoint_), intent(in) :: Quad class(ReferenceTetrahedron_), intent(in) :: RefElem class(H1_), intent(in) :: ContinuityType class(LagrangeInterpolation_), intent(in) :: InterpolType interface This subroutine computes the shape functions given by Lagrange polynomials !! over reference triangle element private subroutine Triangle_H1_Lagrange(Obj, Quad, RefElem, ContinuityType, InterpolType) This subroutine computes shape functions, lagrange polynomials, over\n reference triangle element Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(inout) :: Obj class(QuadraturePoint_), intent(in) :: Quad class(ReferenceTriangle_), intent(in) :: RefElem class(H1_), intent(in) :: ContinuityType class(LagrangeInterpolation_), intent(in) :: InterpolType interface this subroutine deallocates the data stored inside ElemShapeData_ private subroutine deallocate_data(Obj) This subroutine deallocates the data stored inside ElemShapeData_ and STElemShapeData_ Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(inout) :: Obj interface This subroutine display the content of object private subroutine display_obj(Obj, Msg, UnitNo) This subroutine displays the content of ElemShapeData_ and STElemShapeData_ Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Obj character(len=*), intent(in) :: Msg integer(kind=I4B), intent(in), optional :: UnitNo public interface getInterpolation private interface get_interpol_scalar () This subroutine performs interpolations Arguments None private interface get_interpol_vector () This subroutine performs interpolation of a vector Arguments None private interface get_interpol_matrix () This subroutine performs interpolation of matrix Arguments None private interface get_interpol_fevar_scalar () Arguments None private interface get_interpol_fevar_matrix () This subroutine performs interpolation of matrix Arguments None private interface getInterpolation private interface stsd_get_interpol_scalar () This subroutine performs interpolations of scalar Arguments None private interface stsd_get_interpol_vector () This subroutine performs interpolation of a vector Arguments None private interface stsd_get_interpol_matrix () This subroutine performs interpolation of matrix Arguments None private interface stsd_get_interpol_fevar_scalar () Arguments None private interface stsd_get_interpol_fevar_matrix () Arguments None private interface getLocalGradient private interface getLocalGradient_scalar () This subroutine returns the local gradient of a scalar Arguments None private interface getLocalGradient_vector () This subroutine returns the local gradient of a vector Arguments None private interface stsd_getLocalGradient_scalar () This subroutine returns the local gradient of a scalar Arguments None private interface stsd_getLocalGradient_vector () This subroutine returns the local gradient of a vector Arguments None interface This subroutine returns the local gradient of a scalar private subroutine getLocalGradient_scalar(Obj, dPhidXi, Val) This subroutine returns the local gradient of a scalar from space\n nodal values Read more… Arguments Type Intent Optional Attributes Name class(ElemShapeData_), intent(in) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: dPhidXi (:,:) real(kind=DFP), intent(in) :: Val (:) Space nodal values of scalar interface This subroutine returns the local gradient of a vector private subroutine getLocalGradient_vector(Obj, dVdXi, Val) This subroutine returns the local gradient of a vector Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: dVdXi (:,:,:) local gradient at integration points real(kind=DFP), intent(in) :: Val (:,:) nodal values of vector in xiJ format public interface getProjectionOfdNTdXt private interface getProjectionOfdNTdXt_constvector () This subroutine computes the projection of dNTdXt on a vector Arguments None private interface getProjectionOfdNTdXt_fevar () This subroutine computes the projection of dNTdXt on a vector Arguments None interface This subroutine computes the projection of dNTdXt on a vector private subroutine getProjectionOfdNTdXt_constvector(Obj, cdNTdXt, Val) This subroutine computes the projcetion cdNTdXt on the vector Val Here the vector Val is constant in space and time Read more… Arguments Type Intent Optional Attributes Name class(STElemshapeData_), intent(in) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: cdNTdXt (:,:,:) returned $c_{i}\\frac{\\partial N&#94;{I} T_a}{\\partial x_{i}}$ real(kind=DFP), intent(in) :: Val (:) constant value of vector interface This subroutine computes the projection of dNTdXt on a vector private subroutine getProjectionOfdNTdXt_fevar(Obj, cdNTdXt, Val) This subroutine computes the projcetion cdNTdXt on the vector Val Here the vector Val is constant in space and time Read more… Arguments Type Intent Optional Attributes Name class(STElemshapeData_), intent(in) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: cdNTdXt (:,:,:) returned $c_{i}\\frac{\\partial N&#94;{I} T_a}{\\partial x_{i}}$ type(FEVariable_), intent(in) :: Val constant value of vector public interface getProjectionOfdNdXt private interface getProjectionOfdNdXt_spacevalues () This subroutine computes the projection of dNdXt on a vector Arguments None private interface getProjectionOfdNdXt_fevar () This subroutine computes the projection of dNdXt on a vector Arguments None interface This subroutine computes the projection of dNdXt on a vector private subroutine getProjectionOfdNdXt_fevar(Obj, cdNdXt, Val) This subroutine computes the projcetion cdNdXt on the vector Val Here the vector Val is constant in space and time Read more… Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: cdNdXt (:,:) returned $c_{i}\\frac{\\partial N&#94;{I}}{\\partial x_{i}}$ class(FEVariable_), intent(in) :: Val constant value of vector interface This subroutine computes the projection of dNdXt on a vector private subroutine getProjectionOfdNdXt_spacevalues(Obj, cdNdXt, Val) This subroutine computes the projcetion cdNdXt on the vector Val Here the vector Val is constant in space and time Read more… Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: cdNdXt (:,:) returned $c_{i}\\frac{\\partial N&#94;{I}}{\\partial x_{i}}$ real(kind=DFP), intent(in) :: Val (:) constant value of vector public interface getSpatialGradient private interface getSpatialGradient_scalar () This subroutine returns the spatial gradient of scalar Arguments None private interface getSpatialGradient_vector () This subroutine returns the spatial gradient of vector Arguments None private interface stsd_getSpatialGradient_scalar () This subroutine returns the spatial gradient of scalar Arguments None private interface stsd_getSpatialGradient_vector () This subroutine returns the spatial gradient of vector Arguments None interface This subroutine returns the spatial gradient of scalar private subroutine getSpatialGradient_scalar(Obj, dPhidXt, Val) This subroutine returns the spatial gradient of scalar Arguments Type Intent Optional Attributes Name class(ElemShapeData_), intent(in) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: dPhidXt (:,:) Spatial gradient of scalar real(kind=DFP), intent(in) :: Val (:) Nodal values of scalar interface This subroutine returns the spatial gradient of vector private subroutine getSpatialGradient_vector(Obj, dVdXt, Val) This subroutine returns the spatial gradient of a vector Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: dVdXt (:,:,:) spatial gradient of val at integration points real(kind=DFP), intent(in) :: Val (:,:) nodal values of vector in xiJ format public interface getUnitNormal private interface getUnitNormal_vector () Arguments None private interface getUnitNormal_scalar () This subroutine can be used in SUPG formulation Arguments None interface This subroutine can be used in SUPG formulation private subroutine getUnitNormal_scalar(Obj, R, Val) This routine can be used in the SUPG formulation Read more… Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: R (:,:) real(kind=DFP), intent(in) :: Val (:) interface private subroutine getUnitNormal_vector(Obj, R, Val) Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(inout) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: R (:,:) real(kind=DFP), intent(in) :: Val (:,:) interface This subroutine performs interpolation of matrix private subroutine get_interpol_fevar_matrix(Obj, Interpol, Val) This subroutine performs interpolation of matrix Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Obj real(kind=DFP), intent(inout) :: Interpol (:,:,:) type(FEVariable_), intent(in) :: Val interface private subroutine get_interpol_fevar_scalar(Obj, Interpol, Val) Arguments Type Intent Optional Attributes Name class(ElemShapeData_), intent(in) :: Obj real(kind=DFP), intent(inout) :: Interpol (:) type(FEVariable_), intent(in) :: Val interface This subroutine performs interpolation of matrix private subroutine get_interpol_matrix(Obj, Interpol, Val) This subroutine performs interpolation of matrix Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: Interpol (:,:,:) real(kind=DFP), intent(in) :: Val (:,:,:) nodal value of matrix interface This subroutine performs interpolations private subroutine get_interpol_scalar(Obj, Interpol, Val) This subroutine performs interpolation of a scalar from its spatial nodal\n values. u=u_{I}N&#94;{I} Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: Interpol (:) Interpolation value of val at integration points real(kind=DFP), intent(in) :: Val (:) spatial nodal values of scalar interface This subroutine performs interpolation of a vector private subroutine get_interpol_vector(Obj, Interpol, Val) This subroutine performs interpolation of a vector from its spatial\n nodal values Read more… Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: Interpol (:,:) Interpol(:,ips) => interpolation value at integration points real(kind=DFP), intent(in) :: Val (:,:) nodal values of vector in xiJ format interface This subroutine allocate the memory for various matrices in the object private subroutine initiate_obj(Obj, nsd, xidim, nns, nips) This subroutine allocates the memory for various arrays in & ElemShapeData_ object Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(inout) :: Obj object to be returned integer(kind=I4B), intent(in) :: nsd spatial dimension integer(kind=I4B), intent(in) :: xidim xidimension integer(kind=I4B), intent(in) :: nns number of nodes in element integer(kind=I4B), intent(in) :: nips number of integration points interface This function returns the interpolation of matrix private pure function interpol_matrix(Obj, Val) result(Interpol) This function returns the interpolation of matrix Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Obj real(kind=DFP), intent(in) :: Val (:,:,:) Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:,:) interface This function returns the interpolation of a scalar private pure function interpol_scalar(Obj, Val) result(Interpol) This function returns interpolation of scalar Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Obj real(kind=DFP), intent(in) :: Val (:) Return Value real(kind=DFP),\n  ALLOCATABLE, (:) interface This function returns the interpolation of vector private pure function interpol_vector(Obj, Val) result(Interpol) This function returns the interpolation of vectors Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(in) :: Obj real(kind=DFP), intent(in) :: Val (:,:) Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) public interface setBarycentricCoord private interface set_coord () This subroutine set the Barycentric coordinates Arguments None private interface stsd_set_coord () This subroutine set the Barycentric coordinates Arguments None public interface setJacobian private interface set_jacobian () This subroutine set the jacobian Arguments None private interface stsd_set_jacobian () This subroutine set the jacobian using space-time nodal coords Arguments None public interface setJs private interface set_Js () This subroutine set the determinent of jacobian Arguments None public interface setNormal private interface set_normal () Arguments None public interface setThickness private interface set_thickness () This subroutine set the thickness field Arguments None private interface stsd_set_thickness () This subroutine set the thickness field Arguments None public interface setValue private interface set_value () This subroutine set parameters defined on physical element Arguments None private interface stsd_set_value () This subroutine set parameters defined on physical element Arguments None interface This subroutine set the determinent of jacobian private subroutine set_Js(Obj) This subroutine will internally set the value of jacobian Arguments Type Intent Optional Attributes Name class(ElemShapeData_), intent(inout) :: Obj interface This subroutine set the Barycentric coordinates private subroutine set_coord(Obj, Val, N) This subroutine set the barycentric coordinates Read more… Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val (:,:) Nodal coordinates in xiJ format real(kind=DFP), intent(in) :: N (:,:) When element is not an isoparametric we can supply N. interface This subroutine set $\\frac{d N}{d X_t}$ internally private subroutine set_dNdXt_internally(Obj) This subroutine will internally set dNdXt .\n It use the inverse of jacobian stored internally, so make sure jacobian is\n set before calling this  subroutine. Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(inout) :: Obj interface This subroutine set the jacobian private subroutine set_jacobian(Obj, Val, dNdXi) This subroutine set the jacobian by using the nodal coordinates Read more… Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val (:,:) nodal coordinates in xiJ format real(kind=DFP), intent(in) :: dNdXi (:,:,:) interface private subroutine set_normal(Obj) Arguments Type Intent Optional Attributes Name class(ElemShapeData_), intent(inout) :: Obj interface This subroutine set the thickness field private subroutine set_thickness(Obj, Val, N) This subroutine set the thickness field\n Here Val denotes the nodal value of thickeness Read more… Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val (:) Nodal values of thickness real(kind=DFP), intent(in) :: N (:,:) Nodal values of thickness interface This subroutine set parameters defined on physical element private subroutine set_value(Obj, Val, N, dNdXi) This subroutine set parameters defined on physical element Read more… Arguments Type Intent Optional Attributes Name class(ElemshapeData_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val (:,:) Spatial nodal coordinates real(kind=DFP), intent(in) :: N (:,:) Shape function for geometry real(kind=DFP), intent(in) :: dNdXi (:,:,:) Local derivative of shape functions for geometry public interface setdNTdXt private interface stsd_set_dNTdXt_internally () This subroutine set dNTdXt by using internal data Arguments None public interface setdNTdt private interface stsd_set_dNTdt () This subroutine set dNTdt by using the space-time nodal values Arguments None public interface setdNdXt private interface set_dNdXt_internally () This subroutine set $\\frac{d N}{d X_t}$ internally Arguments None interface This subroutine returns the local gradient of a scalar private subroutine stsd_getLocalGradient_scalar(Obj, dPhidXi, Val) This subroutine returns the local gradient of a scalar from space\n time nodal values Read more… Arguments Type Intent Optional Attributes Name class(STElemShapeData_), intent(in) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: dPhidXi (:,:) local gradient of scalar real(kind=DFP), intent(in) :: Val (:,:) space-time nodal values interface This subroutine returns the local gradient of a vector private subroutine stsd_getLocalGradient_vector(Obj, dVdXi, Val) This subroutine returns the local gradient of a vector using space-time\n nodal coordinates Arguments Type Intent Optional Attributes Name class(STElemshapeData_), intent(in) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: dVdXi (:,:,:) local gradient at integration points real(kind=DFP), intent(in) :: Val (:,:,:) space-time nodal values of vector in xiJa format interface This subroutine returns the spatial gradient of scalar private subroutine stsd_getSpatialGradient_scalar(Obj, dPhidXt, Val) This subroutine returns the spatial gradient of scalar Arguments Type Intent Optional Attributes Name class(STElemShapeData_), intent(in) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: dPhidXt (:,:) Spatial gradient of scalar real(kind=DFP), intent(in) :: Val (:,:) space-time Nodal values of scalar interface This subroutine returns the spatial gradient of vector private subroutine stsd_getSpatialGradient_vector(Obj, dVdXt, Val) This subroutine returns the spatial gradient of a vector from its\n space-time nodal values Arguments Type Intent Optional Attributes Name class(STElemshapeData_), intent(in) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: dVdXt (:,:,:) spatial gradient of val at integration points real(kind=DFP), intent(in) :: Val (:,:,:) space-time nodal values of vector in xiJa format interface private subroutine stsd_get_interpol_fevar_matrix(Obj, Interpol, Val) Arguments Type Intent Optional Attributes Name class(STElemShapeData_), intent(in) :: Obj (:) real(kind=DFP), intent(inout) :: Interpol (:,:,:,:) type(FEVariable_), intent(in) :: Val interface private subroutine stsd_get_interpol_fevar_scalar(Obj, Interpol, Val) Arguments Type Intent Optional Attributes Name class(STElemShapeData_), intent(in) :: Obj (:) real(kind=DFP), intent(inout) :: Interpol (:,:) type(FEVariable_), intent(in) :: Val interface This subroutine performs interpolation of matrix private subroutine stsd_get_interpol_matrix(Obj, Interpol, Val) This subroutine performs interpolation of matrix from its space-time\n nodal values Arguments Type Intent Optional Attributes Name class(STElemshapeData_), intent(in) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: Interpol (:,:,:) real(kind=DFP), intent(in) :: Val (:,:,:,:) nodal value of matrix interface This subroutine performs interpolations of scalar private subroutine stsd_get_interpol_scalar(Obj, Interpol, Val) This subroutine performs interpolation of a scalar from its space-time nodal\n values. u=u&#94;{a}_{I}N&#94;{I}T_{a} Arguments Type Intent Optional Attributes Name class(STElemshapeData_), intent(in) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: Interpol (:) Interpolation value of val at integration points real(kind=DFP), intent(in) :: Val (:,:) spatial nodal values of scalar interface This subroutine performs interpolation of a vector private subroutine stsd_get_interpol_vector(Obj, Interpol, Val) This subroutine performs interpolation of a vector from its space-time\n nodal values Read more… Arguments Type Intent Optional Attributes Name class(STElemshapeData_), intent(in) :: Obj real(kind=DFP), intent(inout), ALLOCATABLE :: Interpol (:,:) Interpol(:,ips) => interpolation value at integration points real(kind=DFP), intent(in) :: Val (:,:,:) space-time nodal values of vector in xiJa format interface This subroutine initiate time shape function data in STElemShapeData_ private subroutine stsd_initiate(Obj, elemsd) This subroutine initiate time shape function data in STElemShapeData_ .\n To do so effeciently we construct local shape function for time element\n externally by using ElemShapeData_ , and supply this information. Read more… Arguments Type Intent Optional Attributes Name type(STElemShapeData_), intent(inout), ALLOCATABLE :: Obj (:) type(ElemShapeData_), intent(in) :: elemsd interface This function performs interpolations of matrix private pure function stsd_interpol_matrix(Obj, Val) result(Interpol) This function performs interpolation of a matrix from its space-time nodal\n values. u=u&#94;{a}_{I}N&#94;{I}T_{a} Arguments Type Intent Optional Attributes Name class(STElemshapeData_), intent(in) :: Obj real(kind=DFP), intent(in) :: Val (:,:,:,:) spatial nodal values of matrix Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:,:) Interpolation value of val at integration points interface This function performs interpolations of scalar private pure function stsd_interpol_scalar(Obj, Val) result(Interpol) This function performs interpolation of a scalar from its space-time nodal\n values. u=u&#94;{a}_{I}N&#94;{I}T_{a} Arguments Type Intent Optional Attributes Name class(STElemshapeData_), intent(in) :: Obj real(kind=DFP), intent(in) :: Val (:,:) space-time nodal values of scalar Return Value real(kind=DFP),\n  ALLOCATABLE, (:) Interpolation value of val at integration points interface This function performs interpolations of vector private pure function stsd_interpol_vector(Obj, Val) result(Interpol) This function performs interpolation of a vector from its space-time nodal\n values. u=u&#94;{a}_{I}N&#94;{I}T_{a} Arguments Type Intent Optional Attributes Name class(STElemshapeData_), intent(in) :: Obj real(kind=DFP), intent(in) :: Val (:,:,:) spatial nodal values of vector Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) Interpolation value of val at integration points interface This subroutine set the Barycentric coordinates private subroutine stsd_set_coord(Obj, Val, N, T) This subroutine set the barycentric coordinates by using\n space-time nodal coordinates Read more… Arguments Type Intent Optional Attributes Name class(STElemshapeData_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val (:,:,:) space-time Nodal coordinates in xiJ format real(kind=DFP), intent(in) :: N (:,:) N and T are required to handle non isoparametric elements real(kind=DFP), intent(in) :: T (:) N and T are required to handle non isoparametric elements interface This subroutine set dNTdXt by using internal data private subroutine stsd_set_dNTdXt_internally(Obj) This subroutine set dNTdXt by using internal data\n This subroutine uses inverse of Jacobian, therefore, before calling\n this subroutine make sure to set jacobian Read more… Arguments Type Intent Optional Attributes Name class(STElemShapeData_), intent(inout) :: Obj Space-time nodal values interface This subroutine set dNTdt by using the space-time nodal values private subroutine stsd_set_dNTdt(Obj, Val) \\frac{\\partial N&#94;{I\\  }T_{a}}{\\partial t} =N&#94;{I}\\frac{\\partial T_{a}}\n {\\partial \\theta } J&#94;{-1}_{t}-\\frac{\\partial N&#94;{I}T_{a}}{\\partial x_{k}}\n \\hat{v}_{k} Read more… Arguments Type Intent Optional Attributes Name class(STElemShapeData_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val (:,:,:) Space-time nodal values interface This subroutine set the jacobian using space-time nodal coords private subroutine stsd_set_jacobian(Obj, Val, dNdXi, T) This subroutine set the jacobian by using space-time nodal coords, dNdXi T are used to handle non-isoparameteric elements. Read more… Arguments Type Intent Optional Attributes Name class(STElemshapeData_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val (:,:,:) Space time nodal values of coordinates real(kind=DFP), intent(in) :: dNdXi (:,:,:) Local derivative of shape function for geometry real(kind=DFP), intent(in) :: T (:) Shape function for time element interface This subroutine set the thickness field private subroutine stsd_set_thickness(Obj, Val, N, T) This subroutine set the thickness field\n Here Val denotes the space-time nodal value of thickeness Read more… Arguments Type Intent Optional Attributes Name class(STElemshapeData_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val (:,:) Space-time nodal values of thickness real(kind=DFP), intent(in) :: N (:,:) Space-time nodal values of thickness real(kind=DFP), intent(in) :: T (:) Space-time nodal values of thickness interface This subroutine set parameters defined on physical element private subroutine stsd_set_value(Obj, Val, N, T, dNdXi) This subroutine set parameters defined on physical element Read more… Arguments Type Intent Optional Attributes Name class(STElemshapeData_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val (:,:,:) Spatial nodal coordinates real(kind=DFP), intent(in) :: N (:,:) real(kind=DFP), intent(in) :: T (:) real(kind=DFP), intent(in) :: dNdXi (:,:,:)","tags":"","loc":"module/elemshapedata_method.html"},{"title":"RealMatrix_Method – Fortran Program","text":"This module contains methods for RealMatrix_ Uses GlobalData BaseType Contents Interfaces ASSIGNMENT( = ) AllocateData Allocate_Data ArrayPointer ArrayValues CONVERT COPY Constructor1 Convert Convert Copy_Obj_to_Obj Copy_Obj_to_Val Copy_Val_to_Obj DeallocateData Deallocate_Data Display Display_obj Display_obj_vec Eye Initiate JacobiMethod MakeDiagonalCopies MatMul_1 MatMul_2 MatMul_3 Matmul RANDOM_NUMBER RealMatrix RealMatrix_Pointer SYM Shape Size SkewSym SkewSym_array SkewSym_obj addContribution convert_DofToNodes convert_mat4_to_mat2 eig_jacobi_method eye_int eye_obj eye_real eye_real_b f_getPointer_Real f_getSectionValues_Real f_getSectionValues_Self f_getValuesFromTriplet_Real f_getValuesFromTriplet_self f_getValues_1 f_getValues_2 f_getValues_Real f_getValues_self get_shape get_size initiate_obj initiate_obj_val initiate_obj_vector_a initiate_obj_vector_b realmat_addVal_1 realmat_addVal_2 realmat_addVal_3 realmat_addVal_4 realmat_addVal_5 realmat_convert_doftonodes realmat_make_diag_copy1 realmat_make_diag_copy2 realmat_make_diag_copy3 realmat_make_diag_copy4 realmat_random_number realmat_setValues_1 realmat_setValues_2 realmat_setValues_3 realmat_setValues_4 realmat_setValues_5 setValues sym_array sym_obj Functions Constructor_1 Interfaces public interface ASSIGNMENT( = ) private interface initiate_obj_val () Initiate RealMatrix_ Arguments None public interface AllocateData Generic subroutine to allocate memory for RealMatrix_ private interface Allocate_Data () Allocate memory for RealMatrix_ Arguments None interface Allocate memory for RealMatrix_ private subroutine Allocate_Data(Obj, Dims) This subroutine allocate memory for RealMatrix_ Read more… Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Dims (2) public interface ArrayPointer Generic function to get pointer to the values in RealMatrix_ private interface f_getPointer_Real () Get pointer to the values stored inside RealMatrix_ Arguments None public interface ArrayValues Generic function to get values form RealMatrix_ private interface f_getValues_Real () Returns the values of RealMatrix_ obj in 2D array Arguments None private interface f_getSectionValues_Real () Returns the values of RealMatrix_ obj in 2D array Arguments None private interface f_getValuesFromTriplet_Real () Returns the values of RealMatrix_ obj in 2D array Arguments None private interface f_getValues_self () Returns RealMatrix_ obj from RealMatrix_ Arguments None private interface f_getSectionValues_Self () Returns RealMatrix_ obj from a section of RealMatrix_ Arguments None private interface f_getValuesFromTriplet_self () Returns RealMatrix_ obj from a section of RealMatrix_ Arguments None private interface f_getValues_1 () Returns values in 2D fortran array from RealMatrix_ Read more… Arguments None private interface f_getValues_2 () Returns values in 2D fortran array from RealMatrix_ Read more… Arguments None private interface CONVERT Generic method to convert data to and from RealMatrix_ private interface Copy_Obj_to_Val () Copy from RealMatrix_ to 2D fortran array Arguments None private interface Copy_Obj_to_Obj () Copy from RealMatrix_ to another RealMatrix_ Arguments None private interface Copy_Val_to_Obj () Copy from 2D fortran array to RealMatrix_ Arguments None public interface COPY Generic method to copy data to and from RealMatrix_ private interface Copy_Obj_to_Val () Copy from RealMatrix_ to 2D fortran array Arguments None private interface Copy_Obj_to_Obj () Copy from RealMatrix_ to another RealMatrix_ Arguments None private interface Copy_Val_to_Obj () Copy from 2D fortran array to RealMatrix_ Arguments None interface Fucntion that will initiate RealMatrix_ private pure function Constructor1(Dims) result(Obj) function that return RealMatrix_ of specified dimensions Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Dims (2) Return Value type(RealMatrix_) public interface Convert Generic subroutine for covertsion private interface convert_DofToNodes () Rearrange the dofs in finite element matrix Arguments None private interface realmat_convert_doftonodes () Rearrange the dofs in finite element matrix Arguments None private interface Convert private interface convert_mat4_to_mat2 () This subroutine converts rank4  matrix to rank2 matrix Arguments None interface Copy from RealMatrix_ to another RealMatrix_ private subroutine Copy_Obj_to_Obj(From, To) This subroutine copy the contents of RealMatrix_ object to another RealMatrix_ object Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(in) :: From type(RealMatrix_), intent(inout) :: To interface Copy from RealMatrix_ to 2D fortran array private subroutine Copy_Obj_to_Val(From, To) This subroutine copy the contents of RealMatrix_ object into a 2D\n fortran array Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(in) :: From real(kind=DFP), intent(inout), ALLOCATABLE :: To (:,:) interface Copy from 2D fortran array to RealMatrix_ private subroutine Copy_Val_to_Obj(From, To) This subroutine copy the contents of a 2D\n fortran array to RealMatrix_ object Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: From (:,:) type(RealMatrix_), intent(inout) :: To public interface DeallocateData Generic interface to deallocate RealMatrix_ private interface Deallocate_Data () Deallocate data in RealMatrix_ Arguments None interface Deallocate data in RealMatrix_ private subroutine Deallocate_Data(Obj) This routine deallocates data stored in Obj Read more… Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(inout) :: Obj public interface Display Generic interface to display content of RealMatrix_ private interface Display_obj () Display content of RealMatrix_ Arguments None private interface Display_obj_vec () Display content of RealMatrix_ Arguments None interface Display content of RealMatrix_ private subroutine Display_obj(Obj, Msg, UnitNo) This subroutine displays content of RealMatrix_ Read more… Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(in) :: Obj character(len=*), intent(in) :: Msg integer(kind=I4B), intent(in), optional :: UnitNo interface Display content of RealMatrix_ private subroutine Display_obj_vec(Obj, Msg, UnitNo) This subroutine displays content of RealMatrix_ Read more… Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(in) :: Obj (:) character(len=*), intent(in) :: Msg integer(kind=I4B), intent(in), optional :: UnitNo public interface Eye Generic interface for obtaining identity matrix in array or RealMatrix_ private interface eye_int () Return identity matrix of integers Arguments None private interface eye_obj () Return identity matrix of type RealMatrix_ Arguments None private interface eye_real () Return identity matrix of real numbers Arguments None private interface eye_real_b () Return identity matrix of real number Arguments None public interface Initiate Generic interface to initiate RealMatrix_ private interface initiate_obj_vector_a () Initiate RealMatrix_ Arguments None private interface initiate_obj_vector_b () Initiate RealMatrix_ Arguments None private interface initiate_obj () Initiate RealMatrix_ Arguments None private interface initiate_obj_val () Initiate RealMatrix_ Arguments None public interface JacobiMethod Generic subroutine for computing eigen value of a symmetric matrix private interface eig_jacobi_method () Returns all the eigenvalues of symmetric matrix Arguments None public interface MakeDiagonalCopies Generic subroutine to make diagonal copies of RealMatrix_ and 2d arrays private interface realmat_make_diag_copy1 () Make diagonal copies of Matrix Arguments None private interface realmat_make_diag_copy2 () Make diagonal copies of Matrix Arguments None private interface realmat_make_diag_copy3 () Make diagonal copies of RealMatrix_ Arguments None private interface realmat_make_diag_copy4 () Make diagonal copies of Matrix Arguments None interface private pure function MatMul_1(Obj1, Obj2) result(Ans) Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(in) :: Obj1 type(RealMatrix_), intent(in) :: Obj2 Return Value type(RealMatrix_) interface private pure function MatMul_2(Obj, Vec) result(Ans) Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(in) :: Obj real(kind=DFP), intent(in) :: Vec (:) Return Value real(kind=DFP),\n  ALLOCATABLE, (:) interface private pure function MatMul_3(Obj, Vec) result(Ans) Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(in) :: Obj type(RealVector_), intent(in) :: Vec Return Value type(RealVector_) public interface Matmul private interface MatMul_1 () Arguments None private interface MatMul_2 () Arguments None private interface MatMul_3 () Arguments None public interface RANDOM_NUMBER private interface realmat_random_number () Set a values in RealMatrix_ obj to random values Arguments None public interface RealMatrix Generic function to construct RealMatrix_ private interface Constructor1 () Fucntion that will initiate RealMatrix_ Arguments None public interface RealMatrix_Pointer Generic function to get pointer to RealMatrix_ private pure function Constructor_1 (Dims) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Dims (2) Return Value class(RealMatrix_),\n  POINTER public interface SYM Generic interface for getting symmetric part of RealMatrix_ private interface sym_obj () Return sym(Obj) = 0.5*(Obj + transpose( Obj ) ) Arguments None private interface sym_array () Return sym(Obj) = 0.5*(Obj + transpose( Obj ) ) Arguments None public interface Shape Generic interface to get shape of RealMatrix_ private interface get_shape () Return shape of RealMatrix_ Arguments None public interface Size Generic interface to get size of RealMatrix_ private interface get_size () Return size of RealMatrix_ Arguments None public interface SkewSym Generic interface for getting SkewSymmetric part of RealMatrix_ private interface SkewSym_obj () Return SkewSym(Obj) = 0.5*(Obj + transpose( Obj ) ) Arguments None private interface SkewSym_array () Return SkewSym(Obj) = 0.5*(Obj + transpose( Obj ) ) Arguments None interface Return SkewSym(Obj) = 0.5*(Obj + transpose( Obj ) ) private pure function SkewSym_array(Obj) result(Ans) Return SkewSymmetric part of Obj Read more… Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Obj (:,:) Two dimensiona array Return Value real(kind=DFP)\n  (SIZE(Obj,1),SIZE(Obj,2)) SkewSymmetric array interface Return SkewSym(Obj) = 0.5*(Obj + transpose( Obj ) ) private pure function SkewSym_obj(Obj) result(Ans) Return SkewSymmetric part of Obj Read more… Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(in) :: Obj Real matrix Return Value type(RealMatrix_) SkewSymmetric real matrix public interface addContribution private interface realmat_addVal_1 () Add contribution in values of RealMatrix_ Arguments None private interface realmat_addVal_2 () Add contribution in values of RealMatrix_ Arguments None private interface realmat_addVal_3 () Add contribution in values of RealMatrix_ Arguments None private interface realmat_addVal_4 () Add contribution in values of RealMatrix_ Arguments None private interface realmat_addVal_5 () Add contribution in values of RealMatrix_ Arguments None interface Rearrange the dofs in finite element matrix private subroutine convert_DofToNodes(From, To, Conversion, nns, tdof) This subroutine changes the storage pattern of a two-d matrix\n  - Usually element matrix in easifem are stored in FMT_DOF - Global matrices/tanmat, however, are stored in FMT_Nodes - This subroutine is, therefore, in settings or adding values in SparseMatrix_ . Read more… Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: From (:,:) Matrix in one format real(kind=DFP), intent(inout), ALLOCATABLE :: To (:,:) Matrix is desired format integer(kind=I4B), intent(in) :: Conversion Conversion can be NodesToDOF or DOFToNodes integer(kind=I4B), intent(in), optional :: nns integer(kind=I4B), intent(in), optional :: tdof interface This subroutine converts rank4  matrix to rank2 matrix private subroutine convert_mat4_to_mat2(From, To) This subroutine converts a rank4 matrix to rank2 matrix Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: From (:,:,:,:) real(kind=DFP), intent(inout), ALLOCATABLE :: To (:,:) interface Returns all the eigenvalues of symmetric matrix private subroutine eig_jacobi_method(Mat, EigenValues, EigenVectors, MaxIter) This subroutine computes all eigenvalues and eigenvectors of a real\n symmetric N × N matrix A.\n -  On output, elements of A above the diagonal are destroyed.\n - d is a vector of length N that returns the eigenvalues of A .\n - V is an N × N matrix whose columns contain on output, the normalized\n  eigenvectors of A.\n - tRot returns the number of Jacobi rotations that were required. Read more… Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout) :: Mat (:,:) real(kind=DFP), intent(inout) :: EigenValues (:) real(kind=DFP), intent(inout) :: EigenVectors (:,:) integer(kind=I4B), intent(in) :: MaxIter interface Return identity matrix of integers private pure function eye_int(m, DataType) result(Ans) This function return identity matrix of integer Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: m integer(kind=I4B), intent(in) :: DataType Return Value integer(kind=I4B)\n  (m,m) interface Return identity matrix of type RealMatrix_ private pure function eye_obj(m, DataType) result(Ans) This function returns identity matrix of type RealMatrix_ Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: m type(RealMatrix_), intent(in) :: DataType Return Value type(RealMatrix_) interface Return identity matrix of real numbers private pure function eye_real(m, DataType) result(Ans) This function returns identity matrux of reals Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: m real(kind=DFP), intent(in) :: DataType Return Value real(kind=DFP)\n  (m,m) interface Return identity matrix of real number private pure function eye_real_b(m) result(Ans) This function returns the identity matrix of real numbers Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: m Return Value real(kind=DFP)\n  (m,m) interface Get pointer to the values stored inside RealMatrix_ private function f_getPointer_Real(Obj, DataType) result(Ans) This function returns the pointer to the values stored inside the RealMatrix_ Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(in), TARGET :: Obj real(kind=DFP), intent(in) :: DataType Return Value real(kind=DFP),\n  POINTER, (:,:) interface Returns the values of RealMatrix_ obj in 2D array private pure function f_getSectionValues_Real(Obj, RIndx, CIndx, DataType) result(Ans) This function returns a section of Obj % Val in a 2D fortran array. This\n is equivalent to Val = Obj % Val(RIndx, CIndx) Read more… Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(in) :: Obj integer(kind=I4B), intent(in) :: RIndx (:) integer(kind=I4B), intent(in) :: CIndx (:) real(kind=DFP), intent(in) :: DataType Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) interface Returns RealMatrix_ obj from a section of RealMatrix_ private pure function f_getSectionValues_Self(Obj, RIndx, CIndx, DataType) result(Ans) This function is essentially copy method Ans=Obj(RIndx, CIndx) Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(in) :: Obj integer(kind=I4B), intent(in) :: RIndx (:) integer(kind=I4B), intent(in) :: CIndx (:) type(RealMatrix_), intent(in) :: DataType Return Value type(RealMatrix_) interface Returns the values of RealMatrix_ obj in 2D array private pure function f_getValuesFromTriplet_Real(Obj, iStart, iEnd, Stride, DataType) result(Ans) This function returns a section of Obj % Val in a 2D fortran array. This\n is equivalent to Val = Obj % Val(is:ie:s, is:ie:s) Read more… Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(in) :: Obj integer(kind=I4B), intent(in) :: iStart integer(kind=I4B), intent(in) :: iEnd integer(kind=I4B), intent(in) :: Stride real(kind=DFP), intent(in) :: DataType Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) interface Returns RealMatrix_ obj from a section of RealMatrix_ private pure function f_getValuesFromTriplet_self(Obj, iStart, iEnd, Stride, DataType) result(Ans) This function is essentially copy method Ans=Obj(is:ie, is:ie) Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(in) :: Obj integer(kind=I4B), intent(in) :: iStart integer(kind=I4B), intent(in) :: iEnd integer(kind=I4B), intent(in) :: Stride type(RealMatrix_), intent(in) :: DataType Return Value type(RealMatrix_) interface Returns values in 2D fortran array from RealMatrix_ Read more… private pure function f_getValues_1(Obj, DataType) result(Ans) This function combines all RealMatrix_ value of Obj and\n returns a 2D fortrn array Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(in) :: Obj (:,:) real(kind=DFP), intent(in) :: DataType Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) interface Returns values in 2D fortran array from RealMatrix_ Read more… private pure function f_getValues_2(Obj, DataType) result(Ans) This function combines all RealMatrix_ value of Obj and\n returns a RealMatrix_ object Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(in) :: Obj (:,:) type(RealMatrix_), intent(in) :: DataType Return Value type(RealMatrix_) interface Returns the values of RealMatrix_ obj in 2D array private pure function f_getValues_Real(Obj, DataType) result(Ans) This function returns the value stored in Obj % Val in a 2D fortran array Read more… Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(in) :: Obj real(kind=DFP), intent(in) :: DataType Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) interface Returns RealMatrix_ obj from RealMatrix_ private pure function f_getValues_self(Obj, DataType) result(Ans) This function is essentially copy method Ans=Obj Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(in) :: Obj type(RealMatrix_), intent(in) :: DataType Return Value type(RealMatrix_) interface Return shape of RealMatrix_ private pure function get_shape(Obj) result(Ans) This function return space of RealMatrix_ Read more… Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(in) :: Obj Return Value integer(kind=I4B)\n  (2) interface Return size of RealMatrix_ private pure function get_size(Obj, Dims) result(Ans) This function return size of RealMatrix_ - If Dims is present and equal to 1 then total number of rows (m)\n - If Dims is present and equal to 2 then total number of cols (n)\n - If Dimes is absent then Ans = m * n Read more… Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(in) :: Obj integer(kind=I4B), intent(in), optional :: Dims Return Value integer(kind=I4B) interface Initiate RealMatrix_ private subroutine initiate_obj(Obj, Dims) This subroutine initiate Obj with shape Dims Read more… Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(inout) :: Obj integer(kind=I4B), intent(in) :: Dims (2) interface Initiate RealMatrix_ private subroutine initiate_obj_val(Obj, Val) This subroutine performs Obj % Val = Val , i.e., initiate Obj with Val Read more… Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val (:,:) interface Initiate RealMatrix_ private subroutine initiate_obj_vector_a(Obj, Dims) This subroutine initiate vector of RealMatrix_ with shape Dims Read more… Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(inout) :: Obj (:) integer(kind=I4B), intent(in) :: Dims (2) interface Initiate RealMatrix_ private subroutine initiate_obj_vector_b(Obj, Dims) This subroutine initiate vector of RealMatrix_ with matrices of\n different shapes given in Dims - Dims has two columns; the first column denotes the number of rows, and\n second column denotes the number of columns in a matrix\n - irow of Dims corresponds to the shape of Obj(irow) - in this way SIZE(obj) should be equal to the SIZE(Dims, 1) Read more… Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(inout) :: Obj (:) integer(kind=I4B), intent(in) :: Dims (:,:) interface Add contribution in values of RealMatrix_ private subroutine realmat_addVal_1(Obj, Val, Scale, Op) This subroutine adds contribution in values of Obj % Val Read more… Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val (:,:) Scaling for Val real(kind=DFP), intent(in) :: Scale Scaling for Val character(len=1), intent(in) :: Op operator symbol; +, -, *, / interface Add contribution in values of RealMatrix_ private subroutine realmat_addVal_2(Obj, Val, Row, Col, Scale, Op) This subroutine adds contribution in values of Obj % Val Read more… Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val integer(kind=I4B), intent(in) :: Row integer(kind=I4B), intent(in) :: Col real(kind=DFP), intent(in) :: Scale character(len=1), intent(in) :: Op interface Add contribution in values of RealMatrix_ private subroutine realmat_addVal_3(Obj, Val, Row, Col, Scale, Op) This subroutine adds contribution in values of Obj % Val Read more… Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val (:,:) integer(kind=I4B), intent(in) :: Row (:) integer(kind=I4B), intent(in) :: Col (:) real(kind=DFP), intent(in) :: Scale character(len=1), intent(in) :: Op interface Add contribution in values of RealMatrix_ private subroutine realmat_addVal_4(Obj, Val, Indx, ExtraOption, Scale, Op) This subroutine adds contribution in values of Obj % Val Read more… Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val (:) integer(kind=I4B), intent(in) :: Indx integer(kind=I4B), intent(in) :: ExtraOption real(kind=DFP), intent(in) :: Scale character(len=1), intent(in) :: Op interface Add contribution in values of RealMatrix_ private subroutine realmat_addVal_5(Obj, Val, Indx, ExtraOption, Scale, Op) This subroutine adds contribution in values of Obj % Val Read more… Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val (:,:) integer(kind=I4B), intent(in) :: Indx (:) integer(kind=I4B), intent(in) :: ExtraOption real(kind=DFP), intent(in) :: Scale character(len=1), intent(in) :: Op interface Rearrange the dofs in finite element matrix private subroutine realmat_convert_doftonodes(From, To, Conversion, nns, tdof) This subroutine changes the storage pattern of a two-d matrix\n  - Usually element matrix in easifem are stored in FMT_DOF - Global matrices/tanmat, however, are stored in FMT_Nodes - This subroutine is, therefore, in settings or adding values in SparseMatrix_ . Read more… Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(in) :: From Matrix in one format type(RealMatrix_), intent(inout) :: To Matrix in one format integer(kind=I4B), intent(in) :: Conversion Conversion can be NodesToDOF or DOFToNodes integer(kind=I4B), intent(in), optional :: nns integer(kind=I4B), intent(in), optional :: tdof interface Make diagonal copies of Matrix private subroutine realmat_make_diag_copy1(Mat, nCopy) This subroutine makes ncopy diagonal copies of Mat - The size of Mat on return is nCopy * SIZE( Mat, 1 ) Read more… Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(inout), ALLOCATABLE :: Mat (:,:) integer(kind=I4B), intent(in) :: nCopy interface Make diagonal copies of Matrix private subroutine realmat_make_diag_copy2(From, To, nCopy) This subroutine makes ncopy diagonal copies of Mat Read more… Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: From (:,:) real(kind=DFP), intent(inout), ALLOCATABLE :: To (:,:) integer(kind=I4B), intent(in) :: nCopy interface Make diagonal copies of RealMatrix_ private subroutine realmat_make_diag_copy3(Mat, ncopy) This subroutine makes ncopy diagonal copies of Mat - The size of Mat on return is nCopy * SIZE( Mat, 1 ) Read more… Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(inout) :: Mat integer(kind=I4B), intent(in) :: ncopy interface Make diagonal copies of Matrix private subroutine realmat_make_diag_copy4(From, To, nCopy) This subroutine makes ncopy diagonal copies of Mat Read more… Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(in) :: From type(RealMatrix_), intent(inout) :: To integer(kind=I4B), intent(in) :: nCopy interface Set a values in RealMatrix_ obj to random values private subroutine realmat_random_number(Obj, m, n) This subroutine set values in Obj%Val to random\n - This subroutine calls RANDOM_NUMBER() function from Fortran Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(inout) :: Obj integer(kind=I4B), intent(in), optional :: m integer(kind=I4B), intent(in), optional :: n interface Add values in RealMatrix_ private subroutine realmat_setValues_1(Obj, Val) This subroutine set Obj % Val to Val Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val (:,:) interface Set values in RealMatrix_ private subroutine realmat_setValues_2(Obj, Val, Row, Col) This subroutine set values in Obj % Val Obj % Val( i, j ) = Val Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val integer(kind=I4B), intent(in) :: Row integer(kind=I4B), intent(in) :: Col interface Set values in RealMatrix_ private subroutine realmat_setValues_3(Obj, Val, Row, Col) This subroutine set values in Obj % Val Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val (:,:) integer(kind=I4B), intent(in) :: Row (:) integer(kind=I4B), intent(in) :: Col (:) interface Set values in RealMatrix_ private subroutine realmat_setValues_4(Obj, Val, Indx, ExtraOption) This subroutine set values in Obj % val - If ExtraOption=0 then diagonal values are set; and Indx denotes\n   diagonal number with 0 being the main diagonal\n - If Extraoption=1 then row values are set; Indx then denotes row number\n - If Extraoption=2 then col values are set; Indx then denotes col number Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val (:) integer(kind=I4B), intent(in) :: Indx integer(kind=I4B), intent(in) :: ExtraOption interface Set values in RealMatrix_ private subroutine realmat_setValues_5(Obj, Val, Indx, ExtraOption) This subroutine set values in Obj % val - If ExtraOption=0 then diagonal values are set; and Indx denotes\n   diagonal number with 0 being the main diagonal\n - If Extraoption=1 then row values are set; Indx then denotes row number\n - If Extraoption=2 then col values are set; Indx then denotes col number Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(inout) :: Obj real(kind=DFP), intent(in) :: Val (:,:) integer(kind=I4B), intent(in) :: Indx (:) integer(kind=I4B), intent(in) :: ExtraOption public interface setValues private interface realmat_setValues_1 () Add values in RealMatrix_ Arguments None private interface realmat_setValues_2 () Set values in RealMatrix_ Arguments None private interface realmat_setValues_3 () Set values in RealMatrix_ Arguments None private interface realmat_setValues_4 () Set values in RealMatrix_ Arguments None private interface realmat_setValues_5 () Set values in RealMatrix_ Arguments None interface Return sym(Obj) = 0.5*(Obj + transpose( Obj ) ) private pure function sym_array(Obj) result(Ans) Return symmetric part of Obj Read more… Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Obj (:,:) Two dimensiona array Return Value real(kind=DFP)\n  (SIZE(Obj,1),SIZE(Obj,2)) Symmetric array interface Return sym(Obj) = 0.5*(Obj + transpose( Obj ) ) private pure function sym_obj(Obj) result(Ans) Return symmetric part of Obj Read more… Arguments Type Intent Optional Attributes Name type(RealMatrix_), intent(in) :: Obj Real matrix Return Value type(RealMatrix_) Symmetric real matrix Functions private pure function Constructor_1 (Dims) result(Obj) Arguments Type Intent Optional Attributes Name integer(kind=I4B), intent(in) :: Dims (2) Return Value class(RealMatrix_),\n  POINTER","tags":"","loc":"module/realmatrix_method.html"},{"title":"FEVariable_Method – Fortran Program","text":"Uses GlobalData BaseType Contents Interfaces DeallocateData Display Display_Obj Matrix_Constant Matrix_Space Matrix_SpaceTime NodalVariable NodalVariable NodalVariable NodalVariable NodalVariable NodalVariable NodalVariable NodalVariable NodalVariable Nodal_Matrix_Constant Nodal_Matrix_Space Nodal_Matrix_SpaceTime Nodal_Scalar_Constant Nodal_Scalar_Space Nodal_Scalar_SpaceTime Nodal_Vector_Constant Nodal_Vector_Space Nodal_Vector_SpaceTime QuadratureVariable QuadratureVariable QuadratureVariable QuadratureVariable QuadratureVariable QuadratureVariable QuadratureVariable QuadratureVariable QuadratureVariable Quadrature_Matrix_Constant Quadrature_Matrix_Space Quadrature_Matrix_SpaceTime Quadrature_Scalar_Constant Quadrature_Scalar_Space Quadrature_Scalar_SpaceTime Quadrature_Vector_Constant Quadrature_Vector_Space Quadrature_Vector_SpaceTime SIZE Scalar_Constant Scalar_Space Scalar_SpaceTime Shape Shape_obj Size_obj Vector_Constant Vector_Space Vector_SpaceTime fe_deallocate getValues getValues getValues getValues getValues getValues getValues getValues getValues Interfaces public interface DeallocateData private interface fe_deallocate () Arguments None public interface Display private interface Display_Obj () Arguments None interface private subroutine Display_Obj(Obj, Msg, UnitNo) Arguments Type Intent Optional Attributes Name type(FEVariable_), intent(in) :: Obj character(len=*), intent(in) :: Msg integer(kind=I4B), intent(in), optional :: UnitNo interface private pure function Matrix_Constant(Obj, Rank, VarType) result(Val) Arguments Type Intent Optional Attributes Name class(FEVariable_), intent(in) :: Obj type(FEVariableMatrix_), intent(in) :: Rank type(FEVariableConstant_), intent(in) :: VarType Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) interface private pure function Matrix_Space(Obj, Rank, VarType) result(Val) Arguments Type Intent Optional Attributes Name class(FEVariable_), intent(in) :: Obj type(FEVariableMatrix_), intent(in) :: Rank type(FEVariableSpace_), intent(in) :: VarType Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:,:) interface private pure function Matrix_SpaceTime(Obj, Rank, VarType) result(Val) Arguments Type Intent Optional Attributes Name class(FEVariable_), intent(in) :: Obj type(FEVariableMatrix_), intent(in) :: Rank type(FEVariableSpaceTime_), intent(in) :: VarType Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:,:,:) public interface NodalVariable private interface Nodal_Scalar_Constant () Arguments None private interface NodalVariable private interface Nodal_Scalar_Space () Arguments None private interface NodalVariable private interface Nodal_Scalar_SpaceTime () Arguments None private interface NodalVariable private interface Nodal_Vector_Constant () Arguments None private interface NodalVariable private interface Nodal_Vector_Space () Arguments None private interface NodalVariable private interface Nodal_Vector_SpaceTime () Arguments None private interface NodalVariable private interface Nodal_Matrix_Constant () Arguments None private interface NodalVariable private interface Nodal_Matrix_Space () Arguments None private interface NodalVariable private interface Nodal_Matrix_SpaceTime () Arguments None interface private pure function Nodal_Matrix_Constant(Val, Rank, VarType) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Val (:,:) type(FEVariableMatrix_), intent(in) :: Rank type(FEVariableConstant_), intent(in) :: VarType Return Value type(FEVariable_) interface private pure function Nodal_Matrix_Space(Val, Rank, VarType) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Val (:,:,:) type(FEVariableMatrix_), intent(in) :: Rank type(FEVariableSpace_), intent(in) :: VarType Return Value type(FEVariable_) interface private pure function Nodal_Matrix_SpaceTime(Val, Rank, VarType) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Val (:,:,:,:) type(FEVariableMatrix_), intent(in) :: Rank type(FEVariableSpaceTime_), intent(in) :: VarType Return Value type(FEVariable_) interface private pure function Nodal_Scalar_Constant(Val, Rank, VarType) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Val class(FEVariableScalar_), intent(in) :: Rank class(FEVariableConstant_), intent(in) :: VarType Return Value type(FEVariable_) interface private pure function Nodal_Scalar_Space(Val, Rank, VarType) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Val (:) type(FEVariableScalar_), intent(in) :: Rank type(FEVariableSpace_), intent(in) :: VarType Return Value type(FEVariable_) interface private pure function Nodal_Scalar_SpaceTime(Val, Rank, VarType) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Val (:,:) type(FEVariableScalar_), intent(in) :: Rank type(FEVariableSpaceTime_), intent(in) :: VarType Return Value type(FEVariable_) interface private pure function Nodal_Vector_Constant(Val, Rank, VarType) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Val (:) type(FEVariableVector_), intent(in) :: Rank type(FEVariableConstant_), intent(in) :: VarType Return Value type(FEVariable_) interface private pure function Nodal_Vector_Space(Val, Rank, VarType) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Val (:,:) type(FEVariableVector_), intent(in) :: Rank type(FEVariableSpace_), intent(in) :: VarType Return Value type(FEVariable_) interface private pure function Nodal_Vector_SpaceTime(Val, Rank, VarType) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Val (:,:,:) type(FEVariableVector_), intent(in) :: Rank type(FEVariableSpaceTime_), intent(in) :: VarType Return Value type(FEVariable_) public interface QuadratureVariable private interface Quadrature_Scalar_Constant () Arguments None private interface QuadratureVariable private interface Quadrature_Scalar_Space () Arguments None private interface QuadratureVariable private interface Quadrature_Scalar_SpaceTime () Arguments None private interface QuadratureVariable private interface Quadrature_Vector_Constant () Arguments None private interface QuadratureVariable private interface Quadrature_Vector_Space () Arguments None private interface QuadratureVariable private interface Quadrature_Vector_SpaceTime () Arguments None private interface QuadratureVariable private interface Quadrature_Matrix_Constant () Arguments None private interface QuadratureVariable private interface Quadrature_Matrix_Space () Arguments None private interface QuadratureVariable private interface Quadrature_Matrix_SpaceTime () Arguments None interface private pure function Quadrature_Matrix_Constant(Val, Rank, VarType) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Val (:,:) type(FEVariableMatrix_), intent(in) :: Rank type(FEVariableConstant_), intent(in) :: VarType Return Value type(FEVariable_) interface private pure function Quadrature_Matrix_Space(Val, Rank, VarType) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Val (:,:,:) type(FEVariableMatrix_), intent(in) :: Rank type(FEVariableSpace_), intent(in) :: VarType Return Value type(FEVariable_) interface private pure function Quadrature_Matrix_SpaceTime(Val, Rank, VarType) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Val (:,:,:,:) type(FEVariableMatrix_), intent(in) :: Rank type(FEVariableSpaceTime_), intent(in) :: VarType Return Value type(FEVariable_) interface private pure function Quadrature_Scalar_Constant(Val, Rank, VarType) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Val type(FEVariableScalar_), intent(in) :: Rank type(FEVariableConstant_), intent(in) :: VarType Return Value type(FEVariable_) interface private pure function Quadrature_Scalar_Space(Val, Rank, VarType) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Val (:) type(FEVariableScalar_), intent(in) :: Rank type(FEVariableSpace_), intent(in) :: VarType Return Value type(FEVariable_) interface private pure function Quadrature_Scalar_SpaceTime(Val, Rank, VarType) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Val (:,:) type(FEVariableScalar_), intent(in) :: Rank type(FEVariableSpaceTime_), intent(in) :: VarType Return Value type(FEVariable_) interface private pure function Quadrature_Vector_Constant(Val, Rank, VarType) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Val (:) type(FEVariableVector_), intent(in) :: Rank type(FEVariableConstant_), intent(in) :: VarType Return Value type(FEVariable_) interface private pure function Quadrature_Vector_Space(Val, Rank, VarType) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Val (:,:) type(FEVariableVector_), intent(in) :: Rank type(FEVariableSpace_), intent(in) :: VarType Return Value type(FEVariable_) interface private pure function Quadrature_Vector_SpaceTime(Val, Rank, VarType) result(Obj) Arguments Type Intent Optional Attributes Name real(kind=DFP), intent(in) :: Val (:,:,:) type(FEVariableVector_), intent(in) :: Rank type(FEVariableSpaceTime_), intent(in) :: VarType Return Value type(FEVariable_) public interface SIZE private interface Size_obj () Arguments None interface private pure function Scalar_Constant(Obj, Rank, VarType) result(Val) Arguments Type Intent Optional Attributes Name class(FEVariable_), intent(in) :: Obj type(FEVariableScalar_), intent(in) :: Rank type(FEVariableConstant_), intent(in) :: VarType Return Value real(kind=DFP) interface private pure function Scalar_Space(Obj, Rank, VarType) result(Val) Arguments Type Intent Optional Attributes Name class(FEVariable_), intent(in) :: Obj type(FEVariableScalar_), intent(in) :: Rank type(FEVariableSpace_), intent(in) :: VarType Return Value real(kind=DFP),\n  ALLOCATABLE, (:) interface private pure function Scalar_SpaceTime(Obj, Rank, VarType) result(Val) Arguments Type Intent Optional Attributes Name class(FEVariable_), intent(in) :: Obj type(FEVariableScalar_), intent(in) :: Rank type(FEVariableSpaceTime_), intent(in) :: VarType Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) public interface Shape private interface Shape_obj () Arguments None interface private pure function Shape_obj(Obj) result(Ans) Arguments Type Intent Optional Attributes Name class(FEVariable_), intent(in) :: Obj Return Value integer(kind=I4B),\n  ALLOCATABLE, (:) interface private pure function Size_obj(Obj, Dim) result(Ans) Arguments Type Intent Optional Attributes Name class(FEVariable_), intent(in) :: Obj integer(kind=I4B), intent(in) :: Dim Return Value integer(kind=I4B) interface private pure function Vector_Constant(Obj, Rank, VarType) result(Val) Arguments Type Intent Optional Attributes Name class(FEVariable_), intent(in) :: Obj type(FEVariableVector_), intent(in) :: Rank type(FEVariableConstant_), intent(in) :: VarType Return Value real(kind=DFP),\n  ALLOCATABLE, (:) interface private pure function Vector_Space(Obj, Rank, VarType) result(Val) Arguments Type Intent Optional Attributes Name class(FEVariable_), intent(in) :: Obj type(FEVariableVector_), intent(in) :: Rank type(FEVariableSpace_), intent(in) :: VarType Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) interface private pure function Vector_SpaceTime(Obj, Rank, VarType) result(Val) Arguments Type Intent Optional Attributes Name class(FEVariable_), intent(in) :: Obj type(FEVariableVector_), intent(in) :: Rank type(FEVariableSpaceTime_), intent(in) :: VarType Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:,:) interface private subroutine fe_deallocate(Obj) Arguments Type Intent Optional Attributes Name type(FEVariable_), intent(inout) :: Obj public interface getValues private interface Scalar_Constant () Arguments None private interface getValues private interface Scalar_Space () Arguments None private interface getValues private interface Scalar_SpaceTime () Arguments None private interface getValues private interface Vector_Constant () Arguments None private interface getValues private interface Vector_Space () Arguments None private interface getValues private interface Vector_SpaceTime () Arguments None private interface getValues private interface Matrix_Constant () Arguments None private interface getValues private interface Matrix_Space () Arguments None private interface getValues private interface Matrix_SpaceTime () Arguments None","tags":"","loc":"module/fevariable_method.html"},{"title":"Buffer_Method – Fortran Program","text":"Uses BaseType GlobalData Contents Interfaces Append buffer_append_str Interfaces public interface Append private interface buffer_append_str () Arguments None interface private subroutine buffer_append_str(Obj, Entry) Arguments Type Intent Optional Attributes Name type(Buffer_), intent(inout) :: Obj type(String), intent(in), TARGET :: Entry","tags":"","loc":"module/buffer_method.html"},{"title":"AdditionalMethods – Fortran Program","text":"Uses ReferenceElement_Method Ancestors: BaseType Contents Module Procedures lag_elem_refHexahedron lag_elem_refLine lag_elem_refPrism lag_elem_refPyramid lag_elem_refQuadrangle lag_elem_refTetrahedron lag_elem_refTriangle lag_elem_refelem lp_refelem lp_refelem_Hexahedron lp_refelem_Prism lp_refelem_Pyramid lp_refelem_Quadrangle lp_refelem_Tetrahedron lp_refelem_Triangle lp_refelem_line Module Procedures module procedure lag_elem_refHexahedron module function lag_elem_refHexahedron(Obj, Order) result(Ans) Interface → Arguments Type Intent Optional Attributes Name class( ReferenceHexahedron_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value class( ReferenceElement_ ),\n  POINTER module procedure lag_elem_refLine module function lag_elem_refLine(Obj, Order) result(Ans) Interface → Arguments Type Intent Optional Attributes Name class( ReferenceLine_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value class( ReferenceElement_ ),\n  POINTER module procedure lag_elem_refPrism module function lag_elem_refPrism(Obj, Order) result(Ans) Interface → Arguments Type Intent Optional Attributes Name class( ReferencePrism_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value class( ReferenceElement_ ),\n  POINTER module procedure lag_elem_refPyramid module function lag_elem_refPyramid(Obj, Order) result(Ans) Interface → Arguments Type Intent Optional Attributes Name class( ReferencePyramid_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value class( ReferenceElement_ ),\n  POINTER module procedure lag_elem_refQuadrangle module function lag_elem_refQuadrangle(Obj, Order) result(Ans) Interface → Arguments Type Intent Optional Attributes Name class( ReferenceQuadrangle_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value class( ReferenceElement_ ),\n  POINTER module procedure lag_elem_refTetrahedron module function lag_elem_refTetrahedron(Obj, Order) result(Ans) Interface → Arguments Type Intent Optional Attributes Name class( ReferenceTetrahedron_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value class( ReferenceElement_ ),\n  POINTER module procedure lag_elem_refTriangle module function lag_elem_refTriangle(Obj, Order) result(Ans) Interface → Arguments Type Intent Optional Attributes Name class( ReferenceTriangle_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value class( ReferenceElement_ ),\n  POINTER module procedure lag_elem_refelem module function lag_elem_refelem(Obj, Order) result(Ans) Interface → Arguments Type Intent Optional Attributes Name class( ReferenceElement_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value class( ReferenceElement_ ),\n  POINTER module procedure lp_refelem pure module function lp_refelem(Obj, Order) result(Ans) Interface → Arguments Type Intent Optional Attributes Name class( ReferenceElement_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) module procedure lp_refelem_Hexahedron pure module function lp_refelem_Hexahedron(Obj, Order) result(Ans) Interface → Arguments Type Intent Optional Attributes Name class( ReferenceHexahedron_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) module procedure lp_refelem_Prism pure module function lp_refelem_Prism(Obj, Order) result(Ans) Interface → Arguments Type Intent Optional Attributes Name class( ReferencePrism_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) module procedure lp_refelem_Pyramid pure module function lp_refelem_Pyramid(Obj, Order) result(Ans) Interface → Arguments Type Intent Optional Attributes Name class( ReferencePyramid_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) module procedure lp_refelem_Quadrangle pure module function lp_refelem_Quadrangle(Obj, Order) result(Ans) Interface → Arguments Type Intent Optional Attributes Name class( ReferenceQuadrangle_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) module procedure lp_refelem_Tetrahedron pure module function lp_refelem_Tetrahedron(Obj, Order) result(Ans) Interface → Arguments Type Intent Optional Attributes Name class( ReferenceTetrahedron_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) module procedure lp_refelem_Triangle pure module function lp_refelem_Triangle(Obj, Order) result(Ans) Interface → Arguments Type Intent Optional Attributes Name class( ReferenceTriangle_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:) module procedure lp_refelem_line pure module function lp_refelem_line(Obj, Order) result(Ans) Interface → Arguments Type Intent Optional Attributes Name class( ReferenceLine_ ), intent(in) :: Obj integer(kind=I4B), intent(in) :: Order Return Value real(kind=DFP),\n  ALLOCATABLE, (:,:)","tags":"","loc":"module/additionalmethods.html"}]}